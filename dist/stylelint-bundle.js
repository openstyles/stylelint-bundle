/*!= Stylelint v14.9.1 bundle =*/
/* See https://github.com/openstyles/stylelint-bundle */
;(()=>{"use strict";function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function _extends() {_extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};return _extends.apply(this, arguments);}(function (f) {if (typeof exports === "object" && typeof module !== "undefined") {module.exports = f();} else if (typeof define === "function" && define.amd) {define([], f);} else {var g;if (typeof window !== "undefined") {g = window;} else if (typeof global !== "undefined") {g = global;} else if (typeof self !== "undefined") {g = self;} else {g = this;}g.stylelint = f();}})(function () {var define, module, exports;return function () {function r(e, n, t) {function o(i, f) {if (!n[i]) {if (!e[i]) {var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;}var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {var n = e[i][1][r];return o(n || r);}, p, p.exports, r, e, n, t);}return n[i].exports;}for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);return o;}return r;}()({ 1: [function (require, module, exports) {
      "use strict";function e(e) {return e && "object" == typeof e && "default" in e ? e : { default: e };}Object.defineProperty(exports, "__esModule", { value: !0 });var s = e(require("postcss-selector-parser"));function t(e) {if (!e) return { a: 0, b: 0, c: 0 };let n = 0,c = 0,o = 0;if ("universal" == e.type) return { a: 0, b: 0, c: 0 };if ("id" === e.type) n += 1;else if ("tag" === e.type) o += 1;else if ("class" === e.type) c += 1;else if ("attribute" === e.type) c += 1;else if (function (e) {return s.default.isPseudoElement(e);}(e)) o += 1;else if (s.default.isPseudoClass(e)) switch (e.value.toLowerCase()) {case ":-moz-any":case ":-webkit-any":case ":any":case ":has":case ":is":case ":matches":case ":not":if (e.nodes && e.nodes.length > 0) {const s = a(e.nodes);n += s.a, c += s.b, o += s.c;}break;case ":where":break;case ":nth-child":case ":nth-last-child":if (c += 1, e.nodes && e.nodes.length > 0) {const t = e.nodes[0].nodes.findIndex(e => "tag" === e.type && "of" === e.value.toLowerCase());if (t > -1) {const r = [s.default.selector({ nodes: e.nodes[0].nodes.slice(t + 1), value: "" })];e.nodes.length > 1 && r.push(...e.nodes.slice(1));const l = a(r);n += l.a, c += l.b, o += l.c;}}break;case ":local":case ":global":e.nodes && e.nodes.length > 0 && e.nodes.forEach(e => {const s = t(e);n += s.a, c += s.b, o += s.c;});break;default:c += 1;} else s.default.isContainer(e) && e.nodes.length > 0 && e.nodes.forEach(e => {const s = t(e);n += s.a, c += s.b, o += s.c;});return { a: n, b: c, c: o };}function a(e) {let s = { a: 0, b: 0, c: 0 };return e.forEach(e => {const a = t(e);a.a > s.a ? s = a : a.a < s.a || (a.b > s.b ? s = a : a.b < s.b || a.c > s.c && (s = a));}), s;}exports.compare = function (e, s) {return e.a === s.a ? e.b === s.b ? e.c - s.c : e.b - s.b : e.a - s.a;}, exports.selectorSpecificity = t;

    }, { "postcss-selector-parser": 27 }], 2: [function (require, module, exports) {

    }, {}], 3: [function (require, module, exports) {
      'use strict';
      const isRegexp = require('is-regexp');

      const flagMap = {
        global: 'g',
        ignoreCase: 'i',
        multiline: 'm',
        dotAll: 's',
        sticky: 'y',
        unicode: 'u' };


      module.exports = (regexp, options = {}) => {
        if (!isRegexp(regexp)) {
          throw new TypeError('Expected a RegExp instance');
        }

        const flags = Object.keys(flagMap).map((flag) =>
        (typeof options[flag] === 'boolean' ? options[flag] : regexp[flag]) ? flagMap[flag] : '').
        join('');

        const clonedRegexp = new RegExp(options.source || regexp.source, flags);

        clonedRegexp.lastIndex = typeof options.lastIndex === 'number' ?
        options.lastIndex :
        regexp.lastIndex;

        return clonedRegexp;
      };

    }, { "is-regexp": 16 }], 4: [function (require, module, exports) {
      Object.defineProperty(exports, "__esModule", { value: !0 });var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },t = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},n = function (r, t, n) {return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;},e = function (r, t, n) {return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;},u = function (r) {return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;},o = function (r) {return { r: e(r.r, 0, 255), g: e(r.g, 0, 255), b: e(r.b, 0, 255), a: e(r.a) };},a = function (r) {return { r: n(r.r), g: n(r.g), b: n(r.b), a: n(r.a, 3) };},s = /^#([0-9a-f]{3,8})$/i,i = function (r) {var t = r.toString(16);return t.length < 2 ? "0" + t : t;},h = function (r) {var t = r.r,n = r.g,e = r.b,u = r.a,o = Math.max(t, n, e),a = o - Math.min(t, n, e),s = a ? o === t ? (n - e) / a : o === n ? 2 + (e - t) / a : 4 + (t - n) / a : 0;return { h: 60 * (s < 0 ? s + 6 : s), s: o ? a / o * 100 : 0, v: o / 255 * 100, a: u };},b = function (r) {var t = r.h,n = r.s,e = r.v,u = r.a;t = t / 360 * 6, n /= 100, e /= 100;var o = Math.floor(t),a = e * (1 - n),s = e * (1 - (t - o) * n),i = e * (1 - (1 - t + o) * n),h = o % 6;return { r: 255 * [e, s, a, a, i, e][h], g: 255 * [i, e, e, s, a, a][h], b: 255 * [a, a, i, e, e, s][h], a: u };},d = function (r) {return { h: u(r.h), s: e(r.s, 0, 100), l: e(r.l, 0, 100), a: e(r.a) };},g = function (r) {return { h: n(r.h), s: n(r.s), l: n(r.l), a: n(r.a, 3) };},f = function (r) {return b((n = (t = r).s, { h: t.h, s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0, v: e + n, a: t.a }));var t, n, e;},p = function (r) {return { h: (t = h(r)).h, s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0, l: u / 2, a: t.a };var t, n, e, u;},l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y = { string: [[function (r) {var t = s.exec(r);return t ? (r = t[1]).length <= 4 ? { r: parseInt(r[0] + r[0], 16), g: parseInt(r[1] + r[1], 16), b: parseInt(r[2] + r[2], 16), a: 4 === r.length ? n(parseInt(r[3] + r[3], 16) / 255, 2) : 1 } : 6 === r.length || 8 === r.length ? { r: parseInt(r.substr(0, 2), 16), g: parseInt(r.substr(2, 2), 16), b: parseInt(r.substr(4, 2), 16), a: 8 === r.length ? n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1 } : null : null;}, "hex"], [function (r) {var t = v.exec(r) || m.exec(r);return t ? t[2] !== t[4] || t[4] !== t[6] ? null : o({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;}, "rgb"], [function (t) {var n = l.exec(t) || c.exec(t);if (!n) return null;var e,u,o = d({ h: (e = n[1], u = n[2], void 0 === u && (u = "deg"), Number(e) * (r[u] || 1)), s: Number(n[3]), l: Number(n[4]), a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1) });return f(o);}, "hsl"]], object: [[function (r) {var n = r.r,e = r.g,u = r.b,a = r.a,s = void 0 === a ? 1 : a;return t(n) && t(e) && t(u) ? o({ r: Number(n), g: Number(e), b: Number(u), a: Number(s) }) : null;}, "rgb"], [function (r) {var n = r.h,e = r.s,u = r.l,o = r.a,a = void 0 === o ? 1 : o;if (!t(n) || !t(e) || !t(u)) return null;var s = d({ h: Number(n), s: Number(e), l: Number(u), a: Number(a) });return f(s);}, "hsl"], [function (r) {var n = r.h,o = r.s,a = r.v,s = r.a,i = void 0 === s ? 1 : s;if (!t(n) || !t(o) || !t(a)) return null;var h = function (r) {return { h: u(r.h), s: e(r.s, 0, 100), v: e(r.v, 0, 100), a: e(r.a) };}({ h: Number(n), s: Number(o), v: Number(a), a: Number(i) });return b(h);}, "hsv"]] },N = function (r, t) {for (var n = 0; n < t.length; n++) {var e = t[n][0](r);if (e) return [e, t[n][1]];}return [null, void 0];},x = function (r) {return "string" == typeof r ? N(r.trim(), y.string) : "object" == typeof r && null !== r ? N(r, y.object) : [null, void 0];},M = function (r, t) {var n = p(r);return { h: n.h, s: e(n.s + 100 * t, 0, 100), l: n.l, a: n.a };},I = function (r) {return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;},H = function (r, t) {var n = p(r);return { h: n.h, s: n.s, l: e(n.l + 100 * t, 0, 100), a: n.a };},$ = function () {function r(r) {this.parsed = x(r)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };}return r.prototype.isValid = function () {return null !== this.parsed;}, r.prototype.brightness = function () {return n(I(this.rgba), 2);}, r.prototype.isDark = function () {return I(this.rgba) < .5;}, r.prototype.isLight = function () {return I(this.rgba) >= .5;}, r.prototype.toHex = function () {return r = a(this.rgba), t = r.r, e = r.g, u = r.b, s = (o = r.a) < 1 ? i(n(255 * o)) : "", "#" + i(t) + i(e) + i(u) + s;var r, t, e, u, o, s;}, r.prototype.toRgb = function () {return a(this.rgba);}, r.prototype.toRgbString = function () {return r = a(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? "rgba(" + t + ", " + n + ", " + e + ", " + u + ")" : "rgb(" + t + ", " + n + ", " + e + ")";var r, t, n, e, u;}, r.prototype.toHsl = function () {return g(p(this.rgba));}, r.prototype.toHslString = function () {return r = g(p(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? "hsla(" + t + ", " + n + "%, " + e + "%, " + u + ")" : "hsl(" + t + ", " + n + "%, " + e + "%)";var r, t, n, e, u;}, r.prototype.toHsv = function () {return r = h(this.rgba), { h: n(r.h), s: n(r.s), v: n(r.v), a: n(r.a, 3) };var r;}, r.prototype.invert = function () {return j({ r: 255 - (r = this.rgba).r, g: 255 - r.g, b: 255 - r.b, a: r.a });var r;}, r.prototype.saturate = function (r) {return void 0 === r && (r = .1), j(M(this.rgba, r));}, r.prototype.desaturate = function (r) {return void 0 === r && (r = .1), j(M(this.rgba, -r));}, r.prototype.grayscale = function () {return j(M(this.rgba, -1));}, r.prototype.lighten = function (r) {return void 0 === r && (r = .1), j(H(this.rgba, r));}, r.prototype.darken = function (r) {return void 0 === r && (r = .1), j(H(this.rgba, -r));}, r.prototype.rotate = function (r) {return void 0 === r && (r = 15), this.hue(this.hue() + r);}, r.prototype.alpha = function (r) {return "number" == typeof r ? j({ r: (t = this.rgba).r, g: t.g, b: t.b, a: r }) : n(this.rgba.a, 3);var t;}, r.prototype.hue = function (r) {var t = p(this.rgba);return "number" == typeof r ? j({ h: r, s: t.s, l: t.l, a: t.a }) : n(t.h);}, r.prototype.isEqual = function (r) {return this.toHex() === j(r).toHex();}, r;}(),j = function (r) {return r instanceof $ ? r : new $(r);},w = [];exports.Colord = $, exports.colord = j, exports.extend = function (r) {r.forEach(function (r) {w.indexOf(r) < 0 && (r($, y), w.push(r));});}, exports.getFormat = function (r) {return x(r)[1];}, exports.random = function () {return new $({ r: 255 * Math.random(), g: 255 * Math.random(), b: 255 * Math.random() });};

    }, {}], 5: [function (require, module, exports) {
      var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },n = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},t = function (r, n, t) {return void 0 === n && (n = 0), void 0 === t && (t = Math.pow(10, n)), Math.round(t * r) / t + 0;},u = function (r, n, t) {return void 0 === n && (n = 0), void 0 === t && (t = 1), r > t ? t : r > n ? r : n;},a = function (r) {return { h: (n = r.h, (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360), w: u(r.w, 0, 100), b: u(r.b, 0, 100), a: u(r.a) };var n;},e = function (r) {return { h: t(r.h), w: t(r.w), b: t(r.b), a: t(r.a, 3) };},o = function (r) {return { h: function (r) {var n = r.r,t = r.g,u = r.b,a = r.a,e = Math.max(n, t, u),o = e - Math.min(n, t, u),b = o ? e === n ? (t - u) / o : e === t ? 2 + (u - n) / o : 4 + (n - t) / o : 0;return { h: 60 * (b < 0 ? b + 6 : b), s: e ? o / e * 100 : 0, v: e / 255 * 100, a: a };}(r).h, w: Math.min(r.r, r.g, r.b) / 255 * 100, b: 100 - Math.max(r.r, r.g, r.b) / 255 * 100, a: r.a };},b = function (r) {return function (r) {var n = r.h,t = r.s,u = r.v,a = r.a;n = n / 360 * 6, t /= 100, u /= 100;var e = Math.floor(n),o = u * (1 - t),b = u * (1 - (n - e) * t),i = u * (1 - (1 - n + e) * t),h = e % 6;return { r: 255 * [u, b, o, o, i, u][h], g: 255 * [i, u, u, b, o, o][h], b: 255 * [o, o, i, u, u, b][h], a: a };}({ h: r.h, s: 100 === r.b ? 0 : 100 - r.w / (100 - r.b) * 100, v: 100 - r.b, a: r.a });},i = function (r) {var t = r.h,u = r.w,e = r.b,o = r.a,i = void 0 === o ? 1 : o;if (!n(t) || !n(u) || !n(e)) return null;var h = a({ h: Number(t), w: Number(u), b: Number(e), a: Number(i) });return b(h);},h = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,d = function (n) {var t = h.exec(n);if (!t) return null;var u,e,o = a({ h: (u = t[1], e = t[2], void 0 === e && (e = "deg"), Number(u) * (r[e] || 1)), w: Number(t[3]), b: Number(t[4]), a: void 0 === t[5] ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });return b(o);};module.exports = function (r, n) {r.prototype.toHwb = function () {return e(o(this.rgba));}, r.prototype.toHwbString = function () {return r = e(o(this.rgba)), n = r.h, t = r.w, u = r.b, (a = r.a) < 1 ? "hwb(" + n + " " + t + "% " + u + "% / " + a + ")" : "hwb(" + n + " " + t + "% " + u + "%)";var r, n, t, u, a;}, n.string.push([d, "hwb"]), n.object.push([i, "hwb"]);};

    }, {}], 6: [function (require, module, exports) {
      var a = function (a) {return "string" == typeof a ? a.length > 0 : "number" == typeof a;},t = function (a, t, o) {return void 0 === t && (t = 0), void 0 === o && (o = Math.pow(10, t)), Math.round(o * a) / o + 0;},o = function (a, t, o) {return void 0 === t && (t = 0), void 0 === o && (o = 1), a > o ? o : a > t ? a : t;},r = function (a) {var t = a / 255;return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);},h = function (a) {return 255 * (a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a);},n = 96.422,p = 100,M = 82.521,u = function (a) {var t,r,n = { x: .9555766 * (t = a).x + -.0230393 * t.y + .0631636 * t.z, y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z, z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z };return r = { r: h(.032404542 * n.x - .015371385 * n.y - .004985314 * n.z), g: h(-.00969266 * n.x + .018760108 * n.y + 41556e-8 * n.z), b: h(556434e-9 * n.x - .002040259 * n.y + .010572252 * n.z), a: a.a }, { r: o(r.r, 0, 255), g: o(r.g, 0, 255), b: o(r.b, 0, 255), a: o(r.a) };},e = function (a) {var t = r(a.r),h = r(a.g),u = r(a.b);return function (a) {return { x: o(a.x, 0, n), y: o(a.y, 0, p), z: o(a.z, 0, M), a: o(a.a) };}(function (a) {return { x: 1.0478112 * a.x + .0228866 * a.y + -.050127 * a.z, y: .0295424 * a.x + .9904844 * a.y + -.0170491 * a.z, z: -.0092345 * a.x + .0150436 * a.y + .7521316 * a.z, a: a.a };}({ x: 100 * (.4124564 * t + .3575761 * h + .1804375 * u), y: 100 * (.2126729 * t + .7151522 * h + .072175 * u), z: 100 * (.0193339 * t + .119192 * h + .9503041 * u), a: a.a }));},w = 216 / 24389,b = 24389 / 27,i = function (t) {var r = t.l,h = t.a,n = t.b,p = t.alpha,M = void 0 === p ? 1 : p;if (!a(r) || !a(h) || !a(n)) return null;var u = function (a) {return { l: o(a.l, 0, 400), a: a.a, b: a.b, alpha: o(a.alpha) };}({ l: Number(r), a: Number(h), b: Number(n), alpha: Number(M) });return l(u);},l = function (a) {var t = (a.l + 16) / 116,o = a.a / 500 + t,r = t - a.b / 200;return u({ x: (Math.pow(o, 3) > w ? Math.pow(o, 3) : (116 * o - 16) / b) * n, y: (a.l > 8 ? Math.pow((a.l + 16) / 116, 3) : a.l / b) * p, z: (Math.pow(r, 3) > w ? Math.pow(r, 3) : (116 * r - 16) / b) * M, a: a.alpha });};module.exports = function (a, r) {a.prototype.toLab = function () {return o = e(this.rgba), h = o.y / p, u = o.z / M, r = (r = o.x / n) > w ? Math.cbrt(r) : (b * r + 16) / 116, a = { l: 116 * (h = h > w ? Math.cbrt(h) : (b * h + 16) / 116) - 16, a: 500 * (r - h), b: 200 * (h - (u = u > w ? Math.cbrt(u) : (b * u + 16) / 116)), alpha: o.a }, { l: t(a.l, 2), a: t(a.a, 2), b: t(a.b, 2), alpha: t(a.alpha, 3) };var a, o, r, h, u;}, a.prototype.delta = function (r) {void 0 === r && (r = "#FFF");var h = r instanceof a ? r : new a(r),n = function (a, t) {var o = a.l,r = a.a,h = a.b,n = t.l,p = t.a,M = t.b,u = 180 / Math.PI,e = Math.PI / 180,w = Math.pow(Math.pow(r, 2) + Math.pow(h, 2), .5),b = Math.pow(Math.pow(p, 2) + Math.pow(M, 2), .5),i = (o + n) / 2,l = Math.pow((w + b) / 2, 7),c = .5 * (1 - Math.pow(l / (l + Math.pow(25, 7)), .5)),f = r * (1 + c),y = p * (1 + c),v = Math.pow(Math.pow(f, 2) + Math.pow(h, 2), .5),x = Math.pow(Math.pow(y, 2) + Math.pow(M, 2), .5),z = (v + x) / 2,s = 0 === f && 0 === h ? 0 : Math.atan2(h, f) * u,d = 0 === y && 0 === M ? 0 : Math.atan2(M, y) * u;s < 0 && (s += 360), d < 0 && (d += 360);var g = d - s,m = Math.abs(d - s);m > 180 && d <= s ? g += 360 : m > 180 && d > s && (g -= 360);var N = s + d;m <= 180 ? N /= 2 : N = (s + d < 360 ? N + 360 : N - 360) / 2;var F = 1 - .17 * Math.cos(e * (N - 30)) + .24 * Math.cos(2 * e * N) + .32 * Math.cos(e * (3 * N + 6)) - .2 * Math.cos(e * (4 * N - 63)),L = n - o,I = x - v,P = 2 * Math.sin(e * g / 2) * Math.pow(v * x, .5),j = 1 + .015 * Math.pow(i - 50, 2) / Math.pow(20 + Math.pow(i - 50, 2), .5),k = 1 + .045 * z,q = 1 + .015 * z * F,A = 30 * Math.exp(-1 * Math.pow((N - 275) / 25, 2)),B = -2 * Math.pow(l / (l + Math.pow(25, 7)), .5) * Math.sin(2 * e * A);return Math.pow(Math.pow(L / 1 / j, 2) + Math.pow(I / 1 / k, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k * 1 * q), .5);}(this.toLab(), h.toLab()) / 100;return o(t(n, 3));}, r.object.push([i, "lab"]);};

    }, {}], 7: [function (require, module, exports) {
      var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },t = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},a = function (r, t, a) {return void 0 === t && (t = 0), void 0 === a && (a = Math.pow(10, t)), Math.round(a * r) / a + 0;},n = function (r, t, a) {return void 0 === t && (t = 0), void 0 === a && (a = 1), r > a ? a : r > t ? r : t;},u = function (r) {var t = r / 255;return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);},h = function (r) {return 255 * (r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r);},o = 96.422,e = 100,c = 82.521,i = function (r) {var t,a,u = { x: .9555766 * (t = r).x + -.0230393 * t.y + .0631636 * t.z, y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z, z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z };return a = { r: h(.032404542 * u.x - .015371385 * u.y - .004985314 * u.z), g: h(-.00969266 * u.x + .018760108 * u.y + 41556e-8 * u.z), b: h(556434e-9 * u.x - .002040259 * u.y + .010572252 * u.z), a: r.a }, { r: n(a.r, 0, 255), g: n(a.g, 0, 255), b: n(a.b, 0, 255), a: n(a.a) };},l = function (r) {var t = u(r.r),a = u(r.g),h = u(r.b);return function (r) {return { x: n(r.x, 0, o), y: n(r.y, 0, e), z: n(r.z, 0, c), a: n(r.a) };}(function (r) {return { x: 1.0478112 * r.x + .0228866 * r.y + -.050127 * r.z, y: .0295424 * r.x + .9904844 * r.y + -.0170491 * r.z, z: -.0092345 * r.x + .0150436 * r.y + .7521316 * r.z, a: r.a };}({ x: 100 * (.4124564 * t + .3575761 * a + .1804375 * h), y: 100 * (.2126729 * t + .7151522 * a + .072175 * h), z: 100 * (.0193339 * t + .119192 * a + .9503041 * h), a: r.a }));},b = 216 / 24389,d = 24389 / 27,f = function (r) {return { l: n(r.l, 0, 100), c: r.c, h: (t = r.h, (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360), a: r.a };var t;},p = function (r) {return { l: a(r.l, 2), c: a(r.c, 2), h: a(r.h, 2), a: a(r.a, 3) };},v = function (r) {var a = r.l,n = r.c,u = r.h,h = r.a,o = void 0 === h ? 1 : h;if (!t(a) || !t(n) || !t(u)) return null;var e = f({ l: Number(a), c: Number(n), h: Number(u), a: Number(o) });return M(e);},y = function (r) {var t = function (r) {var t = l(r),a = t.x / o,n = t.y / e,u = t.z / c;return a = a > b ? Math.cbrt(a) : (d * a + 16) / 116, { l: 116 * (n = n > b ? Math.cbrt(n) : (d * n + 16) / 116) - 16, a: 500 * (a - n), b: 200 * (n - (u = u > b ? Math.cbrt(u) : (d * u + 16) / 116)), alpha: t.a };}(r),n = a(t.a, 3),u = a(t.b, 3),h = Math.atan2(u, n) / Math.PI * 180;return { l: t.l, c: Math.sqrt(n * n + u * u), h: h < 0 ? h + 360 : h, a: t.alpha };},M = function (r) {return t = { l: r.l, a: r.c * Math.cos(r.h * Math.PI / 180), b: r.c * Math.sin(r.h * Math.PI / 180), alpha: r.a }, n = t.a / 500 + (a = (t.l + 16) / 116), u = a - t.b / 200, i({ x: (Math.pow(n, 3) > b ? Math.pow(n, 3) : (116 * n - 16) / d) * o, y: (t.l > 8 ? Math.pow((t.l + 16) / 116, 3) : t.l / d) * e, z: (Math.pow(u, 3) > b ? Math.pow(u, 3) : (116 * u - 16) / d) * c, a: t.alpha });var t, a, n, u;},x = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,s = function (t) {var a = x.exec(t);if (!a) return null;var n,u,h = f({ l: Number(a[1]), c: Number(a[2]), h: (n = a[3], u = a[4], void 0 === u && (u = "deg"), Number(n) * (r[u] || 1)), a: void 0 === a[5] ? 1 : Number(a[5]) / (a[6] ? 100 : 1) });return M(h);};module.exports = function (r, t) {r.prototype.toLch = function () {return p(y(this.rgba));}, r.prototype.toLchString = function () {return r = p(y(this.rgba)), t = r.l, a = r.c, n = r.h, (u = r.a) < 1 ? "lch(" + t + "% " + a + " " + n + " / " + u + ")" : "lch(" + t + "% " + a + " " + n + ")";var r, t, a, n, u;}, t.string.push([s, "lch"]), t.object.push([v, "lch"]);};

    }, {}], 8: [function (require, module, exports) {
      module.exports = function (e, f) {var a = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" },r = {};for (var d in a) r[a[d]] = d;var l = {};e.prototype.toName = function (f) {if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";var d,i,o = r[this.toHex()];if (o) return o;if (null == f ? void 0 : f.closest) {var n = this.toRgb(),t = 1 / 0,b = "black";if (!l.length) for (var c in a) l[c] = new e(a[c]).toRgb();for (var g in a) {var u = (d = n, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));u < t && (t = u, b = g);}return b;}};f.string.push([function (f) {var r = f.toLowerCase(),d = "transparent" === r ? "#0000" : a[r];return d ? new e(d).toRgb() : null;}, "name"]);};

    }, {}], 9: [function (require, module, exports) {
      /*! https://mths.be/cssesc v3.0.0 by @mathias */
      'use strict';

      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        for (var key in defaults) {
          // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
          // only recognized option names are used.
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
        }
        return result;
      };

      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexAlwaysEscape = /['"\\]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

      // https://mathiasbynens.be/notes/css-escapes#css
      var cssesc = function cssesc(string, options) {
        options = merge(options, cssesc.options);
        if (options.quotes != 'single' && options.quotes != 'double') {
          options.quotes = 'single';
        }
        var quote = options.quotes == 'double' ? '"' : '\'';
        var isIdentifier = options.isIdentifier;

        var firstChar = string.charAt(0);
        var output = '';
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value = void 0;
          // If it’s not a printable ASCII character…
          if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
              // It’s a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // next character is low surrogate
                codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
              } else {
                // It’s an unmatched surrogate; only append this code unit, in case
                // the next code unit is the high surrogate of a surrogate pair.
                counter--;
              }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value = '\\' + character;
              } else {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value = '\\' + character;
            } else {
              value = character;
            }
          }
          output += value;
        }

        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
          }
        }

        // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
        // since they’re redundant. Note that this is only possible if the escape
        // sequence isn’t preceded by an odd number of backslashes.
        output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
          if ($1 && $1.length % 2) {
            // It’s not safe to remove the space, so don’t.
            return $0;
          }
          // Strip the space.
          return ($1 || '') + $2;
        });

        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };

      // Expose default options (so they can be overridden globally).
      cssesc.options = {
        'escapeEverything': false,
        'isIdentifier': false,
        'quotes': 'single',
        'wrap': false };


      cssesc.version = '3.0.0';

      module.exports = cssesc;

    }, {}], 10: [function (require, module, exports) {
      'use strict';
      const cloneRegexp = require('clone-regexp');

      module.exports = (regexp, string) => {
        let match;
        const matches = [];
        const clonedRegexp = cloneRegexp(regexp, { lastIndex: 0 });
        const isGlobal = clonedRegexp.global;

        // eslint-disable-next-line no-cond-assign
        while (match = clonedRegexp.exec(string)) {
          matches.push({
            match: match[0],
            subMatches: match.slice(1),
            index: match.index });


          if (!isGlobal) {
            break;
          }
        }

        return matches;
      };

    }, { "clone-regexp": 3 }], 11: [function (require, module, exports) {
      "use strict";
      exports.__esModule = true;
      exports.distance = exports.closest = void 0;
      var peq = new Uint32Array(0x10000);
      var myers_32 = function (a, b) {
        var n = a.length;
        var m = b.length;
        var lst = 1 << n - 1;
        var pv = -1;
        var mv = 0;
        var sc = n;
        var i = n;
        while (i--) {
          peq[a.charCodeAt(i)] |= 1 << i;
        }
        for (i = 0; i < m; i++) {
          var eq = peq[b.charCodeAt(i)];
          var xv = eq | mv;
          eq |= (eq & pv) + pv ^ pv;
          mv |= ~(eq | pv);
          pv &= eq;
          if (mv & lst) {
            sc++;
          }
          if (pv & lst) {
            sc--;
          }
          mv = mv << 1 | 1;
          pv = pv << 1 | ~(xv | mv);
          mv &= xv;
        }
        i = n;
        while (i--) {
          peq[a.charCodeAt(i)] = 0;
        }
        return sc;
      };
      var myers_x = function (b, a) {
        var n = a.length;
        var m = b.length;
        var mhc = [];
        var phc = [];
        var hsize = Math.ceil(n / 32);
        var vsize = Math.ceil(m / 32);
        for (var i = 0; i < hsize; i++) {
          phc[i] = -1;
          mhc[i] = 0;
        }
        var j = 0;
        for (; j < vsize - 1; j++) {
          var mv_1 = 0;
          var pv_1 = -1;
          var start_1 = j * 32;
          var vlen_1 = Math.min(32, m) + start_1;
          for (var k = start_1; k < vlen_1; k++) {
            peq[b.charCodeAt(k)] |= 1 << k;
          }
          for (var i = 0; i < n; i++) {
            var eq = peq[a.charCodeAt(i)];
            var pb = phc[i / 32 | 0] >>> i & 1;
            var mb = mhc[i / 32 | 0] >>> i & 1;
            var xv = eq | mv_1;
            var xh = ((eq | mb) & pv_1) + pv_1 ^ pv_1 | eq | mb;
            var ph = mv_1 | ~(xh | pv_1);
            var mh = pv_1 & xh;
            if (ph >>> 31 ^ pb) {
              phc[i / 32 | 0] ^= 1 << i;
            }
            if (mh >>> 31 ^ mb) {
              mhc[i / 32 | 0] ^= 1 << i;
            }
            ph = ph << 1 | pb;
            mh = mh << 1 | mb;
            pv_1 = mh | ~(xv | ph);
            mv_1 = ph & xv;
          }
          for (var k = start_1; k < vlen_1; k++) {
            peq[b.charCodeAt(k)] = 0;
          }
        }
        var mv = 0;
        var pv = -1;
        var start = j * 32;
        var vlen = Math.min(32, m - start) + start;
        for (var k = start; k < vlen; k++) {
          peq[b.charCodeAt(k)] |= 1 << k;
        }
        var score = m;
        for (var i = 0; i < n; i++) {
          var eq = peq[a.charCodeAt(i)];
          var pb = phc[i / 32 | 0] >>> i & 1;
          var mb = mhc[i / 32 | 0] >>> i & 1;
          var xv = eq | mv;
          var xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
          var ph = mv | ~(xh | pv);
          var mh = pv & xh;
          score += ph >>> m - 1 & 1;
          score -= mh >>> m - 1 & 1;
          if (ph >>> 31 ^ pb) {
            phc[i / 32 | 0] ^= 1 << i;
          }
          if (mh >>> 31 ^ mb) {
            mhc[i / 32 | 0] ^= 1 << i;
          }
          ph = ph << 1 | pb;
          mh = mh << 1 | mb;
          pv = mh | ~(xv | ph);
          mv = ph & xv;
        }
        for (var k = start; k < vlen; k++) {
          peq[b.charCodeAt(k)] = 0;
        }
        return score;
      };
      var distance = function (a, b) {
        if (a.length < b.length) {
          var tmp = b;
          b = a;
          a = tmp;
        }
        if (b.length === 0) {
          return a.length;
        }
        if (a.length <= 32) {
          return myers_32(a, b);
        }
        return myers_x(a, b);
      };
      exports.distance = distance;
      var closest = function (str, arr) {
        var min_distance = Infinity;
        var min_index = 0;
        for (var i = 0; i < arr.length; i++) {
          var dist = distance(str, arr[i]);
          if (dist < min_distance) {
            min_distance = dist;
            min_index = i;
          }
        }
        return arr[min_index];
      };
      exports.closest = closest;

    }, {}], 12: [function (require, module, exports) {
      module.exports = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "math",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "slot",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"];


    }, {}], 13: [function (require, module, exports) {
      'use strict';
      module.exports = require('./html-tags.json');

    }, { "./html-tags.json": 12 }], 14: [function (require, module, exports) {
      // A simple implementation of make-array
      function makeArray(subject) {
        return Array.isArray(subject) ?
        subject :
        [subject];
      }

      const EMPTY = '';
      const SPACE = ' ';
      const ESCAPE = '\\';
      const REGEX_TEST_BLANK_LINE = /^\s+$/;
      const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
      const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
      const REGEX_SPLITALL_CRLF = /\r?\n/g;
      // /foo,
      // ./foo,
      // ../foo,
      // .
      // ..
      const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;

      const SLASH = '/';
      const KEY_IGNORE = typeof Symbol !== 'undefined' ?
      Symbol.for('node-ignore')
      /* istanbul ignore next */ :
      'node-ignore';

      const define = (object, key, value) =>
      Object.defineProperty(object, key, { value });

      const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

      const RETURN_FALSE = () => false;

      // Sanitize the range of a regular expression
      // The cases are complicated, see test cases for details
      const sanitizeRange = range => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ?
      match
      // Invalid range (out of order) which is ok for gitignore rules but
      //   fatal for JavaScript regular expression, so eliminate it.
      : EMPTY);


      // See fixtures #59
      const cleanRangeBackSlash = slashes => {
        const { length } = slashes;
        return slashes.slice(0, length - length % 2);
      };

      // > If the pattern ends with a slash,
      // > it is removed for the purpose of the following description,
      // > but it would only find a match with a directory.
      // > In other words, foo/ will match a directory foo and paths underneath it,
      // > but will not match a regular file or a symbolic link foo
      // >  (this is consistent with the way how pathspec works in general in Git).
      // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
      // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
      //      you could use option `mark: true` with `glob`

      // '`foo/`' should not continue with the '`..`'
      const REPLACERS = [

      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a \ ) -> (a  )
      /\\?\s+$/,
      match => match.indexOf('\\') === 0 ?
      SPACE :
      EMPTY],


      // replace (\ ) with ' '
      [
      /\\\s/g,
      () => SPACE],


      // Escape metacharacters
      // which is written down by users but means special for regular expressions.

      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
      /[\\$.|*+(){^]/g,
      match => `\\${match}`],


      [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => '[^/]'],


      // leading slash
      [

      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => '^'],


      // replace special metacharacter slash after the leading slash
      [
      /\//g,
      () => '\\/'],


      [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,

      // '**/foo' <-> 'foo'
      () => '^(?:.*\\/)?'],


      // starting
      [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      function startingReplacer() {
        // If has a slash `/` at the beginning or middle
        return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^';
      }],


      // two globstars
      [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,

      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer

      // Check if it is not the last `'/**'`
      (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'],


      // intermediate wildcards
      [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'

      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule
      /(^|[^\\]+)\\\*(?=.+)/g,

      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (_, p1) => `${p1}[^\\/]*`],


      [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE],


      [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => ESCAPE],


      [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.

      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` :
      close === ']' ?
      endEscape.length % 2 === 0
      // A normal case, and it is a range notation
      // '[bar]'
      // '[bar\\\\]'
      ? `[${sanitizeRange(range)}${endEscape}]`
      // Invalid range notaton
      // '[bar\\]' -> '[bar\\\\]'
      : '[]' :
      '[]'],


      // ending
      [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,

      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38

      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.

      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`],


      // trailing wildcard
      [
      /(\^|\\\/)?\\\*$/,
      (_, p1) => {
        const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*';

        return `${prefix}(?=$|\\/$)`;
      }]];



      // A simple cache, because an ignore rule only has only one certain meaning
      const regexCache = Object.create(null);

      // @param {pattern}
      const makeRegex = (pattern, ignoreCase) => {
        let source = regexCache[pattern];

        if (!source) {
          source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern);

          regexCache[pattern] = source;
        }

        return ignoreCase ?
        new RegExp(source, 'i') :
        new RegExp(source);
      };

      const isString = subject => typeof subject === 'string';

      // > A blank line matches no files, so it can serve as a separator for readability.
      const checkPattern = pattern => pattern &&
      isString(pattern) &&
      !REGEX_TEST_BLANK_LINE.test(pattern)

      // > A line starting with # serves as a comment.
      && pattern.indexOf('#') !== 0;

      const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

      class IgnoreRule {
        constructor(
        origin,
        pattern,
        negative,
        regex)
        {
          this.origin = origin;
          this.pattern = pattern;
          this.negative = negative;
          this.regex = regex;
        }}


      const createRule = (pattern, ignoreCase) => {
        const origin = pattern;
        let negative = false;

        // > An optional prefix "!" which negates the pattern;
        if (pattern.indexOf('!') === 0) {
          negative = true;
          pattern = pattern.substr(1);
        }

        pattern = pattern
        // > Put a backslash ("\") in front of the first "!" for patterns that
        // >   begin with a literal "!", for example, `"\!important!.txt"`.
        .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
        // > Put a backslash ("\") in front of the first hash for patterns that
        // >   begin with a hash.
        .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');

        const regex = makeRegex(pattern, ignoreCase);

        return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex);

      };

      const throwError = (message, Ctor) => {
        throw new Ctor(message);
      };

      const checkPath = (path, originalPath, doThrow) => {
        if (!isString(path)) {
          return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError);

        }

        // We don't know if we should ignore EMPTY, so throw
        if (!path) {
          return doThrow(`path must not be empty`, TypeError);
        }

        // Check if it is a relative path
        if (checkPath.isNotRelative(path)) {
          const r = '`path.relative()`d';
          return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError);

        }

        return true;
      };

      const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

      checkPath.isNotRelative = isNotRelative;
      checkPath.convert = p => p;

      class Ignore {
        constructor({
          ignorecase = true,
          ignoreCase = ignorecase,
          allowRelativePaths = false } =
        {}) {
          define(this, KEY_IGNORE, true);

          this._rules = [];
          this._ignoreCase = ignoreCase;
          this._allowRelativePaths = allowRelativePaths;
          this._initCache();
        }

        _initCache() {
          this._ignoreCache = Object.create(null);
          this._testCache = Object.create(null);
        }

        _addPattern(pattern) {
          // #32
          if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules);
            this._added = true;
            return;
          }

          if (checkPattern(pattern)) {
            const rule = createRule(pattern, this._ignoreCase);
            this._added = true;
            this._rules.push(rule);
          }
        }

        // @param {Array<string> | string | Ignore} pattern
        add(pattern) {
          this._added = false;

          makeArray(
          isString(pattern) ?
          splitPattern(pattern) :
          pattern).
          forEach(this._addPattern, this);

          // Some rules have just added to the ignore,
          // making the behavior changed.
          if (this._added) {
            this._initCache();
          }

          return this;
        }

        // legacy
        addPattern(pattern) {
          return this.add(pattern);
        }

        //          |           ignored : unignored
        // negative |   0:0   |   0:1   |   1:0   |   1:1
        // -------- | ------- | ------- | ------- | --------
        //     0    |  TEST   |  TEST   |  SKIP   |    X
        //     1    |  TESTIF |  SKIP   |  TEST   |    X

        // - SKIP: always skip
        // - TEST: always test
        // - TESTIF: only test if checkUnignored
        // - X: that never happen

        // @param {boolean} whether should check if the path is unignored,
        //   setting `checkUnignored` to `false` could reduce additional
        //   path matching.

        // @returns {TestResult} true if a file is ignored
        _testOne(path, checkUnignored) {
          let ignored = false;
          let unignored = false;

          this._rules.forEach(rule => {
            const { negative } = rule;
            if (
            unignored === negative && ignored !== unignored ||
            negative && !ignored && !unignored && !checkUnignored)
            {
              return;
            }

            const matched = rule.regex.test(path);

            if (matched) {
              ignored = !negative;
              unignored = negative;
            }
          });

          return {
            ignored,
            unignored };

        }

        // @returns {TestResult}
        _test(originalPath, cache, checkUnignored, slices) {
          const path = originalPath
          // Supports nullable path
          && checkPath.convert(originalPath);

          checkPath(
          path,
          originalPath,
          this._allowRelativePaths ?
          RETURN_FALSE :
          throwError);


          return this._t(path, cache, checkUnignored, slices);
        }

        _t(path, cache, checkUnignored, slices) {
          if (path in cache) {
            return cache[path];
          }

          if (!slices) {
            // path/to/a.js
            // ['path', 'to', 'a.js']
            slices = path.split(SLASH);
          }

          slices.pop();

          // If the path has no parent directory, just test it
          if (!slices.length) {
            return cache[path] = this._testOne(path, checkUnignored);
          }

          const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices);


          // If the path contains a parent directory, check the parent first
          return cache[path] = parent.ignored
          // > It is not possible to re-include a file if a parent directory of
          // >   that file is excluded.
          ? parent :
          this._testOne(path, checkUnignored);
        }

        ignores(path) {
          return this._test(path, this._ignoreCache, false).ignored;
        }

        createFilter() {
          return path => !this.ignores(path);
        }

        filter(paths) {
          return makeArray(paths).filter(this.createFilter());
        }

        // @returns {TestResult}
        test(path) {
          return this._test(path, this._testCache, true);
        }}


      const factory = options => new Ignore(options);

      const isPathValid = (path) =>
      checkPath(path && checkPath.convert(path), path, RETURN_FALSE);

      factory.isPathValid = isPathValid;

      // Fixes typescript
      factory.default = factory;

      module.exports = factory;

      // Windows
      // --------------------------------------------------------------
      /* istanbul ignore if  */
      if (
      // Detect `process` so that it can run in browsers.
      typeof process !== 'undefined' && (

      process.env && process.env.IGNORE_TEST_WIN32 ||
      process.platform === 'win32'))

      {
        /* eslint no-control-regex: "off" */
        const makePosix = str => /^\\\\\?\\/.test(str) ||
        /["<>|\u0000-\u001F]+/u.test(str) ?
        str :
        str.replace(/\\/g, '/');

        checkPath.convert = makePosix;

        // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
        // 'd:\\foo'
        const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
        checkPath.isNotRelative = (path) =>
        REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) ||
        isNotRelative(path);
      }

    }, {}], 15: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, '__esModule', { value: true });

      /*!
       * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */

      function isObject(o) {
        return Object.prototype.toString.call(o) === '[object Object]';
      }

      function isPlainObject(o) {
        var ctor, prot;

        if (isObject(o) === false) return false;

        // If has modified constructor
        ctor = o.constructor;
        if (ctor === undefined) return true;

        // If has modified prototype
        prot = ctor.prototype;
        if (isObject(prot) === false) return false;

        // If constructor does not have an Object-specific method
        if (prot.hasOwnProperty('isPrototypeOf') === false) {
          return false;
        }

        // Most likely a plain Object
        return true;
      }

      exports.isPlainObject = isPlainObject;

    }, {}], 16: [function (require, module, exports) {
      'use strict';

      module.exports = input => Object.prototype.toString.call(input) === '[object RegExp]';

    }, {}], 17: [function (require, module, exports) {
      module.exports = {
        "properties": [
        "-epub-caption-side",
        "-epub-hyphens",
        "-epub-text-combine",
        "-epub-text-emphasis",
        "-epub-text-emphasis-color",
        "-epub-text-emphasis-style",
        "-epub-text-orientation",
        "-epub-text-transform",
        "-epub-word-break",
        "-epub-writing-mode",
        "-internal-text-autosizing-status",
        "accelerator",
        "accent-color",
        "-wap-accesskey",
        "additive-symbols",
        "align-content",
        "-webkit-align-content",
        "align-items",
        "-webkit-align-items",
        "align-self",
        "-webkit-align-self",
        "alignment-baseline",
        "all",
        "alt",
        "-webkit-alt",
        "animation",
        "animation-delay",
        "-moz-animation-delay",
        "-ms-animation-delay",
        "-webkit-animation-delay",
        "animation-direction",
        "-moz-animation-direction",
        "-ms-animation-direction",
        "-webkit-animation-direction",
        "animation-duration",
        "-moz-animation-duration",
        "-ms-animation-duration",
        "-webkit-animation-duration",
        "animation-fill-mode",
        "-moz-animation-fill-mode",
        "-ms-animation-fill-mode",
        "-webkit-animation-fill-mode",
        "animation-iteration-count",
        "-moz-animation-iteration-count",
        "-ms-animation-iteration-count",
        "-webkit-animation-iteration-count",
        "-moz-animation",
        "-ms-animation",
        "animation-name",
        "-moz-animation-name",
        "-ms-animation-name",
        "-webkit-animation-name",
        "animation-play-state",
        "-moz-animation-play-state",
        "-ms-animation-play-state",
        "-webkit-animation-play-state",
        "animation-timing-function",
        "-moz-animation-timing-function",
        "-ms-animation-timing-function",
        "-webkit-animation-timing-function",
        "-webkit-animation-trigger",
        "-webkit-animation",
        "app-region",
        "-webkit-app-region",
        "appearance",
        "-moz-appearance",
        "-webkit-appearance",
        "ascent-override",
        "aspect-ratio",
        "-webkit-aspect-ratio",
        "audio-level",
        "azimuth",
        "backdrop-filter",
        "-webkit-backdrop-filter",
        "backface-visibility",
        "-moz-backface-visibility",
        "-ms-backface-visibility",
        "-webkit-backface-visibility",
        "background",
        "background-attachment",
        "-webkit-background-attachment",
        "background-blend-mode",
        "background-clip",
        "-moz-background-clip",
        "-webkit-background-clip",
        "background-color",
        "-webkit-background-color",
        "-webkit-background-composite",
        "background-image",
        "-webkit-background-image",
        "-moz-background-inline-policy",
        "background-origin",
        "-moz-background-origin",
        "-webkit-background-origin",
        "background-position",
        "-webkit-background-position",
        "background-position-x",
        "-webkit-background-position-x",
        "background-position-y",
        "-webkit-background-position-y",
        "background-repeat",
        "-webkit-background-repeat",
        "background-repeat-x",
        "background-repeat-y",
        "background-size",
        "-moz-background-size",
        "-webkit-background-size",
        "-webkit-background",
        "base-palette",
        "baseline-shift",
        "baseline-source",
        "behavior",
        "-moz-binding",
        "block-ellipsis",
        "-ms-block-progression",
        "block-size",
        "block-step",
        "block-step-align",
        "block-step-insert",
        "block-step-round",
        "block-step-size",
        "bookmark-label",
        "bookmark-level",
        "bookmark-state",
        "border",
        "-webkit-border-after-color",
        "-webkit-border-after-style",
        "-webkit-border-after",
        "-webkit-border-after-width",
        "-webkit-border-before-color",
        "-webkit-border-before-style",
        "-webkit-border-before",
        "-webkit-border-before-width",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "-moz-border-bottom-colors",
        "border-bottom-left-radius",
        "-webkit-border-bottom-left-radius",
        "border-bottom-right-radius",
        "-webkit-border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-boundary",
        "border-collapse",
        "border-color",
        "-moz-border-end-color",
        "-webkit-border-end-color",
        "border-end-end-radius",
        "-moz-border-end",
        "border-end-start-radius",
        "-moz-border-end-style",
        "-webkit-border-end-style",
        "-webkit-border-end",
        "-moz-border-end-width",
        "-webkit-border-end-width",
        "-webkit-border-fit",
        "-webkit-border-horizontal-spacing",
        "border-image",
        "-moz-border-image",
        "-o-border-image",
        "border-image-outset",
        "-webkit-border-image-outset",
        "border-image-repeat",
        "-webkit-border-image-repeat",
        "border-image-slice",
        "-webkit-border-image-slice",
        "border-image-source",
        "-webkit-border-image-source",
        "-webkit-border-image",
        "border-image-width",
        "-webkit-border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "-moz-border-left-colors",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "-moz-border-radius-bottomleft",
        "-moz-border-radius-bottomright",
        "-moz-border-radius",
        "-moz-border-radius-topleft",
        "-moz-border-radius-topright",
        "-webkit-border-radius",
        "border-right",
        "border-right-color",
        "-moz-border-right-colors",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "-moz-border-start-color",
        "-webkit-border-start-color",
        "border-start-end-radius",
        "-moz-border-start",
        "border-start-start-radius",
        "-moz-border-start-style",
        "-webkit-border-start-style",
        "-webkit-border-start",
        "-moz-border-start-width",
        "-webkit-border-start-width",
        "border-style",
        "border-top",
        "border-top-color",
        "-moz-border-top-colors",
        "border-top-left-radius",
        "-webkit-border-top-left-radius",
        "border-top-right-radius",
        "-webkit-border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "-webkit-border-vertical-spacing",
        "border-width",
        "bottom",
        "-moz-box-align",
        "-webkit-box-align",
        "box-decoration-break",
        "-webkit-box-decoration-break",
        "-moz-box-direction",
        "-webkit-box-direction",
        "-webkit-box-flex-group",
        "-moz-box-flex",
        "-webkit-box-flex",
        "-webkit-box-lines",
        "-moz-box-ordinal-group",
        "-webkit-box-ordinal-group",
        "-moz-box-orient",
        "-webkit-box-orient",
        "-moz-box-pack",
        "-webkit-box-pack",
        "-webkit-box-reflect",
        "box-shadow",
        "-moz-box-shadow",
        "-webkit-box-shadow",
        "box-sizing",
        "-moz-box-sizing",
        "-webkit-box-sizing",
        "box-snap",
        "break-after",
        "break-before",
        "break-inside",
        "buffered-rendering",
        "caption-side",
        "caret",
        "caret-color",
        "caret-shape",
        "chains",
        "clear",
        "clip",
        "clip-path",
        "-webkit-clip-path",
        "clip-rule",
        "color",
        "color-adjust",
        "-webkit-color-correction",
        "-apple-color-filter",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "color-scheme",
        "-webkit-column-axis",
        "-webkit-column-break-after",
        "-webkit-column-break-before",
        "-webkit-column-break-inside",
        "column-count",
        "-moz-column-count",
        "-webkit-column-count",
        "column-fill",
        "-moz-column-fill",
        "-webkit-column-fill",
        "column-gap",
        "-moz-column-gap",
        "-webkit-column-gap",
        "column-progression",
        "-webkit-column-progression",
        "column-rule",
        "column-rule-color",
        "-moz-column-rule-color",
        "-webkit-column-rule-color",
        "-moz-column-rule",
        "column-rule-style",
        "-moz-column-rule-style",
        "-webkit-column-rule-style",
        "-webkit-column-rule",
        "column-rule-width",
        "-moz-column-rule-width",
        "-webkit-column-rule-width",
        "column-span",
        "-moz-column-span",
        "-webkit-column-span",
        "column-width",
        "-moz-column-width",
        "-webkit-column-width",
        "columns",
        "-moz-columns",
        "-webkit-columns",
        "-webkit-composition-fill-color",
        "-webkit-composition-frame-color",
        "contain",
        "contain-intrinsic-block-size",
        "contain-intrinsic-height",
        "contain-intrinsic-inline-size",
        "contain-intrinsic-size",
        "contain-intrinsic-width",
        "container",
        "container-name",
        "container-type",
        "content",
        "content-visibility",
        "-ms-content-zoom-chaining",
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min",
        "-ms-content-zoom-limit",
        "-ms-content-zoom-snap",
        "-ms-content-zoom-snap-points",
        "-ms-content-zoom-snap-type",
        "-ms-content-zooming",
        "continue",
        "counter-increment",
        "counter-reset",
        "counter-set",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "-webkit-cursor-visibility",
        "cx",
        "cy",
        "d",
        "-apple-dashboard-region",
        "-webkit-dashboard-region",
        "descent-override",
        "direction",
        "display",
        "display-align",
        "dominant-baseline",
        "elevation",
        "empty-cells",
        "enable-background",
        "epub-caption-side",
        "epub-hyphens",
        "epub-text-combine",
        "epub-text-emphasis",
        "epub-text-emphasis-color",
        "epub-text-emphasis-style",
        "epub-text-orientation",
        "epub-text-transform",
        "epub-word-break",
        "epub-writing-mode",
        "fallback",
        "fill",
        "fill-break",
        "fill-color",
        "fill-image",
        "fill-opacity",
        "fill-origin",
        "fill-position",
        "fill-repeat",
        "fill-rule",
        "fill-size",
        "filter",
        "-ms-filter",
        "-webkit-filter",
        "flex",
        "-ms-flex-align",
        "-webkit-flex-align",
        "flex-basis",
        "-webkit-flex-basis",
        "flex-direction",
        "-ms-flex-direction",
        "-webkit-flex-direction",
        "flex-flow",
        "-ms-flex-flow",
        "-webkit-flex-flow",
        "flex-grow",
        "-webkit-flex-grow",
        "-ms-flex-item-align",
        "-webkit-flex-item-align",
        "-ms-flex-line-pack",
        "-webkit-flex-line-pack",
        "-ms-flex",
        "-ms-flex-negative",
        "-ms-flex-order",
        "-webkit-flex-order",
        "-ms-flex-pack",
        "-webkit-flex-pack",
        "-ms-flex-positive",
        "-ms-flex-preferred-size",
        "flex-shrink",
        "-webkit-flex-shrink",
        "-webkit-flex",
        "flex-wrap",
        "-ms-flex-wrap",
        "-webkit-flex-wrap",
        "float",
        "float-defer",
        "-moz-float-edge",
        "float-offset",
        "float-reference",
        "flood-color",
        "flood-opacity",
        "flow",
        "flow-from",
        "-ms-flow-from",
        "-webkit-flow-from",
        "flow-into",
        "-ms-flow-into",
        "-webkit-flow-into",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "-moz-font-feature-settings",
        "-ms-font-feature-settings",
        "-webkit-font-feature-settings",
        "font-kerning",
        "-webkit-font-kerning",
        "font-language-override",
        "-moz-font-language-override",
        "font-optical-sizing",
        "font-palette",
        "font-size",
        "font-size-adjust",
        "-webkit-font-size-delta",
        "-webkit-font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-synthesis-small-caps",
        "font-synthesis-style",
        "font-synthesis-weight",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-emoji",
        "font-variant-ligatures",
        "-webkit-font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "footnote-display",
        "footnote-policy",
        "-moz-force-broken-image-icon",
        "forced-color-adjust",
        "gap",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "grid",
        "-webkit-grid-after",
        "grid-area",
        "grid-auto-columns",
        "-webkit-grid-auto-columns",
        "grid-auto-flow",
        "-webkit-grid-auto-flow",
        "grid-auto-rows",
        "-webkit-grid-auto-rows",
        "-webkit-grid-before",
        "grid-column",
        "-ms-grid-column-align",
        "grid-column-end",
        "grid-column-gap",
        "-ms-grid-column",
        "-ms-grid-column-span",
        "grid-column-start",
        "-webkit-grid-column",
        "-ms-grid-columns",
        "-webkit-grid-columns",
        "-webkit-grid-end",
        "grid-gap",
        "grid-row",
        "-ms-grid-row-align",
        "grid-row-end",
        "grid-row-gap",
        "-ms-grid-row",
        "-ms-grid-row-span",
        "grid-row-start",
        "-webkit-grid-row",
        "-ms-grid-rows",
        "-webkit-grid-rows",
        "-webkit-grid-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "-ms-high-contrast-adjust",
        "-webkit-highlight",
        "hyphenate-character",
        "-webkit-hyphenate-character",
        "-webkit-hyphenate-limit-after",
        "-webkit-hyphenate-limit-before",
        "hyphenate-limit-chars",
        "-ms-hyphenate-limit-chars",
        "hyphenate-limit-last",
        "hyphenate-limit-lines",
        "-ms-hyphenate-limit-lines",
        "-webkit-hyphenate-limit-lines",
        "hyphenate-limit-zone",
        "-ms-hyphenate-limit-zone",
        "hyphens",
        "-moz-hyphens",
        "-ms-hyphens",
        "-webkit-hyphens",
        "image-orientation",
        "-moz-image-region",
        "image-rendering",
        "image-resolution",
        "-ms-ime-align",
        "ime-mode",
        "inherits",
        "initial-letter",
        "initial-letter-align",
        "-webkit-initial-letter",
        "initial-letter-wrap",
        "initial-value",
        "inline-size",
        "inline-sizing",
        "input-format",
        "-wap-input-format",
        "-wap-input-required",
        "input-security",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "-ms-interpolation-mode",
        "isolation",
        "justify-content",
        "-webkit-justify-content",
        "justify-items",
        "-webkit-justify-items",
        "justify-self",
        "-webkit-justify-self",
        "kerning",
        "layout-flow",
        "layout-grid",
        "layout-grid-char",
        "layout-grid-line",
        "layout-grid-mode",
        "layout-grid-type",
        "leading-trim",
        "left",
        "letter-spacing",
        "lighting-color",
        "-webkit-line-align",
        "-webkit-line-box-contain",
        "line-break",
        "-webkit-line-break",
        "line-clamp",
        "-webkit-line-clamp",
        "line-gap-override",
        "line-grid",
        "-webkit-line-grid-snap",
        "-webkit-line-grid",
        "line-height",
        "line-height-step",
        "line-increment",
        "line-padding",
        "line-snap",
        "-webkit-line-snap",
        "-o-link",
        "-o-link-source",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "-webkit-locale",
        "-webkit-logical-height",
        "-webkit-logical-width",
        "margin",
        "-webkit-margin-after-collapse",
        "-webkit-margin-after",
        "-webkit-margin-before-collapse",
        "-webkit-margin-before",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "-webkit-margin-bottom-collapse",
        "margin-break",
        "-webkit-margin-collapse",
        "-moz-margin-end",
        "-webkit-margin-end",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "-moz-margin-start",
        "-webkit-margin-start",
        "margin-top",
        "-webkit-margin-top-collapse",
        "margin-trim",
        "marker",
        "marker-end",
        "marker-knockout-left",
        "marker-knockout-right",
        "marker-mid",
        "marker-offset",
        "marker-pattern",
        "marker-segment",
        "marker-side",
        "marker-start",
        "marks",
        "-wap-marquee-dir",
        "-webkit-marquee-direction",
        "-webkit-marquee-increment",
        "-wap-marquee-loop",
        "-webkit-marquee-repetition",
        "-wap-marquee-speed",
        "-webkit-marquee-speed",
        "-wap-marquee-style",
        "-webkit-marquee-style",
        "-webkit-marquee",
        "mask",
        "-webkit-mask-attachment",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "-webkit-mask-box-image-outset",
        "-webkit-mask-box-image-repeat",
        "-webkit-mask-box-image-slice",
        "-webkit-mask-box-image-source",
        "-webkit-mask-box-image",
        "-webkit-mask-box-image-width",
        "mask-clip",
        "-webkit-mask-clip",
        "mask-composite",
        "-webkit-mask-composite",
        "mask-image",
        "-webkit-mask-image",
        "mask-mode",
        "mask-origin",
        "-webkit-mask-origin",
        "mask-position",
        "-webkit-mask-position",
        "mask-position-x",
        "-webkit-mask-position-x",
        "mask-position-y",
        "-webkit-mask-position-y",
        "mask-repeat",
        "-webkit-mask-repeat",
        "-webkit-mask-repeat-x",
        "-webkit-mask-repeat-y",
        "mask-size",
        "-webkit-mask-size",
        "mask-source-type",
        "-webkit-mask-source-type",
        "mask-type",
        "-webkit-mask",
        "-webkit-match-nearest-mail-blockquote-color",
        "math-style",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-lines",
        "-webkit-max-logical-height",
        "-webkit-max-logical-width",
        "max-width",
        "max-zoom",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-intrinsic-sizing",
        "-webkit-min-logical-height",
        "-webkit-min-logical-width",
        "min-width",
        "min-zoom",
        "mix-blend-mode",
        "motion",
        "motion-offset",
        "motion-path",
        "motion-rotation",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "-webkit-nbsp-mode",
        "negative",
        "object-fit",
        "-o-object-fit",
        "object-overflow",
        "object-position",
        "-o-object-position",
        "object-view-box",
        "offset",
        "offset-anchor",
        "offset-block-end",
        "offset-block-start",
        "offset-distance",
        "offset-inline-end",
        "offset-inline-start",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "offset-rotation",
        "opacity",
        "-moz-opacity",
        "-webkit-opacity",
        "order",
        "-webkit-order",
        "-moz-orient",
        "orientation",
        "orphans",
        "-moz-osx-font-smoothing",
        "outline",
        "outline-color",
        "-moz-outline-color",
        "-moz-outline",
        "outline-offset",
        "-moz-outline-offset",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "outline-style",
        "-moz-outline-style",
        "outline-width",
        "-moz-outline-width",
        "overflow",
        "overflow-anchor",
        "overflow-block",
        "overflow-clip-margin",
        "overflow-inline",
        "-webkit-overflow-scrolling",
        "-ms-overflow-style",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "override-colors",
        "overscroll-behavior",
        "overscroll-behavior-block",
        "overscroll-behavior-inline",
        "overscroll-behavior-x",
        "overscroll-behavior-y",
        "pad",
        "padding",
        "-webkit-padding-after",
        "-webkit-padding-before",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "-moz-padding-end",
        "-webkit-padding-end",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "-moz-padding-start",
        "-webkit-padding-start",
        "padding-top",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-orientation",
        "paint-order",
        "pause",
        "pause-after",
        "pause-before",
        "-apple-pay-button-style",
        "-apple-pay-button-type",
        "pen-action",
        "perspective",
        "-moz-perspective",
        "-ms-perspective",
        "perspective-origin",
        "-moz-perspective-origin",
        "-ms-perspective-origin",
        "-webkit-perspective-origin",
        "perspective-origin-x",
        "-webkit-perspective-origin-x",
        "perspective-origin-y",
        "-webkit-perspective-origin-y",
        "-webkit-perspective",
        "pitch",
        "pitch-range",
        "place-content",
        "place-items",
        "place-self",
        "play-during",
        "pointer-events",
        "position",
        "prefix",
        "print-color-adjust",
        "-webkit-print-color-adjust",
        "property-name",
        "quotes",
        "r",
        "range",
        "-webkit-region-break-after",
        "-webkit-region-break-before",
        "-webkit-region-break-inside",
        "region-fragment",
        "-webkit-region-fragment",
        "-webkit-region-overflow",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "richness",
        "right",
        "rotate",
        "row-gap",
        "-webkit-rtl-ordering",
        "ruby-align",
        "ruby-merge",
        "ruby-overhang",
        "ruby-position",
        "-webkit-ruby-position",
        "running",
        "rx",
        "ry",
        "scale",
        "scroll-behavior",
        "-ms-scroll-chaining",
        "-ms-scroll-limit",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-max",
        "-ms-scroll-limit-y-min",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "-ms-scroll-rails",
        "scroll-snap-align",
        "scroll-snap-coordinate",
        "-webkit-scroll-snap-coordinate",
        "scroll-snap-destination",
        "-webkit-scroll-snap-destination",
        "scroll-snap-margin",
        "scroll-snap-margin-bottom",
        "scroll-snap-margin-left",
        "scroll-snap-margin-right",
        "scroll-snap-margin-top",
        "scroll-snap-points-x",
        "-ms-scroll-snap-points-x",
        "-webkit-scroll-snap-points-x",
        "scroll-snap-points-y",
        "-ms-scroll-snap-points-y",
        "-webkit-scroll-snap-points-y",
        "scroll-snap-stop",
        "scroll-snap-type",
        "-ms-scroll-snap-type",
        "-webkit-scroll-snap-type",
        "scroll-snap-type-x",
        "scroll-snap-type-y",
        "-ms-scroll-snap-x",
        "-ms-scroll-snap-y",
        "-ms-scroll-translation",
        "scrollbar-arrow-color",
        "scrollbar-base-color",
        "scrollbar-color",
        "scrollbar-dark-shadow-color",
        "scrollbar-darkshadow-color",
        "scrollbar-face-color",
        "scrollbar-gutter",
        "scrollbar-highlight-color",
        "scrollbar-shadow-color",
        "scrollbar-track-color",
        "scrollbar-width",
        "scrollbar3d-light-color",
        "scrollbar3dlight-color",
        "shape-image-threshold",
        "-webkit-shape-image-threshold",
        "shape-inside",
        "-webkit-shape-inside",
        "shape-margin",
        "-webkit-shape-margin",
        "shape-outside",
        "-webkit-shape-outside",
        "-webkit-shape-padding",
        "shape-rendering",
        "size",
        "size-adjust",
        "snap-height",
        "solid-color",
        "solid-opacity",
        "spatial-navigation-action",
        "spatial-navigation-contain",
        "spatial-navigation-function",
        "speak",
        "speak-as",
        "speak-header",
        "speak-numeral",
        "speak-punctuation",
        "speech-rate",
        "src",
        "-moz-stack-sizing",
        "stop-color",
        "stop-opacity",
        "stress",
        "string-set",
        "stroke",
        "stroke-align",
        "stroke-alignment",
        "stroke-break",
        "stroke-color",
        "stroke-dash-corner",
        "stroke-dash-justify",
        "stroke-dashadjust",
        "stroke-dasharray",
        "stroke-dashcorner",
        "stroke-dashoffset",
        "stroke-image",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-origin",
        "stroke-position",
        "stroke-repeat",
        "stroke-size",
        "stroke-width",
        "suffix",
        "supported-color-schemes",
        "-webkit-svg-shadow",
        "symbols",
        "syntax",
        "system",
        "tab-size",
        "-moz-tab-size",
        "-o-tab-size",
        "-o-table-baseline",
        "table-layout",
        "-webkit-tap-highlight-color",
        "text-align",
        "text-align-all",
        "text-align-last",
        "-moz-text-align-last",
        "text-anchor",
        "text-autospace",
        "-moz-text-blink",
        "-ms-text-combine-horizontal",
        "text-combine-upright",
        "-webkit-text-combine",
        "text-decoration",
        "text-decoration-blink",
        "text-decoration-color",
        "-moz-text-decoration-color",
        "-webkit-text-decoration-color",
        "text-decoration-line",
        "-moz-text-decoration-line",
        "text-decoration-line-through",
        "-webkit-text-decoration-line",
        "text-decoration-none",
        "text-decoration-overline",
        "text-decoration-skip",
        "text-decoration-skip-box",
        "text-decoration-skip-ink",
        "text-decoration-skip-inset",
        "text-decoration-skip-self",
        "text-decoration-skip-spaces",
        "-webkit-text-decoration-skip",
        "text-decoration-style",
        "-moz-text-decoration-style",
        "-webkit-text-decoration-style",
        "text-decoration-thickness",
        "text-decoration-underline",
        "-webkit-text-decoration",
        "-webkit-text-decorations-in-effect",
        "text-edge",
        "text-emphasis",
        "text-emphasis-color",
        "-webkit-text-emphasis-color",
        "text-emphasis-position",
        "-webkit-text-emphasis-position",
        "text-emphasis-skip",
        "text-emphasis-style",
        "-webkit-text-emphasis-style",
        "-webkit-text-emphasis",
        "-webkit-text-fill-color",
        "text-group-align",
        "text-indent",
        "text-justify",
        "text-justify-trim",
        "text-kashida",
        "text-kashida-space",
        "text-line-through",
        "text-line-through-color",
        "text-line-through-mode",
        "text-line-through-style",
        "text-line-through-width",
        "text-orientation",
        "-webkit-text-orientation",
        "text-overflow",
        "text-overline",
        "text-overline-color",
        "text-overline-mode",
        "text-overline-style",
        "text-overline-width",
        "text-rendering",
        "-webkit-text-security",
        "text-shadow",
        "text-size-adjust",
        "-moz-text-size-adjust",
        "-ms-text-size-adjust",
        "-webkit-text-size-adjust",
        "text-space-collapse",
        "text-space-trim",
        "text-spacing",
        "-webkit-text-stroke-color",
        "-webkit-text-stroke",
        "-webkit-text-stroke-width",
        "text-transform",
        "text-underline",
        "text-underline-color",
        "text-underline-mode",
        "text-underline-offset",
        "text-underline-position",
        "-webkit-text-underline-position",
        "text-underline-style",
        "text-underline-width",
        "text-wrap",
        "-webkit-text-zoom",
        "top",
        "touch-action",
        "touch-action-delay",
        "-ms-touch-action",
        "-webkit-touch-callout",
        "-ms-touch-select",
        "-apple-trailing-word",
        "transform",
        "transform-box",
        "-moz-transform",
        "-ms-transform",
        "-o-transform",
        "transform-origin",
        "-moz-transform-origin",
        "-ms-transform-origin",
        "-o-transform-origin",
        "-webkit-transform-origin",
        "transform-origin-x",
        "-webkit-transform-origin-x",
        "transform-origin-y",
        "-webkit-transform-origin-y",
        "transform-origin-z",
        "-webkit-transform-origin-z",
        "transform-style",
        "-moz-transform-style",
        "-ms-transform-style",
        "-webkit-transform-style",
        "-webkit-transform",
        "transition",
        "transition-delay",
        "-moz-transition-delay",
        "-ms-transition-delay",
        "-o-transition-delay",
        "-webkit-transition-delay",
        "transition-duration",
        "-moz-transition-duration",
        "-ms-transition-duration",
        "-o-transition-duration",
        "-webkit-transition-duration",
        "-moz-transition",
        "-ms-transition",
        "-o-transition",
        "transition-property",
        "-moz-transition-property",
        "-ms-transition-property",
        "-o-transition-property",
        "-webkit-transition-property",
        "transition-timing-function",
        "-moz-transition-timing-function",
        "-ms-transition-timing-function",
        "-o-transition-timing-function",
        "-webkit-transition-timing-function",
        "-webkit-transition",
        "translate",
        "uc-alt-skin",
        "uc-skin",
        "unicode-bidi",
        "unicode-range",
        "-webkit-user-drag",
        "-moz-user-focus",
        "-moz-user-input",
        "-moz-user-modify",
        "-webkit-user-modify",
        "user-select",
        "-moz-user-select",
        "-ms-user-select",
        "-webkit-user-select",
        "user-zoom",
        "vector-effect",
        "vertical-align",
        "viewport-fill",
        "viewport-fill-opacity",
        "viewport-fit",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "volume",
        "white-space",
        "-webkit-widget-region",
        "widows",
        "width",
        "will-change",
        "-moz-window-dragging",
        "-moz-window-shadow",
        "word-boundary-detection",
        "word-boundary-expansion",
        "word-break",
        "word-spacing",
        "word-wrap",
        "wrap-after",
        "wrap-before",
        "wrap-flow",
        "-ms-wrap-flow",
        "-webkit-wrap-flow",
        "wrap-inside",
        "-ms-wrap-margin",
        "-webkit-wrap-margin",
        "-webkit-wrap-padding",
        "-webkit-wrap-shape-inside",
        "-webkit-wrap-shape-outside",
        "wrap-through",
        "-ms-wrap-through",
        "-webkit-wrap-through",
        "-webkit-wrap",
        "writing-mode",
        "-webkit-writing-mode",
        "x",
        "y",
        "z-index",
        "zoom"] };


    }, {}], 18: [function (require, module, exports) {
      module.exports.all = require('./data/all.json').properties;

    }, { "./data/all.json": 17 }], 19: [function (require, module, exports) {
      module.exports = [
      "abs",
      "and",
      "annotation",
      "annotation-xml",
      "apply",
      "approx",
      "arccos",
      "arccosh",
      "arccot",
      "arccoth",
      "arccsc",
      "arccsch",
      "arcsec",
      "arcsech",
      "arcsin",
      "arcsinh",
      "arctan",
      "arctanh",
      "arg",
      "bind",
      "bvar",
      "card",
      "cartesianproduct",
      "cbytes",
      "ceiling",
      "cerror",
      "ci",
      "cn",
      "codomain",
      "complexes",
      "compose",
      "condition",
      "conjugate",
      "cos",
      "cosh",
      "cot",
      "coth",
      "cs",
      "csc",
      "csch",
      "csymbol",
      "curl",
      "declare",
      "degree",
      "determinant",
      "diff",
      "divergence",
      "divide",
      "domain",
      "domainofapplication",
      "emptyset",
      "encoding",
      "eq",
      "equivalent",
      "eulergamma",
      "exists",
      "exp",
      "exponentiale",
      "factorial",
      "factorof",
      "false",
      "floor",
      "fn",
      "forall",
      "function",
      "gcd",
      "geq",
      "grad",
      "gt",
      "ident",
      "image",
      "imaginary",
      "imaginaryi",
      "implies",
      "in",
      "infinity",
      "int",
      "integers",
      "intersect",
      "interval",
      "inverse",
      "lambda",
      "laplacian",
      "lcm",
      "leq",
      "limit",
      "list",
      "ln",
      "log",
      "logbase",
      "lowlimit",
      "lt",
      "maction",
      "malign",
      "maligngroup",
      "malignmark",
      "malignscope",
      "math",
      "matrix",
      "matrixrow",
      "max",
      "mean",
      "median",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mfraction",
      "mglyph",
      "mi",
      "min",
      "minus",
      "mlabeledtr",
      "mlongdiv",
      "mmultiscripts",
      "mn",
      "mo",
      "mode",
      "moment",
      "momentabout",
      "mover",
      "mpadded",
      "mphantom",
      "mprescripts",
      "mroot",
      "mrow",
      "ms",
      "mscarries",
      "mscarry",
      "msgroup",
      "msline",
      "mspace",
      "msqrt",
      "msrow",
      "mstack",
      "mstyle",
      "msub",
      "msubsup",
      "msup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover",
      "naturalnumbers",
      "neq",
      "none",
      "not",
      "notanumber",
      "notin",
      "notprsubset",
      "notsubset",
      "or",
      "otherwise",
      "outerproduct",
      "partialdiff",
      "pi",
      "piece",
      "piecewice",
      "piecewise",
      "plus",
      "power",
      "primes",
      "product",
      "prsubset",
      "quotient",
      "rationals",
      "real",
      "reals",
      "reln",
      "rem",
      "root",
      "scalarproduct",
      "sdev",
      "sec",
      "sech",
      "select",
      "selector",
      "semantics",
      "sep",
      "set",
      "setdiff",
      "share",
      "sin",
      "sinh",
      "span",
      "subset",
      "sum",
      "tan",
      "tanh",
      "tendsto",
      "times",
      "transpose",
      "true",
      "union",
      "uplimit",
      "var",
      "variance",
      "vector",
      "vectorproduct",
      "xor"];


    }, {}], 20: [function (require, module, exports) {
      let urlAlphabet =
      'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
      let customAlphabet = (alphabet, defaultSize = 21) => {
        return (size = defaultSize) => {
          let id = '';
          let i = size;
          while (i--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      let nanoid = (size = 21) => {
        let id = '';
        let i = size;
        while (i--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };

    }, {}], 21: [function (require, module, exports) {
      var x = String;
      var create = function () {return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };};
      module.exports = create();
      module.exports.createColors = create;

    }, {}], 22: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.default = parseMedia;

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      var _parsers = require('./parsers');

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media query list into an array of nodes. A typical node signature:
       *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',
       *    'media-feature-expression', 'media-feature', 'colon', 'value'
       *  {string} node.value -- the contents of a particular element, trimmed
       *    e.g.: `screen`, `max-width`, `1024px`
       *  {string} node.after -- whitespaces that follow the element
       *  {string} node.before -- whitespaces that precede the element
       *  {string} node.sourceIndex -- the index of the element in a source media
       *    query list, 0-based
       *  {object} node.parent -- a link to the parent node (a container)
       *
       * Some nodes (media queries, media feature expressions) contain other nodes.
       * They additionally have:
       *  {array} node.nodes -- an array of nodes of the type described here
       *  {funciton} node.each -- traverses direct children of the node, calling
       *    a callback for each one
       *  {funciton} node.walk -- traverses ALL descendants of the node, calling
       *    a callback for each one
       */

      function parseMedia(value) {
        return new _Container2.default({
          nodes: (0, _parsers.parseMediaList)(value),
          type: 'media-query-list',
          value: value.trim() });

      }
    }, { "./nodes/Container": 23, "./parsers": 25 }], 23: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });


      var _Node = require('./Node');

      var _Node2 = _interopRequireDefault(_Node);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function Container(opts) {
        var _this = this;

        this.constructor(opts);

        this.nodes = opts.nodes;

        if (this.after === undefined) {
          this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : '';
        }

        if (this.before === undefined) {
          this.before = this.nodes.length > 0 ? this.nodes[0].before : '';
        }

        if (this.sourceIndex === undefined) {
          this.sourceIndex = this.before.length;
        }

        this.nodes.forEach(function (node) {
          node.parent = _this; // eslint-disable-line no-param-reassign
        });
      } /**
       * A node that contains other nodes and support traversing over them
       */

      Container.prototype = Object.create(_Node2.default.prototype);
      Container.constructor = _Node2.default;

      /**
       * Iterate over descendant nodes of the node
       *
       * @param {RegExp|string} filter - Optional. Only nodes with node.type that
       *    satisfies the filter will be traversed over
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.walk = function walk(filter, cb) {
        var hasFilter = typeof filter === 'string' || filter instanceof RegExp;
        var callback = hasFilter ? cb : filter;
        var filterReg = typeof filter === 'string' ? new RegExp(filter) : filter;

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          var filtered = hasFilter ? filterReg.test(node.type) : true;
          if (filtered && callback && callback(node, i, this.nodes) === false) {
            return false;
          }
          if (node.nodes && node.walk(filter, cb) === false) {
            return false;
          }
        }
        return true;
      };

      /**
       * Iterate over immediate children of the node
       *
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.each = function each() {
        var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (cb(node, i, this.nodes) === false) {
            return false;
          }
        }
        return true;
      };

      exports.default = Container;
    }, { "./Node": 24 }], 24: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true });

      /**
       * A very generic node. Pretty much any element of a media query
       */

      function Node(opts) {
        this.after = opts.after;
        this.before = opts.before;
        this.type = opts.type;
        this.value = opts.value;
        this.sourceIndex = opts.sourceIndex;
      }

      exports.default = Node;
    }, {}], 25: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.parseMediaFeature = parseMediaFeature;
      exports.parseMediaQuery = parseMediaQuery;
      exports.parseMediaList = parseMediaList;

      var _Node = require('./nodes/Node');

      var _Node2 = _interopRequireDefault(_Node);

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`
       *
       * @param {string} string - the source expression string, can be inside parens
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes, the first element being a media feature,
       *    the secont - its value (may be missing)
       */

      function parseMediaFeature(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var modesEntered = [{
          mode: 'normal',
          character: null }];

        var result = [];
        var lastModeIndex = 0;
        var mediaFeature = '';
        var colon = null;
        var mediaFeatureValue = null;
        var indexLocal = index;

        var stringNormalized = string;
        // Strip trailing parens (if any), and correct the starting index
        if (string[0] === '(' && string[string.length - 1] === ')') {
          stringNormalized = string.substring(1, string.length - 1);
          indexLocal++;
        }

        for (var i = 0; i < stringNormalized.length; i++) {
          var character = stringNormalized[i];

          // If entering/exiting a string
          if (character === '\'' || character === '"') {
            if (modesEntered[lastModeIndex].isCalculationEnabled === true) {
              modesEntered.push({
                mode: 'string',
                isCalculationEnabled: false,
                character: character });

              lastModeIndex++;
            } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\') {
              modesEntered.pop();
              lastModeIndex--;
            }
          }

          // If entering/exiting interpolation
          if (character === '{') {
            modesEntered.push({
              mode: 'interpolation',
              isCalculationEnabled: true });

            lastModeIndex++;
          } else if (character === '}') {
            modesEntered.pop();
            lastModeIndex--;
          }

          // If a : is met outside of a string, function call or interpolation, than
          // this : separates a media feature and a value
          if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {
            var mediaFeatureValueStr = stringNormalized.substring(i + 1);
            mediaFeatureValue = {
              type: 'value',
              before: /^(\s*)/.exec(mediaFeatureValueStr)[1],
              after: /(\s*)$/.exec(mediaFeatureValueStr)[1],
              value: mediaFeatureValueStr.trim() };

            // +1 for the colon
            mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;
            colon = {
              type: 'colon',
              sourceIndex: i + indexLocal,
              after: mediaFeatureValue.before,
              value: ':' };
            break;
          }

          mediaFeature += character;
        }

        // Forming a media feature node
        mediaFeature = {
          type: 'media-feature',
          before: /^(\s*)/.exec(mediaFeature)[1],
          after: /(\s*)$/.exec(mediaFeature)[1],
          value: mediaFeature.trim() };

        mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;
        result.push(mediaFeature);

        if (colon !== null) {
          colon.before = mediaFeature.after;
          result.push(colon);
        }

        if (mediaFeatureValue !== null) {
          result.push(mediaFeatureValue);
        }

        return result;
      }

      /**
       * Parses a media query, e.g. `screen and (color)`, `only tv`
       *
       * @param {string} string - the source media query string
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes and Containers
       */

      function parseMediaQuery(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var result = [];

        // How many timies the parser entered parens/curly braces
        var localLevel = 0;
        // Has any keyword, media type, media feature expression or interpolation
        // ('element' hereafter) started
        var insideSomeValue = false;
        var node = void 0;

        function resetNode() {
          return {
            before: '',
            after: '',
            value: '' };

        }

        node = resetNode();

        for (var i = 0; i < string.length; i++) {
          var character = string[i];
          // If not yet entered any element
          if (!insideSomeValue) {
            if (character.search(/\s/) !== -1) {
              // A whitespace
              // Don't form 'after' yet; will do it later
              node.before += character;
            } else {
              // Not a whitespace - entering an element
              // Expression start
              if (character === '(') {
                node.type = 'media-feature-expression';
                localLevel++;
              }
              node.value = character;
              node.sourceIndex = index + i;
              insideSomeValue = true;
            }
          } else {
            // Already in the middle of some alement
            node.value += character;

            // Here parens just increase localLevel and don't trigger a start of
            // a media feature expression (since they can't be nested)
            // Interpolation start
            if (character === '{' || character === '(') {
              localLevel++;
            }
            // Interpolation/function call/media feature expression end
            if (character === ')' || character === '}') {
              localLevel--;
            }
          }

          // If exited all parens/curlies and the next symbol
          if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\s/) !== -1)) {
            if (['not', 'only', 'and'].indexOf(node.value) !== -1) {
              node.type = 'keyword';
            }
            // if it's an expression, parse its contents
            if (node.type === 'media-feature-expression') {
              node.nodes = parseMediaFeature(node.value, node.sourceIndex);
            }
            result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));
            node = resetNode();
            insideSomeValue = false;
          }
        }

        // Now process the result array - to specify undefined types of the nodes
        // and specify the `after` prop
        for (var _i = 0; _i < result.length; _i++) {
          node = result[_i];
          if (_i > 0) {
            result[_i - 1].after = node.before;
          }

          // Node types. Might not be set because contains interpolation/function
          // calls or fully consists of them
          if (node.type === undefined) {
            if (_i > 0) {
              // only `and` can follow an expression
              if (result[_i - 1].type === 'media-feature-expression') {
                node.type = 'keyword';
                continue;
              }
              // Anything after 'only|not' is a media type
              if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {
                node.type = 'media-type';
                continue;
              }
              // Anything after 'and' is an expression
              if (result[_i - 1].value === 'and') {
                node.type = 'media-feature-expression';
                continue;
              }

              if (result[_i - 1].type === 'media-type') {
                // if it is the last element - it might be an expression
                // or 'and' depending on what is after it
                if (!result[_i + 1]) {
                  node.type = 'media-feature-expression';
                } else {
                  node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';
                }
              }
            }

            if (_i === 0) {
              // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then
              // its type would have been set by now
              if (!result[_i + 1]) {
                node.type = 'media-type';
                continue;
              }

              // `screen and` or `#{...} (max-width: 10px)`
              if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {
                node.type = 'media-type';
                continue;
              }
              if (result[_i + 2]) {
                // `screen and (color) ...`
                if (result[_i + 2].type === 'media-feature-expression') {
                  node.type = 'media-type';
                  result[_i + 1].type = 'keyword';
                  continue;
                }
                // `only screen and ...`
                if (result[_i + 2].type === 'keyword') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  continue;
                }
              }
              if (result[_i + 3]) {
                // `screen and (color) ...`
                if (result[_i + 3].type === 'media-feature-expression') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  result[_i + 2].type = 'keyword';
                  continue;
                }
              }
            }
          }
        }
        return result;
      }

      /**
       * Parses a media query list. Takes a possible `url()` at the start into
       * account, and divides the list into media queries that are parsed separately
       *
       * @param {string} string - the source media query list string
       *
       * @return {Array} an array of Nodes/Containers
       */

      function parseMediaList(string) {
        var result = [];
        var interimIndex = 0;
        var levelLocal = 0;

        // Check for a `url(...)` part (if it is contents of an @import rule)
        var doesHaveUrl = /^(\s*)url\s*\(/.exec(string);
        if (doesHaveUrl !== null) {
          var i = doesHaveUrl[0].length;
          var parenthesesLv = 1;
          while (parenthesesLv > 0) {
            var character = string[i];
            if (character === '(') {
              parenthesesLv++;
            }
            if (character === ')') {
              parenthesesLv--;
            }
            i++;
          }
          result.unshift(new _Node2.default({
            type: 'url',
            value: string.substring(0, i).trim(),
            sourceIndex: doesHaveUrl[1].length,
            before: doesHaveUrl[1],
            after: /^(\s*)/.exec(string.substring(i))[1] }));

          interimIndex = i;
        }

        // Start processing the media query list
        for (var _i2 = interimIndex; _i2 < string.length; _i2++) {
          var _character = string[_i2];

          // Dividing the media query list into comma-separated media queries
          // Only count commas that are outside of any parens
          // (i.e., not part of function call params list, etc.)
          if (_character === '(') {
            levelLocal++;
          }
          if (_character === ')') {
            levelLocal--;
          }
          if (levelLocal === 0 && _character === ',') {
            var _mediaQueryString = string.substring(interimIndex, _i2);
            var _spaceBefore = /^(\s*)/.exec(_mediaQueryString)[1];
            result.push(new _Container2.default({
              type: 'media-query',
              value: _mediaQueryString.trim(),
              sourceIndex: interimIndex + _spaceBefore.length,
              nodes: parseMediaQuery(_mediaQueryString, interimIndex),
              before: _spaceBefore,
              after: /(\s*)$/.exec(_mediaQueryString)[1] }));

            interimIndex = _i2 + 1;
          }
        }

        var mediaQueryString = string.substring(interimIndex);
        var spaceBefore = /^(\s*)/.exec(mediaQueryString)[1];
        result.push(new _Container2.default({
          type: 'media-query',
          value: mediaQueryString.trim(),
          sourceIndex: interimIndex + spaceBefore.length,
          nodes: parseMediaQuery(mediaQueryString, interimIndex),
          before: spaceBefore,
          after: /(\s*)$/.exec(mediaQueryString)[1] }));


        return result;
      }
    }, { "./nodes/Container": 23, "./nodes/Node": 24 }], 26: [function (require, module, exports) {
      module.exports = function resolveNestedSelector(selector, node) {
        var parent = node.parent;
        var parentIsNestAtRule = parent.type === 'atrule' && parent.name === 'nest';

        if (parent.type === 'root') return [selector];
        if (parent.type !== 'rule' && !parentIsNestAtRule) return resolveNestedSelector(selector, parent);

        var parentSelectors = parentIsNestAtRule ?
        parent.params.split(',').map(function (s) {return s.trim();}) :
        parent.selectors;

        var resolvedSelectors = parentSelectors.reduce(function (result, parentSelector) {
          if (selector.indexOf('&') !== -1) {
            var newlyResolvedSelectors = resolveNestedSelector(parentSelector, parent).map(function (resolvedParentSelector) {
              return selector.replace(/&/g, resolvedParentSelector);
            });
            return result.concat(newlyResolvedSelectors);
          }

          var combinedSelector = [parentSelector, selector].join(' ');
          return result.concat(resolveNestedSelector(combinedSelector, parent));
        }, []);

        return resolvedSelectors;
      };

    }, {}], 27: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _processor = _interopRequireDefault(require("./processor"));

      var selectors = _interopRequireWildcard(require("./selectors"));

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var parser = function parser(processor) {
        return new _processor["default"](processor);
      };

      Object.assign(parser, selectors);
      delete parser.__esModule;
      var _default = parser;
      exports["default"] = _default;
      module.exports = exports.default;
    }, { "./processor": 29, "./selectors": 38 }], 28: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _root = _interopRequireDefault(require("./selectors/root"));

      var _selector = _interopRequireDefault(require("./selectors/selector"));

      var _className = _interopRequireDefault(require("./selectors/className"));

      var _comment = _interopRequireDefault(require("./selectors/comment"));

      var _id = _interopRequireDefault(require("./selectors/id"));

      var _tag = _interopRequireDefault(require("./selectors/tag"));

      var _string = _interopRequireDefault(require("./selectors/string"));

      var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));

      var _attribute = _interopRequireWildcard(require("./selectors/attribute"));

      var _universal = _interopRequireDefault(require("./selectors/universal"));

      var _combinator = _interopRequireDefault(require("./selectors/combinator"));

      var _nesting = _interopRequireDefault(require("./selectors/nesting"));

      var _sortAscending = _interopRequireDefault(require("./sortAscending"));

      var _tokenize = _interopRequireWildcard(require("./tokenize"));

      var tokens = _interopRequireWildcard(require("./tokenTypes"));

      var types = _interopRequireWildcard(require("./selectors/types"));

      var _util = require("./util");

      var _WHITESPACE_TOKENS, _Object$assign;

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL] };

      }

      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL] };

      }

      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn },

          end: {
            line: endLine,
            column: endColumn } };


      }

      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }

      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return undefined;
        }

        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }

      function unescapeProp(node, prop) {
        var value = node[prop];

        if (typeof value !== "string") {
          return;
        }

        if (value.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, 'raws');
          node[prop] = (0, _util.unesc)(value);

          if (node.raws[prop] === undefined) {
            node.raws[prop] = value;
          }
        }

        return node;
      }

      function indexesOf(array, item) {
        var i = -1;
        var indexes = [];

        while ((i = array.indexOf(item, i + 1)) !== -1) {
          indexes.push(i);
        }

        return indexes;
      }

      function uniqs() {
        var list = Array.prototype.concat.apply([], arguments);
        return list.filter(function (item, i) {
          return i === list.indexOf(item);
        });
      }

      var Parser = /*#__PURE__*/function () {
        function Parser(rule, options) {
          if (options === void 0) {
            options = {};
          }

          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false },
          options);
          this.position = 0;
          this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe });

          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root["default"]({
            source: rootSource });

          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector["default"]({
            source: {
              start: {
                line: 1,
                column: 1 } } });



          this.root.append(selector);
          this.current = selector;
          this.loop();
        }

        var _proto = Parser.prototype;

        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;

          return function (message, errorOptions) {
            if (typeof _this.rule === 'string') {
              return new Error(message);
            }

            return _this.rule.error(message, errorOptions);
          };
        };

        _proto.attribute = function attribute() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;

          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
          }

          var len = attr.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS] };


          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
          }

          var pos = 0;
          var spaceBefore = '';
          var commentBefore = '';
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;

          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];

            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                // if (
                //     len === 1 ||
                //     pos === 0 && this.content(next) === '|'
                // ) {
                //     return this.expected('attribute', token[TOKEN.START_POS], content);
                // }
                spaceAfterMeaningfulToken = true;

                if (this.options.lossy) {
                  break;
                }

                if (lastAdded) {
                  (0, _util.ensureObject)(node, 'spaces', lastAdded);
                  var prevContent = node.spaces[lastAdded].after || '';
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }

                break;

              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = '';
                  }

                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

                  if (rawValue) {
                    node.raws.namespace += content;
                  }

                  lastAdded = 'namespace';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
                  node.value += "$";

                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }

                  break;
                }

              // Falls through

              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.combinator:
                if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                if (content !== '|') {
                  spaceAfterMeaningfulToken = false;
                  break;
                }

                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.word:
                if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = 'namespace';
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = '';
                  }

                  node.attribute = (node.attribute || "") + content;

                  var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

                  if (_rawValue) {
                    node.raws.attribute += content;
                  }

                  lastAdded = 'attribute';
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                  var _unescaped = (0, _util.unesc)(content);

                  var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

                  var oldValue = node.value || '';
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;

                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }

                  lastAdded = 'value';
                } else {
                  var insensitive = content === 'i' || content === "I";

                  if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;

                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, 'raws');
                      node.raws.insensitiveFlag = content;
                    }

                    lastAdded = 'insensitive';

                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = '';
                    }

                    if (commentBefore) {
                      (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = '';
                    }
                  } else if (node.value || node.value === '') {
                    lastAdded = 'value';
                    node.value += content;

                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                var _unescapeValue = (0, _attribute.unescapeValue)(content),
                unescaped = _unescapeValue.unescaped,
                quoteMark = _unescapeValue.quoteMark;

                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = 'value';
                (0, _util.ensureObject)(node, 'raws');
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.equals:
                if (!node.attribute) {
                  return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
                }

                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                node.operator = node.operator ? node.operator + content : content;
                lastAdded = 'operator';
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
                    var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
                    var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
                    (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || '';
                    var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }

                break;

              default:
                return this.error("Unexpected \"" + content + "\" found.", {
                  index: token[_tokenize.FIELDS.START_POS] });}



            pos++;
          }

          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute["default"](node));
          this.position++;
        }
        /**
         * return a node containing meaningless garbage up to (but not including) the specified token position.
         * if the token position is negative, all remaining tokens are consumed.
         *
         * This returns an array containing a single string node if all whitespace,
         * otherwise an array of comment nodes with space before and after.
         *
         * These tokens are not added to the current selector, the caller can add them or use them to amend
         * a previous node's space metadata.
         *
         * In lossy mode, this returns only comments.
         */;


        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }

          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = undefined;

          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};

              if (space) {
                spaces.before = space;
                space = "";
              }

              lastComment = new _comment["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces: spaces });

              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);

          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string["default"]({
                value: '',
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: '' } }));


            }
          }

          return nodes;
        }
        /**
         * 
         * @param {*} nodes 
         */;


        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;

          if (requiredSpace === void 0) {
            requiredSpace = false;
          }

          var space = "";
          var rawSpace = "";
          nodes.forEach(function (n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });

          if (rawSpace === space) {
            rawSpace = undefined;
          }

          var result = {
            space: space,
            rawSpace: rawSpace };

          return result;
        };

        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }

          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };

        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};

            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }

            var node = new _combinator["default"]({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws: raws });

            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };

        _proto.combinator = function combinator() {
          var _this3 = this;

          if (this.content() === '|') {
            return this.namespace();
          } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

            if (nodes.length > 0) {
              var last = this.current.last;

              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
                space = _this$convertWhitespa.space,
                rawSpace = _this$convertWhitespa.rawSpace;

                if (rawSpace !== undefined) {
                  last.rawSpaceAfter += rawSpace;
                }

                last.spaces.after += space;
              } else {
                nodes.forEach(function (n) {
                  return _this3.newNode(n);
                });
              }
            }

            return;
          }

          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = undefined;

          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }

          var node;

          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS] });

            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }

          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
              _space = _this$convertWhitespa2.space,
              _rawSpace = _this$convertWhitespa2.rawSpace;

              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            // descendant combinator
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
            _space2 = _this$convertWhitespa3.space,
            _rawSpace2 = _this$convertWhitespa3.rawSpace;

            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }

            var spaces = {};
            var raws = {
              spaces: {} };


            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }

            node = new _combinator["default"]({
              value: ' ',
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: spaces,
              raws: raws });

          }

          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }

          return this.newNode(node);
        };

        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }

          this.current._inferEndPosition();

          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1]) } });


          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };

        _proto.comment = function comment() {
          var current = this.currToken;
          this.newNode(new _comment["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };

        _proto.missingBackslash = function missingBackslash() {
          return this.error('Expected a backslash preceding the semicolon.', {
            index: this.currToken[_tokenize.FIELDS.START_POS] });

        };

        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;

          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
        };

        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);

            if (nextContent === "|") {
              this.position++;
              return;
            }
          }

          var current = this.currToken;
          this.newNode(new _nesting["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;

          if (last && last.type === types.PSEUDO) {
            var selector = new _selector["default"]({
              source: {
                start: tokenStart(this.tokens[this.position - 1]) } });


            var cache = this.current;
            last.append(selector);
            this.current = selector;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }

            this.current = cache;
          } else {
            // I think this case should be an error. It's used to implement a basic parse of media queries
            // but I don't think it's a good idea.
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }

            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS] }));

            }
          }

          if (unbalanced) {
            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.pseudo = function pseudo() {
          var _this4 = this;

          var pseudoStr = '';
          var startingToken = this.currToken;

          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }

          if (!this.currToken) {
            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function (first, length) {
              pseudoStr += first;

              _this4.newNode(new _pseudo["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS] }));


              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error('Misplaced parenthesis.', {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS] });

              }
            });
          } else {
            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.space = function space() {
          var content = this.content(); // Handle space before and after the selector

          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
            return node.type === 'comment';
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };

        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          var current = this.currToken;
          this.newNode(new _universal["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }),
          namespace);
          this.position++;
        };

        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;

          var nextToken = this.nextToken;
          var word = this.content();

          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;

            if (current.lastIndexOf('\\') === current.length - 1) {
              var next = this.nextToken;

              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next));
                this.position++;
              }
            }

            nextToken = this.nextToken;
          }

          var hasClass = indexesOf(word, '.').filter(function (i) {
            // Allow escaped dot within class name
            var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

            var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word, '#').filter(function (i) {
            return word[i - 1] !== '\\';
          }); // Eliminate Sass interpolations from the list of id indexes

          var interpolations = indexesOf(word, '#{');

          if (interpolations.length) {
            hasId = hasId.filter(function (hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }

          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function (ind, i) {
            var index = indices[i + 1] || word.length;
            var value = word.slice(ind, index);

            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value, indices.length);
            }

            var node;
            var current = _this5.currToken;
            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _className["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _id["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value,
                source: source,
                sourceIndex: sourceIndex };

              unescapeProp(tagOpts, "value");
              node = new _tag["default"](tagOpts);
            }

            _this5.newNode(node, namespace); // Ensure that the namespace is used only once


            namespace = null;
          });
          this.position++;
        };

        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          return this.splitWord(namespace);
        };

        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }

          this.current._inferEndPosition();

          return this.root;
        };

        _proto.parse = function parse(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;

            case tokens.comment:
              this.comment();
              break;

            case tokens.openParenthesis:
              this.parentheses();
              break;

            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }

              break;

            case tokens.openSquare:
              this.attribute();
              break;

            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;

            case tokens.colon:
              this.pseudo();
              break;

            case tokens.comma:
              this.comma();
              break;

            case tokens.asterisk:
              this.universal();
              break;

            case tokens.ampersand:
              this.nesting();
              break;

            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;

            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.

            case tokens.closeSquare:
              this.missingSquareBracket();

            case tokens.semicolon:
              this.missingBackslash();

            default:
              this.unexpected();}

        }
        /**
         * Helpers
         */;


        _proto.expected = function expected(description, index, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(', ') + " or " + last;
          }

          var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index });

          }

          return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
            index: index });

        };

        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? ' ' : space;
        };

        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? '' : space;
        };

        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? ' ' : '';
          } else {
            return space;
          }
        };

        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);

          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };

        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || '') + namespace;
              }

              namespace = true;
            }

            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }

          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = '';
          }

          return this.current.append(node);
        };

        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }

          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };

        /**
         * returns the index of the next non-whitespace, non-comment token.
         * returns -1 if no meaningful token is found.
         */
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }

          var searchPosition = startPosition;

          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }

          return -1;
        };

        _createClass(Parser, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          } },
        {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          } },
        {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          } }]);


        return Parser;
      }();

      exports["default"] = Parser;
      module.exports = exports.default;
    }, { "./selectors/attribute": 30, "./selectors/className": 31, "./selectors/combinator": 32, "./selectors/comment": 33, "./selectors/id": 37, "./selectors/nesting": 40, "./selectors/pseudo": 42, "./selectors/root": 43, "./selectors/selector": 44, "./selectors/string": 45, "./selectors/tag": 46, "./selectors/types": 47, "./selectors/universal": 48, "./sortAscending": 49, "./tokenTypes": 50, "./tokenize": 51, "./util": 54 }], 29: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _parser = _interopRequireDefault(require("./parser"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var Processor = /*#__PURE__*/function () {
        function Processor(func, options) {
          this.func = func || function noop() {};

          this.funcRes = null;
          this.options = options;
        }

        var _proto = Processor.prototype;

        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };

        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };

        _proto._root = function _root(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var parser = new _parser["default"](rule, this._parseOptions(options));
          return parser.root;
        };

        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options) };

        };

        _proto._run = function _run(rule, options) {
          var _this = this;

          if (options === void 0) {
            options = {};
          }

          return new Promise(function (resolve, reject) {
            try {
              var root = _this._root(rule, options);

              Promise.resolve(_this.func(root)).then(function (transform) {
                var string = undefined;

                if (_this._shouldUpdateSelector(rule, options)) {
                  string = root.toString();
                  rule.selector = string;
                }

                return {
                  transform: transform,
                  root: root,
                  string: string };

              }).then(resolve, reject);
            } catch (e) {
              reject(e);
              return;
            }
          });
        };

        _proto._runSync = function _runSync(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var root = this._root(rule, options);

          var transform = this.func(root);

          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }

          var string = undefined;

          if (options.updateSelector && typeof rule !== "string") {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string };

        }
        /**
         * Process rule into a selector AST.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<parser.Root>} The AST of the selector after processing it.
         */;


        _proto.ast = function ast(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.root;
          });
        }
        /**
         * Process rule into a selector AST synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {parser.Root} The AST of the selector after processing it.
         */;


        _proto.astSync = function astSync(rule, options) {
          return this._runSync(rule, options).root;
        }
        /**
         * Process a selector into a transformed value asynchronously
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<any>} The value returned by the processor.
         */;


        _proto.transform = function transform(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.transform;
          });
        }
        /**
         * Process a selector into a transformed value synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {any} The value returned by the processor.
         */;


        _proto.transformSync = function transformSync(rule, options) {
          return this._runSync(rule, options).transform;
        }
        /**
         * Process a selector into a new selector string asynchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.process = function process(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.string || result.root.toString();
          });
        }
        /**
         * Process a selector into a new selector string synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.processSync = function processSync(rule, options) {
          var result = this._runSync(rule, options);

          return result.string || result.root.toString();
        };

        return Processor;
      }();

      exports["default"] = Processor;
      module.exports = exports.default;
    }, { "./parser": 28 }], 30: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.unescapeValue = unescapeValue;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _unesc = _interopRequireDefault(require("../util/unesc"));

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      var _CSSESC_QUOTE_OPTIONS;

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var deprecate = require("util-deprecate");

      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m = unescaped.match(WRAPPED_IN_QUOTES);

        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }

        unescaped = (0, _unesc["default"])(unescaped);

        if (unescaped !== value) {
          deprecatedUsage = true;
        }

        return {
          deprecatedUsage: deprecatedUsage,
          unescaped: unescaped,
          quoteMark: quoteMark };

      }

      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== undefined) {
          return opts;
        }

        if (opts.value === undefined) {
          return opts;
        }

        warnOfDeprecatedConstructor();

        var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

        if (!opts.raws) {
          opts.raws = {};
        }

        if (opts.raws.value === undefined) {
          opts.raws.value = opts.value;
        }

        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }

      var Attribute = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Attribute, _Namespace);

        function Attribute(opts) {
          var _this;

          if (opts === void 0) {
            opts = {};
          }

          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, 'unquoted', {
            get: deprecate(function () {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function () {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") });

          _this._constructed = true;
          return _this;
        }
        /**
         * Returns the Attribute's value quoted such that it would be legal to use
         * in the value of a css file. The original value's quotation setting
         * used for stringification is left unchanged. See `setValue(value, options)`
         * if you want to control the quote settings of a new value for the attribute.
         *
         * You can also change the quotation used for the current value by setting quoteMark.
         *
         * Options:
         *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
         *     option is not set, the original value for quoteMark will be used. If
         *     indeterminate, a double quote is used. The legal values are:
         *     * `null` - the value will be unquoted and characters will be escaped as necessary.
         *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
         *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
         *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
         *     over the quoteMark option value.
         *   * smart {boolean} - if true, will select a quote mark based on the value
         *     and the other options specified here. See the `smartQuoteMark()`
         *     method.
         **/


        var _proto = Attribute.prototype;

        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }

          var quoteMark = this._determineQuoteMark(options);

          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped;
        };

        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        }
        /**
         * Set the unescaped value with the specified quotation options. The value
         * provided must not include any wrapping quote marks -- those quotes will
         * be interpreted as part of the value and escaped accordingly.
         */;


        _proto.setValue = function setValue(value, options) {
          if (options === void 0) {
            options = {};
          }

          this._value = value;
          this._quoteMark = this._determineQuoteMark(options);

          this._syncRawValue();
        }
        /**
         * Intelligently select a quoteMark value based on the value's contents. If
         * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
         * mark will be picked that minimizes the number of escapes.
         *
         * If there's no clear winner, the quote mark from these options is used,
         * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
         * true). If the quoteMark is unspecified, a double quote is used.
         *
         * @param options This takes the quoteMark and preferCurrentQuoteMark options
         * from the quoteValue method.
         */;


        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, '').length;
          var numDoubleQuotes = v.replace(/[^"]/g, '').length;

          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true });


            if (escaped === v) {
              return Attribute.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);

              if (pref === Attribute.NO_QUOTE) {
                // pick a quote mark that isn't none and see if it's smaller
                var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v, opts);

                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }

              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute.DOUBLE_QUOTE;
          } else {
            return Attribute.SINGLE_QUOTE;
          }
        }
        /**
         * Selects the preferred quote mark based on the options and the current quote mark value.
         * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
         * instead.
         */;


        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

          if (quoteMark === undefined) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }

          if (quoteMark === undefined) {
            quoteMark = Attribute.DOUBLE_QUOTE;
          }

          return quoteMark;
        };

        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };

        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(value, {
              isIdentifier: true });


            if (escaped !== value) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };

        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: '',
            after: '' };

          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };

        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }

          if (concat === void 0) {
            concat = defaultAttrConcat;
          }

          var attrSpaces = this._spacesFor(spaceName);

          return concat(this.stringifyProperty(name), attrSpaces);
        }
        /**
         * returns the offset of the attribute part specified relative to the
         * start of the node of the output string.
         *
         * * "ns" - alias for "namespace"
         * * "namespace" - the namespace if it exists.
         * * "attribute" - the attribute name
         * * "attributeNS" - the start of the attribute or its namespace
         * * "operator" - the match operator of the attribute
         * * "value" - The value (string or identifier)
         * * "insensitive" - the case insensitivity flag;
         * @param part One of the possible values inside an attribute.
         * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
         */;


        _proto.offsetOf = function offsetOf(name) {
          var count = 1;

          var attributeSpaces = this._spacesFor("attribute");

          count += attributeSpaces.before.length;

          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }

          if (name === "attributeNS") {
            return count;
          }

          count += this.namespaceString.length;

          if (this.namespace) {
            count += 1;
          }

          if (name === "attribute") {
            return count;
          }

          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;

          var operatorSpaces = this._spacesFor("operator");

          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");

          if (name === "operator") {
            return operator ? count : -1;
          }

          count += operator.length;
          count += operatorSpaces.after.length;

          var valueSpaces = this._spacesFor("value");

          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");

          if (name === "value") {
            return value ? count : -1;
          }

          count += value.length;
          count += valueSpaces.after.length;

          var insensitiveSpaces = this._spacesFor("insensitive");

          count += insensitiveSpaces.before.length;

          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }

          return -1;
        };

        _proto.toString = function toString() {
          var _this2 = this;

          var selector = [this.rawSpaceBefore, '['];
          selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

          if (this.operator && (this.value || this.value === '')) {
            selector.push(this._stringFor('operator'));
            selector.push(this._stringFor('value'));
            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }

              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }

          selector.push(']');
          selector.push(this.rawSpaceAfter);
          return selector.join('');
        };

        _createClass(Attribute, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */ },

        {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          }
          /**
           * Set the quote mark to be used by this attribute's value.
           * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
           * value is updated accordingly.
           *
           * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
           */,

          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }

            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;

              this._syncRawValue();
            }
          } },
        {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          } },
        {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? 'i' : '';
          } },
        {
          key: "value",
          get: function get() {
            return this._value;
          }
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */,

          set: function set(v) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v),
              deprecatedUsage = _unescapeValue2.deprecatedUsage,
              unescaped = _unescapeValue2.unescaped,
              quoteMark = _unescapeValue2.quoteMark;

              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }

              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }

              this._value = unescaped;
              this._quoteMark = quoteMark;

              this._syncRawValue();
            } else {
              this._value = v;
            }
          } },
        {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set(name) {
            this._handleEscapes("attribute", name);

            this._attribute = name;
          } }]);


        return Attribute;
      }(_namespace["default"]);

      exports["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: 'single',
          wrap: true },

        '"': {
          quotes: 'double',
          wrap: true } },

      _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true },
      _CSSESC_QUOTE_OPTIONS);

      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }, { "../util/unesc": 56, "./namespace": 39, "./types": 47, "cssesc": 9, "util-deprecate": 433 }], 31: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var ClassName = /*#__PURE__*/function (_Node) {
        _inheritsLoose(ClassName, _Node);

        function ClassName(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }

        var _proto = ClassName.prototype;

        _proto.valueToString = function valueToString() {
          return '.' + _Node.prototype.valueToString.call(this);
        };

        _createClass(ClassName, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc["default"])(v, {
                isIdentifier: true });


              if (escaped !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }

            this._value = v;
          } }]);


        return ClassName;
      }(_node["default"]);

      exports["default"] = ClassName;
      module.exports = exports.default;
    }, { "../util": 54, "./node": 41, "./types": 47, "cssesc": 9 }], 32: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Combinator = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Combinator, _Node);

        function Combinator(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }

        return Combinator;
      }(_node["default"]);

      exports["default"] = Combinator;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 33: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Comment = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Comment, _Node);

        function Comment(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }

        return Comment;
      }(_node["default"]);

      exports["default"] = Comment;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 34: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

      var _attribute = _interopRequireDefault(require("./attribute"));

      var _className = _interopRequireDefault(require("./className"));

      var _combinator = _interopRequireDefault(require("./combinator"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _id = _interopRequireDefault(require("./id"));

      var _nesting = _interopRequireDefault(require("./nesting"));

      var _pseudo = _interopRequireDefault(require("./pseudo"));

      var _root = _interopRequireDefault(require("./root"));

      var _selector = _interopRequireDefault(require("./selector"));

      var _string = _interopRequireDefault(require("./string"));

      var _tag = _interopRequireDefault(require("./tag"));

      var _universal = _interopRequireDefault(require("./universal"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var attribute = function attribute(opts) {
        return new _attribute["default"](opts);
      };

      exports.attribute = attribute;

      var className = function className(opts) {
        return new _className["default"](opts);
      };

      exports.className = className;

      var combinator = function combinator(opts) {
        return new _combinator["default"](opts);
      };

      exports.combinator = combinator;

      var comment = function comment(opts) {
        return new _comment["default"](opts);
      };

      exports.comment = comment;

      var id = function id(opts) {
        return new _id["default"](opts);
      };

      exports.id = id;

      var nesting = function nesting(opts) {
        return new _nesting["default"](opts);
      };

      exports.nesting = nesting;

      var pseudo = function pseudo(opts) {
        return new _pseudo["default"](opts);
      };

      exports.pseudo = pseudo;

      var root = function root(opts) {
        return new _root["default"](opts);
      };

      exports.root = root;

      var selector = function selector(opts) {
        return new _selector["default"](opts);
      };

      exports.selector = selector;

      var string = function string(opts) {
        return new _string["default"](opts);
      };

      exports.string = string;

      var tag = function tag(opts) {
        return new _tag["default"](opts);
      };

      exports.tag = tag;

      var universal = function universal(opts) {
        return new _universal["default"](opts);
      };

      exports.universal = universal;
    }, { "./attribute": 30, "./className": 31, "./combinator": 32, "./comment": 33, "./id": 37, "./nesting": 40, "./pseudo": 42, "./root": 43, "./selector": 44, "./string": 45, "./tag": 46, "./universal": 48 }], 35: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var types = _interopRequireWildcard(require("./types"));

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

      function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

      function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Container = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Container, _Node);

        function Container(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;

          if (!_this.nodes) {
            _this.nodes = [];
          }

          return _this;
        }

        var _proto = Container.prototype;

        _proto.append = function append(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };

        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };

        _proto.at = function at(index) {
          return this.nodes[index];
        };

        _proto.index = function index(child) {
          if (typeof child === 'number') {
            return child;
          }

          return this.nodes.indexOf(child);
        };

        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = undefined;
          this.nodes.splice(child, 1);
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          return this;
        };

        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
            var node = _step.value;
            node.parent = undefined;
          }

          this.nodes = [];
          return this;
        };

        _proto.empty = function empty() {
          return this.removeAll();
        };

        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (oldIndex <= index) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index <= oldIndex) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = undefined;
          this.each(function (node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);

              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        }
        /**
         * Return the most specific node at the line and column number given.
         * The source location is based on the original parsed location, locations aren't
         * updated as selector nodes are mutated.
         * 
         * Note that this location is relative to the location of the first character
         * of the selector, and not the location of the selector in the overall document
         * when used in conjunction with postcss.
         *
         * If not found, returns undefined.
         * @param {number} line The line number of the node to find. (1-based index)
         * @param {number} col  The column number of the node to find. (1-based index)
         */;


        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return undefined;
          }
        };

        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };

        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }

          if (!this.indexes) {
            this.indexes = {};
          }

          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;

          if (!this.length) {
            return undefined;
          }

          var index, result;

          while (this.indexes[id] < this.length) {
            index = this.indexes[id];
            result = callback(this.at(index), index);

            if (result === false) {
              break;
            }

            this.indexes[id] += 1;
          }

          delete this.indexes[id];

          if (result === false) {
            return false;
          }
        };

        _proto.walk = function walk(callback) {
          return this.each(function (node, i) {
            var result = callback(node, i);

            if (result !== false && node.length) {
              result = node.walk(callback);
            }

            if (result === false) {
              return false;
            }
          });
        };

        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };

        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;

          return this.walk(function (selector) {
            if (selector.type === types.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };

        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };

        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };

        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ID) {
              return callback.call(_this6, selector);
            }
          });
        };

        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;

          return this.walk(function (selector) {
            if (selector.type === types.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };

        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;

          return this.walk(function (selector) {
            if (selector.type === types.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };

        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;

          return this.walk(function (selector) {
            if (selector.type === types.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };

        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;

          return this.walk(function (selector) {
            if (selector.type === types.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };

        _proto.split = function split(callback) {
          var _this11 = this;

          var current = [];
          return this.reduce(function (memo, node, index) {
            var split = callback.call(_this11, node);
            current.push(node);

            if (split) {
              memo.push(current);
              current = [];
            } else if (index === _this11.length - 1) {
              memo.push(current);
            }

            return memo;
          }, []);
        };

        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };

        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };

        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };

        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };

        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };

        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };

        _proto.toString = function toString() {
          return this.map(String).join('');
        };

        _createClass(Container, [{
          key: "first",
          get: function get() {
            return this.at(0);
          } },
        {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          } },
        {
          key: "length",
          get: function get() {
            return this.nodes.length;
          } }]);


        return Container;
      }(_node["default"]);

      exports["default"] = Container;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 36: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.isNode = isNode;
      exports.isPseudoElement = isPseudoElement;
      exports.isPseudoClass = isPseudoClass;
      exports.isContainer = isContainer;
      exports.isNamespace = isNamespace;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

      var _types = require("./types");

      var _IS_TYPE;

      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }

      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }

      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo;
      var isRoot = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      exports.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;

      function isPseudoElement(node) {
        return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
      }

      function isPseudoClass(node) {
        return isPseudo(node) && !isPseudoElement(node);
      }

      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }

      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }, { "./types": 47 }], 37: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var ID = /*#__PURE__*/function (_Node) {
        _inheritsLoose(ID, _Node);

        function ID(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }

        var _proto = ID.prototype;

        _proto.valueToString = function valueToString() {
          return '#' + _Node.prototype.valueToString.call(this);
        };

        return ID;
      }(_node["default"]);

      exports["default"] = ID;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 38: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;

      var _types = require("./types");

      Object.keys(_types).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _types[key]) return;
        exports[key] = _types[key];
      });

      var _constructors = require("./constructors");

      Object.keys(_constructors).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _constructors[key]) return;
        exports[key] = _constructors[key];
      });

      var _guards = require("./guards");

      Object.keys(_guards).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _guards[key]) return;
        exports[key] = _guards[key];
      });
    }, { "./constructors": 34, "./guards": 36, "./types": 47 }], 39: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Namespace = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Namespace, _Node);

        function Namespace() {
          return _Node.apply(this, arguments) || this;
        }

        var _proto = Namespace.prototype;

        _proto.qualifiedName = function qualifiedName(value) {
          if (this.namespace) {
            return this.namespaceString + "|" + value;
          } else {
            return value;
          }
        };

        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };

        _createClass(Namespace, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;

              if (this.raws) {
                delete this.raws.namespace;
              }

              return;
            }

            var escaped = (0, _cssesc["default"])(namespace, {
              isIdentifier: true });

            this._namespace = namespace;

            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          } },
        {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            this.namespace = namespace;
          } },
        {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");

              if (ns === true) {
                return '';
              } else {
                return ns;
              }
            } else {
              return '';
            }
          } }]);


        return Namespace;
      }(_node["default"]);

      exports["default"] = Namespace;
      ;
      module.exports = exports.default;
    }, { "../util": 54, "./node": 41, "cssesc": 9 }], 40: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Nesting = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Nesting, _Node);

        function Nesting(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = '&';
          return _this;
        }

        return Nesting;
      }(_node["default"]);

      exports["default"] = Nesting;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 41: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _util = require("../util");

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var cloneNode = function cloneNode(obj, parent) {
        if (typeof obj !== 'object' || obj === null) {
          return obj;
        }

        var cloned = new obj.constructor();

        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }

          var value = obj[i];
          var type = typeof value;

          if (i === 'parent' && type === 'object') {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
              return cloneNode(j, cloned);
            });
          } else {
            cloned[i] = cloneNode(value, cloned);
          }
        }

        return cloned;
      };

      var Node = /*#__PURE__*/function () {
        function Node(opts) {
          if (opts === void 0) {
            opts = {};
          }

          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || '';
          this.spaces.after = this.spaces.after || '';
        }

        var _proto = Node.prototype;

        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }

          this.parent = undefined;
          return this;
        };

        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index in arguments) {
              this.parent.insertBefore(this, arguments[index]);
            }

            this.remove();
          }

          return this;
        };

        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };

        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };

        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }

          var cloned = cloneNode(this);

          for (var name in overrides) {
            cloned[name] = overrides[name];
          }

          return cloned;
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows non standard syntax to be appended to an existing property
         * by specifying the escaped value. By specifying the escaped value,
         * illegal characters are allowed to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped optional. the escaped value of the property.
         */;


        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

          if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name]; // delete any escaped value that was created by the setter.
          }
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows the escaped value to be specified directly, allowing illegal
         * characters to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped the escaped value of the property.
         */;


        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          this.raws[name] = valueEscaped;
        }
        /**
         * When you want a value to passed through to CSS directly. This method
         * deletes the corresponding raw value causing the stringifier to fallback
         * to the unescaped value.
         * @param {string} name the property to set.
         * @param {any} value The value that is both escaped and unescaped.
         */;


        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          if (this.raws) {
            delete this.raws[name];
          }
        }
        /**
         *
         * @param {number} line The number (starting with 1)
         * @param {number} column The column number (starting with 1)
         */;


        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }

            if (this.source.end.line < line) {
              return false;
            }

            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }

            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }

            return true;
          }

          return undefined;
        };

        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };

        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };

        _proto.toString = function toString() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
        };

        _createClass(Node, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

            if (rawSpace === undefined) {
              rawSpace = this.spaces && this.spaces.before;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          } },
        {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

            if (rawSpace === undefined) {
              rawSpace = this.spaces.after;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          } }]);


        return Node;
      }();

      exports["default"] = Node;
      module.exports = exports.default;
    }, { "../util": 54 }], 42: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Pseudo = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Pseudo, _Container);

        function Pseudo(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }

        var _proto = Pseudo.prototype;

        _proto.toString = function toString() {
          var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
        };

        return Pseudo;
      }(_container["default"]);

      exports["default"] = Pseudo;
      module.exports = exports.default;
    }, { "./container": 35, "./types": 47 }], 43: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Root = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Root, _Container);

        function Root(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }

        var _proto = Root.prototype;

        _proto.toString = function toString() {
          var str = this.reduce(function (memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(',');
          return this.trailingComma ? str + ',' : str;
        };

        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };

        _createClass(Root, [{
          key: "errorGenerator",
          set: function set(handler) {
            this._error = handler;
          } }]);


        return Root;
      }(_container["default"]);

      exports["default"] = Root;
      module.exports = exports.default;
    }, { "./container": 35, "./types": 47 }], 44: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Selector = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Selector, _Container);

        function Selector(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }

        return Selector;
      }(_container["default"]);

      exports["default"] = Selector;
      module.exports = exports.default;
    }, { "./container": 35, "./types": 47 }], 45: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var String = /*#__PURE__*/function (_Node) {
        _inheritsLoose(String, _Node);

        function String(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }

        return String;
      }(_node["default"]);

      exports["default"] = String;
      module.exports = exports.default;
    }, { "./node": 41, "./types": 47 }], 46: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Tag = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Tag, _Namespace);

        function Tag(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }

        return Tag;
      }(_namespace["default"]);

      exports["default"] = Tag;
      module.exports = exports.default;
    }, { "./namespace": 39, "./types": 47 }], 47: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
      var TAG = 'tag';
      exports.TAG = TAG;
      var STRING = 'string';
      exports.STRING = STRING;
      var SELECTOR = 'selector';
      exports.SELECTOR = SELECTOR;
      var ROOT = 'root';
      exports.ROOT = ROOT;
      var PSEUDO = 'pseudo';
      exports.PSEUDO = PSEUDO;
      var NESTING = 'nesting';
      exports.NESTING = NESTING;
      var ID = 'id';
      exports.ID = ID;
      var COMMENT = 'comment';
      exports.COMMENT = COMMENT;
      var COMBINATOR = 'combinator';
      exports.COMBINATOR = COMBINATOR;
      var CLASS = 'class';
      exports.CLASS = CLASS;
      var ATTRIBUTE = 'attribute';
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = 'universal';
      exports.UNIVERSAL = UNIVERSAL;
    }, {}], 48: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Universal = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Universal, _Namespace);

        function Universal(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = '*';
          return _this;
        }

        return Universal;
      }(_namespace["default"]);

      exports["default"] = Universal;
      module.exports = exports.default;
    }, { "./namespace": 39, "./types": 47 }], 49: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = sortAscending;

      function sortAscending(list) {
        return list.sort(function (a, b) {
          return a - b;
        });
      }

      ;
      module.exports = exports.default;
    }, {}], 50: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38; // `&`.charCodeAt(0);

      exports.ampersand = ampersand;
      var asterisk = 42; // `*`.charCodeAt(0);

      exports.asterisk = asterisk;
      var at = 64; // `@`.charCodeAt(0);

      exports.at = at;
      var comma = 44; // `,`.charCodeAt(0);

      exports.comma = comma;
      var colon = 58; // `:`.charCodeAt(0);

      exports.colon = colon;
      var semicolon = 59; // `;`.charCodeAt(0);

      exports.semicolon = semicolon;
      var openParenthesis = 40; // `(`.charCodeAt(0);

      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41; // `)`.charCodeAt(0);

      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91; // `[`.charCodeAt(0);

      exports.openSquare = openSquare;
      var closeSquare = 93; // `]`.charCodeAt(0);

      exports.closeSquare = closeSquare;
      var dollar = 36; // `$`.charCodeAt(0);

      exports.dollar = dollar;
      var tilde = 126; // `~`.charCodeAt(0);

      exports.tilde = tilde;
      var caret = 94; // `^`.charCodeAt(0);

      exports.caret = caret;
      var plus = 43; // `+`.charCodeAt(0);

      exports.plus = plus;
      var equals = 61; // `=`.charCodeAt(0);

      exports.equals = equals;
      var pipe = 124; // `|`.charCodeAt(0);

      exports.pipe = pipe;
      var greaterThan = 62; // `>`.charCodeAt(0);

      exports.greaterThan = greaterThan;
      var space = 32; // ` `.charCodeAt(0);

      exports.space = space;
      var singleQuote = 39; // `'`.charCodeAt(0);

      exports.singleQuote = singleQuote;
      var doubleQuote = 34; // `"`.charCodeAt(0);

      exports.doubleQuote = doubleQuote;
      var slash = 47; // `/`.charCodeAt(0);

      exports.slash = slash;
      var bang = 33; // `!`.charCodeAt(0);

      exports.bang = bang;
      var backslash = 92; // '\\'.charCodeAt(0);

      exports.backslash = backslash;
      var cr = 13; // '\r'.charCodeAt(0);

      exports.cr = cr;
      var feed = 12; // '\f'.charCodeAt(0);

      exports.feed = feed;
      var newline = 10; // '\n'.charCodeAt(0);

      exports.newline = newline;
      var tab = 9; // '\t'.charCodeAt(0);
      // Expose aliases primarily for readability.

      exports.tab = tab;
      var str = singleQuote; // No good single character representation!

      exports.str = str;
      var comment = -1;
      exports.comment = comment;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }, {}], 51: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = tokenize;
      exports.FIELDS = void 0;

      var t = _interopRequireWildcard(require("./tokenTypes"));

      var _unescapable, _wordDelimiters;

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";

      for (var i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      /**
       *  Returns the last index of the bar css word
       * @param {string} css The string in which the word begins
       * @param {number} start The index into the string where word's first letter occurs
       */


      function consumeWord(css, start) {
        var next = start;
        var code;

        do {
          code = css.charCodeAt(next);

          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            // All other characters are part of the word
            next++;
          }
        } while (next < css.length);

        return next - 1;
      }
      /**
       *  Returns the last index of the escape sequence
       * @param {string} css The string in which the sequence begins
       * @param {number} start The index into the string where escape character (`\`) occurs.
       */


      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);

        if (unescapable[code]) {// just consume the escape char
        } else if (hex[code]) {
          var hexDigits = 0; // consume up to 6 hex chars

          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          // the next char is part of the current word
          next++;
        }

        return next;
      }

      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6 };

      exports.FIELDS = FIELDS;

      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css,
        length = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

        function unclosed(what, fix) {
          if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
          }
        }

        while (start < length) {
          code = css.charCodeAt(start);

          if (code === t.newline) {
            offset = start;
            line += 1;
          }

          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);

                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

              tokenType = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            // Consume these characters as single tokens.

            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;

              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);

                if (next === -1) {
                  unclosed('quote', quote);
                }

                escapePos = next;

                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf('*/', start + 2) + 1;

                if (next === 0) {
                  unclosed('comment', '*/');
                }

                content = css.slice(start, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
              }

              end = next + 1;
              break;}
          // Ensure that the token structure remains consistent


          tokens.push([tokenType, // [0] Token type
          line, // [1] Starting line
          start - offset, // [2] Starting column
          endLine, // [3] Ending line
          endColumn, // [4] Ending column
          start, // [5] Start position / Source index
          end // [6] End position
          ]); // Reset offset for the next token

          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }

          start = end;
        }

        return tokens;
      }
    }, { "./tokenTypes": 50 }], 52: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = ensureObject;

      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            obj[prop] = {};
          }

          obj = obj[prop];
        }
      }

      module.exports = exports.default;
    }, {}], 53: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = getProp;

      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            return undefined;
          }

          obj = obj[prop];
        }

        return obj;
      }

      module.exports = exports.default;
    }, {}], 54: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

      var _unesc = _interopRequireDefault(require("./unesc"));

      exports.unesc = _unesc["default"];

      var _getProp = _interopRequireDefault(require("./getProp"));

      exports.getProp = _getProp["default"];

      var _ensureObject = _interopRequireDefault(require("./ensureObject"));

      exports.ensureObject = _ensureObject["default"];

      var _stripComments = _interopRequireDefault(require("./stripComments"));

      exports.stripComments = _stripComments["default"];

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}
    }, { "./ensureObject": 52, "./getProp": 53, "./stripComments": 55, "./unesc": 56 }], 55: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = stripComments;

      function stripComments(str) {
        var s = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;

        while (commentStart >= 0) {
          s = s + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);

          if (commentEnd < 0) {
            return s;
          }

          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }

        s = s + str.slice(lastEnd);
        return s;
      }

      module.exports = exports.default;
    }, {}], 56: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = unesc;

      // Many thanks for this post which made this migration much easier.
      // https://mathiasbynens.be/notes/css-escapes

      /**
       * 
       * @param {string} str 
       * @returns {[string, number]|undefined}
       */
      function gobbleHex(str) {
        var lower = str.toLowerCase();
        var hex = '';
        var spaceTerminated = false;

        for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
          var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

          spaceTerminated = code === 32;

          if (!valid) {
            break;
          }

          hex += lower[i];
        }

        if (hex.length === 0) {
          return undefined;
        }

        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
        // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
        // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

        if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }

        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }

      var CONTAINS_ESCAPE = /\\/;

      function unesc(str) {
        var needToProcess = CONTAINS_ESCAPE.test(str);

        if (!needToProcess) {
          return str;
        }

        var ret = "";

        for (var i = 0; i < str.length; i++) {
          if (str[i] === "\\") {
            var gobbled = gobbleHex(str.slice(i + 1, i + 7));

            if (gobbled !== undefined) {
              ret += gobbled[0];
              i += gobbled[1];
              continue;
            } // Retain a pair of \\ if double escaped `\\\\`
            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


            if (str[i + 1] === "\\") {
              ret += "\\";
              i++;
              continue;
            } // if \\ is at the end of the string retain it
            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


            if (str.length === i + 1) {
              ret += str[i];
            }

            continue;
          }

          ret += str[i];
        }

        return ret;
      }

      module.exports = exports.default;
    }, {}], 57: [function (require, module, exports) {
      var parse = require("./parse");
      var walk = require("./walk");
      var stringify = require("./stringify");

      function ValueParser(value) {
        if (this instanceof ValueParser) {
          this.nodes = parse(value);
          return this;
        }
        return new ValueParser(value);
      }

      ValueParser.prototype.toString = function () {
        return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
      };

      ValueParser.prototype.walk = function (cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };

      ValueParser.unit = require("./unit");

      ValueParser.walk = walk;

      ValueParser.stringify = stringify;

      module.exports = ValueParser;

    }, { "./parse": 58, "./stringify": 59, "./unit": 60, "./walk": 61 }], 58: [function (require, module, exports) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;

      module.exports = function (input) {
        var tokens = [];
        var value = input;

        var next,
        quote,
        prev,
        token,
        escape,
        escapePos,
        whitespacePos,
        parenthesesOpenPos;
        var pos = 0;
        var code = value.charCodeAt(pos);
        var max = value.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;

        var name = "";
        var before = "";
        var after = "";

        while (pos < max) {
          // Whitespaces
          if (code <= 32) {
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            token = value.slice(pos, next);

            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (
            code === comma ||
            code === colon ||
            code === slash &&
            value.charCodeAt(next + 1) !== star && (
            !parent ||
            parent && parent.type === "function" && parent.value !== "calc"))
            {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            }

            pos = next;

            // Quotes
          } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote: quote };

            do {
              escape = false;
              next = value.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += quote;
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape);
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);

            // Comments
          } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);

            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next + 2 };


            if (next === -1) {
              token.unclosed = true;
              next = value.length;
              token.sourceEndIndex = next;
            }

            token.value = value.slice(pos + 2, next);
            tokens.push(token);

            pos = next + 2;
            code = value.charCodeAt(pos);

            // Operation within calc
          } else if (
          (code === slash || code === star) &&
          parent &&
          parent.type === "function" &&
          parent.value === "calc")
          {
            token = value[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token });

            pos += 1;
            code = value.charCodeAt(pos);

            // Dividers
          } else if (code === slash || code === comma || code === colon) {
            token = value[pos];

            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before: before,
              after: "" });

            before = "";

            pos += 1;
            code = value.charCodeAt(pos);

            // Open parentheses
          } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value.slice(parenthesesOpenPos + 1, next) };

            pos = next;

            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next -= 1;
              do {
                escape = false;
                next = value.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape = !escape;
                  }
                } else {
                  value += ")";
                  next = value.length - 1;
                  token.unclosed = true;
                }
              } while (escape);
              // Whitespaces before closed
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code = value.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value.slice(pos, whitespacePos + 1) }];


                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next,
                    value: value.slice(whitespacePos + 1, next) });

                } else {
                  token.after = value.slice(whitespacePos + 1, next);
                  token.sourceEndIndex = next;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              token.sourceEndIndex = token.unclosed ? next : pos;
              code = value.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";

            // Close parentheses
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);

            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;

            // Words
          } else {
            next = pos;
            do {
              if (code === backslash) {
                next += 1;
              }
              next += 1;
              code = value.charCodeAt(next);
            } while (
            next < max &&
            !(
            code <= 32 ||
            code === singleQuote ||
            code === doubleQuote ||
            code === comma ||
            code === colon ||
            code === slash ||
            code === openParentheses ||
            code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === slash &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === closeParentheses && balanced));


            token = value.slice(pos, next);

            if (openParentheses === code) {
              name = token;
            } else if (
            (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
            plus === token.charCodeAt(1) &&
            isUnicodeRange.test(token.slice(2)))
            {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            }

            pos = next;
          }
        }

        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value.length;
        }

        return stack[0].nodes;
      };

    }, {}], 59: [function (require, module, exports) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value = node.value;
        var buf;
        var customResult;

        if (custom && (customResult = custom(node)) !== undefined) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return (
            value +
            "(" + (
            node.before || "") +
            buf + (
            node.after || "") + (
            node.unclosed ? "" : ")"));

        }
        return value;
      }

      function stringify(nodes, custom) {
        var result, i;

        if (Array.isArray(nodes)) {
          result = "";
          for (i = nodes.length - 1; ~i; i -= 1) {
            result = stringifyNode(nodes[i], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }

      module.exports = stringify;

    }, {}], 60: [function (require, module, exports) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);

      // Check if three code points would start a number
      // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
      function likeNumber(value) {
        var code = value.charCodeAt(0);
        var nextCode;

        if (code === plus || code === minus) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          var nextNextCode = value.charCodeAt(2);

          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code === dot) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code >= 48 && code <= 57) {
          return true;
        }

        return false;
      }

      // Consume a number
      // https://www.w3.org/TR/css-syntax-3/#consume-number
      module.exports = function (value) {
        var pos = 0;
        var length = value.length;
        var code;
        var nextCode;
        var nextNextCode;

        if (length === 0 || !likeNumber(value)) {
          return false;
        }

        code = value.charCodeAt(pos);

        if (code === plus || code === minus) {
          pos++;
        }

        while (pos < length) {
          code = value.charCodeAt(pos);

          if (code < 48 || code > 57) {
            break;
          }

          pos += 1;
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);

        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        nextNextCode = value.charCodeAt(pos + 2);

        if (
        (code === exp || code === EXP) && (
        nextCode >= 48 && nextCode <= 57 ||
        (nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
        {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        return {
          number: value.slice(0, pos),
          unit: value.slice(pos) };

      };

    }, {}], 61: [function (require, module, exports) {
      module.exports = function walk(nodes, cb, bubble) {
        var i, max, node, result;

        for (i = 0, max = nodes.length; i < max; i += 1) {
          node = nodes[i];
          if (!bubble) {
            result = cb(node, i, nodes);
          }

          if (
          result !== false &&
          node.type === "function" &&
          Array.isArray(node.nodes))
          {
            walk(node.nodes, cb, bubble);
          }

          if (bubble) {
            cb(node, i, nodes);
          }
        }
      };

    }, {}], 62: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      class AtRule extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'atrule';
        }

        append(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.append(...children);
        }

        prepend(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.prepend(...children);
        }}


      module.exports = AtRule;
      AtRule.default = AtRule;

      Container.registerAtRule(AtRule);

    }, { "./container": 64 }], 63: [function (require, module, exports) {
      'use strict';

      let Node = require('./node');

      class Comment extends Node {
        constructor(defaults) {
          super(defaults);
          this.type = 'comment';
        }}


      module.exports = Comment;
      Comment.default = Comment;

    }, { "./node": 74 }], 64: [function (require, module, exports) {
      'use strict';

      let { isClean, my } = require('./symbols');
      let Declaration = require('./declaration');
      let Comment = require('./comment');
      let Node = require('./node');

      let parse, Rule, AtRule;

      function cleanSource(nodes) {
        return nodes.map(i => {
          if (i.nodes) i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }

      function markDirtyUp(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i of node.proxyOf.nodes) {
            markDirtyUp(i);
          }
        }
      }

      class Container extends Node {
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }

        each(callback) {
          if (!this.proxyOf.nodes) return undefined;
          let iterator = this.getIterator();

          let index, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index], index);
            if (result === false) break;

            this.indexes[iterator] += 1;
          }

          delete this.indexes[iterator];
          return result;
        }

        walk(callback) {
          return this.each((child, i) => {
            let result;
            try {
              result = callback(child, i);
            } catch (e) {
              throw child.addToError(e);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }

            return result;
          });
        }

        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i) => {
              if (child.type === 'decl') {
                return callback(child, i);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'decl' && prop.test(child.prop)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'decl' && child.prop === prop) {
              return callback(child, i);
            }
          });
        }

        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;

            return this.walk((child, i) => {
              if (child.type === 'rule') {
                return callback(child, i);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'rule' && selector.test(child.selector)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'rule' && child.selector === selector) {
              return callback(child, i);
            }
          });
        }

        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i) => {
              if (child.type === 'atrule') {
                return callback(child, i);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'atrule' && name.test(child.name)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'atrule' && child.name === name) {
              return callback(child, i);
            }
          });
        }

        walkComments(callback) {
          return this.walk((child, i) => {
            if (child.type === 'comment') {
              return callback(child, i);
            }
          });
        }

        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes) this.proxyOf.nodes.push(node);
          }

          this.markDirty();

          return this;
        }

        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, 'prepend').reverse();
            for (let node of nodes) this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes) node.cleanRaws(keepBetween);
          }
        }

        insertBefore(exist, add) {
          exist = this.index(exist);

          let type = exist === 0 ? 'prepend' : false;
          let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();
          for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (exist <= index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        insertAfter(exist, add) {
          exist = this.index(exist);

          let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
          for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (exist < index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = undefined;
          this.proxyOf.nodes.splice(child, 1);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          this.markDirty();

          return this;
        }

        removeAll() {
          for (let node of this.proxyOf.nodes) node.parent = undefined;
          this.proxyOf.nodes = [];

          this.markDirty();

          return this;
        }

        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }

          this.walkDecls(decl => {
            if (opts.props && !opts.props.includes(decl.prop)) return;
            if (opts.fast && !decl.value.includes(opts.fast)) return;

            decl.value = decl.value.replace(pattern, callback);
          });

          this.markDirty();

          return this;
        }

        every(condition) {
          return this.nodes.every(condition);
        }

        some(condition) {
          return this.nodes.some(condition);
        }

        index(child) {
          if (typeof child === 'number') return child;
          if (child.proxyOf) child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }

        get first() {
          if (!this.proxyOf.nodes) return undefined;
          return this.proxyOf.nodes[0];
        }

        get last() {
          if (!this.proxyOf.nodes) return undefined;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }

        normalize(nodes, sample) {
          if (typeof nodes === 'string') {
            nodes = cleanSource(parse(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, 'ignore');
            }
          } else if (nodes.type === 'root' && this.type !== 'document') {
            nodes = nodes.nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, 'ignore');
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === 'undefined') {
              throw new Error('Value field is missed in node creation');
            } else if (typeof nodes.value !== 'string') {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment(nodes)];
          } else {
            throw new Error('Unknown node type in node creation');
          }

          let processed = nodes.map(i => {
            /* c8 ignore next */
            if (!i[my]) Container.rebuild(i);
            i = i.proxyOf;
            if (i.parent) i.parent.removeChild(i);
            if (i[isClean]) markDirtyUp(i);
            if (typeof i.raws.before === 'undefined') {
              if (sample && typeof sample.raws.before !== 'undefined') {
                i.raws.before = sample.raws.before.replace(/\S/g, '');
              }
            }
            i.parent = this.proxyOf;
            return i;
          });

          return processed;
        }

        getProxyProcessor() {
          return {
            set(node, prop, value) {
              if (node[prop] === value) return true;
              node[prop] = value;
              if (prop === 'name' || prop === 'params' || prop === 'selector') {
                node.markDirty();
              }
              return true;
            },

            get(node, prop) {
              if (prop === 'proxyOf') {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (
              prop === 'each' ||
              typeof prop === 'string' && prop.startsWith('walk'))
              {
                return (...args) => {
                  return node[prop](
                  ...args.map(i => {
                    if (typeof i === 'function') {
                      return (child, index) => i(child.toProxy(), index);
                    } else {
                      return i;
                    }
                  }));

                };
              } else if (prop === 'every' || prop === 'some') {
                return cb => {
                  return node[prop]((child, ...other) =>
                  cb(child.toProxy(), ...other));

                };
              } else if (prop === 'root') {
                return () => node.root().toProxy();
              } else if (prop === 'nodes') {
                return node.nodes.map(i => i.toProxy());
              } else if (prop === 'first' || prop === 'last') {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            } };

        }

        getIterator() {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};

          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;

          return iterator;
        }}


      Container.registerParse = dependant => {
        parse = dependant;
      };

      Container.registerRule = dependant => {
        Rule = dependant;
      };

      Container.registerAtRule = dependant => {
        AtRule = dependant;
      };

      module.exports = Container;
      Container.default = Container;

      /* c8 ignore start */
      Container.rebuild = node => {
        if (node.type === 'atrule') {
          Object.setPrototypeOf(node, AtRule.prototype);
        } else if (node.type === 'rule') {
          Object.setPrototypeOf(node, Rule.prototype);
        } else if (node.type === 'decl') {
          Object.setPrototypeOf(node, Declaration.prototype);
        } else if (node.type === 'comment') {
          Object.setPrototypeOf(node, Comment.prototype);
        }

        node[my] = true;

        if (node.nodes) {
          node.nodes.forEach(child => {
            Container.rebuild(child);
          });
        }
      };
      /* c8 ignore stop */

    }, { "./comment": 63, "./declaration": 66, "./node": 74, "./symbols": 85 }], 65: [function (require, module, exports) {
      'use strict';

      let pico = require('picocolors');

      let terminalHighlight = require('./terminal-highlight');

      class CssSyntaxError extends Error {
        constructor(message, line, column, source, file, plugin) {
          super(message);
          this.name = 'CssSyntaxError';
          this.reason = message;

          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin) {
            this.plugin = plugin;
          }
          if (typeof line !== 'undefined' && typeof column !== 'undefined') {
            if (typeof line === 'number') {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }

          this.setMessage();

          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CssSyntaxError);
          }
        }

        setMessage() {
          this.message = this.plugin ? this.plugin + ': ' : '';
          this.message += this.file ? this.file : '<css input>';
          if (typeof this.line !== 'undefined') {
            this.message += ':' + this.line + ':' + this.column;
          }
          this.message += ': ' + this.reason;
        }

        showSourceCode(color) {
          if (!this.source) return '';

          let css = this.source;
          if (color == null) color = pico.isColorSupported;
          if (terminalHighlight) {
            if (color) css = terminalHighlight(css);
          }

          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);

          let maxWidth = String(end).length;

          let mark, aside;
          if (color) {
            let { bold, red, gray } = pico.createColors(true);
            mark = text => bold(red(text));
            aside = text => gray(text);
          } else {
            mark = aside = str => str;
          }

          return lines.
          slice(start, end).
          map((line, index) => {
            let number = start + 1 + index;
            let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
            if (number === this.line) {
              let spacing =
              aside(gutter.replace(/\d/g, ' ')) +
              line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
              return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
            }
            return ' ' + aside(gutter) + line;
          }).
          join('\n');
        }

        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = '\n\n' + code + '\n';
          }
          return this.name + ': ' + this.message + code;
        }}


      module.exports = CssSyntaxError;
      CssSyntaxError.default = CssSyntaxError;

    }, { "./terminal-highlight": 2, "picocolors": 21 }], 66: [function (require, module, exports) {
      'use strict';

      let Node = require('./node');

      class Declaration extends Node {
        constructor(defaults) {
          if (
          defaults &&
          typeof defaults.value !== 'undefined' &&
          typeof defaults.value !== 'string')
          {
            defaults = _extends({}, defaults, { value: String(defaults.value) });
          }
          super(defaults);
          this.type = 'decl';
        }

        get variable() {
          return this.prop.startsWith('--') || this.prop[0] === '$';
        }}


      module.exports = Declaration;
      Declaration.default = Declaration;

    }, { "./node": 74 }], 67: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      let LazyResult, Processor;

      class Document extends Container {
        constructor(defaults) {
          // type needs to be passed to super, otherwise child roots won't be normalized correctly
          super(_extends({ type: 'document' }, defaults));

          if (!this.nodes) {
            this.nodes = [];
          }
        }

        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);

          return lazy.stringify();
        }}


      Document.registerLazyResult = dependant => {
        LazyResult = dependant;
      };

      Document.registerProcessor = dependant => {
        Processor = dependant;
      };

      module.exports = Document;
      Document.default = Document;

    }, { "./container": 64 }], 68: [function (require, module, exports) {
      'use strict';

      let Declaration = require('./declaration');
      let PreviousMap = require('./previous-map');
      let Comment = require('./comment');
      let AtRule = require('./at-rule');
      let Input = require('./input');
      let Root = require('./root');
      let Rule = require('./rule');

      function fromJSON(json, inputs) {
        if (Array.isArray(json)) return json.map(n => fromJSON(n));

        let { inputs: ownInputs } = json,defaults = _objectWithoutPropertiesLoose(json, ["inputs"]);
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = _extends({}, input, { __proto__: Input.prototype });
            if (inputHydrated.map) {
              inputHydrated.map = _extends({},
              inputHydrated.map, {
                __proto__: PreviousMap.prototype });

            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults.nodes) {
          defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
        }
        if (defaults.source) {
          let _defaults$source = defaults.source,{ inputId } = _defaults$source,source = _objectWithoutPropertiesLoose(_defaults$source, ["inputId"]);
          defaults.source = source;
          if (inputId != null) {
            defaults.source.input = inputs[inputId];
          }
        }
        if (defaults.type === 'root') {
          return new Root(defaults);
        } else if (defaults.type === 'decl') {
          return new Declaration(defaults);
        } else if (defaults.type === 'rule') {
          return new Rule(defaults);
        } else if (defaults.type === 'comment') {
          return new Comment(defaults);
        } else if (defaults.type === 'atrule') {
          return new AtRule(defaults);
        } else {
          throw new Error('Unknown node type: ' + json.type);
        }
      }

      module.exports = fromJSON;
      fromJSON.default = fromJSON;

    }, { "./at-rule": 62, "./comment": 63, "./declaration": 66, "./input": 69, "./previous-map": 78, "./root": 81, "./rule": 82 }], 69: [function (require, module, exports) {
      'use strict';

      let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
      let { fileURLToPath, pathToFileURL } = require('url');
      let { resolve, isAbsolute } = require('path');
      let { nanoid } = require('nanoid/non-secure');

      let terminalHighlight = require('./terminal-highlight');
      let CssSyntaxError = require('./css-syntax-error');
      let PreviousMap = require('./previous-map');

      let fromOffsetCache = Symbol('fromOffsetCache');

      let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      let pathAvailable = Boolean(resolve && isAbsolute);

      class Input {
        constructor(css, opts = {}) {
          if (
          css === null ||
          typeof css === 'undefined' ||
          typeof css === 'object' && !css.toString)
          {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }

          this.css = css.toString();

          if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }

          if (opts.from) {
            if (
            !pathAvailable ||
            /^\w+:\/\//.test(opts.from) ||
            isAbsolute(opts.from))
            {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }

          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
          }

          if (!this.file) {
            this.id = '<input css ' + nanoid(6) + '>';
          }
          if (this.map) this.map.file = this.from;
        }

        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split('\n');
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;

            for (let i = 0, l = lines.length; i < l; i++) {
              lineToIndex[i] = prevIndex;
              prevIndex += lines[i].length + 1;
            }

            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];

          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max = lineToIndex.length - 2;
            let mid;
            while (min < max) {
              mid = min + (max - min >> 1);
              if (offset < lineToIndex[mid]) {
                max = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            line: min + 1,
            col: offset - lineToIndex[min] + 1 };

        }

        error(message, line, column, opts = {}) {
          let result, endLine, endColumn;

          if (line && typeof line === 'object') {
            let start = line;
            let end = column;
            if (typeof line.offset === 'number') {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === 'number') {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }

          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError(
            message,
            origin.endLine === undefined ?
            origin.line :
            { line: origin.line, column: origin.column },
            origin.endLine === undefined ?
            origin.column :
            { line: origin.endLine, column: origin.endColumn },
            origin.source,
            origin.file,
            opts.plugin);

          } else {
            result = new CssSyntaxError(
            message,
            endLine === undefined ? line : { line, column },
            endLine === undefined ? column : { line: endLine, column: endColumn },
            this.css,
            this.file,
            opts.plugin);

          }

          result.input = { line, column, endLine, endColumn, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }

          return result;
        }

        origin(line, column, endLine, endColumn) {
          if (!this.map) return false;
          let consumer = this.map.consumer();

          let from = consumer.originalPositionFor({ line, column });
          if (!from.source) return false;

          let to;
          if (typeof endLine === 'number') {
            to = consumer.originalPositionFor({ line: endLine, column: endColumn });
          }

          let fromUrl;

          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));

          }

          let result = {
            url: fromUrl.toString(),
            line: from.line,
            column: from.column,
            endLine: to && to.line,
            endColumn: to && to.column };


          if (fromUrl.protocol === 'file:') {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              /* c8 ignore next 2 */
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }

          let source = consumer.sourceContentFor(from.source);
          if (source) result.source = source;

          return result;
        }

        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);
        }

        get from() {
          return this.file || this.id;
        }

        toJSON() {
          let json = {};
          for (let name of ['hasBOM', 'css', 'file', 'id']) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = _extends({}, this.map);
            if (json.map.consumerCache) {
              json.map.consumerCache = undefined;
            }
          }
          return json;
        }}


      module.exports = Input;
      Input.default = Input;

      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input);
      }

    }, { "./css-syntax-error": 65, "./previous-map": 78, "./terminal-highlight": 2, "nanoid/non-secure": 20, "path": undefined, "source-map-js": 2, "url": undefined }], 70: [function (require, module, exports) {
      'use strict';

      let { isClean, my } = require('./symbols');
      let MapGenerator = require('./map-generator');
      let stringify = require('./stringify');
      let Container = require('./container');
      let Document = require('./document');
      let warnOnce = require('./warn-once');
      let Result = require('./result');
      let parse = require('./parse');
      let Root = require('./root');

      const TYPE_TO_CLASS_NAME = {
        document: 'Document',
        root: 'Root',
        atrule: 'AtRule',
        rule: 'Rule',
        decl: 'Declaration',
        comment: 'Comment' };


      const PLUGIN_PROPS = {
        postcssPlugin: true,
        prepare: true,
        Once: true,
        Document: true,
        Root: true,
        Declaration: true,
        Rule: true,
        AtRule: true,
        Comment: true,
        DeclarationExit: true,
        RuleExit: true,
        AtRuleExit: true,
        CommentExit: true,
        RootExit: true,
        DocumentExit: true,
        OnceExit: true };


      const NOT_VISITORS = {
        postcssPlugin: true,
        prepare: true,
        Once: true };


      const CHILDREN = 0;

      function isPromise(obj) {
        return typeof obj === 'object' && typeof obj.then === 'function';
      }

      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === 'decl') {
          key = node.prop.toLowerCase();
        } else if (node.type === 'atrule') {
          key = node.name.toLowerCase();
        }

        if (key && node.append) {
          return [
          type,
          type + '-' + key,
          CHILDREN,
          type + 'Exit',
          type + 'Exit-' + key];

        } else if (key) {
          return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];
        } else if (node.append) {
          return [type, CHILDREN, type + 'Exit'];
        } else {
          return [type, type + 'Exit'];
        }
      }

      function toStack(node) {
        let events;
        if (node.type === 'document') {
          events = ['Document', CHILDREN, 'DocumentExit'];
        } else if (node.type === 'root') {
          events = ['Root', CHILDREN, 'RootExit'];
        } else {
          events = getEvents(node);
        }

        return {
          node,
          events,
          eventIndex: 0,
          visitors: [],
          visitorIndex: 0,
          iterator: 0 };

      }

      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
        return node;
      }

      let postcss = {};

      class LazyResult {
        constructor(processor, css, opts) {
          this.stringified = false;
          this.processed = false;

          let root;
          if (
          typeof css === 'object' &&
          css !== null && (
          css.type === 'root' || css.type === 'document'))
          {
            root = cleanMarks(css);
          } else if (css instanceof LazyResult || css instanceof Result) {
            root = cleanMarks(css.root);
            if (css.map) {
              if (typeof opts.map === 'undefined') opts.map = {};
              if (!opts.map.inline) opts.map.inline = false;
              opts.map.prev = css.map;
            }
          } else {
            let parser = parse;
            if (opts.syntax) parser = opts.syntax.parse;
            if (opts.parser) parser = opts.parser;
            if (parser.parse) parser = parser.parse;

            try {
              root = parser(css, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }

            if (root && !root[my]) {
              /* c8 ignore next 2 */
              Container.rebuild(root);
            }
          }

          this.result = new Result(processor, root, opts);
          this.helpers = _extends({}, postcss, { result: this.result, postcss });
          this.plugins = this.processor.plugins.map(plugin => {
            if (typeof plugin === 'object' && plugin.prepare) {
              return _extends({}, plugin, plugin.prepare(this.result));
            } else {
              return plugin;
            }
          });
        }

        get [Symbol.toStringTag]() {
          return 'LazyResult';
        }

        get processor() {
          return this.result.processor;
        }

        get opts() {
          return this.result.opts;
        }

        get css() {
          return this.stringify().css;
        }

        get content() {
          return this.stringify().content;
        }

        get map() {
          return this.stringify().map;
        }

        get root() {
          return this.sync().root;
        }

        get messages() {
          return this.sync().messages;
        }

        warnings() {
          return this.sync().warnings();
        }

        toString() {
          return this.css;
        }

        then(onFulfilled, onRejected) {
          if (process.env.NODE_ENV !== 'production') {
            if (!('from' in this.opts)) {
              warnOnce(
              'Without `from` option PostCSS could generate wrong source map ' +
              'and will not find Browserslist config. Set it to CSS file path ' +
              'or to `undefined` to prevent this warning.');

            }
          }
          return this.async().then(onFulfilled, onRejected);
        }

        catch(onRejected) {
          return this.async().catch(onRejected);
        }

        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }

        async() {
          if (this.error) return Promise.reject(this.error);
          if (this.processed) return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }

        sync() {
          if (this.error) throw this.error;
          if (this.processed) return this.result;
          this.processed = true;

          if (this.processing) {
            throw this.getAsyncError();
          }

          for (let plugin of this.plugins) {
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }

          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              this.walkSync(root);
            }
            if (this.listeners.OnceExit) {
              if (root.type === 'document') {
                for (let subRoot of root.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root);
              }
            }
          }

          return this.result;
        }

        stringify() {
          if (this.error) throw this.error;
          if (this.stringified) return this.result;
          this.stringified = true;

          this.sync();

          let opts = this.result.opts;
          let str = stringify;
          if (opts.syntax) str = opts.syntax.stringify;
          if (opts.stringifier) str = opts.stringifier;
          if (str.stringify) str = str.stringify;

          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];

          return this.result;
        }

        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node.nodes) {
                node.each(child => {
                  if (!child[isClean]) this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node.toProxy())) return;
              }
            }
          }
        }

        visitSync(visitors, node) {
          for (let [plugin, visitor] of visitors) {
            this.result.lastPlugin = plugin;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e) {
              throw this.handleError(e, node.proxyOf);
            }
            if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
              return true;
            }
            if (isPromise(promise)) {
              throw this.getAsyncError();
            }
          }
        }

        runOnRoot(plugin) {
          this.result.lastPlugin = plugin;
          try {
            if (typeof plugin === 'object' && plugin.Once) {
              if (this.result.root.type === 'document') {
                let roots = this.result.root.nodes.map((root) =>
                plugin.Once(root, this.helpers));


                if (isPromise(roots[0])) {
                  return Promise.all(roots);
                }

                return roots;
              }

              return plugin.Once(this.result.root, this.helpers);
            } else if (typeof plugin === 'function') {
              return plugin(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }

        getAsyncError() {
          throw new Error('Use process(css).then(cb) to work with async plugins');
        }

        handleError(error, node) {
          let plugin = this.result.lastPlugin;
          try {
            if (node) node.addToError(error);
            this.error = error;
            if (error.name === 'CssSyntaxError' && !error.plugin) {
              error.plugin = plugin.postcssPlugin;
              error.setMessage();
            } else if (plugin.postcssVersion) {
              if (process.env.NODE_ENV !== 'production') {
                let pluginName = plugin.postcssPlugin;
                let pluginVer = plugin.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a = pluginVer.split('.');
                let b = runtimeVer.split('.');

                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                  // eslint-disable-next-line no-console
                  console.error(
                  'Unknown error from PostCSS plugin. Your current PostCSS ' +
                  'version is ' +
                  runtimeVer +
                  ', but ' +
                  pluginName +
                  ' uses ' +
                  pluginVer +
                  '. Perhaps this is the source of the error below.');

                }
              }
            }
          } catch (err) {
            /* c8 ignore next 3 */
            // eslint-disable-next-line no-console
            if (console && console.error) console.error(err);
          }
          return error;
        }

        async runAsync() {
          this.plugin = 0;
          for (let i = 0; i < this.plugins.length; i++) {
            let plugin = this.plugins[i];
            let promise = this.runOnRoot(plugin);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }

          this.prepareVisitors();
          if (this.hasListener) {
            let root = this.result.root;
            while (!root[isClean]) {
              root[isClean] = true;
              let stack = [toStack(root)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (e) {
                    let node = stack[stack.length - 1].node;
                    throw this.handleError(e, node);
                  }
                }
              }
            }

            if (this.listeners.OnceExit) {
              for (let [plugin, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin;
                try {
                  if (root.type === 'document') {
                    let roots = root.nodes.map((subRoot) =>
                    visitor(subRoot, this.helpers));


                    await Promise.all(roots);
                  } else {
                    await visitor(root, this.helpers);
                  }
                } catch (e) {
                  throw this.handleError(e);
                }
              }
            }
          }

          this.processed = true;
          return this.stringify();
        }

        prepareVisitors() {
          this.listeners = {};
          let add = (plugin, type, cb) => {
            if (!this.listeners[type]) this.listeners[type] = [];
            this.listeners[type].push([plugin, cb]);
          };
          for (let plugin of this.plugins) {
            if (typeof plugin === 'object') {
              for (let event in plugin) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                  `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                  `Try to update PostCSS (${this.processor.version} now).`);

                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin[event] === 'object') {
                    for (let filter in plugin[event]) {
                      if (filter === '*') {
                        add(plugin, event, plugin[event][filter]);
                      } else {
                        add(
                        plugin,
                        event + '-' + filter.toLowerCase(),
                        plugin[event][filter]);

                      }
                    }
                  } else if (typeof plugin[event] === 'function') {
                    add(plugin, event, plugin[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }

        visitTick(stack) {
          let visit = stack[stack.length - 1];
          let { node, visitors } = visit;

          if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
            stack.pop();
            return;
          }

          if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
            let [plugin, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e) {
              throw this.handleError(e, node);
            }
          }

          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child;
            while (child = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit.iterator = 0;
            delete node.indexes[iterator];
          }

          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }}


      LazyResult.registerPostcss = dependant => {
        postcss = dependant;
      };

      module.exports = LazyResult;
      LazyResult.default = LazyResult;

      Root.registerLazyResult(LazyResult);
      Document.registerLazyResult(LazyResult);

    }, { "./container": 64, "./document": 67, "./map-generator": 72, "./parse": 75, "./result": 80, "./root": 81, "./stringify": 84, "./symbols": 85, "./warn-once": 87 }], 71: [function (require, module, exports) {
      'use strict';

      let list = {
        split(string, separators, last) {
          let array = [];
          let current = '';
          let split = false;

          let func = 0;
          let quote = false;
          let escape = false;

          for (let letter of string) {
            if (escape) {
              escape = false;
            } else if (letter === '\\') {
              escape = true;
            } else if (quote) {
              if (letter === quote) {
                quote = false;
              }
            } else if (letter === '"' || letter === "'") {
              quote = letter;
            } else if (letter === '(') {
              func += 1;
            } else if (letter === ')') {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter)) split = true;
            }

            if (split) {
              if (current !== '') array.push(current.trim());
              current = '';
              split = false;
            } else {
              current += letter;
            }
          }

          if (last || current !== '') array.push(current.trim());
          return array;
        },

        space(string) {
          let spaces = [' ', '\n', '\t'];
          return list.split(string, spaces);
        },

        comma(string) {
          return list.split(string, [','], true);
        } };


      module.exports = list;
      list.default = list;

    }, {}], 72: [function (require, module, exports) {
      'use strict';

      let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
      let { dirname, resolve, relative, sep } = require('path');
      let { pathToFileURL } = require('url');

      let Input = require('./input');

      let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      let pathAvailable = Boolean(dirname && resolve && relative && sep);

      class MapGenerator {
        constructor(stringify, root, opts, cssString) {
          this.stringify = stringify;
          this.mapOpts = opts.map || {};
          this.root = root;
          this.opts = opts;
          this.css = cssString;
        }

        isMap() {
          if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }

        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk(node => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input(this.css, this.opts);
              if (input.map) this.previousMaps.push(input.map);
            }
          }

          return this.previousMaps;
        }

        isInline() {
          if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
          }

          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
          }

          if (this.previous().length) {
            return this.previous().some(i => i.inline);
          }
          return true;
        }

        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some(i => i.withContent());
          }
          return true;
        }

        clearAnnotation() {
          if (this.mapOpts.annotation === false) return;

          if (this.root) {
            let node;
            for (let i = this.root.nodes.length - 1; i >= 0; i--) {
              node = this.root.nodes[i];
              if (node.type !== 'comment') continue;
              if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '');
          }
        }

        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk(node => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  this.map.setSourceContent(
                  this.toUrl(this.path(from)),
                  node.source.input.css);

                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ?
            this.toUrl(this.path(this.opts.from)) :
            '<no source>';
            this.map.setSourceContent(from, this.css);
          }
        }

        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root = prev.root || dirname(prev.file);
            let map;

            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = map.sourcesContent.map(() => null);
              }
            } else {
              map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
          }
        }

        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some(i => i.annotation);
          }
          return true;
        }

        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString('base64');
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }

        addAnnotation() {
          let content;

          if (this.isInline()) {
            content =
            'data:application/json;base64,' + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === 'function') {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + '.map';
          }
          let eol = '\n';
          if (this.css.includes('\r\n')) eol = '\r\n';

          this.css += eol + '/*# sourceMappingURL=' + content + ' */';
        }

        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return 'to.css';
          }
        }

        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev);
          } else {
            this.map = new SourceMapGenerator({ file: this.outputFile() });
            this.map.addMapping({
              source: this.opts.from ?
              this.toUrl(this.path(this.opts.from)) :
              '<no source>',
              generated: { line: 1, column: 0 },
              original: { line: 1, column: 0 } });

          }

          if (this.isSourcesContent()) this.setSourcesContent();
          if (this.root && this.previous().length > 0) this.applyPrevMaps();
          if (this.isAnnotation()) this.addAnnotation();

          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }

        path(file) {
          if (file.indexOf('<') === 0) return file;
          if (/^\w+:\/\//.test(file)) return file;
          if (this.mapOpts.absolute) return file;

          let from = this.opts.to ? dirname(this.opts.to) : '.';

          if (typeof this.mapOpts.annotation === 'string') {
            from = dirname(resolve(from, this.mapOpts.annotation));
          }

          file = relative(from, file);
          return file;
        }

        toUrl(path) {
          if (sep === '\\') {
            path = path.replace(/\\/g, '/');
          }
          return encodeURI(path).replace(/[#?]/g, encodeURIComponent);
        }

        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.mapOpts.absolute) {
            if (pathToFileURL) {
              return pathToFileURL(node.source.input.from).toString();
            } else {
              throw new Error(
              '`map.absolute` option is not available in this PostCSS build');

            }
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }

        generateString() {
          this.css = '';
          this.map = new SourceMapGenerator({ file: this.outputFile() });

          let line = 1;
          let column = 1;

          let noSource = '<no source>';
          let mapping = {
            source: '',
            generated: { line: 0, column: 0 },
            original: { line: 0, column: 0 } };


          let lines, last;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;

            if (node && type !== 'end') {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }

            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf('\n');
              column = str.length - last;
            } else {
              column += str.length;
            }

            if (node && type !== 'start') {
              let p = node.parent || { raws: {} };
              if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }

        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = '';
            this.stringify(this.root, i => {
              result += i;
            });
            return [result];
          }
        }}


      module.exports = MapGenerator;

    }, { "./input": 69, "path": undefined, "source-map-js": 2, "url": undefined }], 73: [function (require, module, exports) {
      'use strict';

      let MapGenerator = require('./map-generator');
      let stringify = require('./stringify');
      let warnOnce = require('./warn-once');
      let parse = require('./parse');
      const Result = require('./result');

      class NoWorkResult {
        constructor(processor, css, opts) {
          css = css.toString();
          this.stringified = false;

          this._processor = processor;
          this._css = css;
          this._opts = opts;
          this._map = undefined;
          let root;

          let str = stringify;
          this.result = new Result(this._processor, root, this._opts);
          this.result.css = css;

          let self = this;
          Object.defineProperty(this.result, 'root', {
            get() {
              return self.root;
            } });


          let map = new MapGenerator(str, root, this._opts, css);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          }
        }

        get [Symbol.toStringTag]() {
          return 'NoWorkResult';
        }

        get processor() {
          return this.result.processor;
        }

        get opts() {
          return this.result.opts;
        }

        get css() {
          return this.result.css;
        }

        get content() {
          return this.result.css;
        }

        get map() {
          return this.result.map;
        }

        get root() {
          if (this._root) {
            return this._root;
          }

          let root;
          let parser = parse;

          try {
            root = parser(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }

          if (this.error) {
            throw this.error;
          } else {
            this._root = root;
            return root;
          }
        }

        get messages() {
          return [];
        }

        warnings() {
          return [];
        }

        toString() {
          return this._css;
        }

        then(onFulfilled, onRejected) {
          if (process.env.NODE_ENV !== 'production') {
            if (!('from' in this._opts)) {
              warnOnce(
              'Without `from` option PostCSS could generate wrong source map ' +
              'and will not find Browserslist config. Set it to CSS file path ' +
              'or to `undefined` to prevent this warning.');

            }
          }

          return this.async().then(onFulfilled, onRejected);
        }

        catch(onRejected) {
          return this.async().catch(onRejected);
        }

        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }

        async() {
          if (this.error) return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }

        sync() {
          if (this.error) throw this.error;
          return this.result;
        }}


      module.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;

    }, { "./map-generator": 72, "./parse": 75, "./result": 80, "./stringify": 84, "./warn-once": 87 }], 74: [function (require, module, exports) {
      'use strict';

      let { isClean, my } = require('./symbols');
      let CssSyntaxError = require('./css-syntax-error');
      let Stringifier = require('./stringifier');
      let stringify = require('./stringify');

      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();

        for (let i in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i)) {
            /* c8 ignore next 2 */
            continue;
          }
          if (i === 'proxyCache') continue;
          let value = obj[i];
          let type = typeof value;

          if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
          } else if (i === 'source') {
            cloned[i] = value;
          } else if (Array.isArray(value)) {
            cloned[i] = value.map(j => cloneNode(j, cloned));
          } else {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
          }
        }

        return cloned;
      }

      class Node {
        constructor(defaults = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;

          for (let name in defaults) {
            if (name === 'nodes') {
              this.nodes = [];
              for (let node of defaults[name]) {
                if (typeof node.clone === 'function') {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults[name];
            }
          }
        }

        error(message, opts = {}) {
          if (this.source) {
            let { start, end } = this.rangeBy(opts);
            return this.source.input.error(
            message,
            { line: start.line, column: start.column },
            { line: end.line, column: end.column },
            opts);

          }
          return new CssSyntaxError(message);
        }

        warn(result, text, opts) {
          let data = { node: this };
          for (let i in opts) data[i] = opts[i];
          return result.warn(text, data);
        }

        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = undefined;
          return this;
        }

        toString(stringifier = stringify) {
          if (stringifier.stringify) stringifier = stringifier.stringify;
          let result = '';
          stringifier(this, i => {
            result += i;
          });
          return result;
        }

        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }

        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }

        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }

        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }

        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }

            if (!foundSelf) {
              this.remove();
            }
          }

          return this;
        }

        next() {
          if (!this.parent) return undefined;
          let index = this.parent.index(this);
          return this.parent.nodes[index + 1];
        }

        prev() {
          if (!this.parent) return undefined;
          let index = this.parent.index(this);
          return this.parent.nodes[index - 1];
        }

        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }

        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }

        root() {
          let result = this;
          while (result.parent && result.parent.type !== 'document') {
            result = result.parent;
          }
          return result;
        }

        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }

        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween) delete this.raws.between;
        }

        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || new Map();
          let inputsNextIndex = 0;

          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              /* c8 ignore next 2 */
              continue;
            }
            if (name === 'parent' || name === 'proxyCache') continue;
            let value = this[name];

            if (Array.isArray(value)) {
              fixed[name] = value.map(i => {
                if (typeof i === 'object' && i.toJSON) {
                  return i.toJSON(null, inputs);
                } else {
                  return i;
                }
              });
            } else if (typeof value === 'object' && value.toJSON) {
              fixed[name] = value.toJSON(null, inputs);
            } else if (name === 'source') {
              let inputId = inputs.get(value.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                inputId,
                start: value.start,
                end: value.end };

            } else {
              fixed[name] = value;
            }
          }

          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
          }

          return fixed;
        }

        positionInside(index) {
          let string = this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;

          for (let i = 0; i < index; i++) {
            if (string[i] === '\n') {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }

          return { line, column };
        }

        positionBy(opts) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index);
          } else if (opts.word) {
            let index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
          }
          return pos;
        }

        rangeBy(opts) {
          let start = {
            line: this.source.start.line,
            column: this.source.start.column };

          let end = this.source.end ?
          {
            line: this.source.end.line,
            column: this.source.end.column + 1 } :

          {
            line: start.line,
            column: start.column + 1 };


          if (opts.word) {
            let index = this.toString().indexOf(opts.word);
            if (index !== -1) {
              start = this.positionInside(index);
              end = this.positionInside(index + opts.word.length);
            }
          } else {
            if (opts.start) {
              start = {
                line: opts.start.line,
                column: opts.start.column };

            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }

            if (opts.end) {
              end = {
                line: opts.end.line,
                column: opts.end.column };

            } else if (opts.endIndex) {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }

          if (
          end.line < start.line ||
          end.line === start.line && end.column <= start.column)
          {
            end = { line: start.line, column: start.column + 1 };
          }

          return { start, end };
        }

        getProxyProcessor() {
          return {
            set(node, prop, value) {
              if (node[prop] === value) return true;
              node[prop] = value;
              if (
              prop === 'prop' ||
              prop === 'value' ||
              prop === 'name' ||
              prop === 'params' ||
              prop === 'important' ||
              /* c8 ignore next */
              prop === 'text')
              {
                node.markDirty();
              }
              return true;
            },

            get(node, prop) {
              if (prop === 'proxyOf') {
                return node;
              } else if (prop === 'root') {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            } };

        }

        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }

        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s = this.source;
            error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);

          }
          return error;
        }

        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }

        get proxyOf() {
          return this;
        }}


      module.exports = Node;
      Node.default = Node;

    }, { "./css-syntax-error": 65, "./stringifier": 83, "./stringify": 84, "./symbols": 85 }], 75: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');
      let Parser = require('./parser');
      let Input = require('./input');

      function parse(css, opts) {
        let input = new Input(css, opts);
        let parser = new Parser(input);
        try {
          parser.parse();
        } catch (e) {
          if (process.env.NODE_ENV !== 'production') {
            if (e.name === 'CssSyntaxError' && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e.message +=
                '\nYou tried to parse SCSS with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-scss parser';
              } else if (/\.sass/i.test(opts.from)) {
                e.message +=
                '\nYou tried to parse Sass with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-sass parser';
              } else if (/\.less$/i.test(opts.from)) {
                e.message +=
                '\nYou tried to parse Less with ' +
                'the standard CSS parser; ' +
                'try again with the postcss-less parser';
              }
            }
          }
          throw e;
        }

        return parser.root;
      }

      module.exports = parse;
      parse.default = parse;

      Container.registerParse(parse);

    }, { "./container": 64, "./input": 69, "./parser": 76 }], 76: [function (require, module, exports) {
      'use strict';

      let Declaration = require('./declaration');
      let tokenizer = require('./tokenize');
      let Comment = require('./comment');
      let AtRule = require('./at-rule');
      let Root = require('./root');
      let Rule = require('./rule');

      const SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true };


      function findLastWithPosition(tokens) {
        for (let i = tokens.length - 1; i >= 0; i--) {
          let token = tokens[i];
          let pos = token[3] || token[2];
          if (pos) return pos;
        }
      }

      class Parser {
        constructor(input) {
          this.input = input;

          this.root = new Root();
          this.current = this.root;
          this.spaces = '';
          this.semicolon = false;
          this.customProperty = false;

          this.createTokenizer();
          this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
        }

        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }

        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            switch (token[0]) {
              case 'space':
                this.spaces += token[1];
                break;

              case ';':
                this.freeSemicolon(token);
                break;

              case '}':
                this.end(token);
                break;

              case 'comment':
                this.comment(token);
                break;

              case 'at-word':
                this.atrule(token);
                break;

              case '{':
                this.emptyRule(token);
                break;

              default:
                this.other(token);
                break;}

          }
          this.endFile();
        }

        comment(token) {
          let node = new Comment();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);

          let text = token[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }

        emptyRule(token) {
          let node = new Rule();
          this.init(node, token[2]);
          node.selector = '';
          node.raws.between = '';
          this.current = node;
        }

        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith('--');

          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);

            if (type === '(' || type === '[') {
              if (!bracket) bracket = token;
              brackets.push(type === '(' ? ')' : ']');
            } else if (customProperty && colon && type === '{') {
              if (!bracket) bracket = token;
              brackets.push('}');
            } else if (brackets.length === 0) {
              if (type === ';') {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === '{') {
                this.rule(tokens);
                return;
              } else if (type === '}') {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ':') {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }

            token = this.tokenizer.nextToken();
          }

          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);

          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== 'space' && token !== 'comment') break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }

        rule(tokens) {
          tokens.pop();

          let node = new Rule();
          this.init(node, tokens[0][2]);

          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, 'selector', tokens);
          this.current = node;
        }

        decl(tokens, customProperty) {
          let node = new Declaration();
          this.init(node, tokens[0][2]);

          let last = tokens[tokens.length - 1];
          if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
          }

          node.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens));


          while (tokens[0][0] !== 'word') {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);

          node.prop = '';
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
              break;
            }
            node.prop += tokens.shift()[1];
          }

          node.raws.between = '';

          let token;
          while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === 'word' && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }

          if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }

          let firstSpaces = [];
          let next;
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            firstSpaces.push(tokens.shift());
          }

          this.precheckMissedSemicolon(tokens);

          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === '!important') {
              node.important = true;
              let string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== ' !important') node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === 'important') {
              let cache = tokens.slice(0);
              let str = '';
              for (let j = i; j > 0; j--) {
                let type = cache[j][0];
                if (str.trim().indexOf('!') === 0 && type !== 'space') {
                  break;
                }
                str = cache.pop()[1] + str;
              }
              if (str.trim().indexOf('!') === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache;
              }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
              break;
            }
          }

          let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');

          if (hasWord) {
            node.raws.between += firstSpaces.map(i => i[1]).join('');
            firstSpaces = [];
          }
          this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

          if (node.value.includes(':') && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }

        atrule(token) {
          let node = new AtRule();
          node.name = token[1].slice(1);
          if (node.name === '') {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);

          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];

          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];

            if (type === '(' || type === '[') {
              brackets.push(type === '(' ? ')' : ']');
            } else if (type === '{' && brackets.length > 0) {
              brackets.push('}');
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }

            if (brackets.length === 0) {
              if (type === ';') {
                node.source.end = this.getPosition(token[2]);
                this.semicolon = true;
                break;
              } else if (type === '{') {
                open = true;
                break;
              } else if (type === '}') {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === 'space') {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }

            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }

          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              this.spaces = node.raws.between;
              node.raws.between = '';
            }
          } else {
            node.raws.afterName = '';
            node.params = '';
          }

          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }

        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;

          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
          this.spaces = '';

          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }

        endFile() {
          if (this.current.parent) this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        }

        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = '';
            }
          }
        }

        // Helpers

        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            offset,
            line: pos.line,
            column: pos.col };

        }

        init(node, offset) {
          this.current.push(node);
          node.source = {
            start: this.getPosition(offset),
            input: this.input };

          node.raws.before = this.spaces;
          this.spaces = '';
          if (node.type !== 'comment') this.semicolon = false;
        }

        raw(node, prop, tokens, customProperty) {
          let token, type;
          let length = tokens.length;
          let value = '';
          let clean = true;
          let next, prev;

          for (let i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'space' && i === length - 1 && !customProperty) {
              clean = false;
            } else if (type === 'comment') {
              prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
              next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                if (value.slice(-1) === ',') {
                  clean = false;
                } else {
                  value += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i) => all + i[1], '');
            node.raws[prop] = { value, raw };
          }
          node[prop] = value;
        }

        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = '';
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }

        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = '';
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }

        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = '';
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }

        stringFrom(tokens, from) {
          let result = '';
          for (let i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }

        colon(tokens) {
          let brackets = 0;
          let token, type, prev;
          for (let [i, element] of tokens.entries()) {
            token = element;
            type = token[0];

            if (type === '(') {
              brackets += 1;
            }
            if (type === ')') {
              brackets -= 1;
            }
            if (brackets === 0 && type === ':') {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === 'word' && prev[1] === 'progid') {
                continue;
              } else {
                return i;
              }
            }

            prev = token;
          }
          return false;
        }

        // Errors

        unclosedBracket(bracket) {
          throw this.input.error(
          'Unclosed bracket',
          { offset: bracket[2] },
          { offset: bracket[2] + 1 });

        }

        unknownWord(tokens) {
          throw this.input.error(
          'Unknown word',
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length });

        }

        unexpectedClose(token) {
          throw this.input.error(
          'Unexpected }',
          { offset: token[2] },
          { offset: token[2] + 1 });

        }

        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error('Unclosed block', pos.line, pos.column);
        }

        doubleColon(token) {
          throw this.input.error(
          'Double colon',
          { offset: token[2] },
          { offset: token[2] + token[1].length });

        }

        unnamedAtrule(node, token) {
          throw this.input.error(
          'At-rule without name',
          { offset: token[2] },
          { offset: token[2] + token[1].length });

        }

        precheckMissedSemicolon() /* tokens */{
          // Hook for Safe Parser
        }

        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;

          let founded = 0;
          let token;
          for (let j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
              founded += 1;
              if (founded === 2) break;
            }
          }
          // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
          // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
          // And because we need it after that one we do +1 to get the next one.
          throw this.input.error(
          'Missed semicolon',
          token[0] === 'word' ? token[3] + 1 : token[2]);

        }}


      module.exports = Parser;

    }, { "./at-rule": 62, "./comment": 63, "./declaration": 66, "./root": 81, "./rule": 82, "./tokenize": 86 }], 77: [function (require, module, exports) {
      'use strict';

      let CssSyntaxError = require('./css-syntax-error');
      let Declaration = require('./declaration');
      let LazyResult = require('./lazy-result');
      let Container = require('./container');
      let Processor = require('./processor');
      let stringify = require('./stringify');
      let fromJSON = require('./fromJSON');
      let Document = require('./document');
      let Warning = require('./warning');
      let Comment = require('./comment');
      let AtRule = require('./at-rule');
      let Result = require('./result.js');
      let Input = require('./input');
      let parse = require('./parse');
      let list = require('./list');
      let Rule = require('./rule');
      let Root = require('./root');
      let Node = require('./node');

      function postcss(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor(plugins);
      }

      postcss.plugin = function plugin(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          // eslint-disable-next-line no-console
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            // eslint-disable-next-line no-console
            console.warn(
            name +
            ': postcss.plugin was deprecated. Migration guide:\n' +
            'https://evilmartians.com/chronicles/postcss-8-plugin-migration');

            if (process.env.LANG && process.env.LANG.startsWith('cn')) {
              /* c8 ignore next 7 */
              // eslint-disable-next-line no-console
              console.warn(
              name +
              ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
              'https://www.w3ctech.com/topic/2226');

            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor().version;
          return transformer;
        }

        let cache;
        Object.defineProperty(creator, 'postcss', {
          get() {
            if (!cache) cache = creator();
            return cache;
          } });


        creator.process = function (css, processOpts, pluginOpts) {
          return postcss([creator(pluginOpts)]).process(css, processOpts);
        };

        return creator;
      };

      postcss.stringify = stringify;
      postcss.parse = parse;
      postcss.fromJSON = fromJSON;
      postcss.list = list;

      postcss.comment = defaults => new Comment(defaults);
      postcss.atRule = defaults => new AtRule(defaults);
      postcss.decl = defaults => new Declaration(defaults);
      postcss.rule = defaults => new Rule(defaults);
      postcss.root = defaults => new Root(defaults);
      postcss.document = defaults => new Document(defaults);

      postcss.CssSyntaxError = CssSyntaxError;
      postcss.Declaration = Declaration;
      postcss.Container = Container;
      postcss.Processor = Processor;
      postcss.Document = Document;
      postcss.Comment = Comment;
      postcss.Warning = Warning;
      postcss.AtRule = AtRule;
      postcss.Result = Result;
      postcss.Input = Input;
      postcss.Rule = Rule;
      postcss.Root = Root;
      postcss.Node = Node;

      LazyResult.registerPostcss(postcss);

      module.exports = postcss;
      postcss.default = postcss;

    }, { "./at-rule": 62, "./comment": 63, "./container": 64, "./css-syntax-error": 65, "./declaration": 66, "./document": 67, "./fromJSON": 68, "./input": 69, "./lazy-result": 70, "./list": 71, "./node": 74, "./parse": 75, "./processor": 79, "./result.js": 80, "./root": 81, "./rule": 82, "./stringify": 84, "./warning": 88 }], 78: [function (require, module, exports) {
      'use strict';

      let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
      let { existsSync, readFileSync } = require('fs');
      let { dirname, join } = require('path');

      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, 'base64').toString();
        } else {
          /* c8 ignore next 2 */
          return window.atob(str);
        }
      }

      class PreviousMap {
        constructor(css, opts) {
          if (opts.map === false) return;
          this.loadAnnotation(css);
          this.inline = this.startWith(this.annotation, 'data:');

          let prev = opts.map ? opts.map.prev : undefined;
          let text = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile) this.root = dirname(this.mapFile);
          if (text) this.text = text;
        }

        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }

        withContent() {
          return !!(
          this.consumer().sourcesContent &&
          this.consumer().sourcesContent.length > 0);

        }

        startWith(string, start) {
          if (!string) return false;
          return string.substr(0, start.length) === start;
        }

        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim();
        }

        loadAnnotation(css) {
          let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
          if (!comments) return;

          // sourceMappingURLs from comments, strings, etc.
          let start = css.lastIndexOf(comments.pop());
          let end = css.indexOf('*/', start);

          if (start > -1 && end > -1) {
            // Locate the last sourceMappingURL to avoid pickin
            this.annotation = this.getAnnotationURL(css.substring(start, end));
          }
        }

        decodeInline(text) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;

          if (charsetUri.test(text) || uri.test(text)) {
            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
          }

          if (baseCharsetUri.test(text) || baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
          }

          let encoding = text.match(/data:application\/json;([^,]+),/)[1];
          throw new Error('Unsupported source map encoding ' + encoding);
        }

        loadFile(path) {
          this.root = dirname(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, 'utf-8').toString().trim();
          }
        }

        loadMap(file, prev) {
          if (prev === false) return false;

          if (prev) {
            if (typeof prev === 'string') {
              return prev;
            } else if (typeof prev === 'function') {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                  'Unable to load previous source map: ' + prevPath.toString());

                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
              'Unsupported previous source map format: ' + prev.toString());

            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file) map = join(dirname(file), map);
            return this.loadFile(map);
          }
        }

        isMap(map) {
          if (typeof map !== 'object') return false;
          return (
            typeof map.mappings === 'string' ||
            typeof map._mappings === 'string' ||
            Array.isArray(map.sections));

        }}


      module.exports = PreviousMap;
      PreviousMap.default = PreviousMap;

    }, { "fs": undefined, "path": undefined, "source-map-js": 2 }], 79: [function (require, module, exports) {
      'use strict';

      let NoWorkResult = require('./no-work-result');
      let LazyResult = require('./lazy-result');
      let Document = require('./document');
      let Root = require('./root');

      class Processor {
        constructor(plugins = []) {
          this.version = '8.4.14';
          this.plugins = this.normalize(plugins);
        }

        use(plugin) {
          this.plugins = this.plugins.concat(this.normalize([plugin]));
          return this;
        }

        process(css, opts = {}) {
          if (
          this.plugins.length === 0 &&
          typeof opts.parser === 'undefined' &&
          typeof opts.stringifier === 'undefined' &&
          typeof opts.syntax === 'undefined')
          {
            return new NoWorkResult(this, css, opts);
          } else {
            return new LazyResult(this, css, opts);
          }
        }

        normalize(plugins) {
          let normalized = [];
          for (let i of plugins) {
            if (i.postcss === true) {
              i = i();
            } else if (i.postcss) {
              i = i.postcss;
            }

            if (typeof i === 'object' && Array.isArray(i.plugins)) {
              normalized = normalized.concat(i.plugins);
            } else if (typeof i === 'object' && i.postcssPlugin) {
              normalized.push(i);
            } else if (typeof i === 'function') {
              normalized.push(i);
            } else if (typeof i === 'object' && (i.parse || i.stringify)) {
              if (process.env.NODE_ENV !== 'production') {
                throw new Error(
                'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
                'one of the syntax/parser/stringifier options as outlined ' +
                'in your PostCSS runner documentation.');

              }
            } else {
              throw new Error(i + ' is not a PostCSS plugin');
            }
          }
          return normalized;
        }}


      module.exports = Processor;
      Processor.default = Processor;

      Root.registerProcessor(Processor);
      Document.registerProcessor(Processor);

    }, { "./document": 67, "./lazy-result": 70, "./no-work-result": 73, "./root": 81 }], 80: [function (require, module, exports) {
      'use strict';

      let Warning = require('./warning');

      class Result {
        constructor(processor, root, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root;
          this.opts = opts;
          this.css = undefined;
          this.map = undefined;
        }

        toString() {
          return this.css;
        }

        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }

          let warning = new Warning(text, opts);
          this.messages.push(warning);

          return warning;
        }

        warnings() {
          return this.messages.filter(i => i.type === 'warning');
        }

        get content() {
          return this.css;
        }}


      module.exports = Result;
      Result.default = Result;

    }, { "./warning": 88 }], 81: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      let LazyResult, Processor;

      class Root extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'root';
          if (!this.nodes) this.nodes = [];
        }

        removeChild(child, ignore) {
          let index = this.index(child);

          if (!ignore && index === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index].raws.before;
          }

          return super.removeChild(child);
        }

        normalize(child, sample, type) {
          let nodes = super.normalize(child);

          if (sample) {
            if (type === 'prepend') {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }

          return nodes;
        }

        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }}


      Root.registerLazyResult = dependant => {
        LazyResult = dependant;
      };

      Root.registerProcessor = dependant => {
        Processor = dependant;
      };

      module.exports = Root;
      Root.default = Root;

    }, { "./container": 64 }], 82: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');
      let list = require('./list');

      class Rule extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'rule';
          if (!this.nodes) this.nodes = [];
        }

        get selectors() {
          return list.comma(this.selector);
        }

        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
          this.selector = values.join(sep);
        }}


      module.exports = Rule;
      Rule.default = Rule;

      Container.registerRule(Rule);

    }, { "./container": 64, "./list": 71 }], 83: [function (require, module, exports) {
      'use strict';

      const DEFAULT_RAW = {
        colon: ': ',
        indent: '    ',
        beforeDecl: '\n',
        beforeRule: '\n',
        beforeOpen: ' ',
        beforeClose: '\n',
        beforeComment: '\n',
        after: '\n',
        emptyBody: '',
        commentLeft: ' ',
        commentRight: ' ',
        semicolon: false };


      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }

      class Stringifier {
        constructor(builder) {
          this.builder = builder;
        }

        stringify(node, semicolon) {
          /* c8 ignore start */
          if (!this[node.type]) {
            throw new Error(
            'Unknown AST node type ' +
            node.type +
            '. ' +
            'Maybe you need to change PostCSS stringifier.');

          }
          /* c8 ignore stop */
          this[node.type](node, semicolon);
        }

        document(node) {
          this.body(node);
        }

        root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        }

        comment(node) {
          let left = this.raw(node, 'left', 'commentLeft');
          let right = this.raw(node, 'right', 'commentRight');
          this.builder('/*' + left + node.text + right + '*/', node);
        }

        decl(node, semicolon) {
          let between = this.raw(node, 'between', 'colon');
          let string = node.prop + between + this.rawValue(node, 'value');

          if (node.important) {
            string += node.raws.important || ' !important';
          }

          if (semicolon) string += ';';
          this.builder(string, node);
        }

        rule(node) {
          this.block(node, this.rawValue(node, 'selector'));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, 'end');
          }
        }

        atrule(node, semicolon) {
          let name = '@' + node.name;
          let params = node.params ? this.rawValue(node, 'params') : '';

          if (typeof node.raws.afterName !== 'undefined') {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || '') + (semicolon ? ';' : '');
            this.builder(name + params + end, node);
          }
        }

        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== 'comment') break;
            last -= 1;
          }

          let semicolon = this.raw(node, 'semicolon');
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            let before = this.raw(child, 'before');
            if (before) this.builder(before);
            this.stringify(child, last !== i || semicolon);
          }
        }

        block(node, start) {
          let between = this.raw(node, 'between', 'beforeOpen');
          this.builder(start + between + '{', node, 'start');

          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, 'after');
          } else {
            after = this.raw(node, 'after', 'emptyBody');
          }

          if (after) this.builder(after);
          this.builder('}', node, 'end');
        }

        raw(node, own, detect) {
          let value;
          if (!detect) detect = own;

          // Already had
          if (own) {
            value = node.raws[own];
            if (typeof value !== 'undefined') return value;
          }

          let parent = node.parent;

          if (detect === 'before') {
            // Hack for first rule in CSS
            if (!parent || parent.type === 'root' && parent.first === node) {
              return '';
            }

            // `root` nodes in `document` should use only their own raws
            if (parent && parent.type === 'document') {
              return '';
            }
          }

          // Floating child without parent
          if (!parent) return DEFAULT_RAW[detect];

          // Detect style by other nodes
          let root = node.root();
          if (!root.rawCache) root.rawCache = {};
          if (typeof root.rawCache[detect] !== 'undefined') {
            return root.rawCache[detect];
          }

          if (detect === 'before' || detect === 'after') {
            return this.beforeAfter(node, detect);
          } else {
            let method = 'raw' + capitalize(detect);
            if (this[method]) {
              value = this[method](root, node);
            } else {
              root.walk(i => {
                value = i.raws[own];
                if (typeof value !== 'undefined') return false;
              });
            }
          }

          if (typeof value === 'undefined') value = DEFAULT_RAW[detect];

          root.rawCache[detect] = value;
          return value;
        }

        rawSemicolon(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length && i.last.type === 'decl') {
              value = i.raws.semicolon;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawEmptyBody(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length === 0) {
              value = i.raws.after;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawIndent(root) {
          if (root.raws.indent) return root.raws.indent;
          let value;
          root.walk(i => {
            let p = i.parent;
            if (p && p !== root && p.parent && p.parent === root) {
              if (typeof i.raws.before !== 'undefined') {
                let parts = i.raws.before.split('\n');
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, '');
                return false;
              }
            }
          });
          return value;
        }

        rawBeforeComment(root, node) {
          let value;
          root.walkComments(i => {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false;
            }
          });
          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (value) {
            value = value.replace(/\S/g, '');
          }
          return value;
        }

        rawBeforeDecl(root, node) {
          let value;
          root.walkDecls(i => {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false;
            }
          });
          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeRule');
          } else if (value) {
            value = value.replace(/\S/g, '');
          }
          return value;
        }

        rawBeforeRule(root) {
          let value;
          root.walk(i => {
            if (i.nodes && (i.parent !== root || root.first !== i)) {
              if (typeof i.raws.before !== 'undefined') {
                value = i.raws.before;
                if (value.includes('\n')) {
                  value = value.replace(/[^\n]+$/, '');
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, '');
          return value;
        }

        rawBeforeClose(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== 'undefined') {
                value = i.raws.after;
                if (value.includes('\n')) {
                  value = value.replace(/[^\n]+$/, '');
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, '');
          return value;
        }

        rawBeforeOpen(root) {
          let value;
          root.walk(i => {
            if (i.type !== 'decl') {
              value = i.raws.between;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawColon(root) {
          let value;
          root.walkDecls(i => {
            if (typeof i.raws.between !== 'undefined') {
              value = i.raws.between.replace(/[^\s:]/g, '');
              return false;
            }
          });
          return value;
        }

        beforeAfter(node, detect) {
          let value;
          if (node.type === 'decl') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (node.type === 'comment') {
            value = this.raw(node, null, 'beforeComment');
          } else if (detect === 'before') {
            value = this.raw(node, null, 'beforeRule');
          } else {
            value = this.raw(node, null, 'beforeClose');
          }

          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== 'root') {
            depth += 1;
            buf = buf.parent;
          }

          if (value.includes('\n')) {
            let indent = this.raw(node, null, 'indent');
            if (indent.length) {
              for (let step = 0; step < depth; step++) value += indent;
            }
          }

          return value;
        }

        rawValue(node, prop) {
          let value = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }

          return value;
        }}


      module.exports = Stringifier;
      Stringifier.default = Stringifier;

    }, {}], 84: [function (require, module, exports) {
      'use strict';

      let Stringifier = require('./stringifier');

      function stringify(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }

      module.exports = stringify;
      stringify.default = stringify;

    }, { "./stringifier": 83 }], 85: [function (require, module, exports) {
      'use strict';

      module.exports.isClean = Symbol('isClean');

      module.exports.my = Symbol('my');

    }, {}], 86: [function (require, module, exports) {
      'use strict';

      const SINGLE_QUOTE = "'".charCodeAt(0);
      const DOUBLE_QUOTE = '"'.charCodeAt(0);
      const BACKSLASH = '\\'.charCodeAt(0);
      const SLASH = '/'.charCodeAt(0);
      const NEWLINE = '\n'.charCodeAt(0);
      const SPACE = ' '.charCodeAt(0);
      const FEED = '\f'.charCodeAt(0);
      const TAB = '\t'.charCodeAt(0);
      const CR = '\r'.charCodeAt(0);
      const OPEN_SQUARE = '['.charCodeAt(0);
      const CLOSE_SQUARE = ']'.charCodeAt(0);
      const OPEN_PARENTHESES = '('.charCodeAt(0);
      const CLOSE_PARENTHESES = ')'.charCodeAt(0);
      const OPEN_CURLY = '{'.charCodeAt(0);
      const CLOSE_CURLY = '}'.charCodeAt(0);
      const SEMICOLON = ';'.charCodeAt(0);
      const ASTERISK = '*'.charCodeAt(0);
      const COLON = ':'.charCodeAt(0);
      const AT = '@'.charCodeAt(0);

      const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      const RE_BAD_BRACKET = /.[\n"'(/\\]/;
      const RE_HEX_ESCAPE = /[\da-f]/i;

      module.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;

        let code, next, quote, content, escape;
        let escaped, escapePos, prev, n, currentToken;

        let length = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];

        function position() {
          return pos;
        }

        function unclosed(what) {
          throw input.error('Unclosed ' + what, pos);
        }

        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }

        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length) return;

          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;

          code = css.charCodeAt(pos);

          switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED:{
                next = pos;
                do {
                  next += 1;
                  code = css.charCodeAt(next);
                } while (
                code === SPACE ||
                code === NEWLINE ||
                code === TAB ||
                code === CR ||
                code === FEED);


                currentToken = ['space', css.slice(pos, next)];
                pos = next - 1;
                break;
              }

            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES:{
                let controlChar = String.fromCharCode(code);
                currentToken = [controlChar, controlChar, pos];
                break;
              }

            case OPEN_PARENTHESES:{
                prev = buffer.length ? buffer.pop()[1] : '';
                n = css.charCodeAt(pos + 1);
                if (
                prev === 'url' &&
                n !== SINGLE_QUOTE &&
                n !== DOUBLE_QUOTE &&
                n !== SPACE &&
                n !== NEWLINE &&
                n !== TAB &&
                n !== FEED &&
                n !== CR)
                {
                  next = pos;
                  do {
                    escaped = false;
                    next = css.indexOf(')', next + 1);
                    if (next === -1) {
                      if (ignore || ignoreUnclosed) {
                        next = pos;
                        break;
                      } else {
                        unclosed('bracket');
                      }
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                      escapePos -= 1;
                      escaped = !escaped;
                    }
                  } while (escaped);

                  currentToken = ['brackets', css.slice(pos, next + 1), pos, next];

                  pos = next;
                } else {
                  next = css.indexOf(')', pos + 1);
                  content = css.slice(pos, next + 1);

                  if (next === -1 || RE_BAD_BRACKET.test(content)) {
                    currentToken = ['(', '(', pos];
                  } else {
                    currentToken = ['brackets', content, pos, next];
                    pos = next;
                  }
                }

                break;
              }

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:{
                quote = code === SINGLE_QUOTE ? "'" : '"';
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(quote, next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos + 1;
                      break;
                    } else {
                      unclosed('string');
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);

                currentToken = ['string', css.slice(pos, next + 1), pos, next];
                pos = next;
                break;
              }

            case AT:{
                RE_AT_END.lastIndex = pos + 1;
                RE_AT_END.test(css);
                if (RE_AT_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_AT_END.lastIndex - 2;
                }

                currentToken = ['at-word', css.slice(pos, next + 1), pos, next];

                pos = next;
                break;
              }

            case BACKSLASH:{
                next = pos;
                escape = true;
                while (css.charCodeAt(next + 1) === BACKSLASH) {
                  next += 1;
                  escape = !escape;
                }
                code = css.charCodeAt(next + 1);
                if (
                escape &&
                code !== SLASH &&
                code !== SPACE &&
                code !== NEWLINE &&
                code !== TAB &&
                code !== CR &&
                code !== FEED)
                {
                  next += 1;
                  if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                    while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                      next += 1;
                    }
                    if (css.charCodeAt(next + 1) === SPACE) {
                      next += 1;
                    }
                  }
                }

                currentToken = ['word', css.slice(pos, next + 1), pos, next];

                pos = next;
                break;
              }

            default:{
                if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                  next = css.indexOf('*/', pos + 2) + 1;
                  if (next === 0) {
                    if (ignore || ignoreUnclosed) {
                      next = css.length;
                    } else {
                      unclosed('comment');
                    }
                  }

                  currentToken = ['comment', css.slice(pos, next + 1), pos, next];
                  pos = next;
                } else {
                  RE_WORD_END.lastIndex = pos + 1;
                  RE_WORD_END.test(css);
                  if (RE_WORD_END.lastIndex === 0) {
                    next = css.length - 1;
                  } else {
                    next = RE_WORD_END.lastIndex - 2;
                  }

                  currentToken = ['word', css.slice(pos, next + 1), pos, next];
                  buffer.push(currentToken);
                  pos = next;
                }

                break;
              }}


          pos++;
          return currentToken;
        }

        function back(token) {
          returned.push(token);
        }

        return {
          back,
          nextToken,
          endOfFile,
          position };

      };

    }, {}], 87: [function (require, module, exports) {
      /* eslint-disable no-console */
      'use strict';

      let printed = {};

      module.exports = function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;

        if (typeof console !== 'undefined' && console.warn) {
          console.warn(message);
        }
      };

    }, {}], 88: [function (require, module, exports) {
      'use strict';

      class Warning {
        constructor(text, opts = {}) {
          this.type = 'warning';
          this.text = text;

          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }

          for (let opt in opts) this[opt] = opts[opt];
        }

        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              plugin: this.plugin,
              index: this.index,
              word: this.word }).
            message;
          }

          if (this.plugin) {
            return this.plugin + ': ' + this.text;
          }

          return this.text;
        }}


      module.exports = Warning;
      Warning.default = Warning;

    }, {}], 89: [function (require, module, exports) {
      var SKIP = 'skip';
      var CHECK = 'check';
      var ONLY = 'only';

      module.exports = function (options, callback) {
        var source = options.source;
        var target = options.target;

        var skipComments = options.comments ? options.comments === SKIP : true;
        var skipStrings = options.strings ? options.strings === SKIP : true;
        var skipFunctionNames = options.functionNames ? options.functionNames === SKIP : true;
        var skipFunctionArguments = options.functionArguments === SKIP;
        var skipParentheticals = options.parentheticals === SKIP;

        var onceOptionUsed = false;
        Object.keys(options).forEach(function (key) {
          if (options[key] !== ONLY) return;
          if (!onceOptionUsed) {
            onceOptionUsed = true;
          } else {
            throw new Error('Only one syntax feature option can be the "only" one to check');
          }
        });

        var onlyComments = options.comments === ONLY;
        var onlyStrings = options.strings === ONLY;
        var onlyFunctionNames = options.functionNames === ONLY;
        var onlyFunctionArguments = options.functionArguments === ONLY;
        var onlyParentheticals = options.parentheticals === ONLY;

        var insideString = false;
        var insideComment = false;
        var insideSingleLineComment = false;
        var insideParens = false;
        var insideFunctionArguments = false;
        var openingParenCount = 0;
        var matchCount = 0;
        var openingQuote;

        var targetIsArray = Array.isArray(target);

        // If the target is just a string, it is easy to check whether
        // some index of the source matches it.
        // If the target is an array of strings, though, we have to
        // check whether some index of the source matches *any* of
        // those target strings (stopping after the first match).
        var getMatch = function () {
          if (!targetIsArray) {
            return getMatchBase.bind(null, target);
          }
          return function (index) {
            for (var ti = 0, tl = target.length; ti < tl; ti++) {
              var checkResult = getMatchBase(target[ti], index);
              if (checkResult) return checkResult;
            }
            return false;
          };
        }();

        function getMatchBase(targetString, index) {
          var targetStringLength = targetString.length;

          // Target is a single character
          if (targetStringLength === 1 && source[index] !== targetString) return false;

          // Target is multiple characters
          if (source.substr(index, targetStringLength) !== targetString) return false;

          return {
            insideParens: insideParens,
            insideFunctionArguments: insideFunctionArguments,
            insideComment: insideComment,
            insideString: insideString,
            startIndex: index,
            endIndex: index + targetStringLength,
            target: targetString };

        }

        for (var i = 0, l = source.length; i < l; i++) {
          var currentChar = source[i];

          // Register the beginning of a comment
          if (
          !insideString && !insideComment &&
          currentChar === "/" &&
          source[i - 1] !== "\\" // escaping
          ) {
              // standard comments
              if (source[i + 1] === "*") {
                insideComment = true;
                continue;
              }
              // single-line comments
              if (source[i + 1] === "/") {
                insideComment = true;
                insideSingleLineComment = true;
                continue;
              }
            }

          if (insideComment) {
            // Register the end of a standard comment
            if (
            !insideSingleLineComment &&
            currentChar === "*" &&
            source[i - 1] !== "\\" // escaping
            && source[i + 1] === "/" &&
            source[i - 1] !== "/" // don't end if it's /*/
            ) {
                insideComment = false;
                continue;
              }

            // Register the end of a single-line comment
            if (
            insideSingleLineComment &&
            currentChar === "\n")
            {
              insideComment = false;
              insideSingleLineComment = false;
            }

            if (skipComments) continue;
          }

          // Register the beginning of a string
          if (!insideComment && !insideString && (currentChar === "\"" || currentChar === "'")) {
            if (source[i - 1] === "\\") continue; // escaping

            openingQuote = currentChar;
            insideString = true;

            // For string-quotes rule
            if (target === currentChar) handleMatch(getMatch(i));
            continue;
          }

          if (insideString) {
            // Register the end of a string
            if (currentChar === openingQuote) {
              if (source[i - 1] === "\\") continue; // escaping
              insideString = false;
              continue;
            }

            if (skipStrings) continue;
          }

          // Register the beginning of parens/functions
          if (!insideString && !insideComment && currentChar === "(") {
            // Keep track of opening parentheticals so that we
            // know when the outermost function (possibly
            // containing nested functions) is closing
            openingParenCount++;

            insideParens = true;
            // Only inside a function if there is a function name
            // before the opening paren
            if (/[a-zA-Z]/.test(source[i - 1])) {
              insideFunctionArguments = true;
            }

            if (target === "(") handleMatch(getMatch(i));
            continue;
          }

          if (insideParens) {
            // Register the end of a function
            if (currentChar === ")") {
              openingParenCount--;
              // Do this here so the match is still technically inside a function
              if (target === ")") handleMatch(getMatch(i));
              if (openingParenCount === 0) {
                insideParens = false;
                insideFunctionArguments = false;
              }
              continue;
            }
          }

          var isFunctionName = /^[a-zA-Z]*\(/.test(source.slice(i));
          if (skipFunctionNames && isFunctionName) continue;
          if (onlyFunctionNames && !isFunctionName) continue;

          var match = getMatch(i);

          if (!match) continue;
          handleMatch(match);
          if (options.once) return;
        }

        function handleMatch(match) {
          if (onlyParentheticals && !insideParens) return;
          if (skipParentheticals && insideParens) return;
          if (onlyFunctionArguments && !insideFunctionArguments) return;
          if (skipFunctionArguments && insideFunctionArguments) return;
          if (onlyStrings && !insideString) return;
          if (onlyComments && !insideComment) return;
          matchCount++;
          callback(match, matchCount);
        }
      };

    }, {}], 90: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('./utils/isStandardSyntaxComment');
      const { assert, assertNumber, assertString } = require('./utils/validateTypes');

      const COMMAND_PREFIX = 'stylelint-';
      const disableCommand = `${COMMAND_PREFIX}disable`;
      const enableCommand = `${COMMAND_PREFIX}enable`;
      const disableLineCommand = `${COMMAND_PREFIX}disable-line`;
      const disableNextLineCommand = `${COMMAND_PREFIX}disable-next-line`;
      const ALL_RULES = 'all';

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('postcss').Root} PostcssRoot */
      /** @typedef {import('postcss').Document} PostcssDocument */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */

      /**
       * @param {PostcssComment} comment
       * @param {number} start
       * @param {boolean} strictStart
       * @param {string|undefined} description
       * @param {number} [end]
       * @param {boolean} [strictEnd]
       * @returns {DisabledRange}
       */
      function createDisableRange(comment, start, strictStart, description, end, strictEnd) {
        return {
          comment,
          start,
          end: end || undefined,
          strictStart,
          strictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,
          description };

      }

      /**
       * Run it like a PostCSS plugin
       * @param {PostcssRoot | PostcssDocument} root
       * @param {PostcssResult} result
       * @returns {PostcssResult}
       */
      module.exports = function assignDisabledRanges(root, result) {
        result.stylelint = result.stylelint || {
          disabledRanges: {},
          ruleSeverities: {},
          customMessages: {},
          ruleMetadata: {} };


        /**
         * Most of the functions below work via side effects mutating this object
         * @type {DisabledRangeObject & { all: DisabledRange[] }}
         */
        const disabledRanges = {
          [ALL_RULES]: [] };


        result.stylelint.disabledRanges = disabledRanges;

        // Work around postcss/postcss-scss#109 by merging adjacent `//` comments
        // into a single node before passing to `checkComment`.

        /** @type {PostcssComment?} */
        let inlineEnd;

        root.walkComments(comment => {
          if (inlineEnd) {
            // Ignore comments already processed by grouping with a previous one.
            if (inlineEnd === comment) inlineEnd = null;

            return;
          }

          const nextComment = comment.next();

          // If any of these conditions are not met, do not merge comments.
          if (
          !(
          !isStandardSyntaxComment(comment) &&
          isStylelintCommand(comment) &&
          nextComment &&
          nextComment.type === 'comment' && (
          comment.text.includes('--') || nextComment.text.startsWith('--'))))

          {
            checkComment(comment);

            return;
          }

          let lastLine = comment.source && comment.source.end && comment.source.end.line || 0;
          const fullComment = comment.clone();

          let current = nextComment;

          while (!isStandardSyntaxComment(current) && !isStylelintCommand(current)) {
            const currentLine = current.source && current.source.end && current.source.end.line || 0;

            if (lastLine + 1 !== currentLine) break;

            fullComment.text += `\n${current.text}`;

            if (fullComment.source && current.source) {
              fullComment.source.end = current.source.end;
            }

            inlineEnd = current;
            const next = current.next();

            if (!next || next.type !== 'comment') break;

            current = next;
            lastLine = currentLine;
          }

          checkComment(fullComment);
        });

        return result;

        /**
         * @param {PostcssComment} comment
         */
        function isStylelintCommand(comment) {
          return comment.text.startsWith(disableCommand) || comment.text.startsWith(enableCommand);
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableLineCommand(comment) {
          if (comment.source && comment.source.start) {
            const line = comment.source.start.line;
            const description = getDescription(comment.text);

            for (const ruleName of getCommandRules(disableLineCommand, comment.text)) {
              disableLine(comment, line, ruleName, description);
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableNextLineCommand(comment) {
          if (comment.source && comment.source.end) {
            const line = comment.source.end.line;
            const description = getDescription(comment.text);

            for (const ruleName of getCommandRules(disableNextLineCommand, comment.text)) {
              disableLine(comment, line + 1, ruleName, description);
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {string|undefined} description
         */
        function disableLine(comment, line, ruleName, description) {
          if (ruleIsDisabled(ALL_RULES)) {
            throw comment.error('All rules have already been disabled', {
              plugin: 'stylelint' });

          }

          if (ruleName === ALL_RULES) {
            for (const disabledRuleName of Object.keys(disabledRanges)) {
              if (ruleIsDisabled(disabledRuleName)) continue;

              const strict = disabledRuleName === ALL_RULES;

              startDisabledRange(comment, line, disabledRuleName, strict, description);
              endDisabledRange(line, disabledRuleName, strict);
            }
          } else {
            if (ruleIsDisabled(ruleName)) {
              throw comment.error(`"${ruleName}" has already been disabled`, {
                plugin: 'stylelint' });

            }

            startDisabledRange(comment, line, ruleName, true, description);
            endDisabledRange(line, ruleName, true);
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableCommand(comment) {
          const description = getDescription(comment.text);

          for (const ruleToDisable of getCommandRules(disableCommand, comment.text)) {
            const isAllRules = ruleToDisable === ALL_RULES;

            if (ruleIsDisabled(ruleToDisable)) {
              throw comment.error(
              isAllRules ?
              'All rules have already been disabled' :
              `"${ruleToDisable}" has already been disabled`,
              {
                plugin: 'stylelint' });


            }

            if (comment.source && comment.source.start) {
              const line = comment.source.start.line;

              if (isAllRules) {
                for (const ruleName of Object.keys(disabledRanges)) {
                  startDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);
                }
              } else {
                startDisabledRange(comment, line, ruleToDisable, true, description);
              }
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processEnableCommand(comment) {
          for (const ruleToEnable of getCommandRules(enableCommand, comment.text)) {
            // need fallback if endLine will be undefined
            const endLine = comment.source && comment.source.end && comment.source.end.line;

            assertNumber(endLine);

            if (ruleToEnable === ALL_RULES) {
              if (
              Object.values(disabledRanges).every(ranges => {
                if (ranges.length === 0) return true;

                const lastRange = ranges[ranges.length - 1];

                return lastRange && typeof lastRange.end === 'number';
              }))
              {
                throw comment.error('No rules have been disabled', {
                  plugin: 'stylelint' });

              }

              for (const [ruleName, ranges] of Object.entries(disabledRanges)) {
                const lastRange = ranges[ranges.length - 1];

                if (!lastRange || !lastRange.end) {
                  endDisabledRange(endLine, ruleName, ruleName === ALL_RULES);
                }
              }

              continue;
            }

            if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {
              // Get a starting point from the where all rules were disabled
              disabledRanges[ruleToEnable] = disabledRanges[ALL_RULES].map(
              ({ start, end, description }) =>
              createDisableRange(comment, start, false, description, end, false));


              endDisabledRange(endLine, ruleToEnable, true);

              continue;
            }

            if (ruleIsDisabled(ruleToEnable)) {
              endDisabledRange(endLine, ruleToEnable, true);

              continue;
            }

            throw comment.error(`"${ruleToEnable}" has not been disabled`, {
              plugin: 'stylelint' });

          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function checkComment(comment) {
          const text = comment.text;

          // Ignore comments that are not relevant commands

          if (text.indexOf(COMMAND_PREFIX) !== 0) {
            return;
          }

          if (text.startsWith(disableLineCommand)) {
            processDisableLineCommand(comment);
          } else if (text.startsWith(disableNextLineCommand)) {
            processDisableNextLineCommand(comment);
          } else if (text.startsWith(disableCommand)) {
            processDisableCommand(comment);
          } else if (text.startsWith(enableCommand)) {
            processEnableCommand(comment);
          }
        }

        /**
         * @param {string} command
         * @param {string} fullText
         * @returns {string[]}
         */
        function getCommandRules(command, fullText) {
          // Allow for description (f.e. /* stylelint-disable a, b -- Description */).
          const splitted = fullText.slice(command.length).split(/\s-{2,}\s/u)[0];

          assertString(splitted);
          const rules = splitted.
          trim().
          split(',').
          filter(Boolean).
          map(r => r.trim());

          if (rules.length === 0) {
            return [ALL_RULES];
          }

          return rules;
        }

        /**
         * @param {string} fullText
         * @returns {string|undefined}
         */
        function getDescription(fullText) {
          const descriptionStart = fullText.indexOf('--');

          if (descriptionStart === -1) return;

          return fullText.slice(descriptionStart + 2).trim();
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         * @param {string|undefined} description
         */
        function startDisabledRange(comment, line, ruleName, strict, description) {
          const rangeObj = createDisableRange(comment, line, strict, description);

          ensureRuleRanges(ruleName);

          const range = disabledRanges[ruleName];

          assert(range);
          range.push(rangeObj);
        }

        /**
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         */
        function endDisabledRange(line, ruleName, strict) {
          const ranges = disabledRanges[ruleName];
          const lastRangeForRule = ranges ? ranges[ranges.length - 1] : null;

          if (!lastRangeForRule) {
            return;
          }

          // Add an `end` prop to the last range of that rule
          lastRangeForRule.end = line;
          lastRangeForRule.strictEnd = strict;
        }

        /**
         * @param {string} ruleName
         */
        function ensureRuleRanges(ruleName) {
          if (!disabledRanges[ruleName]) {
            disabledRanges[ruleName] = disabledRanges[ALL_RULES].map(
            ({ comment, start, end, description }) =>
            createDisableRange(comment, start, false, description, end, false));

          }
        }

        /**
         * @param {string} ruleName
         * @returns {boolean}
         */
        function ruleIsDisabled(ruleName) {
          const ranges = disabledRanges[ruleName];

          if (!ranges) return false;

          const lastRange = ranges[ranges.length - 1];

          if (!lastRange) return false;

          if (!lastRange.end) return true;

          return false;
        }
      };

    }, { "./utils/isStandardSyntaxComment": 385, "./utils/validateTypes": 418 }], 91: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').LintResult} StylelintResult */

      /**
       * @param {PostcssResult} [postcssResult]
       * @param {import('stylelint').CssSyntaxError} [cssSyntaxError]
       * @return {StylelintResult}
       */
      module.exports = function (postcssResult, cssSyntaxError) {
        /** @type {StylelintResult} */
        let stylelintResult;
        /** @type {string | undefined} */
        let source;

        if (postcssResult && postcssResult.root) {
          if (postcssResult.root.source) {
            source = postcssResult.root.source.input.file;

            if (!source && 'id' in postcssResult.root.source.input) {
              source = postcssResult.root.source.input.id;
            }
          }

          const deprecationMessages = postcssResult.messages.filter(
          message => message.stylelintType === 'deprecation');

          const deprecations = deprecationMessages.map(deprecationMessage => {
            return {
              text: deprecationMessage.text,
              reference: deprecationMessage.stylelintReference };

          });

          const invalidOptionMessages = postcssResult.messages.filter(
          message => message.stylelintType === 'invalidOption');

          const invalidOptionWarnings = invalidOptionMessages.map(invalidOptionMessage => {
            return {
              text: invalidOptionMessage.text };

          });

          const parseErrors = postcssResult.messages.filter(
          message => message.stylelintType === 'parseError');


          // Remove deprecation warnings, invalid options, and parse errors from the messages
          postcssResult.messages = postcssResult.messages.filter(
          (message) =>
          message.stylelintType !== 'deprecation' &&
          message.stylelintType !== 'invalidOption' &&
          message.stylelintType !== 'parseError');


          // This defines the stylelint result object that formatters receive
          stylelintResult = {
            source,
            deprecations,
            invalidOptionWarnings,
            // @ts-expect-error -- TS2322: Type 'Message[]' is not assignable to type '(Warning & { stylelintType: string; })[]'.
            parseErrors,
            errored: postcssResult.stylelint.stylelintError,
            warnings: postcssResult.messages.map(message => {
              return {
                line: message.line,
                column: message.column,
                endLine: message.endLine,
                endColumn: message.endColumn,
                rule: message.rule,
                severity: message.severity,
                text: message.text };

            }),
            ignored: postcssResult.stylelint.ignored,
            _postcssResult: postcssResult };

        } else if (cssSyntaxError) {
          if (cssSyntaxError.name !== 'CssSyntaxError') {
            throw cssSyntaxError;
          }

          stylelintResult = {
            source: cssSyntaxError.file || '<input css 1>',
            deprecations: [],
            invalidOptionWarnings: [],
            parseErrors: [],
            errored: true,
            warnings: [
            {
              line: cssSyntaxError.line,
              column: cssSyntaxError.column,
              endLine: cssSyntaxError.endLine,
              endColumn: cssSyntaxError.endColumn,
              rule: cssSyntaxError.name,
              severity: 'error',
              text: `${cssSyntaxError.reason} (${cssSyntaxError.name})` }] };



        } else {
          throw new Error(
          'createPartialStylelintResult must be called with either postcssResult or CssSyntaxError');

        }

        return stylelintResult;
      };

    }, {}], 92: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').Rule} StylelintRule */

      /**
       * @param {string} ruleName
       * @param {StylelintRule} rule
       * @returns {{ruleName: string, rule: StylelintRule}}
       */
      function createPlugin(ruleName, rule) {
        return {
          ruleName,
          rule };

      }

      module.exports = /** @type {typeof import('stylelint').createPlugin} */createPlugin;

    }, {}], 93: [function (require, module, exports) {
      'use strict';

      /* const augmentConfig = require('./augmentConfig'); */
      const createStylelintResult = require('./createStylelintResult');
      /* const getConfigForFile = require('./getConfigForFile'); */
      const getConfigForFile = async stylelint => ({
        config: require('./normalizeAllRuleSettings')(stylelint._options.config) });

      const getPostcssResult = require('./getPostcssResult');
      /* const isPathIgnored = require('./isPathIgnored'); */
      const isPathIgnored = async () => false;
      const lintSource = require('./lintSource');
      /* const { cosmiconfig } = require('cosmiconfig'); */

      const IS_TEST = process.env.NODE_ENV === 'test';
      const STOP_DIR = IS_TEST ? process.cwd() : undefined;

      /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

      /**
       * The stylelint "internal API" is passed among functions
       * so that methods on a stylelint instance can invoke
       * each other while sharing options and caches.
       *
       * @param {import('stylelint').LinterOptions} options
       * @returns {StylelintInternalApi}
       */
      function createStylelint(options = {}) {
        const cwd = options.cwd || process.cwd();

        /** @type {StylelintInternalApi} */
        // @ts-expect-error -- TS2740: Type '{ _options: LinterOptions; }' is missing the following properties from type 'InternalApi'
        const stylelint = { _options: _extends({}, options, { cwd }) };

        /* stylelint._extendExplorer = cosmiconfig('', {
        	transform: augmentConfig.augmentConfigExtended(cwd),
        	stopDir: STOP_DIR,
        }); */

        stylelint._specifiedConfigCache = new Map();
        stylelint._postcssResultCache = new Map();
        stylelint._createStylelintResult = createStylelintResult.bind(null, stylelint);
        stylelint._getPostcssResult = getPostcssResult.bind(null, stylelint);
        stylelint._lintSource = lintSource.bind(null, stylelint);

        stylelint.getConfigForFile = getConfigForFile.bind(null, stylelint);
        stylelint.isPathIgnored = isPathIgnored.bind(null, stylelint);

        return stylelint;
      }

      module.exports = /** @type {typeof import('stylelint').createLinter} */createStylelint;

    }, { "./createStylelintResult": 94, "./getPostcssResult": 98, "./lintSource": 101, "./normalizeAllRuleSettings": 103 }], 94: [function (require, module, exports) {
      'use strict';

      const createPartialStylelintResult = require('./createPartialStylelintResult');

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').LintResult} StylelintResult */

      /**
       * @param {import('stylelint').InternalApi} stylelint
       * @param {PostcssResult} [postcssResult]
       * @param {string} [filePath]
       * @param {import('stylelint').CssSyntaxError} [cssSyntaxError]
       * @return {Promise<StylelintResult>}
       */
      module.exports = async function createStylelintResult(
      stylelint,
      postcssResult,
      filePath,
      cssSyntaxError)
      {
        let stylelintResult = createPartialStylelintResult(postcssResult, cssSyntaxError);

        const configForFile = await stylelint.getConfigForFile(filePath, filePath);

        const config = configForFile === null ? {} : configForFile.config;
        const file = stylelintResult.source || cssSyntaxError && cssSyntaxError.file;

        if (config.resultProcessors) {
          for (const resultProcessor of config.resultProcessors) {
            // Result processors might just mutate the result object,
            // or might return a new one
            const returned = resultProcessor(stylelintResult, file);

            if (returned) {
              stylelintResult = returned;
            }
          }
        }

        return stylelintResult;
      };

    }, { "./createPartialStylelintResult": 91 }], 95: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */
      /** @typedef {import('stylelint').DisableOptionsReport} StylelintDisableOptionsReport */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function descriptionlessDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(
          result._postcssResult,
          'reportDescriptionlessDisables');


          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          /** @type {Set<PostcssComment>} */
          const alreadyReported = new Set();

          for (const [rule, ruleRanges] of Object.entries(stylelintResult.disabledRanges)) {
            for (const range of ruleRanges) {
              if (range.description) continue;

              if (alreadyReported.has(range.comment)) continue;

              if (enabled === optionsMatches(options, 'except', rule)) {
                // An 'all' rule will get copied for each individual rule. If the
                // configuration is `[false, {except: ['specific-rule']}]`, we
                // don't want to report the copies that match except, so we record
                // the comment as already reported.
                if (!enabled && rule === 'all') alreadyReported.add(range.comment);

                continue;
              }

              alreadyReported.add(range.comment);

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Disable for "${rule}" is missing a description`,
                rule: '--report-descriptionless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                endLine: range.comment.source.end && range.comment.source.end.line,
                endColumn: range.comment.source.end && range.comment.source.end.column,
                severity: options.severity });

            }
          }
        }
      };

    }, { "./utils/optionsMatches": 403, "./validateDisableSettings": 421 }], 96: [function (require, module, exports) {
      'use strict';

      /* const _importLazy = require('import-lazy'); */

      /* const importLazy = _importLazy(require); */

      /** @type {typeof import('stylelint').formatters} */
      const formatters = {
        compact: /* importLazy('./compactFormatter'), */
        () => {},
        json: /* importLazy( */
        require('./jsonFormatter'),
        string: /* importLazy('./stringFormatter'), */
        () => {},
        tap: /* importLazy('./tapFormatter'), */
        () => {},
        unix: /* importLazy('./unixFormatter'), */
        () => {},
        verbose: /* importLazy('./verboseFormatter'), */
        () => {} };


      module.exports = formatters;

    }, { "./jsonFormatter": 97 }], 97: [function (require, module, exports) {
      'use strict';

      /**
       * Omit any properties starting with `_`, which are fake-private
       *
       * @type {import('stylelint').Formatter}
       */
      module.exports = function jsonFormatter(results) {
        const cleanedResults = results.map((result) =>
        Object.entries(result).
        filter(([key]) => !key.startsWith('_')).
        reduce(( /** @type {{ [key: string]: any }} */obj, [key, value]) => {
          obj[key] = value;

          return obj;
        }, {}));


        return JSON.stringify(cleanedResults);
      };

    }, {}], 98: [function (require, module, exports) {
      'use strict';

      const LazyResult = require('postcss/lib/lazy-result').default;
      /* const path = require('path'); */
      const { default: postcss } = require('postcss');
      /* const { promises: fs } = require('fs'); */

      /** @typedef {import('postcss').Result} Result */
      /** @typedef {import('postcss').Syntax} Syntax */
      /** @typedef {import('stylelint').CustomSyntax} CustomSyntax */
      /** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */
      /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

      const postcssProcessor = postcss();

      /**
       * @param {StylelintInternalApi} stylelint
       * @param {GetPostcssOptions} options
       *
       * @returns {Promise<Result>}
       */
      module.exports = async function getPostcssResult(stylelint, options = {}) {
        const cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;

        if (cached) {
          return cached;
        }

        if (stylelint._options.syntax) {
          let error = 'The "syntax" option is no longer available. ';

          error +=
          stylelint._options.syntax === 'css' ?
          'You can remove the "--syntax" CLI flag as stylelint will now parse files as CSS by default' :
          `You should install an appropriate syntax, e.g. postcss-scss, and use the "customSyntax" option`;

          return Promise.reject(new Error(error));
        }

        const syntax = options.customSyntax ?
        getCustomSyntax(options.customSyntax) :
        cssSyntax(stylelint, options.filePath);

        const postcssOptions = {
          from: options.filePath,
          syntax };


        /** @type {string | undefined} */
        let getCode;

        if (options.code !== undefined) {
          getCode = options.code;
        } else if (options.filePath) {
          /* getCode = await fs.readFile(options.filePath, 'utf8'); */
        }

        if (getCode === undefined) {
          return Promise.reject(new Error('code or filePath required'));
        }

        if (options.codeProcessors && options.codeProcessors.length) {
          if (stylelint._options.fix) {
            console.warn(
            'Autofix is incompatible with processors and will be disabled. Are you sure you need a processor?');

            stylelint._options.fix = false;
          }

          const sourceName = options.code ? options.codeFilename : options.filePath;

          for (const codeProcessor of options.codeProcessors) {
            getCode = codeProcessor(getCode, sourceName);
          }
        }

        const postcssResult = await new LazyResult(postcssProcessor, getCode, postcssOptions);

        if (options.filePath) {
          stylelint._postcssResultCache.set(options.filePath, postcssResult);
        }

        return postcssResult;
      };

      /**
       * @param {CustomSyntax} customSyntax
       * @returns {Syntax}
       */
      function getCustomSyntax(customSyntax) {
        let resolved;

        if (typeof customSyntax === 'string') {
          try {
            resolved = require(customSyntax);
          } catch (error) {
            if (
            error &&
            typeof error === 'object' &&
            // @ts-expect-error -- TS2571: Object is of type 'unknown'.
            error.code === 'MODULE_NOT_FOUND' &&
            // @ts-expect-error -- TS2571: Object is of type 'unknown'.
            error.message.includes(customSyntax))
            {
              throw new Error(
              `Cannot resolve custom syntax module "${customSyntax}". Check that module "${customSyntax}" is available and spelled correctly.\n\nCaused by: ${error}`);

            }

            throw error;
          }

          /*
           * PostCSS allows for syntaxes that only contain a parser, however,
           * it then expects the syntax to be set as the `parse` option.
           */
          if (!resolved.parse) {
            resolved = {
              parse: resolved,
              stringify: postcss.stringify };

          }

          return resolved;
        }

        if (typeof customSyntax === 'object') {
          if (typeof customSyntax.parse === 'function') {
            resolved = _extends({}, customSyntax);
          } else {
            throw new TypeError(
            `An object provided to the "customSyntax" option must have a "parse" property. Ensure the "parse" property exists and its value is a function.`);

          }

          return resolved;
        }

        throw new Error(`Custom syntax must be a string or a Syntax object`);
      }

      /** @type {{ [key: string]: string }} */
      const previouslyInferredExtensions = {
        html: 'postcss-html',
        js: '@stylelint/postcss-css-in-js',
        jsx: '@stylelint/postcss-css-in-js',
        less: 'postcss-less',
        md: 'postcss-markdown',
        sass: 'postcss-sass',
        sss: 'sugarss',
        scss: 'postcss-scss',
        svelte: 'postcss-html',
        ts: '@stylelint/postcss-css-in-js',
        tsx: '@stylelint/postcss-css-in-js',
        vue: 'postcss-html',
        xml: 'postcss-html',
        xst: 'postcss-html' };


      /**
       * @param {StylelintInternalApi} stylelint
       * @param {string|undefined} filePath
       * @returns {Syntax}
       */
      function cssSyntax(stylelint, filePath) {/*
        const fileExtension = filePath ? path.extname(filePath).slice(1).toLowerCase() : '';
        const extensions = ['css', 'pcss', 'postcss'];
        if (previouslyInferredExtensions[fileExtension]) {
        console.warn(
        `${filePath}: When linting something other than CSS, you should install an appropriate syntax, e.g. "${previouslyInferredExtensions[fileExtension]}", and use the "customSyntax" option`,
        );
        }
        return {
        parse:
        stylelint._options.fix && extensions.includes(fileExtension)
        ? require('postcss-safe-parser')
        : postcss.parse,
        */


        return postcss;
      }
      cssSyntax.sugarss = require("sugarss");

    }, { "postcss": 77, "postcss/lib/lazy-result": 70, "sugarss": 423 }], 99: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('stylelint').RangeType} RangeType */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function invalidScopeDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(result._postcssResult, 'reportInvalidScopeDisables');

          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          const configRules = (stylelintResult.config || {}).rules || {};

          const usedRules = new Set(Object.keys(configRules));

          usedRules.add('all');

          for (const [rule, ruleRanges] of Object.entries(stylelintResult.disabledRanges)) {
            if (usedRules.has(rule)) continue;

            if (enabled === optionsMatches(options, 'except', rule)) continue;

            for (const range of ruleRanges) {
              if (!range.strictStart && !range.strictEnd) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Rule "${rule}" isn't enabled`,
                rule: '--report-invalid-scope-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                endLine: range.comment.source.end && range.comment.source.end.line,
                endColumn: range.comment.source.end && range.comment.source.end.column,
                severity: options.severity });

            }
          }
        }
      };

    }, { "./utils/optionsMatches": 403, "./validateDisableSettings": 421 }], 100: [function (require, module, exports) {
      'use strict';

      const assignDisabledRanges = require('./assignDisabledRanges');
      const getOsEol = require('./utils/getOsEol');
      const reportUnknownRuleNames = require('./reportUnknownRuleNames');
      const rules = require('./rules');

      /** @typedef {import('stylelint').LinterOptions} LinterOptions */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').Config} StylelintConfig */

      /**
       * @param {LinterOptions} stylelintOptions
       * @param {PostcssResult} postcssResult
       * @param {StylelintConfig} config
       * @returns {Promise<any>}
       */
      function lintPostcssResult(stylelintOptions, postcssResult, config) {
        postcssResult.stylelint.ruleSeverities = {};
        postcssResult.stylelint.customMessages = {};
        postcssResult.stylelint.ruleMetadata = {};
        postcssResult.stylelint.stylelintError = false;
        postcssResult.stylelint.quiet = config.quiet;
        postcssResult.stylelint.config = config;

        /** @type {string | undefined} */
        let newline;
        const postcssDoc = postcssResult.root;

        if (postcssDoc) {
          if (!('type' in postcssDoc)) {
            throw new Error('Unexpected Postcss root object!');
          }

          const newlineMatch = postcssDoc.source && postcssDoc.source.input.css.match(/\r?\n/);

          newline = newlineMatch ? newlineMatch[0] : getOsEol();

          assignDisabledRanges(postcssDoc, postcssResult);
        }

        const isFileFixCompatible = isFixCompatible(postcssResult);

        if (!isFileFixCompatible) {
          postcssResult.stylelint.disableWritingFix = true;
        }

        const postcssRoots = /** @type {import('postcss').Root[]} */
        postcssDoc && postcssDoc.constructor.name === 'Document' ? postcssDoc.nodes : [postcssDoc];


        // Promises for the rules. Although the rule code runs synchronously now,
        // the use of Promises makes it compatible with the possibility of async
        // rules down the line.
        /** @type {Array<Promise<any>>} */
        const performRules = [];

        const rulesOrder = Object.keys(rules);
        const ruleNames = config.rules ?
        Object.keys(config.rules).sort((a, b) => rulesOrder.indexOf(a) - rulesOrder.indexOf(b)) :
        [];

        for (const ruleName of ruleNames) {
          const ruleFunction =
          rules[ruleName] || config.pluginFunctions && config.pluginFunctions[ruleName];

          if (ruleFunction === undefined) {
            performRules.push(
            Promise.all(
            postcssRoots.map((postcssRoot) =>
            reportUnknownRuleNames(ruleName, postcssRoot, postcssResult))));




            continue;
          }

          const ruleSettings = config.rules && config.rules[ruleName];

          if (ruleSettings === null || ruleSettings[0] === null) {
            continue;
          }

          const primaryOption = ruleSettings[0];
          const secondaryOptions = ruleSettings[1];

          // Log the rule's severity in the PostCSS result
          const defaultSeverity = config.defaultSeverity || 'error';
          // disableFix in secondary option
          const disableFix = secondaryOptions && secondaryOptions.disableFix === true || false;

          if (disableFix) {
            postcssResult.stylelint.ruleDisableFix = true;
          }

          postcssResult.stylelint.ruleSeverities[ruleName] =
          secondaryOptions && secondaryOptions.severity || defaultSeverity;
          postcssResult.stylelint.customMessages[ruleName] = secondaryOptions && secondaryOptions.message;
          postcssResult.stylelint.ruleMetadata[ruleName] = ruleFunction.meta || {};

          performRules.push(
          Promise.all(
          postcssRoots.map((postcssRoot) =>
          ruleFunction(primaryOption, secondaryOptions, {
            fix:
            !disableFix &&
            stylelintOptions.fix &&
            // Next two conditionals are temporary measures until #2643 is resolved
            isFileFixCompatible &&
            !postcssResult.stylelint.disabledRanges[ruleName],
            newline })(
          postcssRoot, postcssResult))));



        }

        return Promise.all(performRules);
      }

      /**
       * There are currently some bugs in the autofixer of Stylelint.
       * The autofixer does not yet adhere to stylelint-disable comments, so if there are disabled
       * ranges we can not autofix this document. More info in issue #2643.
       *
       * @param {PostcssResult} postcssResult
       * @returns {boolean}
       */
      function isFixCompatible({ stylelint }) {
        // Check for issue #2643
        if (stylelint.disabledRanges.all && stylelint.disabledRanges.all.length) return false;

        return true;
      }

      module.exports = lintPostcssResult;

    }, { "./assignDisabledRanges": 90, "./reportUnknownRuleNames": 112, "./rules": 205, "./utils/getOsEol": 343 }], 101: [function (require, module, exports) {
      'use strict';

      const isPathNotFoundError = require('./utils/isPathNotFoundError');
      const lintPostcssResult = require('./lintPostcssResult');
      const path = require('path');

      /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */
      /** @typedef {import('stylelint').GetLintSourceOptions} Options */
      /** @typedef {import('postcss').Result} Result */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult */

      /**
       * Run stylelint on a PostCSS Result, either one that is provided
       * or one that we create
       * @param {StylelintInternalApi} stylelint
       * @param {Options} options
       * @returns {Promise<PostcssResult>}
       */
      module.exports = async function lintSource(stylelint, options = {}) {
        if (!options.filePath && options.code === undefined && !options.existingPostcssResult) {
          return Promise.reject(new Error('You must provide filePath, code, or existingPostcssResult'));
        }

        const isCodeNotFile = options.code !== undefined;

        const inputFilePath = isCodeNotFile ? options.codeFilename : options.filePath;

        if (inputFilePath !== undefined && !path.isAbsolute(inputFilePath)) {
          if (isCodeNotFile) {
            return Promise.reject(new Error('codeFilename must be an absolute path'));
          }

          return Promise.reject(new Error('filePath must be an absolute path'));
        }

        const isIgnored = await stylelint.isPathIgnored(inputFilePath).catch(err => {
          if (isCodeNotFile && isPathNotFoundError(err)) return false;

          throw err;
        });

        if (isIgnored) {
          return options.existingPostcssResult ?
          Object.assign(options.existingPostcssResult, {
            stylelint: createEmptyStylelintPostcssResult() }) :

          createEmptyPostcssResult(inputFilePath);
        }

        const configSearchPath = stylelint._options.configFile || inputFilePath;
        const cwd = stylelint._options.cwd;

        const configForFile = await stylelint.
        getConfigForFile(configSearchPath, inputFilePath).
        catch(err => {
          if (isCodeNotFile && isPathNotFoundError(err)) return stylelint.getConfigForFile(cwd);

          throw err;
        });

        if (!configForFile) {
          return Promise.reject(new Error('Config file not found'));
        }

        const config = configForFile.config;
        const existingPostcssResult = options.existingPostcssResult;

        /** @type {StylelintPostcssResult} */
        const stylelintResult = {
          ruleSeverities: {},
          customMessages: {},
          ruleMetadata: {},
          disabledRanges: {} };


        const postcssResult =
        existingPostcssResult || (
        await stylelint._getPostcssResult({
          code: options.code,
          codeFilename: options.codeFilename,
          filePath: inputFilePath,
          codeProcessors: config.codeProcessors,
          customSyntax: config.customSyntax }));


        const stylelintPostcssResult = Object.assign(postcssResult, {
          stylelint: stylelintResult });


        await lintPostcssResult(stylelint._options, stylelintPostcssResult, config);

        return stylelintPostcssResult;
      };

      /**
       * @returns {StylelintPostcssResult}
       */
      function createEmptyStylelintPostcssResult() {
        return {
          ruleSeverities: {},
          customMessages: {},
          ruleMetadata: {},
          disabledRanges: {},
          ignored: true,
          stylelintError: false };

      }

      /**
       * @param {string} [filePath]
       * @returns {PostcssResult}
       */
      function createEmptyPostcssResult(filePath) {
        return {
          root: {
            source: {
              input: { file: filePath } } },


          messages: [],
          opts: undefined,
          stylelint: createEmptyStylelintPostcssResult(),
          warn: () => {} };

      }

    }, { "./lintPostcssResult": 100, "./utils/isPathNotFoundError": 377, "path": undefined }], 102: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const putIfAbsent = require('./utils/putIfAbsent');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function needlessDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(result._postcssResult, 'reportNeedlessDisables');

          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          const rangeData = stylelintResult.disabledRanges;

          if (!rangeData) continue;

          const disabledWarnings = stylelintResult.disabledWarnings || [];

          // A map from `stylelint-disable` comments to the set of rules that
          // are usefully disabled by each comment. We track this
          // comment-by-comment rather than range-by-range because ranges that
          // disable *all* rules are duplicated for each rule they apply to in
          // practice.
          /** @type {Map<PostcssComment, Set<string>>}} */
          const usefulDisables = new Map();

          for (const warning of disabledWarnings) {
            const rule = warning.rule;
            const ruleRanges = rangeData[rule];

            if (ruleRanges) {
              for (const range of ruleRanges) {
                if (isWarningInRange(warning, range)) {
                  putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
                }
              }
            }

            for (const range of rangeData.all || []) {
              if (isWarningInRange(warning, range)) {
                putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
              }
            }
          }

          const allRangeComments = new Set((rangeData.all || []).map(range => range.comment));

          for (const [rule, ranges] of Object.entries(rangeData)) {
            for (const range of ranges) {
              if (rule !== 'all' && allRangeComments.has(range.comment)) continue;

              if (enabled === optionsMatches(options, 'except', rule)) continue;

              const useful = usefulDisables.get(range.comment) || new Set();

              // Only emit a warning if this range's comment isn't useful for this rule.
              // For the special rule "all", only emit a warning if it's not useful for
              // *any* rules, because it covers all of them.
              if (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Needless disable for "${rule}"`,
                rule: '--report-needless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                endLine: range.comment.source.end && range.comment.source.end.line,
                endColumn: range.comment.source.end && range.comment.source.end.column,
                severity: options.severity });

            }
          }
        }
      };

      /**
       * @param {import('stylelint').DisabledWarning} warning
       * @param {RangeType} range
       * @return {boolean}
       */
      function isWarningInRange(warning, range) {
        const line = warning.line;

        // Need to check if range.end exist, because line number type cannot be compared to undefined
        return (
          range.start <= line && (
          range.end !== undefined && range.end >= line || range.end === undefined));

      }

    }, { "./utils/optionsMatches": 403, "./utils/putIfAbsent": 405, "./validateDisableSettings": 421 }], 103: [function (require, module, exports) {
      'use strict';

      const normalizeRuleSettings = require('./normalizeRuleSettings');
      const rules = require('./rules');

      /** @typedef {import('stylelint').ConfigRules} StylelintConfigRules */
      /** @typedef {import('stylelint').Config} StylelintConfig */

      /**
       * @param {StylelintConfig} config
       * @return {StylelintConfig}
       */
      function normalizeAllRuleSettings(config) {
        if (!config.rules) return config;

        /** @type {StylelintConfigRules} */
        const normalizedRules = {};

        for (const [ruleName, rawRuleSettings] of Object.entries(config.rules)) {
          const rule = rules[ruleName] || config.pluginFunctions && config.pluginFunctions[ruleName];

          if (rule) {
            normalizedRules[ruleName] = normalizeRuleSettings(
            rawRuleSettings,
            ruleName,
            rule.primaryOptionArray);

          } else {
            normalizedRules[ruleName] = [];
          }
        }

        config.rules = normalizedRules;

        return config;
      }

      module.exports = normalizeAllRuleSettings;

    }, { "./normalizeRuleSettings": 104, "./rules": 205 }], 104: [function (require, module, exports) {
      'use strict';

      const rules = require('./rules');
      const { isPlainObject } = require('./utils/validateTypes');

      // Rule settings can take a number of forms, e.g.
      // a. "rule-name": null
      // b. "rule-name": [null, ...]
      // c. "rule-name": primaryOption
      // d. "rule-name": [primaryOption]
      // e. "rule-name": [primaryOption, secondaryOption]
      // Where primaryOption can be anything: primitive, Object, or Array.

      /**
       * This function normalizes all the possibilities into the
       * standard form: [primaryOption, secondaryOption]
       * Except in the cases with null, a & b, in which case
       * null is returned
       * @template T
       * @template {Object} O
       * @param {import('stylelint').ConfigRuleSettings<T, O>} rawSettings
       * @param {string} ruleName
       * @param {boolean} [primaryOptionArray] If primaryOptionArray is not provided, we try to get it from the rules themselves, which will not work for plugins
       * @return {[T] | [T, O] | null}
       */
      module.exports = function normalizeRuleSettings(
      rawSettings,
      ruleName,
      // If primaryOptionArray is not provided, we try to get it from the
      // rules themselves, which will not work for plugins
      primaryOptionArray)
      {
        if (rawSettings === null || rawSettings === undefined) {
          return null;
        }

        if (!Array.isArray(rawSettings)) {
          return [rawSettings];
        }
        // Everything below is an array ...

        if (rawSettings.length > 0 && (rawSettings[0] === null || rawSettings[0] === undefined)) {
          return null;
        }

        if (primaryOptionArray === undefined) {
          const rule = rules[ruleName];

          if (rule && 'primaryOptionArray' in rule) {
            primaryOptionArray = rule.primaryOptionArray;
          }
        }

        if (!primaryOptionArray) {
          return rawSettings;
        }
        // Everything below is a rule that CAN have an array for a primary option ...
        // (they might also have something else, e.g. rule-properties-order can
        // have the string "alphabetical")

        if (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {
          return rawSettings;
        }

        if (rawSettings.length === 2 && !isPlainObject(rawSettings[0]) && isPlainObject(rawSettings[1])) {
          return rawSettings;
        }

        // `T` must be an array type, but TSC thinks it's probably invalid to
        // cast `[T]` to `T` so we cast through `any` first.
        return [/** @type {T} */ /** @type {any} */rawSettings];
      };

    }, { "./rules": 205, "./utils/validateTypes": 418 }], 105: [function (require, module, exports) {
      'use strict';

      const createStylelint = require('./createStylelint');
      const path = require('path');

      /** @typedef {import('stylelint').PostcssPluginOptions} PostcssPluginOptions */
      /** @typedef {import('stylelint').Config} StylelintConfig */

      /**
       * @type {import('postcss').PluginCreator<PostcssPluginOptions>}
       * */
      module.exports = (options = {}) => {
        const [cwd, tailoredOptions] = isConfig(options) ?
        [process.cwd(), { config: options }] :
        [options.cwd || process.cwd(), options];
        const stylelint = createStylelint(tailoredOptions);

        return {
          postcssPlugin: 'stylelint',
          Once(root, { result }) {
            let filePath = root.source && root.source.input.file;

            if (filePath && !path.isAbsolute(filePath)) {
              filePath = path.join(cwd, filePath);
            }

            return stylelint._lintSource({
              filePath,
              existingPostcssResult: result });

          } };

      };

      module.exports.postcss = true;

      /**
       * @param {PostcssPluginOptions} options
       * @returns {options is StylelintConfig}
       */
      function isConfig(options) {
        return 'rules' in options;
      }

    }, { "./createStylelint": 93, "path": undefined }], 106: [function (require, module, exports) {
      'use strict';

      const descriptionlessDisables = require('./descriptionlessDisables');
      const invalidScopeDisables = require('./invalidScopeDisables');
      const needlessDisables = require('./needlessDisables');
      const reportDisables = require('./reportDisables');

      /** @typedef {import('stylelint').Formatter} Formatter */
      /** @typedef {import('stylelint').LintResult} StylelintResult */
      /** @typedef {import('stylelint').LinterOptions["maxWarnings"]} maxWarnings */
      /** @typedef {import('stylelint').LinterResult} LinterResult */

      /**
       * @param {StylelintResult[]} stylelintResults
       * @param {maxWarnings} maxWarnings
       * @param {Formatter} formatter
       * @param {string} cwd
       *
       * @returns {LinterResult}
       */
      function prepareReturnValue(stylelintResults, maxWarnings, formatter, cwd) {
        reportDisables(stylelintResults);
        needlessDisables(stylelintResults);
        invalidScopeDisables(stylelintResults);
        descriptionlessDisables(stylelintResults);

        const errored = stylelintResults.some(
        (result) =>
        result.errored ||
        result.parseErrors.length > 0 ||
        result.warnings.some(warning => warning.severity === 'error'));


        /** @type {LinterResult} */
        const returnValue = {
          cwd,
          errored,
          results: [],
          output: '',
          reportedDisables: [] };


        if (maxWarnings !== undefined) {
          const foundWarnings = stylelintResults.reduce((count, file) => count + file.warnings.length, 0);

          if (foundWarnings > maxWarnings) {
            returnValue.maxWarningsExceeded = { maxWarnings, foundWarnings };
          }
        }

        returnValue.output = formatter(stylelintResults, returnValue);
        returnValue.results = stylelintResults;

        return returnValue;
      }

      module.exports = prepareReturnValue;

    }, { "./descriptionlessDisables": 95, "./invalidScopeDisables": 99, "./needlessDisables": 102, "./reportDisables": 111 }], 107: [function (require, module, exports) {
      'use strict';

      const htmlTags = require('html-tags');

      const keywordSets = {};

      keywordSets.nonLengthUnits = new Set([
      // Relative length units
      '%',
      // Time length units
      's',
      'ms',
      // Angle
      'deg',
      'grad',
      'turn',
      'rad',
      // Frequency
      'Hz',
      'kHz',
      // Resolution
      'dpi',
      'dpcm',
      'dppx']);


      keywordSets.lengthUnits = new Set([
      // Relative length units
      'em',
      'ex',
      'ch',
      'rem',
      'rlh',
      'lh',
      // Viewport-percentage lengths
      'dvh',
      'dvmax',
      'dvmin',
      'dvw',
      'lvh',
      'lvmax',
      'lvmin',
      'lvw',
      'svh',
      'svmax',
      'svmin',
      'svw',
      'vh',
      'vw',
      'vmin',
      'vmax',
      'vm',
      // Absolute length units
      'px',
      'mm',
      'cm',
      'in',
      'pt',
      'pc',
      'q',
      'mozmm',
      // Flexible length units
      'fr']);


      keywordSets.units = uniteSets(keywordSets.nonLengthUnits, keywordSets.lengthUnits);

      keywordSets.camelCaseFunctionNames = new Set([
      'translateX',
      'translateY',
      'translateZ',
      'scaleX',
      'scaleY',
      'scaleZ',
      'rotateX',
      'rotateY',
      'rotateZ',
      'skewX',
      'skewY']);


      keywordSets.basicKeywords = new Set(['initial', 'inherit', 'revert', 'revert-layer', 'unset']);

      keywordSets.systemFontValues = uniteSets(keywordSets.basicKeywords, [
      'caption',
      'icon',
      'menu',
      'message-box',
      'small-caption',
      'status-bar']);


      keywordSets.fontFamilyKeywords = uniteSets(keywordSets.basicKeywords, [
      'serif',
      'sans-serif',
      'cursive',
      'fantasy',
      'monospace',
      'system-ui',
      'ui-serif',
      'ui-sans-serif',
      'ui-monospace',
      'ui-rounded']);


      keywordSets.fontWeightRelativeKeywords = new Set(['bolder', 'lighter']);

      keywordSets.fontWeightAbsoluteKeywords = new Set(['bold']);

      keywordSets.fontWeightNumericKeywords = new Set([
      '100',
      '200',
      '300',
      '400',
      '500',
      '600',
      '700',
      '800',
      '900']);


      keywordSets.fontWeightKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontWeightRelativeKeywords,
      keywordSets.fontWeightAbsoluteKeywords,
      keywordSets.fontWeightNumericKeywords);


      keywordSets.animationNameKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.animationTimingFunctionKeywords = uniteSets(keywordSets.basicKeywords, [
      'linear',
      'ease',
      'ease-in',
      'ease-in-out',
      'ease-out',
      'step-start',
      'step-end',
      'steps',
      'cubic-bezier']);


      keywordSets.animationIterationCountKeywords = new Set(['infinite']);

      keywordSets.animationDirectionKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'reverse',
      'alternate',
      'alternate-reverse']);


      keywordSets.animationFillModeKeywords = new Set(['none', 'forwards', 'backwards', 'both']);

      keywordSets.animationPlayStateKeywords = uniteSets(keywordSets.basicKeywords, [
      'running',
      'paused']);


      // cf. https://developer.mozilla.org/en-US/docs/Web/CSS/animation
      keywordSets.animationShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.animationNameKeywords,
      keywordSets.animationTimingFunctionKeywords,
      keywordSets.animationIterationCountKeywords,
      keywordSets.animationDirectionKeywords,
      keywordSets.animationFillModeKeywords,
      keywordSets.animationPlayStateKeywords);


      // These are the ones that can have single-colon notation
      keywordSets.levelOneAndTwoPseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter']);


      keywordSets.levelThreeAndUpPseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter',
      // These are the ones that require double-colon notation
      'backdrop',
      'content',
      'cue',
      'file-selector-button',
      'grammar-error',
      'marker',
      'placeholder',
      'selection',
      'shadow',
      'slotted',
      'spelling-error',
      'target-text']);


      keywordSets.shadowTreePseudoElements = new Set(['part']);

      keywordSets.webkitScrollbarPseudoElements = new Set([
      '-webkit-resizer',
      '-webkit-scrollbar',
      '-webkit-scrollbar-button',
      '-webkit-scrollbar-corner',
      '-webkit-scrollbar-thumb',
      '-webkit-scrollbar-track',
      '-webkit-scrollbar-track-piece']);


      keywordSets.vendorSpecificPseudoElements = new Set([
      '-moz-focus-inner',
      '-moz-focus-outer',
      '-moz-list-bullet',
      '-moz-meter-bar',
      '-moz-placeholder',
      '-moz-progress-bar',
      '-moz-range-progress',
      '-moz-range-thumb',
      '-moz-range-track',
      '-ms-browse',
      '-ms-check',
      '-ms-clear',
      '-ms-expand',
      '-ms-fill',
      '-ms-fill-lower',
      '-ms-fill-upper',
      '-ms-reveal',
      '-ms-thumb',
      '-ms-ticks-after',
      '-ms-ticks-before',
      '-ms-tooltip',
      '-ms-track',
      '-ms-value',
      '-webkit-color-swatch',
      '-webkit-color-swatch-wrapper',
      '-webkit-calendar-picker-indicator',
      '-webkit-clear-button',
      '-webkit-date-and-time-value',
      '-webkit-datetime-edit',
      '-webkit-datetime-edit-ampm-field',
      '-webkit-datetime-edit-day-field',
      '-webkit-datetime-edit-fields-wrapper',
      '-webkit-datetime-edit-hour-field',
      '-webkit-datetime-edit-millisecond-field',
      '-webkit-datetime-edit-minute-field',
      '-webkit-datetime-edit-month-field',
      '-webkit-datetime-edit-second-field',
      '-webkit-datetime-edit-text',
      '-webkit-datetime-edit-week-field',
      '-webkit-datetime-edit-year-field',
      '-webkit-details-marker',
      '-webkit-distributed',
      '-webkit-file-upload-button',
      '-webkit-input-placeholder',
      '-webkit-keygen-select',
      '-webkit-meter-bar',
      '-webkit-meter-even-less-good-value',
      '-webkit-meter-inner-element',
      '-webkit-meter-optimum-value',
      '-webkit-meter-suboptimum-value',
      '-webkit-progress-bar',
      '-webkit-progress-inner-element',
      '-webkit-progress-value',
      '-webkit-search-cancel-button',
      '-webkit-search-decoration',
      '-webkit-search-results-button',
      '-webkit-search-results-decoration',
      '-webkit-slider-runnable-track',
      '-webkit-slider-thumb',
      '-webkit-textfield-decoration-container',
      '-webkit-validation-bubble',
      '-webkit-validation-bubble-arrow',
      '-webkit-validation-bubble-arrow-clipper',
      '-webkit-validation-bubble-heading',
      '-webkit-validation-bubble-message',
      '-webkit-validation-bubble-text-block',
      ...keywordSets.webkitScrollbarPseudoElements]);


      keywordSets.pseudoElements = uniteSets(
      keywordSets.levelOneAndTwoPseudoElements,
      keywordSets.levelThreeAndUpPseudoElements,
      keywordSets.vendorSpecificPseudoElements,
      keywordSets.shadowTreePseudoElements);


      keywordSets.aNPlusBNotationPseudoClasses = new Set([
      'nth-column',
      'nth-last-column',
      'nth-last-of-type',
      'nth-of-type']);


      keywordSets.linguisticPseudoClasses = new Set(['dir', 'lang']);

      keywordSets.atRulePagePseudoClasses = new Set(['first', 'right', 'left', 'blank']);

      keywordSets.logicalCombinationsPseudoClasses = new Set(['has', 'is', 'matches', 'not', 'where']);

      keywordSets.aNPlusBOfSNotationPseudoClasses = new Set(['nth-child', 'nth-last-child']);

      keywordSets.otherPseudoClasses = new Set([
      'active',
      'any-link',
      'autofill',
      'blank',
      'checked',
      'current',
      'default',
      'defined',
      'disabled',
      'empty',
      'enabled',
      'first-child',
      'first-of-type',
      'focus',
      'focus-within',
      'focus-visible',
      'fullscreen',
      'fullscreen-ancestor',
      'future',
      'host',
      'host-context',
      'hover',
      'indeterminate',
      'in-range',
      'invalid',
      'last-child',
      'last-of-type',
      'link',
      'only-child',
      'only-of-type',
      'optional',
      'out-of-range',
      'past',
      'placeholder-shown',
      'playing',
      'picture-in-picture',
      'paused',
      'read-only',
      'read-write',
      'required',
      'root',
      'scope',
      'state',
      'target',
      'unresolved',
      'user-invalid',
      'user-valid',
      'valid',
      'visited',
      'window-inactive' // for ::selection (chrome)
      ]);

      keywordSets.vendorSpecificPseudoClasses = new Set([
      '-khtml-drag',
      '-moz-any',
      '-moz-any-link',
      '-moz-broken',
      '-moz-drag-over',
      '-moz-first-node',
      '-moz-focusring',
      '-moz-full-screen',
      '-moz-full-screen-ancestor',
      '-moz-last-node',
      '-moz-loading',
      '-moz-meter-optimum',
      '-moz-meter-sub-optimum',
      '-moz-meter-sub-sub-optimum',
      '-moz-placeholder',
      '-moz-submit-invalid',
      '-moz-suppressed',
      '-moz-ui-invalid',
      '-moz-ui-valid',
      '-moz-user-disabled',
      '-moz-window-inactive',
      '-ms-fullscreen',
      '-ms-input-placeholder',
      '-webkit-drag',
      '-webkit-any',
      '-webkit-any-link',
      '-webkit-autofill',
      '-webkit-full-screen',
      '-webkit-full-screen-ancestor']);


      // https://webkit.org/blog/363/styling-scrollbars/
      keywordSets.webkitScrollbarPseudoClasses = new Set([
      'horizontal',
      'vertical',
      'decrement',
      'increment',
      'start',
      'end',
      'double-button',
      'single-button',
      'no-button',
      'corner-present',
      'window-inactive']);


      keywordSets.pseudoClasses = uniteSets(
      keywordSets.aNPlusBNotationPseudoClasses,
      keywordSets.linguisticPseudoClasses,
      keywordSets.logicalCombinationsPseudoClasses,
      keywordSets.aNPlusBOfSNotationPseudoClasses,
      keywordSets.otherPseudoClasses,
      keywordSets.vendorSpecificPseudoClasses);


      keywordSets.shorthandTimeProperties = new Set(['transition', 'animation']);

      keywordSets.longhandTimeProperties = new Set([
      'transition-duration',
      'transition-delay',
      'animation-duration',
      'animation-delay']);


      keywordSets.timeProperties = uniteSets(
      keywordSets.shorthandTimeProperties,
      keywordSets.longhandTimeProperties);


      keywordSets.camelCaseKeywords = new Set([
      'optimizeSpeed',
      'optimizeQuality',
      'optimizeLegibility',
      'geometricPrecision',
      'currentColor',
      'crispEdges',
      'visiblePainted',
      'visibleFill',
      'visibleStroke',
      'sRGB',
      'linearRGB']);


      // https://developer.mozilla.org/docs/Web/CSS/counter-increment
      keywordSets.counterIncrementKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.counterResetKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.gridRowKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridColumnKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridAreaKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      // https://developer.mozilla.org/ru/docs/Web/CSS/list-style-type
      keywordSets.listStyleTypeKeywords = uniteSets(keywordSets.basicKeywords, [
      'none',
      'disc',
      'circle',
      'square',
      'decimal',
      'cjk-decimal',
      'decimal-leading-zero',
      'lower-roman',
      'upper-roman',
      'lower-greek',
      'lower-alpha',
      'lower-latin',
      'upper-alpha',
      'upper-latin',
      'arabic-indic',
      'armenian',
      'bengali',
      'cambodian',
      'cjk-earthly-branch',
      'cjk-ideographic',
      'devanagari',
      'ethiopic-numeric',
      'georgian',
      'gujarati',
      'gurmukhi',
      'hebrew',
      'hiragana',
      'hiragana-iroha',
      'japanese-formal',
      'japanese-informal',
      'kannada',
      'katakana',
      'katakana-iroha',
      'khmer',
      'korean-hangul-formal',
      'korean-hanja-formal',
      'korean-hanja-informal',
      'lao',
      'lower-armenian',
      'malayalam',
      'mongolian',
      'myanmar',
      'oriya',
      'persian',
      'simp-chinese-formal',
      'simp-chinese-informal',
      'tamil',
      'telugu',
      'thai',
      'tibetan',
      'trad-chinese-formal',
      'trad-chinese-informal',
      'upper-armenian',
      'disclosure-open',
      'disclosure-closed',
      // Non-standard extensions (without prefixe)
      'ethiopic-halehame',
      'ethiopic-halehame-am',
      'ethiopic-halehame-ti-er',
      'ethiopic-halehame-ti-et',
      'hangul',
      'hangul-consonant',
      'urdu']);


      keywordSets.listStylePositionKeywords = uniteSets(keywordSets.basicKeywords, ['inside', 'outside']);

      keywordSets.listStyleImageKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.listStyleShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.listStyleTypeKeywords,
      keywordSets.listStylePositionKeywords,
      keywordSets.listStyleImageKeywords);


      keywordSets.fontStyleKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'italic',
      'oblique']);


      keywordSets.fontVariantKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'none',
      'historical-forms',
      'none',
      'common-ligatures',
      'no-common-ligatures',
      'discretionary-ligatures',
      'no-discretionary-ligatures',
      'historical-ligatures',
      'no-historical-ligatures',
      'contextual',
      'no-contextual',
      'small-caps',
      'small-caps',
      'all-small-caps',
      'petite-caps',
      'all-petite-caps',
      'unicase',
      'titling-caps',
      'lining-nums',
      'oldstyle-nums',
      'proportional-nums',
      'tabular-nums',
      'diagonal-fractions',
      'stacked-fractions',
      'ordinal',
      'slashed-zero',
      'jis78',
      'jis83',
      'jis90',
      'jis04',
      'simplified',
      'traditional',
      'full-width',
      'proportional-width',
      'ruby']);


      keywordSets.fontStretchKeywords = uniteSets(keywordSets.basicKeywords, [
      'semi-condensed',
      'condensed',
      'extra-condensed',
      'ultra-condensed',
      'semi-expanded',
      'expanded',
      'extra-expanded',
      'ultra-expanded']);


      keywordSets.fontSizeKeywords = uniteSets(keywordSets.basicKeywords, [
      'xx-small',
      'x-small',
      'small',
      'medium',
      'large',
      'x-large',
      'xx-large',
      'larger',
      'smaller']);


      keywordSets.lineHeightKeywords = uniteSets(keywordSets.basicKeywords, ['normal']);

      keywordSets.fontShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontStyleKeywords,
      keywordSets.fontVariantKeywords,
      keywordSets.fontWeightKeywords,
      keywordSets.fontStretchKeywords,
      keywordSets.fontSizeKeywords,
      keywordSets.lineHeightKeywords,
      keywordSets.fontFamilyKeywords);


      keywordSets.keyframeSelectorKeywords = new Set(['from', 'to']);

      // https://www.w3.org/TR/css-page-3/#syntax-page-selector
      keywordSets.pageMarginAtRules = new Set([
      'top-left-corner',
      'top-left',
      'top-center',
      'top-right',
      'top-right-corner',
      'bottom-left-corner',
      'bottom-left',
      'bottom-center',
      'bottom-right',
      'bottom-right-corner',
      'left-top',
      'left-middle',
      'left-bottom',
      'right-top',
      'right-middle',
      'right-bottom']);


      // https://developer.mozilla.org/en/docs/Web/CSS/At-rule
      keywordSets.atRules = uniteSets(keywordSets.pageMarginAtRules, [
      'annotation',
      'apply',
      'character-variant',
      'charset',
      'counter-style',
      'custom-media',
      'custom-selector',
      'document',
      'font-face',
      'font-feature-values',
      'import',
      'keyframes',
      'layer',
      'media',
      'namespace',
      'nest',
      'ornaments',
      'page',
      'property',
      'styleset',
      'stylistic',
      'supports',
      'swash',
      'viewport']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.deprecatedMediaFeatureNames = new Set([
      'device-aspect-ratio',
      'device-height',
      'device-width',
      'max-device-aspect-ratio',
      'max-device-height',
      'max-device-width',
      'min-device-aspect-ratio',
      'min-device-height',
      'min-device-width']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.mediaFeatureNames = uniteSets(keywordSets.deprecatedMediaFeatureNames, [
      'any-hover',
      'any-pointer',
      'aspect-ratio',
      'color',
      'color-gamut',
      'color-index',
      'display-mode',
      'dynamic-range',
      'forced-colors',
      'grid',
      'height',
      'hover',
      'inverted-colors',
      'light-level',
      'max-aspect-ratio',
      'max-color',
      'max-color-index',
      'max-height',
      'max-monochrome',
      'max-resolution',
      'max-width',
      'min-aspect-ratio',
      'min-color',
      'min-color-index',
      'min-height',
      'min-monochrome',
      'min-resolution',
      'min-width',
      'monochrome',
      'orientation',
      'overflow-block',
      'overflow-inline',
      'pointer',
      'prefers-color-scheme',
      'prefers-contrast',
      'prefers-reduced-motion',
      'prefers-reduced-transparency',
      'resolution',
      'scan',
      'scripting',
      'update',
      'video-dynamic-range',
      'width']);


      // https://www.w3.org/TR/CSS22/ui.html#system-colors
      keywordSets.systemColors = new Set([
      'activeborder',
      'activecaption',
      'appworkspace',
      'background',
      'buttonface',
      'buttonhighlight',
      'buttonshadow',
      'buttontext',
      'captiontext',
      'graytext',
      'highlight',
      'highlighttext',
      'inactiveborder',
      'inactivecaption',
      'inactivecaptiontext',
      'infobackground',
      'infotext',
      'menu',
      'menutext',
      'scrollbar',
      'threeddarkshadow',
      'threedface',
      'threedhighlight',
      'threedlightshadow',
      'threedshadow',
      'window',
      'windowframe',
      'windowtext']);


      // typecasting htmlTags to be more generic; see https://github.com/stylelint/stylelint/pull/6013 for discussion
      /** @type {Set<string>} */
      keywordSets.standardHtmlTags = new Set(htmlTags);

      // htmlTags includes only "standard" tags. So we augment it with older tags etc.
      keywordSets.nonStandardHtmlTags = new Set([
      'acronym',
      'applet',
      'basefont',
      'big',
      'blink',
      'center',
      'content',
      'dir',
      'font',
      'frame',
      'frameset',
      'hgroup',
      'isindex',
      'keygen',
      'listing',
      'marquee',
      'nobr',
      'noembed',
      'plaintext',
      'spacer',
      'strike',
      'tt',
      'xmp']);


      keywordSets.validMixedCaseSvgElements = new Set([
      'altGlyph',
      'altGlyphDef',
      'altGlyphItem',
      'animateColor',
      'animateMotion',
      'animateTransform',
      'clipPath',
      'feBlend',
      'feColorMatrix',
      'feComponentTransfer',
      'feComposite',
      'feConvolveMatrix',
      'feDiffuseLighting',
      'feDisplacementMap',
      'feDistantLight',
      'feDropShadow',
      'feFlood',
      'feFuncA',
      'feFuncB',
      'feFuncG',
      'feFuncR',
      'feGaussianBlur',
      'feImage',
      'feMerge',
      'feMergeNode',
      'feMorphology',
      'feOffset',
      'fePointLight',
      'feSpecularLighting',
      'feSpotLight',
      'feTile',
      'feTurbulence',
      'foreignObject',
      'glyphRef',
      'linearGradient',
      'radialGradient',
      'textPath']);


      /**
       * @param {(string[] | Set<string>)[]} args
       */
      function uniteSets(...args) {
        return new Set([...args].reduce((result, set) => [...result, ...set], []));
      }

      module.exports = keywordSets;

    }, { "html-tags": 13 }], 108: [function (require, module, exports) {
      'use strict';

      module.exports = ['calc', 'clamp', 'max', 'min'];

    }, {}], 109: [function (require, module, exports) {
      'use strict';

      const propertySets = {};

      propertySets.acceptCustomIdents = new Set([
      'animation',
      'animation-name',
      'font',
      'font-family',
      'counter-increment',
      'grid-row',
      'grid-column',
      'grid-area',
      'list-style',
      'list-style-type']);


      module.exports = propertySets;

    }, {}], 110: [function (require, module, exports) {
      'use strict';

      /** @type {Record<string, string[]>} */
      module.exports = {
        margin: ['margin-top', 'margin-bottom', 'margin-left', 'margin-right'],
        padding: ['padding-top', 'padding-bottom', 'padding-left', 'padding-right'],
        background: [
        'background-image',
        'background-size',
        'background-position',
        'background-repeat',
        'background-origin',
        'background-clip',
        'background-attachment',
        'background-color'],

        font: [
        'font-style',
        'font-variant',
        'font-weight',
        'font-stretch',
        'font-size',
        'font-family',
        'line-height'],

        border: [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width',
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style',
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'border-top': ['border-top-width', 'border-top-style', 'border-top-color'],
        'border-bottom': ['border-bottom-width', 'border-bottom-style', 'border-bottom-color'],
        'border-left': ['border-left-width', 'border-left-style', 'border-left-color'],
        'border-right': ['border-right-width', 'border-right-style', 'border-right-color'],
        'border-width': [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width'],

        'border-style': [
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style'],

        'border-color': [
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'list-style': ['list-style-type', 'list-style-position', 'list-style-image'],
        'border-radius': [
        'border-top-right-radius',
        'border-top-left-radius',
        'border-bottom-right-radius',
        'border-bottom-left-radius'],

        transition: [
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'],

        animation: [
        'animation-name',
        'animation-duration',
        'animation-timing-function',
        'animation-delay',
        'animation-iteration-count',
        'animation-direction',
        'animation-fill-mode',
        'animation-play-state'],

        'border-block-end': [
        'border-block-end-width',
        'border-block-end-style',
        'border-block-end-color'],

        'border-block-start': [
        'border-block-start-width',
        'border-block-start-style',
        'border-block-start-color'],

        'border-image': [
        'border-image-source',
        'border-image-slice',
        'border-image-width',
        'border-image-outset',
        'border-image-repeat'],

        'border-inline-end': [
        'border-inline-end-width',
        'border-inline-end-style',
        'border-inline-end-color'],

        'border-inline-start': [
        'border-inline-start-width',
        'border-inline-start-style',
        'border-inline-start-color'],

        'column-rule': ['column-rule-width', 'column-rule-style', 'column-rule-color'],
        columns: ['column-width', 'column-count'],
        flex: ['flex-grow', 'flex-shrink', 'flex-basis'],
        'flex-flow': ['flex-direction', 'flex-wrap'],
        grid: [
        'grid-template-rows',
        'grid-template-columns',
        'grid-template-areas',
        'grid-auto-rows',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-column-gap',
        'grid-row-gap'],

        'grid-area': ['grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end'],
        'grid-column': ['grid-column-start', 'grid-column-end'],
        'grid-gap': ['grid-row-gap', 'grid-column-gap'],
        'grid-row': ['grid-row-start', 'grid-row-end'],
        'grid-template': ['grid-template-columns', 'grid-template-rows', 'grid-template-areas'],
        outline: ['outline-color', 'outline-style', 'outline-width'],
        'text-decoration': ['text-decoration-color', 'text-decoration-style', 'text-decoration-line'],
        'text-emphasis': ['text-emphasis-style', 'text-emphasis-color'],
        mask: [
        'mask-image',
        'mask-mode',
        'mask-position',
        'mask-size',
        'mask-repeat',
        'mask-origin',
        'mask-clip',
        'mask-composite'] };



    }, {}], 111: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisabledRange */
      /** @typedef {import('stylelint').LintResult} StylelintResult */
      /** @typedef {import('stylelint').ConfigRuleSettings<any, Object>} StylelintConfigRuleSettings */

      /**
       * Returns a report describing which `results` (if any) contain disabled ranges
       * for rules that disallow disables via `reportDisables: true`.
       *
       * @param {StylelintResult[]} results
       */
      module.exports = function (results) {
        for (const result of results) {
          // File with `CssSyntaxError` don't have `_postcssResult`s.
          if (!result._postcssResult) {
            continue;
          }

          /** @type {{[ruleName: string]: Array<RangeType>}} */
          const rangeData = result._postcssResult.stylelint.disabledRanges;

          if (!rangeData) continue;

          const config = result._postcssResult.stylelint.config;

          if (!config || !config.rules) continue;

          // If no rules actually disallow disables, don't bother looking for ranges
          // that correspond to disabled rules.
          if (!Object.values(config.rules).some(rule => reportDisablesForRule(rule))) {
            continue;
          }

          for (const [rule, ranges] of Object.entries(rangeData)) {
            for (const range of ranges) {
              if (!reportDisablesForRule(config.rules[rule] || [])) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Rule "${rule}" may not be disabled`,
                rule: 'reportDisables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                endLine: range.comment.source.end && range.comment.source.end.line,
                endColumn: range.comment.source.end && range.comment.source.end.column,
                severity: 'error' });

            }
          }
        }
      };

      /**
       * @param {StylelintConfigRuleSettings} options
       * @return {boolean}
       */
      function reportDisablesForRule(options) {
        if (!options || !options[1]) return false;

        return Boolean(options[1].reportDisables);
      }

    }, {}], 112: [function (require, module, exports) {
      'use strict';

      const levenshtein = require('fastest-levenshtein');
      const rules = require('./rules');

      const MAX_LEVENSHTEIN_DISTANCE = 6;
      const MAX_SUGGESTIONS_COUNT = 3;

      /**
       * @param {string} ruleName
       * @return {string[]}
       */
      function extractSuggestions(ruleName) {
        const suggestions = Array.from({ length: MAX_LEVENSHTEIN_DISTANCE });

        for (let i = 0; i < suggestions.length; i++) {
          suggestions[i] = [];
        }

        for (const existRuleName of Object.keys(rules)) {
          const distance = levenshtein.distance(existRuleName, ruleName);

          if (distance <= MAX_LEVENSHTEIN_DISTANCE) {
            suggestions[distance - 1].push(existRuleName);
          }
        }

        /** @type {string[]} */
        let result = [];

        for (const [i, suggestion] of suggestions.entries()) {
          if (suggestion.length > 0) {
            if (i < 3) {
              return suggestion.slice(0, MAX_SUGGESTIONS_COUNT);
            }

            result = result.concat(suggestion);
          }
        }

        return result.slice(0, MAX_SUGGESTIONS_COUNT);
      }

      /**
       * @param {string} ruleName
       * @param {string[]} [suggestions=[]]
       * @return {string}
       */
      function rejectMessage(ruleName, suggestions = []) {
        return `Unknown rule ${ruleName}.${
        suggestions.length > 0 ? ` Did you mean ${suggestions.join(', ')}?` : ''
        }`;
      }

      /** @type {Map<string, string[]>} */
      const cache = new Map();

      /**
       * @param {string} unknownRuleName
       * @param {import('postcss').Root} postcssRoot
       * @param {import('stylelint').PostcssResult} postcssResult
       * @returns {void}
       */
      module.exports = function reportUnknownRuleNames(unknownRuleName, postcssRoot, postcssResult) {
        const suggestions = cache.has(unknownRuleName) ?
        /** @type {string[]} */cache.get(unknownRuleName) :
        extractSuggestions(unknownRuleName);

        cache.set(unknownRuleName, suggestions);
        postcssResult.warn(rejectMessage(unknownRuleName, suggestions), {
          severity: 'error',
          rule: unknownRuleName,
          node: postcssRoot,
          index: 0 });

      };

    }, { "./rules": 205, "fastest-levenshtein": 11 }], 113: [function (require, module, exports) {
      'use strict';

      const createStylelint = require('./createStylelint');
      const path = require('path');

      /**
       * Resolves the effective configuation for a given file. Resolves to `undefined`
       * if no config is found.
       * @param {string} filePath - The path to the file to get the config for.
       * @param {Pick<
       *   import('stylelint').LinterOptions,
       *   | 'cwd'
       *   | 'config'
       *   | 'configBasedir'
       *   | 'configFile'
       * >} [options] - The options to use when creating the Stylelint instance.
       * @returns {Promise<import('stylelint').Config | undefined>}
       */
      module.exports = async function resolveConfig(
      filePath,
      { cwd = process.cwd(), config, configBasedir, configFile } = {})
      {
        if (!filePath) {
          return undefined;
        }

        const stylelint = createStylelint({
          config,
          configFile,
          configBasedir,
          cwd });


        const absoluteFilePath = !path.isAbsolute(filePath) ?
        path.join(cwd, filePath) :
        path.normalize(filePath);

        const configSearchPath = stylelint._options.configFile || absoluteFilePath;

        const resolved = await stylelint.getConfigForFile(configSearchPath, absoluteFilePath);

        if (!resolved) {
          return undefined;
        }

        return resolved.config;
      };

    }, { "./createStylelint": 93, "path": undefined }], 114: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString, assert } = require('../../utils/validateTypes');

      const ruleName = 'alpha-value-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/alpha-value-notation' };


      const ALPHA_PROPS = new Set(['opacity', 'shape-image-threshold']);
      const ALPHA_FUNCS = new Set(['hsl', 'hsla', 'hwb', 'lab', 'lch', 'rgb', 'rgba']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['number', 'percentage'] },

          {
            actual: secondaryOptions,
            possible: {
              exceptProperties: [isString, isRegExp] },

            optional: true });



          if (!validOptions) return;

          const optionFuncs = Object.freeze({
            number: {
              expFunc: isNumber,
              fixFunc: asNumber },

            percentage: {
              expFunc: isPercentage,
              fixFunc: asPercentage } });



          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              /** @type {import('postcss-value-parser').Node | undefined} */
              let alpha;

              if (ALPHA_PROPS.has(decl.prop.toLowerCase())) {
                alpha = findAlphaInValue(node);
              } else {
                if (node.type !== 'function') return;

                if (!ALPHA_FUNCS.has(node.value.toLowerCase())) return;

                alpha = findAlphaInFunction(node);
              }

              if (!alpha) return;

              const { value } = alpha;

              if (!isStandardSyntaxValue(value)) return;

              if (!isNumber(value) && !isPercentage(value)) return;

              /** @type {'number' | 'percentage'} */
              let expectation = primary;

              if (optionsMatches(secondaryOptions, 'exceptProperties', decl.prop)) {
                if (expectation === 'number') {
                  expectation = 'percentage';
                } else if (expectation === 'percentage') {
                  expectation = 'number';
                }
              }

              if (optionFuncs[expectation].expFunc(value)) return;

              const fixed = optionFuncs[expectation].fixFunc(value);
              const unfixed = value;

              if (context.fix) {
                alpha.value = String(fixed);
                needsFix = true;

                return;
              }

              const index = declarationValueIndex(decl) + alpha.sourceIndex;
              const endIndex = index + alpha.value.length;

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} value
       * @returns {string}
       */
      function asPercentage(value) {
        const number = Number(value);

        return `${Number((number * 100).toPrecision(3))}%`;
      }

      /**
       * @param {string} value
       * @returns {string}
       */
      function asNumber(value) {
        const dimension = valueParser.unit(value);

        assert(dimension);

        const number = Number(dimension.number);

        return Number((number / 100).toPrecision(3)).toString();
      }

      /**
       * @template {import('postcss-value-parser').Node} T
       * @param {T} node
       * @returns {T | undefined}
       */
      function findAlphaInValue(node) {
        return node.type === 'word' || node.type === 'function' ? node : undefined;
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       * @returns {import('postcss-value-parser').Node | undefined}
       */
      function findAlphaInFunction(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');

        if (args.length === 4) return args[3];

        const slashNodeIndex = node.nodes.findIndex(({ type, value }) => type === 'div' && value === '/');

        if (slashNodeIndex !== -1) {
          const nodesAfterSlash = node.nodes.slice(slashNodeIndex + 1, node.nodes.length);

          return nodesAfterSlash.find(({ type }) => type === 'word');
        }

        return undefined;
      }

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function isPercentage(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '%';
      }

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function isNumber(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isStandardSyntaxValue": 395, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 115: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-allowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (primaryValues.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName,
              word: `@${name}` });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 382, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 116: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-disallowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (!primaryValues.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName,
              word: `@${atRule.name}` });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 382, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 117: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterBlocklessAtRule');
      const isBlocklessAtRuleAfterSameNameBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before at-rule',
        rejected: 'Unexpected empty line before at-rule' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-empty-line-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: [
              'after-same-name',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless',
              'first-nested'],

              ignore: [
              'after-comment',
              'first-nested',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless'],

              ignoreAtRules: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /** @type {'always' | 'never'} */
          const expectation = primary;

          root.walkAtRules(atRule => {
            const isNested = atRule.parent && atRule.parent.type !== 'root';

            // Ignore the first node
            if (isFirstNodeOfRoot(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            if (
            optionsMatches(secondaryOptions, 'ignore', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(atRule)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            // and following another blockless at-rule with the same name
            if (
            optionsMatches(secondaryOptions, 'ignore', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the expectation if the node is inside a block
            if (optionsMatches(secondaryOptions, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(atRule)) {
              return;
            }

            const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);
            let expectEmptyLineBefore = expectation === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'after-same-name') &&
            isAtRuleAfterSameNameAtRule(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'inside-block') && isNested ||
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix && context.newline) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(atRule, context.newline);
              } else {
                removeEmptyLinesBefore(atRule, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: atRule, result, ruleName });
          });
        };
      };

      /**
       * @param {import('postcss').AtRule} atRule
       */
      function isAtRuleAfterSameNameAtRule(atRule) {
        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        // @ts-expect-error -- TS2339: Property 'name' does not exist on type 'Node'.
        return previousNode && previousNode.type === 'atrule' && previousNode.name === atRule.name;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 320, "../../utils/getPreviousNonSharedLineCommentNode": 344, "../../utils/hasEmptyLine": 350, "../../utils/isAfterComment": 356, "../../utils/isBlocklessAtRuleAfterBlocklessAtRule": 359, "../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule": 360, "../../utils/isFirstNested": 369, "../../utils/isFirstNodeOfRoot": 370, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesBefore": 408, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 118: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-name-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          /** @type {'lower' | 'upper'} */
          const expectation = primary;

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            const expectedName = expectation === 'lower' ? name.toLowerCase() : name.toUpperCase();

            if (name === expectedName) {
              return;
            }

            if (context.fix) {
              atRule.name = expectedName;

              return;
            }

            report({
              message: messages.expected(name, expectedName),
              node: atRule,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 382, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 119: [function (require, module, exports) {
      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected newline after at-rule name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-name-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../atRuleNameSpaceChecker": 125 }], 120: [function (require, module, exports) {
      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected single space after at-rule name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-name-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            atRule => {
              if (typeof atRule.raws.afterName === 'string') {
                atRule.raws.afterName = atRule.raws.afterName.replace(/^\s*/, ' ');
              }
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../atRuleNameSpaceChecker": 125 }], 121: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: atRule => `Unexpected unknown at-rule "${atRule}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            // Return early if at-rule is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
              return;
            }

            if (vendor.prefix(name) || keywordSets.atRules.has(name.toLowerCase())) {
              return;
            }

            const atName = `@${name}`;

            report({
              message: messages.rejected(atName),
              node: atRule,
              ruleName,
              result,
              word: atName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 122: [function (require, module, exports) {
      'use strict';

      const flattenArray = require('../../utils/flattenArray');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-property-required-list';

      const messages = ruleMessages(ruleName, {
        expected: (property, atRule) => `Expected property "${property}" for at-rule "${atRule}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-property-required-list' };


      /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString)] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const { name, nodes } = atRule;
            const atRuleName = name.toLowerCase();
            const propList = flattenArray(primary[atRuleName]);

            if (!propList) {
              return;
            }

            for (const property of propList) {
              const propertyName = property.toLowerCase();

              const hasProperty = nodes.find(
              node => node.type === 'decl' && node.prop.toLowerCase() === propertyName);


              if (hasProperty) {
                continue;
              }

              report({
                message: messages.expected(propertyName, atRuleName),
                node: atRule,
                result,
                ruleName });

              continue;
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/flattenArray": 335, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 123: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-semicolon-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const nextNode = atRule.next();

            if (!nextNode) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              err: msg => {
                if (context.fix) {
                  nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                } else {
                  report({
                    message: msg,
                    node: atRule,
                    index: atRule.toString().length + 1,
                    result,
                    ruleName });

                }
              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/hasBlock": 348, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/nextNonCommentNode": 401, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 124: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/at-rule-semicolon-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const nodeString = rawNodeString(atRule);

            checker.before({
              source: nodeString,
              index: nodeString.length,
              err: m => {
                report({
                  message: m,
                  node: atRule,
                  index: nodeString.length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/hasBlock": 348, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 125: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../utils/isStandardSyntaxAtRule');
      const report = require('../utils/report');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void, errTarget: string }) => void,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       *   fix?: ((atRule: import('postcss').AtRule) => void) | null,
       * }} options
       */
      module.exports = function atRuleNameSpaceChecker(options) {
        options.root.walkAtRules(atRule => {
          if (!isStandardSyntaxAtRule(atRule)) {
            return;
          }

          checkColon(
          `@${atRule.name}${atRule.raws.afterName || ''}${atRule.params}`,
          atRule.name.length,
          atRule);

        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkColon(source, index, node) {
          options.locationChecker({
            source,
            index,
            err: m => {
              if (options.fix) {
                options.fix(node);

                return;
              }

              report({
                message: m,
                node,
                index,
                result: options.result,
                ruleName: options.checkedRuleName });

            },
            errTarget: `@${node.name}` });

        }
      };

    }, { "../utils/isStandardSyntaxAtRule": 382, "../utils/report": 409 }], 126: [function (require, module, exports) {
      'use strict';

      const addEmptyLineAfter = require('../../utils/addEmptyLineAfter');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesAfter = require('../../utils/removeEmptyLinesAfter');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before closing brace',
        rejected: 'Unexpected empty line before closing brace' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-closing-brace-empty-line-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always-multi-line', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['after-closing-brace'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Get whitespace after ""}", ignoring extra semicolon
            const before = (statement.raws.after || '').replace(/;+/, '');

            // Calculate index
            const statementString = statement.toString();
            let index = statementString.length - 1;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // Set expectation
            const expectEmptyLineBefore = (() => {
              const childNodeTypes = statement.nodes.map(item => item.type);

              // Reverse the primary options if `after-closing-brace` is set
              if (
              optionsMatches(secondaryOptions, 'except', 'after-closing-brace') &&
              statement.type === 'atrule' &&
              !childNodeTypes.includes('decl'))
              {
                return primary === 'never';
              }

              return primary === 'always-multi-line' && !isSingleLineString(blockString(statement));
            })();

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            if (context.fix) {
              const { newline } = context;

              if (typeof newline !== 'string') return;

              if (expectEmptyLineBefore) {
                addEmptyLineAfter(statement, newline);
              } else {
                removeEmptyLinesAfter(statement, newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              result,
              ruleName,
              node: statement,
              index });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineAfter": 319, "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/hasEmptyLine": 350, "../../utils/isSingleLineString": 381, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesAfter": 407, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 127: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'block-closing-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "}"',
        expectedAfterSingleLine: () => 'Expected newline after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected newline after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-closing-brace-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            if (!hasBlock(statement)) {
              return;
            }

            if (
            statement.type === 'atrule' &&
            optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name))
            {
              return;
            }

            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            // Allow an end-of-line comment x spaces after the brace
            const nextNodeIsSingleLineComment =
            nextNode.type === 'comment' &&
            !/[^ ]/.test(nextNode.raws.before || '') &&
            !nextNode.toString().includes('\n');

            const nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;

            if (!nodeToCheck) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nodeToCheck);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            // Only check one after, because there might be other
            // spaces handled by the indentation rule
            checker.afterOneOnly({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                if (context.fix) {
                  const nodeToCheckRaws = nodeToCheck.raws;

                  if (typeof nodeToCheckRaws.before !== 'string') return;

                  if (primary.startsWith('always')) {
                    const index = nodeToCheckRaws.before.search(/\r?\n/);

                    nodeToCheckRaws.before =
                    index >= 0 ?
                    nodeToCheckRaws.before.slice(index) :
                    context.newline + nodeToCheckRaws.before;

                    return;
                  }

                  if (primary.startsWith('never')) {
                    nodeToCheckRaws.before = '';

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/optionsMatches": 403, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/whitespaceChecker": 420 }], 128: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: 'Expected newline before "}"',
        expectedBeforeMultiLine: 'Expected newline before "}" of a multi-line block',
        rejectedBeforeMultiLine: 'Unexpected whitespace before "}" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-closing-brace-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Ignore extra semicolon
            const after = (statement.raws.after || '').replace(/;+/, '');

            if (after === undefined) {
              return;
            }

            const blockIsMultiLine = !isSingleLineString(blockString(statement));
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // We're really just checking whether a
            // newline *starts* the block's final space -- between
            // the last declaration and the closing brace. We can
            // ignore any other whitespace between them, because that
            // will be checked by the indentation rule.
            if (!after.startsWith('\n') && !after.startsWith('\r\n')) {
              if (primary === 'always') {
                complain(messages.expectedBefore);
              } else if (blockIsMultiLine && primary === 'always-multi-line') {
                complain(messages.expectedBeforeMultiLine);
              }
            }

            if (after !== '' && blockIsMultiLine && primary === 'never-multi-line') {
              complain(messages.rejectedBeforeMultiLine);
            }

            /**
             * @param {string} message
             */
            function complain(message) {
              if (context.fix) {
                const statementRaws = statement.raws;

                if (typeof statementRaws.after !== 'string') return;

                if (primary.startsWith('always')) {
                  const firstWhitespaceIndex = statementRaws.after.search(/\s/);
                  const newlineBefore =
                  firstWhitespaceIndex >= 0 ?
                  statementRaws.after.slice(0, firstWhitespaceIndex) :
                  statementRaws.after;
                  const newlineAfter =
                  firstWhitespaceIndex >= 0 ? statementRaws.after.slice(firstWhitespaceIndex) : '';
                  const newlineIndex = newlineAfter.search(/\r?\n/);

                  statementRaws.after =
                  newlineIndex >= 0 ?
                  newlineBefore + newlineAfter.slice(newlineIndex) :
                  newlineBefore + context.newline + newlineAfter;

                  return;
                }

                if (primary === 'never-multi-line') {
                  statementRaws.after = statementRaws.after.replace(/\s/g, '');

                  return;
                }
              }

              report({
                message,
                result,
                ruleName,
                node: statement,
                index });

            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/isSingleLineString": 381, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 129: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "}"',
        rejectedAfter: () => 'Unexpected whitespace after "}"',
        expectedAfterSingleLine: () => 'Expected single space after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-closing-brace-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('space', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nextNode);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            checker.after({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 130: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "}"',
        rejectedBefore: () => 'Unexpected whitespace before "}"',
        expectedBeforeSingleLine: () => 'Expected single space before "}" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "}" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "}" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "}" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-closing-brace-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = blockString(statement);
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length - 1,
              err: msg => {
                if (context.fix) {
                  const statementRaws = statement.raws;

                  if (typeof statementRaws.after !== 'string') return;

                  if (primary.startsWith('always')) {
                    statementRaws.after = statementRaws.after.replace(/\s*$/, ' ');

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementRaws.after = statementRaws.after.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 131: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean } = require('../../utils/validateTypes');

      const ruleName = 'block-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-no-empty' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isBoolean },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            if (!hasEmptyBlock(statement) && !ignoreComments) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            const hasCommentsOnly = statement.nodes.every(node => node.type === 'comment');

            if (!hasCommentsOnly) {
              return;
            }

            let index = beforeBlockString(statement, { noRawBefore: true }).length;

            // For empty blocks when using SugarSS parser
            if (statement.raws.between === undefined) {
              index--;
            }

            report({
              message: messages.rejected,
              node: statement,
              start: statement.positionBy({ index }),
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 132: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "{"',
        expectedAfterMultiLine: () => 'Expected newline after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-opening-brace-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'rules', 'always-multi-line', 'never-multi-line'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['rules'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          if (!optionsMatches(secondaryOptions, 'ignore', 'rules')) {
            root.walkRules(check);
          }

          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const backupCommentNextBefores = new Map();

            /**
             * next node with checking newlines after comment
             *
             * @param {import('postcss').ChildNode | undefined} startNode
             * @returns {import('postcss').ChildNode | undefined}
             */
            function nextNode(startNode) {
              if (!startNode || !startNode.next) return;

              if (startNode.type === 'comment') {
                const reNewLine = /\r?\n/;
                const newLineMatch = reNewLine.test(startNode.raws.before || '');

                const next = startNode.next();

                if (next && newLineMatch && !reNewLine.test(next.raws.before || '')) {
                  backupCommentNextBefores.set(next, next.raws.before);
                  next.raws.before = startNode.raws.before;
                }

                return nextNode(next);
              }

              return startNode;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNode(statement.first);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  const nodeToCheckRaws = nodeToCheck.raws;

                  if (typeof nodeToCheckRaws.before !== 'string') return;

                  if (primary.startsWith('always')) {
                    const index = nodeToCheckRaws.before.search(/\r?\n/);

                    nodeToCheckRaws.before =
                    index >= 0 ?
                    nodeToCheckRaws.before.slice(index) :
                    context.newline + nodeToCheckRaws.before;

                    backupCommentNextBefores.delete(nodeToCheck);

                    return;
                  }

                  if (primary === 'never-multi-line') {
                    // Restore the `before` of the node next to the comment node.
                    for (const [node, before] of backupCommentNextBefores.entries()) {
                      node.raws.before = before;
                    }

                    backupCommentNextBefores.clear();

                    // Fix
                    const reNewLine = /\r?\n/;
                    let fixTarget = statement.first;

                    while (fixTarget) {
                      const fixTargetRaws = fixTarget.raws;

                      if (typeof fixTargetRaws.before !== 'string') continue;

                      if (reNewLine.test(fixTargetRaws.before || '')) {
                        fixTargetRaws.before = fixTargetRaws.before.replace(/\r?\n/g, '');
                      }

                      if (fixTarget.type !== 'comment') {
                        break;
                      }

                      fixTarget = fixTarget.next();
                    }

                    nodeToCheckRaws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });


            // Restore the `before` of the node next to the comment node.
            for (const [node, before] of backupCommentNextBefores.entries()) {
              node.raws.before = before;
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/optionsMatches": 403, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 133: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before "{"',
        expectedBeforeSingleLine: () => 'Expected newline before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected newline before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-opening-brace-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.beforeAllowingIndentation({
              lineCheckStr: blockString(statement),
              source,
              index: source.length,
              err: m => {
                if (context.fix) {
                  const statementRaws = statement.raws;

                  if (typeof statementRaws.between !== 'string') return;

                  if (primary.startsWith('always')) {
                    const spaceIndex = statementRaws.between.search(/\s+$/);

                    if (spaceIndex >= 0) {
                      statement.raws.between =
                      statementRaws.between.slice(0, spaceIndex) +
                      context.newline +
                      statementRaws.between.slice(spaceIndex);
                    } else {
                      statementRaws.between += context.newline;
                    }

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementRaws.between = statementRaws.between.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 134: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "{"',
        rejectedAfter: () => 'Unexpected whitespace after "{"',
        expectedAfterSingleLine: () => 'Expected single space after "{" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "{" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-opening-brace-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: secondaryOptions,
            possible: {
              ignore: ['at-rules'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);

          if (!optionsMatches(secondaryOptions, 'ignore', 'at-rules')) {
            root.walkAtRules(check);
          }

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            checker.after({
              source: blockString(statement),
              index: 0,
              err: m => {
                if (context.fix) {
                  const statementFirst = statement.first;

                  if (statementFirst == null) return;

                  if (primary.startsWith('always')) {
                    statementFirst.raws.before = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementFirst.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 135: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'block-opening-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "{"',
        rejectedBefore: () => 'Unexpected whitespace before "{"',
        expectedBeforeSingleLine: () => 'Expected single space before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/block-opening-brace-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString, isRegExp],
              ignoreSelectors: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (
            statement.type === 'atrule' &&
            optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name))
            {
              return;
            }

            // Return early if selector is to be ignored
            if (
            statement.type === 'rule' &&
            optionsMatches(secondaryOptions, 'ignoreSelectors', statement.selector))
            {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    statement.raws.between = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statement.raws.between = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/blockString": 325, "../../utils/hasBlock": 348, "../../utils/hasEmptyBlock": 349, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/whitespaceChecker": 420 }], 136: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxColorFunction = require('../../utils/isStandardSyntaxColorFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const { isValueFunction } = require('../../utils/typeGuards');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-function-notation';

      const messages = ruleMessages(ruleName, {
        expected: primary => `Expected ${primary} color-function notation` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-function-notation' };


      const LEGACY_FUNCS = new Set(['rgba', 'hsla']);
      const LEGACY_NOTATION_FUNCS = new Set(['rgb', 'rgba', 'hsl', 'hsla']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['modern', 'legacy'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (!isValueFunction(node)) return;

              if (!isStandardSyntaxColorFunction(node)) return;

              const { value, sourceIndex, sourceEndIndex, nodes } = node;

              if (!LEGACY_NOTATION_FUNCS.has(value.toLowerCase())) return;

              if (primary === 'modern' && !hasCommas(node)) return;

              if (primary === 'legacy' && hasCommas(node)) return;

              if (context.fix && primary === 'modern') {
                let commaCount = 0;

                // Convert punctuation
                node.nodes = nodes.map(childNode => {
                  if (isComma(childNode)) {
                    // Non-alpha commas to space and alpha commas to slashes
                    if (commaCount < 2) {
                      // @ts-expect-error -- TS2322: Type '"space"' is not assignable to type '"div"'.
                      childNode.type = 'space';
                      childNode.value = atLeastOneSpace(childNode.after);
                      commaCount++;
                    } else {
                      childNode.value = '/';
                      childNode.before = atLeastOneSpace(childNode.before);
                      childNode.after = atLeastOneSpace(childNode.after);
                    }
                  }

                  return childNode;
                });

                // Remove trailing 'a' from legacy function name
                if (LEGACY_FUNCS.has(node.value.toLowerCase())) {
                  node.value = node.value.slice(0, -1);
                }

                needsFix = true;

                return;
              }

              const index = declarationValueIndex(decl) + sourceIndex;
              const endIndex = index + (sourceEndIndex - sourceIndex);

              report({
                message: messages.expected(primary),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} whitespace
       */
      function atLeastOneSpace(whitespace) {
        return whitespace !== '' ? whitespace : ' ';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {node is import('postcss-value-parser').DivNode}
       */
      function isComma(node) {
        return node.type === 'div' && node.value === ',';
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       */
      function hasCommas(node) {
        return node.nodes && node.nodes.some(childNode => isComma(childNode));
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isStandardSyntaxColorFunction": 383, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 137: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'color-hex-alpha';

      const messages = ruleMessages(ruleName, {
        expected: hex => `Expected alpha channel in "${hex}"`,
        unexpected: hex => `Unexpected alpha channel in "${hex}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-hex-alpha' };


      const HEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            const parsedValue = valueParser(decl.value);

            parsedValue.walk(node => {
              if (isUrlFunction(node)) return false;

              if (!isHexColor(node)) return;

              const { value } = node;

              if (primary === 'always' && hasAlphaChannel(value)) return;

              if (primary === 'never' && !hasAlphaChannel(value)) return;

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + value.length;

              report({
                message: primary === 'never' ? messages.unexpected(value) : messages.expected(value),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isUrlFunction({ type, value }) {
        return type === 'function' && value === 'url';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      /**
       * @param {string} hex
       */
      function hasAlphaChannel(hex) {
        return hex.length === 5 || hex.length === 9;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 138: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-hex-case' };


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));
            let needsFix = false;

            parsedValue.walk(node => {
              const { value } = node;

              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              const expected = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

              if (value === expected) return;

              if (context.fix) {
                node.value = expected;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(value, expected),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 139: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-length';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-hex-length' };


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['short', 'long'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));
            let needsFix = false;

            parsedValue.walk(node => {
              const { value: hexValue } = node;

              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              if (primary === 'long' && hexValue.length !== 4 && hexValue.length !== 5) {
                return;
              }

              if (primary === 'short' && (hexValue.length < 6 || !canShrink(hexValue))) {
                return;
              }

              const variant = primary === 'long' ? longer : shorter;
              const expectedHex = variant(hexValue);

              if (context.fix) {
                node.value = expectedHex;
                needsFix = true;

                return;
              }

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.expected(hexValue, expectedHex),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} hex
       */
      function canShrink(hex) {
        hex = hex.toLowerCase();

        return (
          hex[1] === hex[2] &&
          hex[3] === hex[4] &&
          hex[5] === hex[6] && (
          hex.length === 7 || hex.length === 9 && hex[7] === hex[8]));

      }

      /**
       * @param {string} hex
       */
      function shorter(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i += 2) {
          hexVariant += hex[i];
        }

        return hexVariant;
      }

      /**
       * @param {string} hex
       */
      function longer(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i++) {
          hexVariant += hex.charAt(i).repeat(2);
        }

        return hexVariant;
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 140: [function (require, module, exports) {
      const { colord, extend } = require('colord');
      const valueParser = require('postcss-value-parser');

      const namesPlugin = require('colord/plugins/names');
      const hwbPlugin = require('colord/plugins/hwb');
      const labPlugin = require('colord/plugins/lab');
      const lchPlugin = require('colord/plugins/lch');

      extend([
      // Type definitions are not compatible with commonjs.
      /** @type {any} */namesPlugin,
      /** @type {any} */hwbPlugin,
      /** @type {any} */labPlugin,
      /** @type {any} */lchPlugin,

      /* Syntaxes that is removed in Color Module Level 4 specification. */

      // hwb() with comma
      (_colordClass, parsers) => {
        parsers.string.push([parseHwbWithCommaString, /** @type {any} */'hwb-with-comma']);
      },
      // gray()
      (_colordClass, parsers) => {
        parsers.string.push([parseGrayString, /** @type {any} */'gray']);
      }]);


      module.exports = {
        colord };


      /**
       * Parses a valid hwb with comma CSS color function
       * https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb()#syntax
       * @type {import('colord/types').ParseFunction<string>}
       */
      function parseHwbWithCommaString(input) {
        input = input.toLowerCase();

        if (!input.startsWith('hwb(') || !input.endsWith(')') || input.includes('/')) {
          return null;
        }

        const [hue, whiteness = '', blackness = '', alpha, ...extraArgs] = input.slice(4, -1).split(',');

        if (!hue || !hue.trim() || !whiteness.trim() || !blackness.trim() || extraArgs.length > 0) {
          return null;
        }

        // Change the delimiter and parse with colord.
        const colordInstance = colord(
        `hwb(${hue} ${whiteness} ${blackness}${alpha ? ` / ${alpha}` : ''})`);


        if (!colordInstance.isValid()) {
          return null;
        }

        return colordInstance.rgba;
      }

      /**
       * Parses a valid gray() CSS color function
       * @type {import('colord/types').ParseFunction<string>}
       */
      function parseGrayString(input) {
        input = input.toLowerCase();

        if (!input.startsWith('gray(') || !input.endsWith(')')) {
          return null;
        }

        const [lightness, alpha, ...extraArgs] = input.slice(5, -1).split(',');

        if (!lightness || extraArgs.length > 0) {
          return null;
        }

        const lightnessWithUnit = valueParser.unit(lightness.trim());

        if (!lightnessWithUnit || !['', '%'].includes(lightnessWithUnit.unit)) {
          return null;
        }

        /**
         * @type {import('colord/types').LabColor | import('colord/types').LabaColor}
         */
        let colorObject = {
          l: Number(lightnessWithUnit.number),
          a: 0,
          b: 0 };


        if (alpha) {
          const alphaWithUnit = valueParser.unit(alpha.trim());

          if (!alphaWithUnit || !['', '%'].includes(alphaWithUnit.unit)) {
            return null;
          }

          colorObject = _extends({},
          colorObject, {
            alpha: Number(alphaWithUnit.number) / (alphaWithUnit.unit ? 100 : 1) });

        }

        return colord(colorObject).rgba;
      }

    }, { "colord": 4, "colord/plugins/hwb": 5, "colord/plugins/lab": 6, "colord/plugins/lch": 7, "colord/plugins/names": 8, "postcss-value-parser": 57 }], 141: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const optionsMatches = require('../../utils/optionsMatches');
      const propertySets = require('../../reference/propertySets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');
      const { colord } = require('./colordUtils');

      const ruleName = 'color-named';

      const messages = ruleMessages(ruleName, {
        expected: (named, original) => `Expected "${original}" to be "${named}"`,
        rejected: named => `Unexpected named color "${named}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-named' };


      // Todo tested on case insensitivity
      const NODE_TYPES = new Set(['word', 'function']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['never', 'always-where-possible'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignore: ['inside-function'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (propertySets.acceptCustomIdents.has(decl.prop)) {
              return;
            }

            // Return early if the property is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreProperties', decl.prop)) {
              return;
            }

            valueParser(decl.value).walk(node => {
              const value = node.value;
              const type = node.type;
              const sourceIndex = node.sourceIndex;

              if (optionsMatches(secondaryOptions, 'ignore', 'inside-function') && type === 'function') {
                return false;
              }

              if (!isStandardSyntaxFunction(node)) {
                return false;
              }

              if (!isStandardSyntaxValue(value)) {
                return;
              }

              // Return early if neither a word nor a function
              if (!NODE_TYPES.has(type)) {
                return;
              }

              // Check for named colors for "never" option
              if (
              primary === 'never' &&
              type === 'word' &&
              /^[a-z]+$/iu.test(value) &&
              value.toLowerCase() !== 'transparent' &&
              colord(value).isValid())
              {
                complain(
                messages.rejected(value),
                decl,
                declarationValueIndex(decl) + sourceIndex,
                value.length);


                return;
              }

              // Check "always-where-possible" option ...
              if (primary !== 'always-where-possible') {
                return;
              }

              let rawColorString = null;
              let colorString = null;

              if (type === 'function') {
                rawColorString = valueParser.stringify(node);

                // First by checking for alternative color function representations ...
                // Remove all spaces to match what's in `representations`
                colorString = rawColorString.replace(/\s*([,/()])\s*/g, '$1').replace(/\s{2,}/g, ' ');
              } else if (type === 'word' && value.startsWith('#')) {
                // Then by checking for alternative hex representations
                rawColorString = colorString = value;
              } else {
                return;
              }

              const color = colord(colorString);

              if (!color.isValid()) {
                return;
              }

              const namedColor = color.toName();

              if (namedColor && namedColor.toLowerCase() !== 'transparent') {
                complain(
                messages.expected(namedColor, colorString),
                decl,
                declarationValueIndex(decl) + sourceIndex,
                rawColorString.length);

              }
            });
          });

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {number} length
           */
          function complain(message, node, index, length) {
            report({
              result,
              ruleName,
              message,
              node,
              index,
              endIndex: index + length });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/propertySets": 109, "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxFunction": 387, "../../utils/isStandardSyntaxValue": 395, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "./colordUtils": 140, "postcss-value-parser": 57 }], 142: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-no-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected hex color "${hex}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-no-hex' };


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 143: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxHexColor = require('../../utils/isStandardSyntaxHexColor');
      const isValidHex = require('../../utils/isValidHex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'color-no-invalid-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected invalid hex color "${hex}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/color-no-invalid-hex' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxHexColor(decl.value)) {
              return;
            }

            valueParser(decl.value).walk(({ value, type, sourceIndex }) => {
              if (type === 'function' && value.endsWith('url')) return false;

              if (type !== 'word') return;

              const hexMatch = /^#[0-9A-Za-z]+/.exec(value);

              if (!hexMatch) return;

              const hexValue = hexMatch[0];

              if (!hexValue || isValidHex(hexValue)) return;

              const index = declarationValueIndex(decl) + sourceIndex;
              const endIndex = index + hexValue.length;

              report({
                message: messages.rejected(hexValue),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxHexColor": 388, "../../utils/isValidHex": 397, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 144: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSharedLineComment = require('../../utils/isSharedLineComment');
      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before comment',
        rejected: 'Unexpected empty line before comment' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/comment-empty-line-before' };


      const stylelintCommandPrefix = 'stylelint-';

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested'],
              ignore: ['stylelint-commands', 'after-comment'],
              ignoreComments: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // Ignore the first node
            if (isFirstNodeOfRoot(comment)) {
              return;
            }

            // Optionally ignore stylelint commands
            if (
            comment.text.startsWith(stylelintCommandPrefix) &&
            optionsMatches(secondaryOptions, 'ignore', 'stylelint-commands'))
            {
              return;
            }

            // Optionally ignore newlines between comments
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(comment)) {
              return;
            }

            // Ignore comments matching the ignoreComments option.
            if (optionsMatches(secondaryOptions, 'ignoreComments', comment.text)) {
              return;
            }

            // Ignore shared-line comments
            if (isSharedLineComment(comment)) {
              return;
            }

            // Ignore non-standard comments
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            const expectEmptyLineBefore = (() => {
              if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(comment)) {
                return false;
              }

              return primary === 'always';
            })();

            const before = comment.raws.before || '';
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (typeof context.newline !== 'string') return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(comment, context.newline);
              } else {
                removeEmptyLinesBefore(comment, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 320, "../../utils/hasEmptyLine": 350, "../../utils/isAfterComment": 356, "../../utils/isFirstNested": 369, "../../utils/isFirstNodeOfRoot": 370, "../../utils/isSharedLineComment": 380, "../../utils/isStandardSyntaxComment": 385, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesBefore": 408, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 145: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty comment' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/comment-no-empty' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // To ignore non-standard comments
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            // To ignore comments that are not empty
            if (comment.text && comment.text.length !== 0) {
              return;
            }

            report({
              message: messages.rejected,
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxComment": 385, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 146: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected comment to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/comment-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkComments(comment => {
            const text = comment.text;

            if (normalizedPattern.test(text)) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 147: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-whitespace-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected whitespace after "/*"',
        rejectedOpening: 'Unexpected whitespace after "/*"',
        expectedClosing: 'Expected whitespace before "*/"',
        rejectedClosing: 'Unexpected whitespace before "*/"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/comment-whitespace-inside' };


      /**
       * @param {import('postcss').Comment} comment
       */
      function addWhitespaceBefore(comment) {
        if (comment.text.startsWith('*')) {
          comment.text = comment.text.replace(/^(\*+)/, `$1 `);
        } else {
          comment.raws.left = ' ';
        }
      }

      /**
       * @param {import('postcss').Comment} comment
       */
      function addWhitespaceAfter(comment) {
        if (comment.text[comment.text.length - 1] === '*') {
          comment.text = comment.text.replace(/(\*+)$/, ` $1`);
        } else {
          comment.raws.right = ' ';
        }
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            const rawComment = comment.toString();
            const firstFourChars = rawComment.slice(0, 4);

            // Return early if sourcemap or copyright comment
            if (/^\/\*[#!]\s/.test(firstFourChars)) {
              return;
            }

            const leftMatches = rawComment.match(/(^\/\*+)(\s)?/);

            if (leftMatches == null || leftMatches[1] == null) {
              throw new Error(`Invalid comment: "${rawComment}"`);
            }

            const rightMatches = rawComment.match(/(\s)?(\*+\/)$/);

            if (rightMatches == null || rightMatches[2] == null) {
              throw new Error(`Invalid comment: "${rawComment}"`);
            }

            const opener = leftMatches[1];
            const leftSpace = leftMatches[2] || '';
            const rightSpace = rightMatches[1] || '';
            const closer = rightMatches[2];

            if (primary === 'never' && leftSpace !== '') {
              complain(messages.rejectedOpening, opener.length);
            }

            if (primary === 'always' && !isWhitespace(leftSpace)) {
              complain(messages.expectedOpening, opener.length);
            }

            if (primary === 'never' && rightSpace !== '') {
              complain(messages.rejectedClosing, comment.toString().length - closer.length - 1);
            }

            if (primary === 'always' && !isWhitespace(rightSpace)) {
              complain(messages.expectedClosing, comment.toString().length - closer.length - 1);
            }

            /**
             * @param {string} message
             * @param {number} index
             */
            function complain(message, index) {
              if (context.fix) {
                if (primary === 'never') {
                  comment.raws.left = '';
                  comment.raws.right = '';
                  comment.text = comment.text.replace(/^(\*+)(\s+)?/, '$1').replace(/(\s+)?(\*+)$/, '$2');
                } else {
                  if (!leftSpace) {
                    addWhitespaceBefore(comment);
                  }

                  if (!rightSpace) {
                    addWhitespaceAfter(comment);
                  }
                }

                return;
              }

              report({
                message,
                index,
                result,
                ruleName,
                node: comment });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxComment": 385, "../../utils/isWhitespace": 399, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 148: [function (require, module, exports) {
      'use strict';

      const containsString = require('../../utils/containsString');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-word-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: pattern => `Unexpected word matching pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/comment-word-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            const text = comment.text;
            const rawComment = comment.toString();
            const firstFourChars = rawComment.slice(0, 4);

            // Return early if sourcemap
            if (firstFourChars === '/*# ') {
              return;
            }

            const matchesWord = matchesStringOrRegExp(text, primary) || containsString(text, primary);

            if (!matchesWord) {
              return;
            }

            report({
              message: messages.rejected(matchesWord.pattern),
              node: comment,
              word: matchesWord.substring,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/containsString": 329, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 149: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'custom-media-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom media query name to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/custom-media-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() !== 'custom-media') {
              return;
            }

            const match = atRule.params.match(/^--(\S+)\b/);

            if (match == null || match[0] == null) {
              throw new Error(`Unexpected at-rule params: "${atRule.params}"`);
            }

            const customMediaName = match[1];

            if (regexpPattern.test(customMediaName)) {
              return;
            }

            const index = atRuleParamIndex(atRule);

            report({
              message: messages.expected(primary),
              node: atRule,
              index,
              endIndex: index + match[0].length,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 150: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRule } = require('../../utils/typeGuards');

      const ruleName = 'custom-property-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before custom property',
        rejected: 'Unexpected empty line before custom property' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/custom-property-empty-line-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested', 'after-comment', 'after-custom-property'],
              ignore: ['after-comment', 'first-nested', 'inside-single-line-block'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (!isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') &&
            parent != null && (
            isAtRule(parent) || isRule(parent)) &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = primary === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-custom-property') &&
            isAfterCustomProperty(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (context.newline == null) return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: decl,
              result,
              ruleName });

          });
        };
      };

      /**
       * @param {import('postcss').Declaration} decl
       */
      function isAfterCustomProperty(decl) {
        const prevNode = getPreviousNonSharedLineCommentNode(decl);

        return prevNode != null && isDeclaration(prevNode) && isCustomProperty(prevNode.prop);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 320, "../../utils/blockString": 325, "../../utils/getPreviousNonSharedLineCommentNode": 344, "../../utils/hasEmptyLine": 350, "../../utils/isAfterComment": 356, "../../utils/isCustomProperty": 367, "../../utils/isFirstNested": 369, "../../utils/isSingleLineString": 381, "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesBefore": 408, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417 }], 151: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'custom-property-no-missing-var-function';

      const messages = ruleMessages(ruleName, {
        rejected: customProperty => `Unexpected missing var function for "${customProperty}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/custom-property-no-missing-var-function' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) return;

          /** @type {Set<string>} */
          const knownCustomProperties = new Set();

          root.walkAtRules(/^property$/i, atRule => {
            knownCustomProperties.add(atRule.params);
          });

          root.walkDecls(({ prop }) => {
            if (isCustomProperty(prop)) knownCustomProperties.add(prop);
          });

          root.walkDecls(decl => {
            const { value } = decl;
            const parsedValue = valueParser(value);

            parsedValue.walk(node => {
              if (isVarFunction(node)) return false;

              if (!isDashedIdent(node)) return;

              if (!knownCustomProperties.has(node.value)) return;

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });


              return false;
            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isDashedIdent({ type, value }) {
        return type === 'word' && value.startsWith('--');
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isVarFunction({ type, value }) {
        return type === 'function' && value === 'var';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isCustomProperty": 367, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 152: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const { isRegExp, isString } = require('../../utils/validateTypes');
      const { isValueFunction } = require('../../utils/typeGuards');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');

      const ruleName = 'custom-property-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom property name to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/custom-property-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = isString(primary) ? new RegExp(primary) : primary;

          /**
           * @param {string} property
           * @returns {boolean}
           */
          function check(property) {
            return (
              !isStandardSyntaxProperty(property) ||
              !isCustomProperty(property) ||
              regexpPattern.test(property.slice(2)));

          }

          root.walkDecls(decl => {
            const { prop, value } = decl;

            const parsedValue = valueParser(value);

            parsedValue.walk(node => {
              if (!isValueFunction(node)) return;

              if (node.value.toLowerCase() !== 'var') return;

              const { nodes } = node;

              const firstNode = nodes[0];

              if (!firstNode || check(firstNode.value)) return;

              complain(declarationValueIndex(decl) + firstNode.sourceIndex, firstNode.value.length, decl);
            });

            if (check(prop)) return;

            complain(0, prop.length, decl);
          });

          /**
           * @param {number} index
           * @param {number} length
           * @param {import('postcss').Declaration} decl
           */
          function complain(index, length, decl) {
            report({
              result,
              ruleName,
              message: messages.expected(primary),
              node: decl,
              index,
              endIndex: index + length });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 153: [function (require, module, exports) {
      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "!"',
        rejectedAfter: () => 'Unexpected whitespace after "!"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-bang-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const declValue = getDeclarationValue(decl);
              let target;
              /** @type {(value: string) => void} */
              let setFixed;

              if (bangIndex < declValue.length) {
                target = declValue;
                setFixed = value => {
                  setDeclarationValue(decl, value);
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= declValue.length;
                setFixed = value => {
                  decl.raws.important = value;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex + 1);
              const targetAfter = target.slice(bangIndex + 1);

              if (primary === 'always') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (primary === 'never') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ''));

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../declarationBangSpaceChecker": 175 }], 154: [function (require, module, exports) {
      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "!"',
        rejectedBefore: () => 'Unexpected whitespace before "!"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-bang-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const value = getDeclarationValue(decl);
              let target;
              /** @type {(val: string) => void} */
              let setFixed;

              if (bangIndex < value.length) {
                target = value;
                setFixed = val => {
                  setDeclarationValue(decl, val);
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= value.length;
                setFixed = val => {
                  decl.raws.important = val;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex);
              const targetAfter = target.slice(bangIndex);

              if (primary === 'always') {
                // eslint-disable-next-line prefer-template
                setFixed(targetBefore.replace(/\s*$/, '') + ' ' + targetAfter);

                return true;
              }

              if (primary === 'never') {
                setFixed(targetBefore.replace(/\s*$/, '') + targetAfter);

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../declarationBangSpaceChecker": 175 }], 155: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-no-duplicate-custom-properties';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected duplicate "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-no-duplicate-custom-properties' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            const decls = new Set();

            eachDecl(decl => {
              const prop = decl.prop;

              if (!isStandardSyntaxProperty(prop)) {
                return;
              }

              if (!isCustomProperty(prop)) {
                return;
              }

              const isDuplicate = decls.has(prop);

              if (isDuplicate) {
                report({
                  message: messages.rejected(prop),
                  node: decl,
                  result,
                  ruleName,
                  word: prop });


                return;
              }

              decls.add(prop);
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/eachDeclarationBlock": 331, "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 156: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-duplicate-properties';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected duplicate "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-no-duplicate-properties' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignore: [
              'consecutive-duplicates',
              'consecutive-duplicates-with-different-values',
              'consecutive-duplicates-with-same-prefixless-values'],

              ignoreProperties: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreDuplicates = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates');
          const ignoreDiffValues = optionsMatches(
          secondaryOptions,
          'ignore',
          'consecutive-duplicates-with-different-values');

          const ignorePrefixlessSameValues = optionsMatches(
          secondaryOptions,
          'ignore',
          'consecutive-duplicates-with-same-prefixless-values');


          eachDeclarationBlock(root, eachDecl => {
            /** @type {string[]} */
            const decls = [];
            /** @type {string[]} */
            const values = [];

            eachDecl(decl => {
              const prop = decl.prop;
              const value = decl.value;

              if (!isStandardSyntaxProperty(prop)) {
                return;
              }

              if (isCustomProperty(prop)) {
                return;
              }

              // Return early if the property is to be ignored
              if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
                return;
              }

              // Ignore the src property as commonly duplicated in at-fontface
              if (prop.toLowerCase() === 'src') {
                return;
              }

              const indexDuplicate = decls.indexOf(prop.toLowerCase());

              if (indexDuplicate !== -1) {
                if (ignoreDiffValues || ignorePrefixlessSameValues) {
                  // fails if duplicates are not consecutive
                  if (indexDuplicate !== decls.length - 1) {
                    report({
                      message: messages.rejected(prop),
                      node: decl,
                      result,
                      ruleName,
                      word: prop });


                    return;
                  }

                  const duplicateValue = values[indexDuplicate] || '';

                  if (ignorePrefixlessSameValues) {
                    // fails if values of consecutive, unprefixed duplicates are equal
                    if (vendor.unprefixed(value) !== vendor.unprefixed(duplicateValue)) {
                      report({
                        message: messages.rejected(prop),
                        node: decl,
                        result,
                        ruleName,
                        word: prop });


                      return;
                    }
                  }

                  // fails if values of consecutive duplicates are equal
                  if (value === duplicateValue) {
                    report({
                      message: messages.rejected(prop),
                      node: decl,
                      result,
                      ruleName,
                      word: prop });


                    return;
                  }

                  return;
                }

                if (ignoreDuplicates && indexDuplicate === decls.length - 1) {
                  return;
                }

                report({
                  message: messages.rejected(prop),
                  node: decl,
                  result,
                  ruleName,
                  word: prop });

              }

              decls.push(prop.toLowerCase());
              values.push(value.toLowerCase());
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/eachDeclarationBlock": 331, "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 157: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('../../utils/arrayEqual');
      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'declaration-block-no-redundant-longhand-properties';

      const messages = ruleMessages(ruleName, {
        expected: props => `Expected shorthand property "${props}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-no-redundant-longhand-properties' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreShorthands: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const longhandProperties = Object.entries(shorthandData).reduce(
          ( /** @type {Record<string, string[]>} */longhandProps, [key, values]) => {
            if (optionsMatches(secondaryOptions, 'ignoreShorthands', key)) {
              return longhandProps;
            }

            for (const value of values) {
              (longhandProps[value] || (longhandProps[value] = [])).push(key);
            }

            return longhandProps;
          },
          {});


          eachDeclarationBlock(root, eachDecl => {
            /** @type {Record<string, string[]>} */
            const longhandDeclarations = {};

            eachDecl(decl => {
              const prop = decl.prop.toLowerCase();
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop);

              const shorthandProperties = longhandProperties[unprefixedProp];

              if (!shorthandProperties) {
                return;
              }

              for (const shorthandProperty of shorthandProperties) {
                const prefixedShorthandProperty = prefix + shorthandProperty;
                let longhandDeclaration = longhandDeclarations[prefixedShorthandProperty];

                if (!longhandDeclaration) {
                  longhandDeclaration = longhandDeclarations[prefixedShorthandProperty] = [];
                }

                longhandDeclaration.push(prop);

                const prefixedShorthandData = (shorthandData[shorthandProperty] || []).map(
                item => prefix + item);


                if (!arrayEqual(prefixedShorthandData.sort(), longhandDeclaration.sort())) {
                  continue;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.expected(prefixedShorthandProperty) });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/shorthandData": 110, "../../utils/arrayEqual": 322, "../../utils/eachDeclarationBlock": 331, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 158: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-shorthand-property-overrides';

      const messages = ruleMessages(ruleName, {
        rejected: (shorthand, original) => `Unexpected shorthand "${shorthand}" after "${original}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-no-shorthand-property-overrides' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            /** @type {Record<string, string>} */
            const declarations = {};

            eachDecl(decl => {
              const prop = decl.prop;
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop).toLowerCase();

              const overrideables = shorthandData[unprefixedProp.toLowerCase()];

              if (!overrideables) {
                declarations[prop.toLowerCase()] = prop;

                return;
              }

              for (const longhandProp of overrideables) {
                if (!Object.prototype.hasOwnProperty.call(declarations, prefix + longhandProp)) {
                  continue;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.rejected(prop, declarations[prefix + longhandProp] || ''),
                  word: prop });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/shorthandData": 110, "../../utils/eachDeclarationBlock": 331, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/vendor": 419 }], 159: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"',
        expectedAfterMultiLine: () => 'Expected newline after ";" in a multi-line declaration block',
        rejectedAfterMultiLine: () => 'Unexpected newline after ";" in a multi-line declaration block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-semicolon-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextNode = decl.next();

            if (!nextNode) {
              return;
            }

            // Allow end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    const index = nodeToCheck.raws.before.search(/\r?\n/);

                    nodeToCheck.raws.before =
                    index >= 0 ?
                    nodeToCheck.raws.before.slice(index) :
                    context.newline + nodeToCheck.raws.before;

                    return;
                  }

                  if (primary === 'never-multi-line') {
                    nodeToCheck.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/nextNonCommentNode": 401, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 160: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ";"',
        expectedBeforeMultiLine: () => 'Expected newline before ";" in a multi-line declaration block',
        rejectedBeforeMultiLine: () =>
        'Unexpected whitespace before ";" in a multi-line declaration block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-semicolon-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.beforeAllowingIndentation({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 161: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ";"',
        rejectedAfter: () => 'Unexpected whitespace after ";"',
        expectedAfterSingleLine: () =>
        'Expected single space after ";" in a single-line declaration block',
        rejectedAfterSingleLine: () =>
        'Unexpected whitespace after ";" in a single-line declaration block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-semicolon-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextDecl = decl.next();

            if (!nextDecl) {
              return;
            }

            checker.after({
              source: rawNodeString(nextDecl),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    nextDecl.raws.before = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    nextDecl.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/rawNodeString": 406, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 162: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"',
        expectedBeforeSingleLine: () =>
        'Expected single space before ";" in a single-line declaration block',
        rejectedBeforeSingleLine: () =>
        'Unexpected whitespace before ";" in a single-line declaration block' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-semicolon-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.before({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  const value = getDeclarationValue(decl);

                  if (primary.startsWith('always')) {
                    if (decl.important) {
                      decl.raws.important = ' !important ';
                    } else {
                      setDeclarationValue(decl, value.replace(/\s*$/, ' '));
                    }

                    return;
                  }

                  if (primary.startsWith('never')) {
                    if (decl.raws.important) {
                      decl.raws.important = decl.raws.important.replace(/\s*$/, '');
                    } else {
                      setDeclarationValue(decl, value.replace(/\s*$/, ''));
                    }

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 163: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'declaration-block-single-line-max-declarations';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} ${max === 1 ? 'declaration' : 'declarations'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-single-line-max-declarations' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isNumber] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            const block = blockString(ruleNode);

            if (!isSingleLineString(block)) {
              return;
            }

            if (!ruleNode.nodes) {
              return;
            }

            const decls = ruleNode.nodes.filter(node => node.type === 'decl');

            if (decls.length <= primary) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: ruleNode,
              word: block,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/blockString": 325, "../../utils/isSingleLineString": 381, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 164: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-trailing-semicolon';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a trailing semicolon',
        rejected: 'Unexpected trailing semicolon' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-block-trailing-semicolon' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['single-declaration'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!atRule.parent) throw new Error('A parent node must be present');

            if (atRule.parent === root) {
              return;
            }

            if (atRule !== atRule.parent.last) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            checkLastNode(atRule);
          });

          root.walkDecls(decl => {
            if (!decl.parent) throw new Error('A parent node must be present');

            if (decl.parent.type === 'object') {
              return;
            }

            if (decl !== decl.parent.last) {
              return;
            }

            checkLastNode(decl);
          });

          /**
           * @param {import('postcss').Node} node
           */
          function checkLastNode(node) {
            if (!node.parent) throw new Error('A parent node must be present');

            const hasSemicolon = node.parent.raws.semicolon;
            const ignoreSingleDeclaration = optionsMatches(
            secondaryOptions,
            'ignore',
            'single-declaration');


            if (ignoreSingleDeclaration && node.parent.first === node) {
              return;
            }

            let message;

            if (primary === 'always') {
              if (hasSemicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = true;

                if (node.type === 'atrule') {
                  node.raws.between = '';
                  node.parent.raws.after = ' ';
                }

                return;
              }

              message = messages.expected;
            } else if (primary === 'never') {
              if (!hasSemicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = false;

                return;
              }

              message = messages.rejected;
            } else {
              throw new Error(`Unexpected primary option: "${primary}"`);
            }

            report({
              message,
              node,
              index: node.toString().trim().length - 1,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/hasBlock": 348, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 165: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ":"',
        expectedAfterMultiLine: () => 'Expected newline after ":" with a multi-line declaration' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-colon-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            // Get the raw prop, and only the prop
            const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

            // The extra characters tacked onto the end ensure that there is a character to check
            // after the colon. Otherwise, with `background:pink` the character after the
            const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

            for (let i = 0, l = propPlusColon.length; i < l; i++) {
              if (propPlusColon[i] !== ':') {
                continue;
              }

              const indexToCheck = /^[^\S\r\n]*\/\*/.test(propPlusColon.slice(i + 1)) ?
              propPlusColon.indexOf('*/', i) + 1 :
              i;

              checker.afterOneOnly({
                source: propPlusColon,
                index: indexToCheck,
                lineCheckStr: decl.value,
                err: m => {
                  if (context.fix) {
                    const between = decl.raws.between;

                    if (between == null) throw new Error('`between` must be present');

                    const betweenStart = declarationValueIndex(decl) - between.length;
                    const sliceIndex = indexToCheck - betweenStart + 1;
                    const betweenBefore = between.slice(0, sliceIndex);
                    const betweenAfter = between.slice(sliceIndex);

                    decl.raws.between = /^\s*\n/.test(betweenAfter) ?
                    betweenBefore + betweenAfter.replace(/^[^\S\r\n]*/, '') :
                    betweenBefore + context.newline + betweenAfter;

                    return;
                  }

                  report({
                    message: m,
                    node: decl,
                    index: indexToCheck,
                    result,
                    ruleName });

                } });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420 }], 166: [function (require, module, exports) {
      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"',
        expectedAfterSingleLine: () => 'Expected single space after ":" with a single-line declaration' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-colon-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (between == null) throw new Error('`between` must be present');

              if (primary.startsWith('always')) {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ': ');

                return true;
              }

              if (primary === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ':');

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../declarationColonSpaceChecker": 176 }], 167: [function (require, module, exports) {
      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-colon-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (between == null) throw new Error('`between` must be present');

              if (primary === 'always') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, ' ') + between.slice(colonIndex);

                return true;
              }

              if (primary === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, '') + between.slice(colonIndex);

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../declarationColonSpaceChecker": 176 }], 168: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isAfterStandardPropertyDeclaration = require('../../utils/isAfterStandardPropertyDeclaration');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isRule, isRoot } = require('../../utils/typeGuards');

      const ruleName = 'declaration-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before declaration',
        rejected: 'Unexpected empty line before declaration' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-empty-line-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested', 'after-comment', 'after-declaration'],
              ignore: [
              'after-comment',
              'after-declaration',
              'first-nested',
              'inside-single-line-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            if (parent == null) {
              return;
            }

            // Ignore the first node
            if (isFirstNodeOfRoot(decl)) {
              return;
            }

            if (!isAtRule(parent) && !isRule(parent) && !isRoot(parent)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if a declaration precedes it
            if (
            optionsMatches(secondaryOptions, 'ignore', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = primary === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (context.newline == null) return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: decl, result, ruleName });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 320, "../../utils/blockString": 325, "../../utils/hasEmptyLine": 350, "../../utils/isAfterComment": 356, "../../utils/isAfterStandardPropertyDeclaration": 358, "../../utils/isCustomProperty": 367, "../../utils/isFirstNested": 369, "../../utils/isFirstNodeOfRoot": 370, "../../utils/isSingleLineString": 381, "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesBefore": 408, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417 }], 169: [function (require, module, exports) {
      'use strict';

      const getImportantPosition = require('../../utils/getImportantPosition');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { assert } = require('../../utils/validateTypes');

      const ruleName = 'declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-no-important' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.important) {
              return;
            }

            const pos = getImportantPosition(decl.toString());

            assert(pos);

            report({
              message: messages.rejected,
              node: decl,
              index: pos.index,
              endIndex: pos.endIndex,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/getImportantPosition": 341, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 170: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const vendor = require('../../utils/vendor');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber, assertNumber } = require('../../utils/validateTypes');
      const validateObjectWithProps = require('../../utils/validateObjectWithProps');

      const ruleName = 'declaration-property-max-values';

      const messages = ruleMessages(ruleName, {
        rejected: (property, max) =>
        `Expected "${property}" to have no more than ${max} ${max === 1 ? 'value' : 'values'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-property-max-values' };


      /**
       * @param {valueParser.Node} node
       */
      const isValueNode = node => {
        return node.type === 'word' || node.type === 'function' || node.type === 'string';
      };

      /** @type {import('stylelint').Rule<Record<string, number>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithProps(isNumber)] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const { prop, value } = decl;
            const propLength = valueParser(value).nodes.filter(isValueNode).length;

            const unprefixedProp = vendor.unprefixed(prop);
            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const max = primary[propKey];

            assertNumber(max);

            if (propLength <= max) {
              return;
            }

            report({
              message: messages.rejected(prop, max),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithProps": 416, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 171: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const flattenArray = require('../../utils/flattenArray');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-property-unit-allowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString)] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['inside-function'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = flattenArray(primary[propKey]);

            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function') {
                if (node.value.toLowerCase() === 'url') {
                  return false;
                }

                if (optionsMatches(secondaryOptions, 'ignore', 'inside-function')) {
                  return false;
                }
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || unit && propList.includes(unit.toLowerCase())) {
                return;
              }

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/flattenArray": 335, "../../utils/getUnitFromValueNode": 347, "../../utils/matchesStringOrRegExp": 400, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 172: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const flattenArray = require('../../utils/flattenArray');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-property-unit-disallowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | string[]>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString)] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = flattenArray(primary[propKey]);

            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || unit && !propList.includes(unit.toLowerCase())) {
                return;
              }

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/flattenArray": 335, "../../utils/getUnitFromValueNode": 347, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 173: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString, isRegExp } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-property-value-allowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString, isRegExp)] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            if (optionsMatches(primary, propKey, value)) {
              return;
            }

            const index = declarationValueIndex(decl);
            const endIndex = index + decl.value.length;

            report({
              message: messages.rejected(prop, value),
              node: decl,
              index,
              endIndex,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/matchesStringOrRegExp": 400, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 174: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString, isRegExp } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/declaration-property-value-disallowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString, isRegExp)] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            if (!optionsMatches(primary, propKey, value)) {
              return;
            }

            const index = declarationValueIndex(decl);
            const endIndex = index + decl.value.length;

            report({
              message: messages.rejected(prop, value),
              node: decl,
              index,
              endIndex,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/matchesStringOrRegExp": 400, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 175: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /** @typedef {import('postcss').Declaration} Declaration */

      /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       *   fix: ((decl: Declaration, index: number) => boolean) | null,
       * }} opts
       * @returns {void}
       */
      module.exports = function declarationBangSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          const indexOffset = declarationValueIndex(decl);
          const declString = decl.toString();
          const valueString = decl.toString().slice(indexOffset);

          if (!valueString.includes('!')) {
            return;
          }

          styleSearch({ source: valueString, target: '!' }, match => {
            check(declString, match.startIndex + indexOffset, decl);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {Declaration} decl
         */
        function check(source, index, decl) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              if (opts.fix && opts.fix(decl, index)) {
                return;
              }

              report({
                message,
                node: decl,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/declarationValueIndex": 330, "../utils/report": 409, "style-search": 89 }], 176: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const report = require('../utils/report');

      /** @typedef {(args: { source: string, index: number, lineCheckStr: string, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   fix: ((decl: import('postcss').Declaration, index: number) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function declarationColonSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl)) {
            return;
          }

          // Get the raw prop, and only the prop
          const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

          // The extra characters tacked onto the end ensure that there is a character to check
          // after the colon. Otherwise, with `background:pink` the character after the
          const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

          for (let i = 0, l = propPlusColon.length; i < l; i++) {
            if (propPlusColon[i] !== ':') {
              continue;
            }

            opts.locationChecker({
              source: propPlusColon,
              index: i,
              lineCheckStr: decl.value,
              err: message => {
                if (opts.fix && opts.fix(decl, i)) {
                  return;
                }

                report({
                  message,
                  node: decl,
                  index: decl.prop.toString().length + 1,
                  result: opts.result,
                  ruleName: opts.checkedRuleName });

              } });

            break;
          }
        });
      };

    }, { "../utils/declarationValueIndex": 330, "../utils/isStandardSyntaxDeclaration": 386, "../utils/report": 409 }], 177: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const rangeOperators = ['>=', '<=', '>', '<', '='];

      /** @typedef {import('style-search').StyleSearchMatch} StyleSearchMatch */

      /**
       * @template {import('postcss').AtRule} T
       * @param {T} atRule
       * @param {(match: StyleSearchMatch, params: string, atRule: T) => void} cb
       */
      module.exports = function findMediaOperator(atRule, cb) {
        if (atRule.name.toLowerCase() !== 'media') {
          return;
        }

        const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

        styleSearch({ source: params, target: rangeOperators }, match => {
          const before = params[match.startIndex - 1];

          if (before === '>' || before === '<') {
            return;
          }

          cb(match, params, atRule);
        });
      };

    }, { "style-search": 89 }], 178: [function (require, module, exports) {
      'use strict';

      const findFontFamily = require('../../utils/findFontFamily');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'font-family-name-quotes';

      const messages = ruleMessages(ruleName, {
        expected: family => `Expected quotes around "${family}"`,
        rejected: family => `Unexpected quotes around "${family}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/font-family-name-quotes' };


      /**
       * @param {string} font
       * @returns {boolean}
       */
      function isSystemFontKeyword(font) {
        if (font.startsWith('-apple-')) {
          return true;
        }

        if (font === 'BlinkMacSystemFont') {
          return true;
        }

        return false;
      }

      /**
       * "To avoid mistakes in escaping, it is recommended to quote font family names
       * that contain white space, digits, or punctuation characters other than hyphens"
       * (https://www.w3.org/TR/CSS2/fonts.html#font-family-prop)
       *
       * @param {string} family
       * @returns {boolean}
       */
      function quotesRecommended(family) {
        return !/^[-a-zA-Z]+$/.test(family);
      }

      /**
       * Quotes are required if the family is not a valid CSS identifier
       * (regexes from https://mathiasbynens.be/notes/unquoted-font-family)
       *
       * @param {string} family
       * @returns {boolean}
       */
      function quotesRequired(family) {
        return family.
        split(/\s+/).
        some(word => /^(?:-?\d|--)/.test(word) || !/^[-\w\u{00A0}-\u{10FFFF}]+$/u.test(word));
      }

      /**
       * @typedef {{
       *   name: string,
       *   rawName: string,
       *   hasQuotes: boolean,
       *   sourceIndex: number,
       *   resetIndexes: (offset: number) => void,
       *   removeQuotes: () => void,
       *   addQuotes: () => void,
       * }} MutableNode
       */

      /**
       *
       * @param {import('postcss-value-parser').Node[]} fontFamilies
       * @param {import('postcss').Declaration} decl
       * @returns {MutableNode[]}
       */
      const makeMutableFontFamilies = (fontFamilies, decl) => {
        /**
         * @type {MutableNode[]}
         */
        const mutableNodes = [];

        fontFamilies.forEach((fontFamily, idx) => {
          const quote = 'quote' in fontFamily && fontFamily.quote;
          const name = fontFamily.value;

          /** @type {MutableNode} */
          const newNode = {
            name,
            rawName: quote ? `${quote}${name}${quote}` : name,
            sourceIndex: fontFamily.sourceIndex,
            hasQuotes: Boolean(quote),
            resetIndexes(offset) {
              mutableNodes.slice(idx + 1).forEach(n => n.sourceIndex += offset);
            },
            removeQuotes() {
              if (this.hasQuotes === false) return;

              const openIndex = this.sourceIndex;
              const closeIndex = openIndex + this.name.length + 2;

              this.hasQuotes = false;
              decl.value = decl.value.slice(0, openIndex) + this.name + decl.value.substring(closeIndex);
              this.resetIndexes(-2);
            },
            addQuotes() {
              if (this.hasQuotes === true) return;

              const openIndex = this.sourceIndex;
              const closeIndex = openIndex + this.name.length;

              this.hasQuotes = true;
              const fixedName = `"${this.name}"`;

              decl.value = decl.value.slice(0, openIndex) + fixedName + decl.value.substring(closeIndex);
              this.resetIndexes(2);
            } };


          mutableNodes.push(newNode);
        });

        return mutableNodes;
      };

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always-where-required', 'always-where-recommended', 'always-unless-keyword'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            let fontFamilyNodes = makeMutableFontFamilies(findFontFamily(decl.value), decl);

            if (fontFamilyNodes.length === 0) {
              return;
            }

            for (const fontFamilyNode of fontFamilyNodes) {
              checkFamilyName(fontFamilyNode, decl);
            }
          });

          /**
           * @param {MutableNode} fontFamilyNode
           * @param {import('postcss').Declaration} decl
           */
          function checkFamilyName(fontFamilyNode, decl) {
            const { name: family, rawName: rawFamily, hasQuotes } = fontFamilyNode;

            if (!isStandardSyntaxValue(rawFamily)) {
              return;
            }

            if (isVariable(rawFamily)) {
              return;
            }

            // Disallow quotes around (case-insensitive) keywords
            // and system font keywords in all cases
            if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
              if (hasQuotes) {
                if (context.fix) {
                  fontFamilyNode.removeQuotes();

                  return;
                }

                return complain(messages.rejected(family), rawFamily, decl);
              }

              return;
            }

            const required = quotesRequired(family);
            const recommended = quotesRecommended(family);

            switch (primary) {
              case 'always-unless-keyword':
                if (!hasQuotes) {
                  if (context.fix) {
                    fontFamilyNode.addQuotes();

                    return;
                  }

                  return complain(messages.expected(family), rawFamily, decl);
                }

                return;

              case 'always-where-recommended':
                if (!recommended && hasQuotes) {
                  if (context.fix) {
                    fontFamilyNode.removeQuotes();

                    return;
                  }

                  return complain(messages.rejected(family), rawFamily, decl);
                }

                if (recommended && !hasQuotes) {
                  if (context.fix) {
                    fontFamilyNode.addQuotes();

                    return;
                  }

                  return complain(messages.expected(family), rawFamily, decl);
                }

                return;

              case 'always-where-required':
                if (!required && hasQuotes) {
                  if (context.fix) {
                    fontFamilyNode.removeQuotes();

                    return;
                  }

                  return complain(messages.rejected(family), rawFamily, decl);
                }

                if (required && !hasQuotes) {
                  if (context.fix) {
                    fontFamilyNode.addQuotes();

                    return;
                  }

                  return complain(messages.expected(family), rawFamily, decl);
                }}

          }

          /**
           * @param {string} message
           * @param {string} family
           * @param {import('postcss').Declaration} decl
           */
          function complain(message, family, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              word: family });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/findFontFamily": 334, "../../utils/isStandardSyntaxValue": 395, "../../utils/isVariable": 398, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 179: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'font-family-no-duplicate-names';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected duplicate name ${name}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/font-family-no-duplicate-names' };


      /**
       * @param {import('postcss-value-parser').Node} node
       */
      const isFamilyNameKeyword = (node) =>
      !('quote' in node) && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreFontFamilyNames: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            const keywords = new Set();
            const familyNames = new Set();

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            for (const fontFamilyNode of fontFamilies) {
              const family = fontFamilyNode.value.trim();

              if (optionsMatches(secondaryOptions, 'ignoreFontFamilyNames', family)) {
                continue;
              }

              const rawFamily =
              'quote' in fontFamilyNode ? fontFamilyNode.quote + family + fontFamilyNode.quote : family;

              if (isFamilyNameKeyword(fontFamilyNode)) {
                if (keywords.has(family.toLowerCase())) {
                  complain(
                  messages.rejected(family),
                  declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                  rawFamily.length,
                  decl);


                  continue;
                }

                keywords.add(family);

                continue;
              }

              if (familyNames.has(family)) {
                complain(
                messages.rejected(family),
                declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                rawFamily.length,
                decl);


                continue;
              }

              familyNames.add(family);
            }
          });

          /**
           * @param {string} message
           * @param {number} index
           * @param {number} length
           * @param {import('postcss').Declaration} decl
           */
          function complain(message, index, length, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              index,
              endIndex: index + length });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/findFontFamily": 334, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 180: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule } = require('../../utils/typeGuards');
      const { isRegExp, isString, assert } = require('../../utils/validateTypes');

      const ruleName = 'font-family-no-missing-generic-family-keyword';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing generic font family' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/font-family-no-missing-generic-family-keyword' };


      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {boolean}
       */
      const isFamilyNameKeyword = (node) =>
      !('quote' in node) && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      /**
       * @param {string} value
       * @returns {boolean}
       */
      const isLastFontFamilyVariable = value => {
        const lastValue = postcss.list.comma(value).pop();

        return lastValue != null && (isVariable(lastValue) || !isStandardSyntaxValue(lastValue));
      };

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreFontFamilies: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            // Ignore @font-face
            const parent = decl.parent;

            if (parent && isAtRule(parent) && parent.name.toLowerCase() === 'font-face') {
              return;
            }

            if (decl.prop === 'font' && keywordSets.systemFontValues.has(decl.value.toLowerCase())) {
              return;
            }

            if (isLastFontFamilyVariable(decl.value)) {
              return;
            }

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            if (fontFamilies.some(node => isFamilyNameKeyword(node))) {
              return;
            }

            if (
            fontFamilies.some((node) =>
            optionsMatches(secondaryOptions, 'ignoreFontFamilies', node.value)))

            {
              return;
            }

            const lastFontFamily = fontFamilies[fontFamilies.length - 1];

            assert(lastFontFamily);

            const valueIndex = declarationValueIndex(decl);
            const index = valueIndex + lastFontFamily.sourceIndex;
            const endIndex = valueIndex + lastFontFamily.sourceEndIndex;

            report({
              result,
              ruleName,
              message: messages.rejected,
              node: decl,
              index,
              endIndex });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/findFontFamily": 334, "../../utils/isStandardSyntaxValue": 395, "../../utils/isVariable": 398, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss": 77 }], 181: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isNumbery = require('../../utils/isNumbery');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule } = require('../../utils/typeGuards');

      const ruleName = 'font-weight-notation';

      const messages = ruleMessages(ruleName, {
        expected: type => `Expected ${type} font-weight notation`,
        invalidNamed: name => `Unexpected invalid font-weight name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/font-weight-notation' };


      const INHERIT_KEYWORD = 'inherit';
      const INITIAL_KEYWORD = 'initial';
      const NORMAL_KEYWORD = 'normal';
      const WEIGHTS_WITH_KEYWORD_EQUIVALENTS = new Set(['400', '700']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['numeric', 'named-where-possible'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['relative'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-weight)?$/i, decl => {
            const prop = decl.prop.toLowerCase();

            if (prop === 'font-weight') {
              checkWeight(decl, decl.value);
            } else if (prop === 'font') {
              checkFont(decl);
            }
          });

          /**
           * @param {import('postcss').Declaration} decl
           */
          function checkFont(decl) {
            const valueNodes = findFontWeights(decl.value);

            // We do not need to more carefully distinguish font-weight
            // numbers from unitless line-heights because line-heights in
            // `font` values need to be part of a font-size/line-height pair
            const hasNumericFontWeight = valueNodes.some(({ value }) => isNumbery(value));

            for (const valueNode of valueNodes) {
              const value = valueNode.value;
              const lowerValue = value.toLowerCase();

              if (
              lowerValue === NORMAL_KEYWORD && !hasNumericFontWeight ||
              isNumbery(value) ||
              lowerValue !== NORMAL_KEYWORD && keywordSets.fontWeightKeywords.has(lowerValue))
              {
                checkWeight(decl, value, valueNode);

                return;
              }
            }
          }

          /**
           * @param {import('postcss').Declaration} decl
           * @param {string} weightValue
           * @param {import('postcss-value-parser').Node} [weightValueNode]
           */
          function checkWeight(decl, weightValue, weightValueNode) {
            if (!isStandardSyntaxValue(weightValue)) {
              return;
            }

            if (isVariable(weightValue)) {
              return;
            }

            if (includesOnlyFunction(weightValue)) {
              return;
            }

            const lowerWeightValue = weightValue.toLowerCase();

            if (lowerWeightValue === INHERIT_KEYWORD || lowerWeightValue === INITIAL_KEYWORD) {
              return;
            }

            if (
            optionsMatches(secondaryOptions, 'ignore', 'relative') &&
            keywordSets.fontWeightRelativeKeywords.has(lowerWeightValue))
            {
              return;
            }

            if (primary === 'numeric') {
              const parent = decl.parent;

              if (parent && isAtRule(parent) && parent.name.toLowerCase() === 'font-face') {
                // @font-face allows multiple values.
                for (const valueNode of findFontWeights(weightValue)) {
                  if (!isNumbery(valueNode.value)) {
                    return complain(messages.expected('numeric'), valueNode.value, valueNode);
                  }
                }

                return;
              }

              if (!isNumbery(weightValue)) {
                return complain(messages.expected('numeric'), weightValue, weightValueNode);
              }
            }

            if (primary === 'named-where-possible') {
              if (isNumbery(weightValue)) {
                if (WEIGHTS_WITH_KEYWORD_EQUIVALENTS.has(weightValue)) {
                  complain(messages.expected('named'), weightValue, weightValueNode);
                }

                return;
              }

              if (
              !keywordSets.fontWeightKeywords.has(lowerWeightValue) &&
              lowerWeightValue !== NORMAL_KEYWORD)
              {
                return complain(messages.invalidNamed(weightValue), weightValue, weightValueNode);
              }
            }

            /**
             * @param {string} message
             * @param {string} value
             * @param {import('postcss-value-parser').Node | undefined} valueNode
             */
            function complain(message, value, valueNode) {
              const index = declarationValueIndex(decl) + (valueNode ? valueNode.sourceIndex : 0);
              const endIndex = index + value.length;

              report({
                ruleName,
                result,
                message,
                node: decl,
                index,
                endIndex });

            }
          }
        };
      };

      /**
       * @param {string} value
       * @returns {import('postcss-value-parser').Node[]}
       */
      function findFontWeights(value) {
        return valueParser(value).nodes.filter((node, index, nodes) => {
          if (node.type !== 'word') return false;

          // Exclude `<font-size>/<line-height>` format like `16px/3`.
          const prevNode = nodes[index - 1];
          const nextNode = nodes[index + 1];

          if (prevNode && prevNode.type === 'div') return false;

          if (nextNode && nextNode.type === 'div') return false;

          return true;
        });
      }

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function includesOnlyFunction(value) {
        return valueParser(value).nodes.every(({ type }) => {
          return type === 'function' || type === 'comment' || type === 'space';
        });
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/isNumbery": 375, "../../utils/isStandardSyntaxValue": 395, "../../utils/isVariable": 398, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 182: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (matchesStringOrRegExp(vendor.unprefixed(node.value), primary)) {
                return;
              }

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxFunction": 387, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 183: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { assert } = require('../../utils/validateTypes');

      const ruleName = 'function-calc-no-unspaced-operator';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}" operator`,
        expectedAfter: operator => `Expected single space after "${operator}" operator`,
        expectedOperatorBeforeSign: operator => `Expected an operator before sign "${operator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-calc-no-unspaced-operator' };


      const OPERATORS = new Set(['+', '-']);
      const OPERATOR_REGEX = /[+-]/;
      const ALL_OPERATORS = new Set([...OPERATORS, '*', '/']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) return;

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {string} operator
           */
          function complain(message, node, index, operator) {
            const endIndex = index + operator.length;

            report({ message, node, index, endIndex, result, ruleName });
          }

          root.walkDecls(decl => {
            let needsFix = false;
            const valueIndex = declarationValueIndex(decl);
            const parsedValue = valueParser(getDeclarationValue(decl));

            /**
             * @param {import('postcss-value-parser').Node} operatorNode
             * @param {import('postcss-value-parser').Node} currentNode
             * @param {boolean} isBeforeOp
             */
            function checkAroundOperator(operatorNode, currentNode, isBeforeOp) {
              const operator = operatorNode.value;
              const operatorSourceIndex = operatorNode.sourceIndex;

              if (currentNode && !isSingleSpace(currentNode)) {
                if (currentNode.type === 'word') {
                  if (isBeforeOp) {
                    const lastChar = currentNode.value.slice(-1);

                    if (OPERATORS.has(lastChar)) {
                      if (context.fix) {
                        currentNode.value = `${currentNode.value.slice(0, -1)} ${lastChar}`;

                        return true;
                      }

                      complain(
                      messages.expectedOperatorBeforeSign(operator),
                      decl,
                      operatorSourceIndex,
                      operator);


                      return true;
                    }
                  } else {
                    const firstChar = currentNode.value.slice(0, 1);

                    if (OPERATORS.has(firstChar)) {
                      if (context.fix) {
                        currentNode.value = `${firstChar} ${currentNode.value.slice(1)}`;

                        return true;
                      }

                      complain(messages.expectedAfter(operator), decl, operatorSourceIndex, operator);

                      return true;
                    }
                  }

                  if (context.fix) {
                    needsFix = true;
                    currentNode.value = isBeforeOp ? `${currentNode.value} ` : ` ${currentNode.value}`;

                    return true;
                  }

                  complain(
                  isBeforeOp ? messages.expectedBefore(operator) : messages.expectedAfter(operator),
                  decl,
                  valueIndex + operatorSourceIndex,
                  operator);


                  return true;
                }

                if (currentNode.type === 'space') {
                  const indexOfFirstNewLine = currentNode.value.search(/(\n|\r\n)/);

                  if (indexOfFirstNewLine === 0) return;

                  if (context.fix) {
                    needsFix = true;
                    currentNode.value =
                    indexOfFirstNewLine === -1 ? ' ' : currentNode.value.slice(indexOfFirstNewLine);

                    return true;
                  }

                  const message = isBeforeOp ?
                  messages.expectedBefore(operator) :
                  messages.expectedAfter(operator);

                  complain(message, decl, valueIndex + operatorSourceIndex, operator);

                  return true;
                }

                if (currentNode.type === 'function') {
                  if (context.fix) {
                    needsFix = true;
                    currentNode.value = isBeforeOp ? `${currentNode.value} ` : ` ${currentNode.value}`;

                    return true;
                  }

                  const message = isBeforeOp ?
                  messages.expectedBefore(operator) :
                  messages.expectedAfter(operator);

                  complain(message, decl, valueIndex + operatorSourceIndex, operator);

                  return true;
                }
              }

              return false;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkForOperatorInFirstNode(nodes) {
              const firstNode = nodes[0];

              assert(firstNode);

              if (firstNode.type !== 'word') return false;

              if (!isStandardSyntaxValue(firstNode.value)) return false;

              const operatorIndex = firstNode.value.search(OPERATOR_REGEX);
              const operator = firstNode.value.slice(operatorIndex, operatorIndex + 1);

              if (operatorIndex <= 0) return false;

              const charBefore = firstNode.value.charAt(operatorIndex - 1);
              const charAfter = firstNode.value.charAt(operatorIndex + 1);

              if (charBefore && charBefore !== ' ' && charAfter && charAfter !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex + 1, ' ');
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedBefore(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex,
                  operator);

                  complain(
                  messages.expectedAfter(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex + 1,
                  operator);

                }
              } else if (charBefore && charBefore !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedBefore(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex,
                  operator);

                }
              } else if (charAfter && charAfter !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedAfter(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex + 1,
                  operator);

                }
              }

              return true;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkForOperatorInLastNode(nodes) {
              if (nodes.length === 1) return false;

              const lastNode = nodes[nodes.length - 1];

              assert(lastNode);

              if (lastNode.type !== 'word') return false;

              const operatorIndex = lastNode.value.search(OPERATOR_REGEX);

              if (operatorIndex === -1) return false;

              if (lastNode.value.charAt(operatorIndex - 1) === ' ') return false;

              // E.g. "10px * -2" when the last node is "-2"
              if (
              isOperator(nodes[nodes.length - 3], ALL_OPERATORS) &&
              isSingleSpace(nodes[nodes.length - 2]))
              {
                return false;
              }

              if (context.fix) {
                needsFix = true;
                lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex + 1, ' ').trim();
                lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex, ' ').trim();

                return true;
              }

              const operator = lastNode.value.charAt(operatorIndex);

              complain(
              messages.expectedOperatorBeforeSign(operator),
              decl,
              valueIndex + lastNode.sourceIndex + operatorIndex,
              operator);


              return true;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkWords(nodes) {
              if (checkForOperatorInFirstNode(nodes) || checkForOperatorInLastNode(nodes)) return;

              for (const [index, node] of nodes.entries()) {
                const lastChar = node.value.slice(-1);
                const firstChar = node.value.slice(0, 1);

                if (node.type === 'word') {
                  if (index === 0 && OPERATORS.has(lastChar)) {
                    if (context.fix) {
                      node.value = `${node.value.slice(0, -1)} ${lastChar}`;

                      continue;
                    }

                    complain(messages.expectedBefore(lastChar), decl, node.sourceIndex, lastChar);
                  } else if (index === nodes.length && OPERATORS.has(firstChar)) {
                    if (context.fix) {
                      node.value = `${firstChar} ${node.value.slice(1)}`;

                      continue;
                    }

                    complain(
                    messages.expectedOperatorBeforeSign(firstChar),
                    decl,
                    node.sourceIndex,
                    firstChar);

                  }
                }
              }
            }

            parsedValue.walk(node => {
              if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') return;

              const { nodes } = node;
              let foundOperatorNode = false;

              for (const [nodeIndex, currNode] of nodes.entries()) {
                if (!isOperator(currNode)) continue;

                foundOperatorNode = true;

                const nodeBefore = nodes[nodeIndex - 1];
                const nodeAfter = nodes[nodeIndex + 1];

                if (isSingleSpace(nodeBefore) && isSingleSpace(nodeAfter)) continue;

                if (nodeAfter && checkAroundOperator(currNode, nodeAfter, false)) continue;

                nodeBefore && checkAroundOperator(currNode, nodeBefore, true);
              }

              if (!foundOperatorNode) {
                checkWords(nodes);
              }
            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} str
       * @param {number} index
       * @param {string} char
       */
      function insertCharAtIndex(str, index, char) {
        return str.slice(0, index) + char + str.slice(index, str.length);
      }

      /**
       * @param {import('postcss-value-parser').Node | undefined} node
       * @returns {node is import('postcss-value-parser').SpaceNode & { value: ' ' } }
       */
      function isSingleSpace(node) {
        return node != null && node.type === 'space' && node.value === ' ';
      }

      /**
       * @param {import('postcss-value-parser').Node | undefined} node
       * @param {Set<string>} [operators]
       * @returns {node is import('postcss-value-parser').WordNode}
       */
      function isOperator(node, operators = OPERATORS) {
        return node != null && node.type === 'word' && operators.has(node.value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isStandardSyntaxValue": 395, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 184: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line function',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-comma-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'after',
              symb: context.newline || '' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../functionCommaSpaceChecker": 200, "../functionCommaSpaceFix": 201 }], 185: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line function',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-comma-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'before',
              symb: context.newline || '' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../functionCommaSpaceChecker": 200, "../functionCommaSpaceFix": 201 }], 186: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line function',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-comma-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'after',
              symb: ' ' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../functionCommaSpaceChecker": 200, "../functionCommaSpaceFix": 201 }], 187: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line function',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-comma-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'before',
              symb: ' ' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../functionCommaSpaceChecker": 200, "../functionCommaSpaceFix": 201 }], 188: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (!matchesStringOrRegExp(vendor.unprefixed(node.value), primary)) {
                return;
              }

              const index = declarationValueIndex(decl) + node.sourceIndex;
              const endIndex = index + node.value.length;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index,
                endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxFunction": 387, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 189: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-linear-gradient-no-nonstandard-direction';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected nonstandard direction' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-linear-gradient-no-nonstandard-direction' };


      /**
       * @param {string} source
       * @param {boolean} withToPrefix
       */
      function isStandardDirection(source, withToPrefix) {
        const regexp = withToPrefix ?
        /^to (top|left|bottom|right)(?: (top|left|bottom|right))?$/ :
        /^(top|left|bottom|right)(?: (top|left|bottom|right))?$/;

        const matches = source.match(regexp);

        if (!matches) {
          return false;
        }

        if (matches.length === 2) {
          return true;
        }

        // Cannot repeat side-or-corner, e.g. "to top top"
        if (matches.length === 3 && matches[1] !== matches[2]) {
          return true;
        }

        return false;
      }

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              functionArgumentsSearch(
              valueParser.stringify(valueNode).toLowerCase(),
              /^(-webkit-|-moz-|-o-|-ms-)?linear-gradient$/i,
              (expression, expressionIndex) => {
                const args = expression.split(',');
                const firstArg = (args[0] || '').trim();

                // If the first arg is not standard, return early
                if (!isStandardSyntaxValue(firstArg)) {
                  return;
                }

                // If the first character is a number, we can assume the user intends an angle
                if (/[\d.]/.test(firstArg.charAt(0))) {
                  if (/^[\d.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {
                    return;
                  }

                  complain();

                  return;
                }

                // The first argument may not be a direction: it may be an angle,
                // or a color stop (in which case user gets default direction, "to bottom")
                // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax
                if (!/left|right|top|bottom/.test(firstArg)) {
                  return;
                }

                const withToPrefix = !vendor.prefix(valueNode.value);

                if (!isStandardDirection(firstArg, withToPrefix)) {
                  complain();
                }

                function complain() {
                  const index = declarationValueIndex(decl) + valueNode.sourceIndex + expressionIndex;
                  const endIndex = index + (args[0] || '').trimEnd().length;

                  report({
                    message: messages.rejected,
                    node: decl,
                    index,
                    endIndex,
                    result,
                    ruleName });

                }
              });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/functionArgumentsSearch": 336, "../../utils/isStandardSyntaxValue": 395, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 190: [function (require, module, exports) {
      'use strict';

      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'function-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-max-empty-lines' };


      /**
       * @param {import('postcss').Declaration} decl
       */
      function placeIndexOnValueStart(decl) {
        if (decl.raws.between == null) throw new Error('`between` must be present');

        return decl.prop.length + decl.raws.between.length - 1;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const maxAdjacentNewlines = primary + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            const stringValue = getDeclarationValue(decl);
            /** @type {Array<[string, string]>} */
            const splittedValue = [];
            let sourceIndexStart = 0;

            valueParser(stringValue).walk(node => {
              if (
              node.type !== 'function' /* ignore non functions */ ||
              node.value.length === 0 /* ignore sass lists */)
                {
                  return;
                }

              const stringifiedNode = valueParser.stringify(node);

              if (
              !violatedLFNewLinesRegex.test(stringifiedNode) &&
              !violatedCRLFNewLinesRegex.test(stringifiedNode))
              {
                return;
              }

              if (context.fix) {
                const newNodeString = stringifiedNode.
                replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
                replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

                splittedValue.push([
                stringValue.slice(sourceIndexStart, node.sourceIndex),
                newNodeString]);

                sourceIndexStart = node.sourceIndex + stringifiedNode.length;
              } else {
                report({
                  message: messages.expected(primary),
                  node: decl,
                  index: placeIndexOnValueStart(decl) + node.sourceIndex,
                  result,
                  ruleName });

              }
            });

            if (context.fix && splittedValue.length > 0) {
              const updatedValue =
              splittedValue.reduce((acc, curr) => acc + curr[0] + curr[1], '') +
              stringValue.slice(sourceIndexStart);

              setDeclarationValue(decl, updatedValue);
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 191: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-name-case' };


      const mapLowercaseFunctionNamesToCamelCase = new Map();

      for (const func of keywordSets.camelCaseFunctionNames) {
        mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['lower', 'upper'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            let needFix = false;
            const parsed = valueParser(getDeclarationValue(decl));

            parsed.walk(node => {
              if (node.type !== 'function' || !isStandardSyntaxFunction(node)) {
                return;
              }

              const functionName = node.value;
              const functionNameLowerCase = functionName.toLowerCase();

              if (optionsMatches(secondaryOptions, 'ignoreFunctions', functionName)) {
                return;
              }

              let expectedFunctionName = null;

              if (
              primary === 'lower' &&
              mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase))
              {
                expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);
              } else if (primary === 'lower') {
                expectedFunctionName = functionNameLowerCase;
              } else {
                expectedFunctionName = functionName.toUpperCase();
              }

              if (functionName === expectedFunctionName) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedFunctionName;

                return;
              }

              report({
                message: messages.expected(functionName, expectedFunctionName),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              setDeclarationValue(decl, parsed.toString());
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isStandardSyntaxFunction": 387, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 192: [function (require, module, exports) {
      'use strict';

      /* const fs = require('fs'); */
      const valueParser = require('postcss-value-parser');
      /* const functionsListPath = require('css-functions-list'); */

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const isCustomFunction = require('../../utils/isCustomFunction');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected unknown function "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const functionsList = JSON.parse( /* fs.readFileSync(functionsListPath.toString(), 'utf8') */
          "[\n\t\"abs\",\n\t\"acos\",\n\t\"annotation\",\n\t\"asin\",\n\t\"atan\",\n\t\"atan2\",\n\t\"attr\",\n\t\"blur\",\n\t\"brightness\",\n\t\"calc\",\n\t\"character-variant\",\n\t\"circle\",\n\t\"clamp\",\n\t\"color\",\n\t\"color-contrast\",\n\t\"color-mix\",\n\t\"conic-gradient\",\n\t\"contrast\",\n\t\"cos\",\n\t\"counter\",\n\t\"counters\",\n\t\"cross-fade\",\n\t\"cubic-bezier\",\n\t\"device-cmyk\",\n\t\"drop-shadow\",\n\t\"element\",\n\t\"ellipse\",\n\t\"env\",\n\t\"exp\",\n\t\"fit-content\",\n\t\"format\",\n\t\"grayscale\",\n\t\"hsl\",\n\t\"hsla\",\n\t\"hue-rotate\",\n\t\"hwb\",\n\t\"hypot\",\n\t\"image\",\n\t\"image-set\",\n\t\"inset\",\n\t\"invert\",\n\t\"lab\",\n\t\"layer\",\n\t\"lch\",\n\t\"leader\",\n\t\"linear-gradient\",\n\t\"local\",\n\t\"log\",\n\t\"matrix\",\n\t\"matrix3d\",\n\t\"max\",\n\t\"min\",\n\t\"minmax\",\n\t\"mod\",\n\t\"oklab\",\n\t\"oklch\",\n\t\"opacity\",\n\t\"ornaments\",\n\t\"paint\",\n\t\"path\",\n\t\"perspective\",\n\t\"polygon\",\n\t\"pow\",\n\t\"radial-gradient\",\n\t\"rect\",\n\t\"rem\",\n\t\"repeat\",\n\t\"repeating-conic-gradient\",\n\t\"repeating-linear-gradient\",\n\t\"repeating-radial-gradient\",\n\t\"rgb\",\n\t\"rgba\",\n\t\"rotate\",\n\t\"rotate3d\",\n\t\"rotateX\",\n\t\"rotateY\",\n\t\"rotateZ\",\n\t\"rotatex\",\n\t\"rotatey\",\n\t\"rotatez\",\n\t\"round\",\n\t\"saturate\",\n\t\"scale\",\n\t\"scale3d\",\n\t\"scaleX\",\n\t\"scaleY\",\n\t\"scaleZ\",\n\t\"scalex\",\n\t\"scaley\",\n\t\"scalez\",\n\t\"selector\",\n\t\"sepia\",\n\t\"sign\",\n\t\"sin\",\n\t\"skew\",\n\t\"skewX\",\n\t\"skewY\",\n\t\"skewx\",\n\t\"skewy\",\n\t\"sqrt\",\n\t\"steps\",\n\t\"styleset\",\n\t\"stylistic\",\n\t\"swash\",\n\t\"symbols\",\n\t\"tan\",\n\t\"target-counter\",\n\t\"target-counters\",\n\t\"target-text\",\n\t\"translate\",\n\t\"translate3d\",\n\t\"translateX\",\n\t\"translateY\",\n\t\"translateZ\",\n\t\"translatex\",\n\t\"translatey\",\n\t\"translatez\",\n\t\"type\",\n\t\"url\",\n\t\"var\",\n\t\"-webkit-abs\",\n\t\"-webkit-acos\",\n\t\"-webkit-annotation\",\n\t\"-webkit-asin\",\n\t\"-webkit-atan\",\n\t\"-webkit-atan2\",\n\t\"-webkit-attr\",\n\t\"-webkit-blur\",\n\t\"-webkit-brightness\",\n\t\"-webkit-calc\",\n\t\"-webkit-character-variant\",\n\t\"-webkit-circle\",\n\t\"-webkit-clamp\",\n\t\"-webkit-color\",\n\t\"-webkit-color-contrast\",\n\t\"-webkit-color-mix\",\n\t\"-webkit-conic-gradient\",\n\t\"-webkit-contrast\",\n\t\"-webkit-cos\",\n\t\"-webkit-counter\",\n\t\"-webkit-counters\",\n\t\"-webkit-cross-fade\",\n\t\"-webkit-cubic-bezier\",\n\t\"-webkit-device-cmyk\",\n\t\"-webkit-drop-shadow\",\n\t\"-webkit-element\",\n\t\"-webkit-ellipse\",\n\t\"-webkit-env\",\n\t\"-webkit-exp\",\n\t\"-webkit-fit-content\",\n\t\"-webkit-format\",\n\t\"-webkit-grayscale\",\n\t\"-webkit-hsl\",\n\t\"-webkit-hsla\",\n\t\"-webkit-hue-rotate\",\n\t\"-webkit-hwb\",\n\t\"-webkit-hypot\",\n\t\"-webkit-image\",\n\t\"-webkit-image-set\",\n\t\"-webkit-inset\",\n\t\"-webkit-invert\",\n\t\"-webkit-lab\",\n\t\"-webkit-layer\",\n\t\"-webkit-lch\",\n\t\"-webkit-leader\",\n\t\"-webkit-linear-gradient\",\n\t\"-webkit-local\",\n\t\"-webkit-log\",\n\t\"-webkit-matrix\",\n\t\"-webkit-matrix3d\",\n\t\"-webkit-max\",\n\t\"-webkit-min\",\n\t\"-webkit-minmax\",\n\t\"-webkit-mod\",\n\t\"-webkit-oklab\",\n\t\"-webkit-oklch\",\n\t\"-webkit-opacity\",\n\t\"-webkit-ornaments\",\n\t\"-webkit-paint\",\n\t\"-webkit-path\",\n\t\"-webkit-perspective\",\n\t\"-webkit-polygon\",\n\t\"-webkit-pow\",\n\t\"-webkit-radial-gradient\",\n\t\"-webkit-rect\",\n\t\"-webkit-rem\",\n\t\"-webkit-repeat\",\n\t\"-webkit-repeating-conic-gradient\",\n\t\"-webkit-repeating-linear-gradient\",\n\t\"-webkit-repeating-radial-gradient\",\n\t\"-webkit-rgb\",\n\t\"-webkit-rgba\",\n\t\"-webkit-rotate\",\n\t\"-webkit-rotate3d\",\n\t\"-webkit-rotateX\",\n\t\"-webkit-rotateY\",\n\t\"-webkit-rotateZ\",\n\t\"-webkit-rotatex\",\n\t\"-webkit-rotatey\",\n\t\"-webkit-rotatez\",\n\t\"-webkit-round\",\n\t\"-webkit-saturate\",\n\t\"-webkit-scale\",\n\t\"-webkit-scale3d\",\n\t\"-webkit-scaleX\",\n\t\"-webkit-scaleY\",\n\t\"-webkit-scaleZ\",\n\t\"-webkit-scalex\",\n\t\"-webkit-scaley\",\n\t\"-webkit-scalez\",\n\t\"-webkit-selector\",\n\t\"-webkit-sepia\",\n\t\"-webkit-sign\",\n\t\"-webkit-sin\",\n\t\"-webkit-skew\",\n\t\"-webkit-skewX\",\n\t\"-webkit-skewY\",\n\t\"-webkit-skewx\",\n\t\"-webkit-skewy\",\n\t\"-webkit-sqrt\",\n\t\"-webkit-steps\",\n\t\"-webkit-styleset\",\n\t\"-webkit-stylistic\",\n\t\"-webkit-swash\",\n\t\"-webkit-symbols\",\n\t\"-webkit-tan\",\n\t\"-webkit-target-counter\",\n\t\"-webkit-target-counters\",\n\t\"-webkit-target-text\",\n\t\"-webkit-translate\",\n\t\"-webkit-translate3d\",\n\t\"-webkit-translateX\",\n\t\"-webkit-translateY\",\n\t\"-webkit-translateZ\",\n\t\"-webkit-translatex\",\n\t\"-webkit-translatey\",\n\t\"-webkit-translatez\",\n\t\"-webkit-type\",\n\t\"-webkit-url\",\n\t\"-webkit-var\",\n\t\"-moz-abs\",\n\t\"-moz-acos\",\n\t\"-moz-annotation\",\n\t\"-moz-asin\",\n\t\"-moz-atan\",\n\t\"-moz-atan2\",\n\t\"-moz-attr\",\n\t\"-moz-blur\",\n\t\"-moz-brightness\",\n\t\"-moz-calc\",\n\t\"-moz-character-variant\",\n\t\"-moz-circle\",\n\t\"-moz-clamp\",\n\t\"-moz-color\",\n\t\"-moz-color-contrast\",\n\t\"-moz-color-mix\",\n\t\"-moz-conic-gradient\",\n\t\"-moz-contrast\",\n\t\"-moz-cos\",\n\t\"-moz-counter\",\n\t\"-moz-counters\",\n\t\"-moz-cross-fade\",\n\t\"-moz-cubic-bezier\",\n\t\"-moz-device-cmyk\",\n\t\"-moz-drop-shadow\",\n\t\"-moz-element\",\n\t\"-moz-ellipse\",\n\t\"-moz-env\",\n\t\"-moz-exp\",\n\t\"-moz-fit-content\",\n\t\"-moz-format\",\n\t\"-moz-grayscale\",\n\t\"-moz-hsl\",\n\t\"-moz-hsla\",\n\t\"-moz-hue-rotate\",\n\t\"-moz-hwb\",\n\t\"-moz-hypot\",\n\t\"-moz-image\",\n\t\"-moz-image-set\",\n\t\"-moz-inset\",\n\t\"-moz-invert\",\n\t\"-moz-lab\",\n\t\"-moz-layer\",\n\t\"-moz-lch\",\n\t\"-moz-leader\",\n\t\"-moz-linear-gradient\",\n\t\"-moz-local\",\n\t\"-moz-log\",\n\t\"-moz-matrix\",\n\t\"-moz-matrix3d\",\n\t\"-moz-max\",\n\t\"-moz-min\",\n\t\"-moz-minmax\",\n\t\"-moz-mod\",\n\t\"-moz-oklab\",\n\t\"-moz-oklch\",\n\t\"-moz-opacity\",\n\t\"-moz-ornaments\",\n\t\"-moz-paint\",\n\t\"-moz-path\",\n\t\"-moz-perspective\",\n\t\"-moz-polygon\",\n\t\"-moz-pow\",\n\t\"-moz-radial-gradient\",\n\t\"-moz-rect\",\n\t\"-moz-rem\",\n\t\"-moz-repeat\",\n\t\"-moz-repeating-conic-gradient\",\n\t\"-moz-repeating-linear-gradient\",\n\t\"-moz-repeating-radial-gradient\",\n\t\"-moz-rgb\",\n\t\"-moz-rgba\",\n\t\"-moz-rotate\",\n\t\"-moz-rotate3d\",\n\t\"-moz-rotateX\",\n\t\"-moz-rotateY\",\n\t\"-moz-rotateZ\",\n\t\"-moz-rotatex\",\n\t\"-moz-rotatey\",\n\t\"-moz-rotatez\",\n\t\"-moz-round\",\n\t\"-moz-saturate\",\n\t\"-moz-scale\",\n\t\"-moz-scale3d\",\n\t\"-moz-scaleX\",\n\t\"-moz-scaleY\",\n\t\"-moz-scaleZ\",\n\t\"-moz-scalex\",\n\t\"-moz-scaley\",\n\t\"-moz-scalez\",\n\t\"-moz-selector\",\n\t\"-moz-sepia\",\n\t\"-moz-sign\",\n\t\"-moz-sin\",\n\t\"-moz-skew\",\n\t\"-moz-skewX\",\n\t\"-moz-skewY\",\n\t\"-moz-skewx\",\n\t\"-moz-skewy\",\n\t\"-moz-sqrt\",\n\t\"-moz-steps\",\n\t\"-moz-styleset\",\n\t\"-moz-stylistic\",\n\t\"-moz-swash\",\n\t\"-moz-symbols\",\n\t\"-moz-tan\",\n\t\"-moz-target-counter\",\n\t\"-moz-target-counters\",\n\t\"-moz-target-text\",\n\t\"-moz-translate\",\n\t\"-moz-translate3d\",\n\t\"-moz-translateX\",\n\t\"-moz-translateY\",\n\t\"-moz-translateZ\",\n\t\"-moz-translatex\",\n\t\"-moz-translatey\",\n\t\"-moz-translatez\",\n\t\"-moz-type\",\n\t\"-moz-url\",\n\t\"-moz-var\",\n\t\"-o-abs\",\n\t\"-o-acos\",\n\t\"-o-annotation\",\n\t\"-o-asin\",\n\t\"-o-atan\",\n\t\"-o-atan2\",\n\t\"-o-attr\",\n\t\"-o-blur\",\n\t\"-o-brightness\",\n\t\"-o-calc\",\n\t\"-o-character-variant\",\n\t\"-o-circle\",\n\t\"-o-clamp\",\n\t\"-o-color\",\n\t\"-o-color-contrast\",\n\t\"-o-color-mix\",\n\t\"-o-conic-gradient\",\n\t\"-o-contrast\",\n\t\"-o-cos\",\n\t\"-o-counter\",\n\t\"-o-counters\",\n\t\"-o-cross-fade\",\n\t\"-o-cubic-bezier\",\n\t\"-o-device-cmyk\",\n\t\"-o-drop-shadow\",\n\t\"-o-element\",\n\t\"-o-ellipse\",\n\t\"-o-env\",\n\t\"-o-exp\",\n\t\"-o-fit-content\",\n\t\"-o-format\",\n\t\"-o-grayscale\",\n\t\"-o-hsl\",\n\t\"-o-hsla\",\n\t\"-o-hue-rotate\",\n\t\"-o-hwb\",\n\t\"-o-hypot\",\n\t\"-o-image\",\n\t\"-o-image-set\",\n\t\"-o-inset\",\n\t\"-o-invert\",\n\t\"-o-lab\",\n\t\"-o-layer\",\n\t\"-o-lch\",\n\t\"-o-leader\",\n\t\"-o-linear-gradient\",\n\t\"-o-local\",\n\t\"-o-log\",\n\t\"-o-matrix\",\n\t\"-o-matrix3d\",\n\t\"-o-max\",\n\t\"-o-min\",\n\t\"-o-minmax\",\n\t\"-o-mod\",\n\t\"-o-oklab\",\n\t\"-o-oklch\",\n\t\"-o-opacity\",\n\t\"-o-ornaments\",\n\t\"-o-paint\",\n\t\"-o-path\",\n\t\"-o-perspective\",\n\t\"-o-polygon\",\n\t\"-o-pow\",\n\t\"-o-radial-gradient\",\n\t\"-o-rect\",\n\t\"-o-rem\",\n\t\"-o-repeat\",\n\t\"-o-repeating-conic-gradient\",\n\t\"-o-repeating-linear-gradient\",\n\t\"-o-repeating-radial-gradient\",\n\t\"-o-rgb\",\n\t\"-o-rgba\",\n\t\"-o-rotate\",\n\t\"-o-rotate3d\",\n\t\"-o-rotateX\",\n\t\"-o-rotateY\",\n\t\"-o-rotateZ\",\n\t\"-o-rotatex\",\n\t\"-o-rotatey\",\n\t\"-o-rotatez\",\n\t\"-o-round\",\n\t\"-o-saturate\",\n\t\"-o-scale\",\n\t\"-o-scale3d\",\n\t\"-o-scaleX\",\n\t\"-o-scaleY\",\n\t\"-o-scaleZ\",\n\t\"-o-scalex\",\n\t\"-o-scaley\",\n\t\"-o-scalez\",\n\t\"-o-selector\",\n\t\"-o-sepia\",\n\t\"-o-sign\",\n\t\"-o-sin\",\n\t\"-o-skew\",\n\t\"-o-skewX\",\n\t\"-o-skewY\",\n\t\"-o-skewx\",\n\t\"-o-skewy\",\n\t\"-o-sqrt\",\n\t\"-o-steps\",\n\t\"-o-styleset\",\n\t\"-o-stylistic\",\n\t\"-o-swash\",\n\t\"-o-symbols\",\n\t\"-o-tan\",\n\t\"-o-target-counter\",\n\t\"-o-target-counters\",\n\t\"-o-target-text\",\n\t\"-o-translate\",\n\t\"-o-translate3d\",\n\t\"-o-translateX\",\n\t\"-o-translateY\",\n\t\"-o-translateZ\",\n\t\"-o-translatex\",\n\t\"-o-translatey\",\n\t\"-o-translatez\",\n\t\"-o-type\",\n\t\"-o-url\",\n\t\"-o-var\",\n\t\"-ms-abs\",\n\t\"-ms-acos\",\n\t\"-ms-annotation\",\n\t\"-ms-asin\",\n\t\"-ms-atan\",\n\t\"-ms-atan2\",\n\t\"-ms-attr\",\n\t\"-ms-blur\",\n\t\"-ms-brightness\",\n\t\"-ms-calc\",\n\t\"-ms-character-variant\",\n\t\"-ms-circle\",\n\t\"-ms-clamp\",\n\t\"-ms-color\",\n\t\"-ms-color-contrast\",\n\t\"-ms-color-mix\",\n\t\"-ms-conic-gradient\",\n\t\"-ms-contrast\",\n\t\"-ms-cos\",\n\t\"-ms-counter\",\n\t\"-ms-counters\",\n\t\"-ms-cross-fade\",\n\t\"-ms-cubic-bezier\",\n\t\"-ms-device-cmyk\",\n\t\"-ms-drop-shadow\",\n\t\"-ms-element\",\n\t\"-ms-ellipse\",\n\t\"-ms-env\",\n\t\"-ms-exp\",\n\t\"-ms-fit-content\",\n\t\"-ms-format\",\n\t\"-ms-grayscale\",\n\t\"-ms-hsl\",\n\t\"-ms-hsla\",\n\t\"-ms-hue-rotate\",\n\t\"-ms-hwb\",\n\t\"-ms-hypot\",\n\t\"-ms-image\",\n\t\"-ms-image-set\",\n\t\"-ms-inset\",\n\t\"-ms-invert\",\n\t\"-ms-lab\",\n\t\"-ms-layer\",\n\t\"-ms-lch\",\n\t\"-ms-leader\",\n\t\"-ms-linear-gradient\",\n\t\"-ms-local\",\n\t\"-ms-log\",\n\t\"-ms-matrix\",\n\t\"-ms-matrix3d\",\n\t\"-ms-max\",\n\t\"-ms-min\",\n\t\"-ms-minmax\",\n\t\"-ms-mod\",\n\t\"-ms-oklab\",\n\t\"-ms-oklch\",\n\t\"-ms-opacity\",\n\t\"-ms-ornaments\",\n\t\"-ms-paint\",\n\t\"-ms-path\",\n\t\"-ms-perspective\",\n\t\"-ms-polygon\",\n\t\"-ms-pow\",\n\t\"-ms-radial-gradient\",\n\t\"-ms-rect\",\n\t\"-ms-rem\",\n\t\"-ms-repeat\",\n\t\"-ms-repeating-conic-gradient\",\n\t\"-ms-repeating-linear-gradient\",\n\t\"-ms-repeating-radial-gradient\",\n\t\"-ms-rgb\",\n\t\"-ms-rgba\",\n\t\"-ms-rotate\",\n\t\"-ms-rotate3d\",\n\t\"-ms-rotateX\",\n\t\"-ms-rotateY\",\n\t\"-ms-rotateZ\",\n\t\"-ms-rotatex\",\n\t\"-ms-rotatey\",\n\t\"-ms-rotatez\",\n\t\"-ms-round\",\n\t\"-ms-saturate\",\n\t\"-ms-scale\",\n\t\"-ms-scale3d\",\n\t\"-ms-scaleX\",\n\t\"-ms-scaleY\",\n\t\"-ms-scaleZ\",\n\t\"-ms-scalex\",\n\t\"-ms-scaley\",\n\t\"-ms-scalez\",\n\t\"-ms-selector\",\n\t\"-ms-sepia\",\n\t\"-ms-sign\",\n\t\"-ms-sin\",\n\t\"-ms-skew\",\n\t\"-ms-skewX\",\n\t\"-ms-skewY\",\n\t\"-ms-skewx\",\n\t\"-ms-skewy\",\n\t\"-ms-sqrt\",\n\t\"-ms-steps\",\n\t\"-ms-styleset\",\n\t\"-ms-stylistic\",\n\t\"-ms-swash\",\n\t\"-ms-symbols\",\n\t\"-ms-tan\",\n\t\"-ms-target-counter\",\n\t\"-ms-target-counters\",\n\t\"-ms-target-text\",\n\t\"-ms-translate\",\n\t\"-ms-translate3d\",\n\t\"-ms-translateX\",\n\t\"-ms-translateY\",\n\t\"-ms-translateZ\",\n\t\"-ms-translatex\",\n\t\"-ms-translatey\",\n\t\"-ms-translatez\",\n\t\"-ms-type\",\n\t\"-ms-url\",\n\t\"-ms-var\"\n]\n");

          root.walkDecls(decl => {
            const { value } = decl;

            valueParser(value).walk(node => {
              const name = node.value;

              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (isCustomFunction(name)) {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreFunctions', name)) {
                return;
              }

              if (functionsList.includes(name.toLowerCase())) {
                return;
              }

              report({
                message: messages.rejected(name),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName,
                word: name });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/isCustomFunction": 365, "../../utils/isStandardSyntaxFunction": 387, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 193: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-newline-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected newline after "("',
        expectedClosing: 'Expected newline before ")"',
        expectedOpeningMultiLine: 'Expected newline after "(" in a multi-line function',
        rejectedOpeningMultiLine: 'Unexpected whitespace after "(" in a multi-line function',
        expectedClosingMultiLine: 'Expected newline before ")" in a multi-line function',
        rejectedClosingMultiLine: 'Unexpected whitespace before ")" in a multi-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-parentheses-newline-inside' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = getDeclarationValue(decl);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isMultiLine = !isSingleLineString(functionString);
              const containsNewline = /** @type {string} */str => str.includes('\n');

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;
              const checkBefore = getCheckBefore(valueNode);

              if (primary === 'always' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedOpeningMultiLine, openingIndex);
                }
              }

              if (isMultiLine && primary === 'never-multi-line' && checkBefore !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForNever(valueNode);
                } else {
                  complain(messages.rejectedOpeningMultiLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;
              const checkAfter = getCheckAfter(valueNode);

              if (primary === 'always' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedClosingMultiLine, closingIndex);
                }
              }

              if (isMultiLine && primary === 'never-multi-line' && checkAfter !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForNever(valueNode);
                } else {
                  complain(messages.rejectedClosingMultiLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              setDeclarationValue(decl, parsedValue.toString());
            }

            /**
             * @param {string} message
             * @param {number} offset
             */
            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      };

      /** @typedef {import('postcss-value-parser').FunctionNode} FunctionNode */

      /**
       * @param {FunctionNode} valueNode
       */
      function getCheckBefore(valueNode) {
        let before = valueNode.before;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            before += node.value;
            continue;
          }

          break;
        }

        return before;
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function getCheckAfter(valueNode) {
        let after = '';

        for (const node of [...valueNode.nodes].reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            after = node.value + after;
            continue;
          }

          break;
        }

        after += valueNode.after;

        return after;
      }

      /**
       * @param {FunctionNode} valueNode
       * @param {string} newline
       */
      function fixBeforeForAlways(valueNode, newline) {
        let target;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            target = node;
            continue;
          }

          break;
        }

        if (target) {
          target.value = newline + target.value;
        } else {
          valueNode.before = newline + valueNode.before;
        }
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function fixBeforeForNever(valueNode) {
        valueNode.before = '';

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      /**
       * @param {FunctionNode} valueNode
       * @param {string} newline
       */
      function fixAfterForAlways(valueNode, newline) {
        valueNode.after = newline + valueNode.after;
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function fixAfterForNever(valueNode) {
        valueNode.after = '';

        for (const node of [...valueNode.nodes].reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isSingleLineString": 381, "../../utils/isStandardSyntaxFunction": 387, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 194: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"',
        expectedOpeningSingleLine: 'Expected single space after "(" in a single-line function',
        rejectedOpeningSingleLine: 'Unexpected whitespace after "(" in a single-line function',
        expectedClosingSingleLine: 'Expected single space before ")" in a single-line function',
        rejectedClosingSingleLine: 'Unexpected whitespace before ")" in a single-line function' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-parentheses-space-inside' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = getDeclarationValue(decl);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              // Ignore function without parameters
              if (!valueNode.nodes.length) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isSingleLine = isSingleLineString(functionString);

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;

              if (primary === 'always' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (primary === 'never' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpening, openingIndex);
                }
              }

              if (isSingleLine && primary === 'always-single-line' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpeningSingleLine, openingIndex);
                }
              }

              if (isSingleLine && primary === 'never-single-line' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpeningSingleLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;

              if (primary === 'always' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (primary === 'never' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosing, closingIndex);
                }
              }

              if (isSingleLine && primary === 'always-single-line' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosingSingleLine, closingIndex);
                }
              }

              if (isSingleLine && primary === 'never-single-line' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosingSingleLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              setDeclarationValue(decl, parsedValue.toString());
            }

            /**
             * @param {string} message
             * @param {number} offset
             */
            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isSingleLineString": 381, "../../utils/isStandardSyntaxFunction": 387, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 195: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-no-scheme-relative';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected scheme-relative url' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-url-no-scheme-relative' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const url = args.trim().replace(/^['"]+|['"]+$/g, '');

              if (!isStandardSyntaxUrl(url) || !url.startsWith('//')) {
                return;
              }

              report({
                message: messages.rejected,
                node: decl,
                index,
                endIndex: index + args.length,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 336, "../../utils/isStandardSyntaxUrl": 394, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 196: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-quotes';

      const messages = ruleMessages(ruleName, {
        expected: functionName => `Expected quotes around "${functionName}" function argument`,
        rejected: functionName => `Unexpected quotes around "${functionName}" function argument` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-url-quotes' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['empty'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(checkAtRuleParams);
          root.walkDecls(checkDeclParams);

          /**
           * @param {import('postcss').Declaration} decl
           */
          function checkDeclParams(decl) {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              checkArgs(args, decl, index, 'url');
            });
          }

          /**
           * @param {import('postcss').AtRule} atRule
           */
          function checkAtRuleParams(atRule) {
            const atRuleParamsLowerCase = atRule.params.toLowerCase();

            functionArgumentsSearch(atRuleParamsLowerCase, 'url', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'url-prefix', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url-prefix');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'domain', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'domain');
            });
          }

          /**
           * @param {string} args
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {string} functionName
           */
          function checkArgs(args, node, index, functionName) {
            let shouldHasQuotes = primary === 'always';

            const leftTrimmedArgs = args.trimStart();

            if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
              return;
            }

            const complaintIndex = index + args.length - leftTrimmedArgs.length;
            const complaintEndIndex = index + args.length;
            const hasQuotes = leftTrimmedArgs.startsWith("'") || leftTrimmedArgs.startsWith('"');

            const trimmedArg = args.trim();
            const isEmptyArgument = ['', "''", '""'].includes(trimmedArg);

            if (optionsMatches(secondaryOptions, 'except', 'empty') && isEmptyArgument) {
              shouldHasQuotes = !shouldHasQuotes;
            }

            if (shouldHasQuotes) {
              if (hasQuotes) {
                return;
              }

              complain(messages.expected(functionName), node, complaintIndex, complaintEndIndex);
            } else {
              if (!hasQuotes) {
                return;
              }

              complain(messages.rejected(functionName), node, complaintIndex, complaintEndIndex);
            }
          }

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {number} endIndex
           */
          function complain(message, node, index, endIndex) {
            report({
              message,
              node,
              index,
              endIndex,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/functionArgumentsSearch": 336, "../../utils/isStandardSyntaxUrl": 394, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 197: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-url-scheme-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-url-scheme-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = args.trim();

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (matchesStringOrRegExp(scheme, primary)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                endIndex: index + args.length,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 336, "../../utils/getSchemeFromUrl": 346, "../../utils/isStandardSyntaxUrl": 394, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 198: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-url-scheme-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-url-scheme-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = args.trim();

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (!matchesStringOrRegExp(scheme, primary)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                endIndex: index + args.length,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 336, "../../utils/getSchemeFromUrl": 346, "../../utils/isStandardSyntaxUrl": 394, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 199: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-whitespace-after';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected whitespace after ")"',
        rejected: 'Unexpected whitespace after ")"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/function-whitespace-after' };


      const ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss').Node} node
           * @param {string} value
           * @param {number} nodeIndex
           * @param {((index: number) => void) | undefined} fix
           */
          function check(node, value, nodeIndex, fix) {
            styleSearch(
            {
              source: value,
              target: ')',
              functionArguments: 'only' },

            match => {
              checkClosingParen(value, match.startIndex + 1, node, nodeIndex, fix);
            });

          }

          /**
           * @param {string} source
           * @param {number} index
           * @param {import('postcss').Node} node
           * @param {number} nodeIndex
           * @param {((index: number) => void) | undefined} fix
           */
          function checkClosingParen(source, index, node, nodeIndex, fix) {
            const nextChar = source.charAt(index);

            if (!nextChar) return;

            if (primary === 'always') {
              // Allow for the next character to be a single empty space,
              // another closing parenthesis, a comma, or the end of the value
              if (nextChar === ' ') {
                return;
              }

              if (nextChar === '\n') {
                return;
              }

              if (source.slice(index, index + 2) === '\r\n') {
                return;
              }

              if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
                return;
              }

              if (fix) {
                fix(index);

                return;
              }

              report({
                message: messages.expected,
                node,
                index: nodeIndex + index,
                result,
                ruleName });

            } else if (primary === 'never' && isWhitespace(nextChar)) {
              if (fix) {
                fix(index);

                return;
              }

              report({
                message: messages.rejected,
                node,
                index: nodeIndex + index,
                result,
                ruleName });

            }
          }

          /**
           * @param {string} value
           */
          function createFixer(value) {
            let fixed = '';
            let lastIndex = 0;
            /** @type {(index: number) => void} */
            let applyFix;

            if (primary === 'always') {
              applyFix = index => {
                // eslint-disable-next-line prefer-template
                fixed += value.slice(lastIndex, index) + ' ';
                lastIndex = index;
              };
            } else if (primary === 'never') {
              applyFix = index => {
                let whitespaceEndIndex = index + 1;

                while (
                whitespaceEndIndex < value.length &&
                isWhitespace(value.charAt(whitespaceEndIndex)))
                {
                  whitespaceEndIndex++;
                }

                fixed += value.slice(lastIndex, index);
                lastIndex = whitespaceEndIndex;
              };
            } else {
              throw new Error(`Unexpected option: "${primary}"`);
            }

            return {
              applyFix,
              get hasFixed() {
                return Boolean(lastIndex);
              },
              get fixed() {
                return fixed + value.slice(lastIndex);
              } };

          }

          root.walkAtRules(/^import$/i, atRule => {
            const param = atRule.raws.params && atRule.raws.params.raw || atRule.params;
            const fixer = context.fix && createFixer(param);

            check(atRule, param, atRuleParamIndex(atRule), fixer ? fixer.applyFix : undefined);

            if (fixer && fixer.hasFixed) {
              if (atRule.raws.params) {
                atRule.raws.params.raw = fixer.fixed;
              } else {
                atRule.params = fixer.fixed;
              }
            }
          });
          root.walkDecls(decl => {
            const value = getDeclarationValue(decl);
            const fixer = context.fix && createFixer(value);

            check(decl, value, declarationValueIndex(decl), fixer ? fixer.applyFix : undefined);

            if (fixer && fixer.hasFixed) {
              setDeclarationValue(decl, fixer.fixed);
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isWhitespace": 399, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "style-search": 89 }], 200: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const getDeclarationValue = require('../utils/getDeclarationValue');
      const isStandardSyntaxFunction = require('../utils/isStandardSyntaxFunction');
      const report = require('../utils/report');
      const setDeclarationValue = require('../utils/setDeclarationValue');
      const valueParser = require('postcss-value-parser');

      /** @typedef {import('postcss-value-parser').Node} ValueParserNode */
      /** @typedef {import('postcss-value-parser').DivNode} ValueParserDivNode */
      /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   fix: ((node: ValueParserDivNode, index: number, nodes: ValueParserNode[]) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function functionCommaSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          const declValue = getDeclarationValue(decl);

          let hasFixed;
          const parsedValue = valueParser(declValue);

          parsedValue.walk(valueNode => {
            if (valueNode.type !== 'function') {
              return;
            }

            if (!isStandardSyntaxFunction(valueNode)) {
              return;
            }

            // Ignore `url()` arguments, which may contain data URIs or other funky stuff
            if (valueNode.value.toLowerCase() === 'url') {
              return;
            }

            const argumentStrings = valueNode.nodes.map(node => valueParser.stringify(node));

            const functionArguments = (() => {
              // Remove function name and parens
              let result = valueNode.before + argumentStrings.join('') + valueNode.after;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              // eslint-disable-next-line regexp/no-dupe-disjunctions -- TODO: Possible to simplify the regex.
              result = result.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return result;
            })();

            /**
             * Gets the index of the comma for checking.
             * @param {ValueParserDivNode} commaNode The comma node
             * @param {number} nodeIndex The index of the comma node
             * @returns {number} The index of the comma for checking
             */
            const getCommaCheckIndex = (commaNode, nodeIndex) => {
              let commaBefore =
              valueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              // eslint-disable-next-line regexp/no-dupe-disjunctions -- TODO: Possible to simplify the regex.
              commaBefore = commaBefore.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return commaBefore.length;
            };

            /** @type {{ commaNode: ValueParserDivNode, checkIndex: number, nodeIndex: number }[]} */
            const commaDataList = [];

            for (const [nodeIndex, node] of valueNode.nodes.entries()) {
              if (node.type !== 'div' || node.value !== ',') {
                continue;
              }

              const checkIndex = getCommaCheckIndex(node, nodeIndex);

              commaDataList.push({
                commaNode: node,
                checkIndex,
                nodeIndex });

            }

            for (const { commaNode, checkIndex, nodeIndex } of commaDataList) {
              opts.locationChecker({
                source: functionArguments,
                index: checkIndex,
                err: message => {
                  const index =
                  declarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;

                  if (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {
                    hasFixed = true;

                    return;
                  }

                  report({
                    index,
                    message,
                    node: decl,
                    result: opts.result,
                    ruleName: opts.checkedRuleName });

                } });

            }
          });

          if (hasFixed) {
            setDeclarationValue(decl, parsedValue.toString());
          }
        });
      };

    }, { "../utils/declarationValueIndex": 330, "../utils/getDeclarationValue": 338, "../utils/isStandardSyntaxFunction": 387, "../utils/report": 409, "../utils/setDeclarationValue": 412, "postcss-value-parser": 57 }], 201: [function (require, module, exports) {
      'use strict';

      /**
       * @param {{
       *   div: import('postcss-value-parser').DivNode,
       *   index: number,
       *   nodes: import('postcss-value-parser').Node[],
       *   expectation: string,
       *   position: 'before' | 'after',
       *   symb: string,
       * }} params
       * @returns {boolean}
       */
      module.exports = function functionCommaSpaceFix(params) {
        const { div, index, nodes, expectation, position, symb } = params;

        if (expectation.startsWith('always')) {
          div[position] = symb;

          return true;
        }

        if (expectation.startsWith('never')) {
          div[position] = '';

          for (let i = index + 1; i < nodes.length; i++) {
            const node = nodes[i];

            if (node === undefined) {
              continue;
            }

            if (node.type === 'comment') {
              continue;
            }

            if (node.type === 'space') {
              node.value = '';
              continue;
            }

            break;
          }

          return true;
        }

        return false;
      };

    }, {}], 202: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'hue-degree-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/hue-degree-notation' };


      const HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];
      const HUE_THIRD_ARG_FUNCS = ['lch'];
      const HUE_FUNCS = new Set([...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS]);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['angle', 'number'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (node.type !== 'function') return;

              if (!HUE_FUNCS.has(node.value.toLowerCase())) return;

              const hue = findHue(node);

              if (!hue) return;

              const { value } = hue;

              if (!isStandardSyntaxValue(value)) return;

              if (!isDegree(value) && !isNumber(value)) return;

              if (primary === 'angle' && isDegree(value)) return;

              if (primary === 'number' && isNumber(value)) return;

              const fixed = primary === 'angle' ? asDegree(value) : asNumber(value);
              const unfixed = value;

              if (context.fix) {
                hue.value = fixed;
                needsFix = true;

                return;
              }

              const valueIndex = declarationValueIndex(decl);

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index: valueIndex + hue.sourceIndex,
                endIndex: valueIndex + hue.sourceEndIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} value
       */
      function asDegree(value) {
        return `${value}deg`;
      }

      /**
       * @param {string} value
       */
      function asNumber(value) {
        const dimension = valueParser.unit(value);

        if (dimension) return dimension.number;

        throw new TypeError(`The "${value}" value must have a unit`);
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       */
      function findHue(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');
        const value = node.value.toLowerCase();

        if (HUE_FIRST_ARG_FUNCS.includes(value)) {
          return args[0];
        }

        if (HUE_THIRD_ARG_FUNCS.includes(value)) {
          return args[2];
        }

        return undefined;
      }

      /**
       * @param {string} value
       */
      function isDegree(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit.toLowerCase() === 'deg';
      }

      /**
       * @param {string} value
       */
      function isNumber(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/isStandardSyntaxValue": 395, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 203: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const setAtRuleParams = require('../../utils/setAtRuleParams');
      const getAtRuleParams = require('../../utils/getAtRuleParams');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');

      const ruleName = 'import-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/import-notation' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['string', 'url'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^import$/i, checkAtRuleImportParams);

          /**
           * @param {import('postcss').AtRule} atRule
           */
          function checkAtRuleImportParams(atRule) {
            const params = getAtRuleParams(atRule);
            const parsed = valueParser(params);

            for (const node of parsed.nodes) {
              const start = atRuleParamIndex(atRule);
              const end = start + node.sourceEndIndex;

              if (primary === 'string') {
                if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                  const urlFunctionFull = valueParser.stringify(node);
                  const urlFunctionArguments = valueParser.stringify(node.nodes);

                  const quotedUrlFunctionFirstArgument =
                  node.nodes[0] && node.nodes[0].type === 'word' ?
                  `"${urlFunctionArguments}"` :
                  urlFunctionArguments;

                  if (context.fix) {
                    const restAtRuleParams = atRule.params.slice(node.sourceEndIndex);

                    setAtRuleParams(atRule, `${quotedUrlFunctionFirstArgument}${restAtRuleParams}`);

                    return;
                  }

                  complain(
                  messages.expected(urlFunctionFull, quotedUrlFunctionFirstArgument),
                  atRule,
                  start,
                  end);


                  return;
                }
              }

              if (primary === 'url') {
                if (node.type === 'space') return;

                if (node.type === 'word' || node.type === 'string') {
                  const path = valueParser.stringify(node);

                  const urlFunctionFull = `url(${path})`;

                  if (context.fix) {
                    const restAtRuleParams = atRule.params.slice(node.sourceEndIndex);

                    setAtRuleParams(atRule, `${urlFunctionFull}${restAtRuleParams}`);

                    return;
                  }

                  const quotedNodeValue =
                  node.type === 'word' ? `"${node.value}"` : `${node.quote}${node.value}${node.quote}`;

                  complain(messages.expected(quotedNodeValue, urlFunctionFull), atRule, start, end);

                  return;
                }
              }
            }
          }

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {number} endIndex
           */
          function complain(message, node, index, endIndex) {
            report({
              message,
              node,
              index,
              endIndex,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/getAtRuleParams": 337, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setAtRuleParams": 411, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 204: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRoot, isRule } = require('../../utils/typeGuards');
      const { isBoolean, isNumber, isString, assertString } = require('../../utils/validateTypes');

      const ruleName = 'indentation';
      const messages = ruleMessages(ruleName, {
        expected: x => `Expected indentation of ${x}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/indentation' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions = {}, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isNumber, 'tab'] },

          {
            actual: secondaryOptions,
            possible: {
              baseIndentLevel: [isNumber, 'auto'],
              except: ['block', 'value', 'param'],
              ignore: ['value', 'param', 'inside-parens'],
              indentInsideParens: ['twice', 'once-at-root-twice-in-block'],
              indentClosingBrace: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const spaceCount = isNumber(primary) ? primary : null;
          const indentChar = spaceCount == null ? '\t' : ' '.repeat(spaceCount);
          const warningWord = primary === 'tab' ? 'tab' : 'space';

          /** @type {number | 'auto'} */
          const baseIndentLevel = secondaryOptions.baseIndentLevel;
          /** @type {boolean} */
          const indentClosingBrace = secondaryOptions.indentClosingBrace;

          /**
           * @param {number} level
           */
          const legibleExpectation = level => {
            const count = spaceCount == null ? level : level * spaceCount;
            const quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;

            return `${count} ${quantifiedWarningWord}`;
          };

          // Cycle through all nodes using walk.
          root.walk(node => {
            if (isRoot(node)) {
              // Ignore nested template literals root in css-in-js lang
              return;
            }

            const nodeLevel = indentationLevel(node);

            // Cut out any * and _ hacks from `before`
            const before = (node.raws.before || '').replace(/[*_]$/, '');
            const after = typeof node.raws.after === 'string' ? node.raws.after : '';
            const parent = node.parent;

            if (!parent) throw new Error('A parent node must be present');

            const expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel);

            // Only inspect the spaces before the node
            // if this is the first node in root
            // or there is a newline in the `before` string.
            // (If there is no newline before a node,
            // there is no "indentation" to check.)
            const isFirstChild = parent.type === 'root' && parent.first === node;
            const lastIndexOfNewline = before.lastIndexOf('\n');

            // Inspect whitespace in the `before` string that is
            // *after* the *last* newline character,
            // because anything besides that is not indentation for this node:
            // it is some other kind of separation, checked by some separate rule
            if (
            (lastIndexOfNewline !== -1 ||
            isFirstChild && (
            !getDocument(parent) ||
            parent.raws.codeBefore && parent.raws.codeBefore.endsWith('\n'))) &&
            before.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation)
            {
              if (context.fix) {
                if (isFirstChild && isString(node.raws.before)) {
                  node.raws.before = node.raws.before.replace(
                  /^[ \t]*(?=\S|$)/,
                  expectedOpeningBraceIndentation);

                }

                node.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(nodeLevel)),
                  node,
                  result,
                  ruleName });

              }
            }

            // Only blocks have the `after` string to check.
            // Only inspect `after` strings that start with a newline;
            // otherwise there's no indentation involved.
            // And check `indentClosingBrace` to see if it should be indented an extra level.
            const closingBraceLevel = indentClosingBrace ? nodeLevel + 1 : nodeLevel;
            const expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);

            if (
            (isRule(node) || isAtRule(node)) &&
            hasBlock(node) &&
            after &&
            after.includes('\n') &&
            after.slice(after.lastIndexOf('\n') + 1) !== expectedClosingBraceIndentation)
            {
              if (context.fix) {
                node.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(closingBraceLevel)),
                  node,
                  index: node.toString().length - 1,
                  result,
                  ruleName });

              }
            }

            // If this is a declaration, check the value
            if (isDeclaration(node)) {
              checkValue(node, nodeLevel);
            }

            // If this is a rule, check the selector
            if (isRule(node)) {
              checkSelector(node, nodeLevel);
            }

            // If this is an at rule, check the params
            if (isAtRule(node)) {
              checkAtRuleParams(node, nodeLevel);
            }
          });

          /**
           * @param {import('postcss').Node} node
           * @param {number} level
           * @returns {number}
           */
          function indentationLevel(node, level = 0) {
            if (!node.parent) throw new Error('A parent node must be present');

            if (isRoot(node.parent)) {
              return level + getRootBaseIndentLevel(node.parent, baseIndentLevel, primary);
            }

            let calculatedLevel;

            // Indentation level equals the ancestor nodes
            // separating this node from root; so recursively
            // run this operation
            calculatedLevel = indentationLevel(node.parent, level + 1);

            // If `secondaryOptions.except` includes "block",
            // blocks are taken down one from their calculated level
            // (all blocks are the same level as their parents)
            if (
            optionsMatches(secondaryOptions, 'except', 'block') && (
            isRule(node) || isAtRule(node)) &&
            hasBlock(node))
            {
              calculatedLevel--;
            }

            return calculatedLevel;
          }

          /**
           * @param {import('postcss').Declaration} decl
           * @param {number} declLevel
           */
          function checkValue(decl, declLevel) {
            if (!decl.value.includes('\n')) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignore', 'value')) {
              return;
            }

            const declString = decl.toString();
            const valueLevel = optionsMatches(secondaryOptions, 'except', 'value') ?
            declLevel :
            declLevel + 1;

            checkMultilineBit(declString, valueLevel, decl);
          }

          /**
           * @param {import('postcss').Rule} ruleNode
           * @param {number} ruleLevel
           */
          function checkSelector(ruleNode, ruleLevel) {
            const selector = ruleNode.selector;

            // Less mixins have params, and they should be indented extra
            // @ts-expect-error -- TS2339: Property 'params' does not exist on type 'Rule'.
            if (ruleNode.params) {
              ruleLevel += 1;
            }

            checkMultilineBit(selector, ruleLevel, ruleNode);
          }

          /**
           * @param {import('postcss').AtRule} atRule
           * @param {number} ruleLevel
           */
          function checkAtRuleParams(atRule, ruleLevel) {
            if (optionsMatches(secondaryOptions, 'ignore', 'param')) {
              return;
            }

            // @nest and SCSS's @at-root rules should be treated like regular rules, not expected
            // to have their params (selectors) indented
            const paramLevel =
            optionsMatches(secondaryOptions, 'except', 'param') ||
            atRule.name === 'nest' ||
            atRule.name === 'at-root' ?
            ruleLevel :
            ruleLevel + 1;

            checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);
          }

          /**
           * @param {string} source
           * @param {number} newlineIndentLevel
           * @param {import('postcss').Node} node
           */
          function checkMultilineBit(source, newlineIndentLevel, node) {
            if (!source.includes('\n')) {
              return;
            }

            // Data for current node fixing
            /** @type {Array<{ expectedIndentation: string, currentIndentation: string, startIndex: number }>} */
            const fixPositions = [];

            // `outsideParens` because function arguments and also non-standard parenthesized stuff like
            // Sass maps are ignored to allow for arbitrary indentation
            let parentheticalDepth = 0;

            const ignoreInsideParans = optionsMatches(secondaryOptions, 'ignore', 'inside-parens');

            styleSearch(
            {
              source,
              target: '\n',
              // @ts-expect-error -- The `outsideParens` option is unsupported. Why?
              outsideParens: ignoreInsideParans },

            (match, matchCount) => {
              const precedesClosingParenthesis = /^[ \t]*\)/.test(source.slice(match.startIndex + 1));

              if (ignoreInsideParans && (precedesClosingParenthesis || match.insideParens)) {
                return;
              }

              let expectedIndentLevel = newlineIndentLevel;

              // Modififications for parenthetical content
              if (!ignoreInsideParans && match.insideParens) {
                // If the first match in is within parentheses, reduce the parenthesis penalty
                if (matchCount === 1) parentheticalDepth -= 1;

                // Account for windows line endings
                let newlineIndex = match.startIndex;

                if (source[match.startIndex - 1] === '\r') {
                  newlineIndex--;
                }

                const followsOpeningParenthesis = /\([ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningParenthesis) {
                  parentheticalDepth += 1;
                }

                const followsOpeningBrace = /\{[ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningBrace) {
                  parentheticalDepth += 1;
                }

                const startingClosingBrace = /^[ \t]*\}/.test(source.slice(match.startIndex + 1));

                if (startingClosingBrace) {
                  parentheticalDepth -= 1;
                }

                expectedIndentLevel += parentheticalDepth;

                // Past this point, adjustments to parentheticalDepth affect next line

                if (precedesClosingParenthesis) {
                  parentheticalDepth -= 1;
                }

                switch (secondaryOptions.indentInsideParens) {
                  case 'twice':
                    if (!precedesClosingParenthesis || indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  case 'once-at-root-twice-in-block':
                    if (node.parent === node.root()) {
                      if (precedesClosingParenthesis && !indentClosingBrace) {
                        expectedIndentLevel -= 1;
                      }

                      break;
                    }

                    if (!precedesClosingParenthesis || indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  default:
                    if (precedesClosingParenthesis && !indentClosingBrace) {
                      expectedIndentLevel -= 1;
                    }}

              }

              // Starting at the index after the newline, we want to
              // check that the whitespace characters (excluding newlines) before the first
              // non-whitespace character equal the expected indentation
              const afterNewlineSpaceMatches = /^([ \t]*)\S/.exec(source.slice(match.startIndex + 1));

              if (!afterNewlineSpaceMatches) {
                return;
              }

              const afterNewlineSpace = afterNewlineSpaceMatches[1] || '';
              const expectedIndentation = indentChar.repeat(
              expectedIndentLevel > 0 ? expectedIndentLevel : 0);


              if (afterNewlineSpace !== expectedIndentation) {
                if (context.fix) {
                  // Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string
                  fixPositions.unshift({
                    expectedIndentation,
                    currentIndentation: afterNewlineSpace,
                    startIndex: match.startIndex });

                } else {
                  report({
                    message: messages.expected(legibleExpectation(expectedIndentLevel)),
                    node,
                    index: match.startIndex + afterNewlineSpace.length + 1,
                    result,
                    ruleName });

                }
              }
            });


            if (fixPositions.length) {
              if (isRule(node)) {
                for (const fixPosition of fixPositions) {
                  node.selector = replaceIndentation(
                  node.selector,
                  fixPosition.currentIndentation,
                  fixPosition.expectedIndentation,
                  fixPosition.startIndex);

                }
              }

              if (isDeclaration(node)) {
                const declProp = node.prop;
                const declBetween = node.raws.between;

                if (!isString(declBetween)) {
                  throw new TypeError('The `between` property must be a string');
                }

                for (const fixPosition of fixPositions) {
                  if (fixPosition.startIndex < declProp.length + declBetween.length) {
                    node.raws.between = replaceIndentation(
                    declBetween,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length);

                  } else {
                    node.value = replaceIndentation(
                    node.value,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length - declBetween.length);

                  }
                }
              }

              if (isAtRule(node)) {
                const atRuleName = node.name;
                const atRuleAfterName = node.raws.afterName;
                const atRuleParams = node.params;

                if (!isString(atRuleAfterName)) {
                  throw new TypeError('The `afterName` property must be a string');
                }

                for (const fixPosition of fixPositions) {
                  // 1 — it's a @ length
                  if (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {
                    node.raws.afterName = replaceIndentation(
                    atRuleAfterName,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - 1);

                  } else {
                    node.params = replaceIndentation(
                    atRuleParams,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1);

                  }
                }
              }
            }
          }
        };
      };

      /**
       * @param {import('postcss').Root} root
       * @param {number | 'auto'} baseIndentLevel
       * @param {string} space
       * @returns {number}
       */
      function getRootBaseIndentLevel(root, baseIndentLevel, space) {
        const document = getDocument(root);

        if (!document) {
          return 0;
        }

        if (!root.source) {
          throw new Error('The root node must have a source');
        }

        /** @type {import('postcss').Source & { baseIndentLevel?: number }} */
        const source = root.source;

        const indentLevel = source.baseIndentLevel;

        if (isNumber(indentLevel) && Number.isSafeInteger(indentLevel)) {
          return indentLevel;
        }

        const newIndentLevel = inferRootIndentLevel(root, baseIndentLevel, () =>
        inferDocIndentSize(document, space));


        source.baseIndentLevel = newIndentLevel;

        return newIndentLevel;
      }

      /**
       * @param {import('postcss').Node} node
       */
      function getDocument(node) {
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.
        const document = node.document;

        if (document) {
          return document;
        }

        const root = node.root();

        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.
        return root && root.document;
      }

      /**
       * @param {import('postcss').Document} document
       * @param {string} space
       * returns {number}
       */
      function inferDocIndentSize(document, space) {
        if (!document.source) throw new Error('The document node must have a source');

        /** @type {import('postcss').Source & { indentSize?: number }} */
        const docSource = document.source;

        let indentSize = docSource.indentSize;

        if (isNumber(indentSize) && Number.isSafeInteger(indentSize)) {
          return indentSize;
        }

        const source = document.source.input.css;
        const indents = source.match(/^ *(?=\S)/gm);

        if (indents) {
          /** @type {Map<number, number>} */
          const scores = new Map();
          let lastIndentSize = 0;
          let lastLeadingSpacesLength = 0;

          /**
           * @param {number} leadingSpacesLength
           */
          const vote = leadingSpacesLength => {
            if (leadingSpacesLength) {
              lastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;

              if (lastIndentSize > 1) {
                const score = scores.get(lastIndentSize);

                if (score) {
                  scores.set(lastIndentSize, score + 1);
                } else {
                  scores.set(lastIndentSize, 1);
                }
              }
            } else {
              lastIndentSize = 0;
            }

            lastLeadingSpacesLength = leadingSpacesLength;
          };

          for (const leadingSpaces of indents) {
            vote(leadingSpaces.length);
          }

          let bestScore = 0;

          for (const [indentSizeDate, score] of scores.entries()) {
            if (score > bestScore) {
              bestScore = score;
              indentSize = indentSizeDate;
            }
          }
        }

        indentSize =
        Number(indentSize) || indents && indents[0] && indents[0].length || Number(space) || 2;
        docSource.indentSize = indentSize;

        return indentSize;
      }

      /**
       * @param {import('postcss').Root} root
       * @param {number | 'auto'} baseIndentLevel
       * @param {() => number} indentSize
       * @returns {number}
       */
      function inferRootIndentLevel(root, baseIndentLevel, indentSize) {
        /**
         * @param {string} indent
         */
        function getIndentLevel(indent) {
          const tabMatch = indent.match(/\t/g);
          const tabCount = tabMatch ? tabMatch.length : 0;

          const spaceMatch = indent.match(/ /g);
          const spaceCount = spaceMatch ? Math.round(spaceMatch.length / indentSize()) : 0;

          return tabCount + spaceCount;
        }

        let newBaseIndentLevel = 0;

        if (!isNumber(baseIndentLevel) || !Number.isSafeInteger(baseIndentLevel)) {
          if (!root.source) throw new Error('The root node must have a source');

          let source = root.source.input.css;

          source = source.replace(/^[^\r\n]+/, firstLine => {
            const match = root.raws.codeBefore && /(?:^|\n)([ \t]*)$/.exec(root.raws.codeBefore);

            if (match) {
              return match[1] + firstLine;
            }

            return '';
          });

          const indents = source.match(/^[ \t]*(?=\S)/gm);

          if (indents) {
            return Math.min(...indents.map(indent => getIndentLevel(indent)));
          }

          newBaseIndentLevel = 1;
        } else {
          newBaseIndentLevel = baseIndentLevel;
        }

        const indents = [];
        const foundIndents = root.raws.codeBefore && /(?:^|\n)([ \t]*)\S/m.exec(root.raws.codeBefore);

        // The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.
        if (foundIndents) {
          let shortest = Number.MAX_SAFE_INTEGER;
          let i = 0;

          while (++i < foundIndents.length) {
            const foundIndent = foundIndents[i];

            assertString(foundIndent);
            const current = getIndentLevel(foundIndent);

            if (current < shortest) {
              shortest = current;

              if (shortest === 0) {
                break;
              }
            }
          }

          if (shortest !== Number.MAX_SAFE_INTEGER) {
            indents.push(new Array(shortest).fill(' ').join(''));
          }
        }

        const after = root.raws.after;

        if (after) {
          let afterEnd;

          if (after.endsWith('\n')) {
            // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
            const document = root.document;

            if (document) {
              const nextRoot = document.nodes[document.nodes.indexOf(root) + 1];

              afterEnd = nextRoot ? nextRoot.raws.codeBefore : document.raws.codeAfter;
            } else {
              // Nested root node in css-in-js lang
              const parent = root.parent;

              if (!parent) throw new Error('The root node must have a parent');

              const nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];

              afterEnd = nextRoot ? nextRoot.raws.codeBefore : root.raws.codeAfter;
            }
          } else {
            afterEnd = after;
          }

          if (afterEnd) indents.push(afterEnd.match(/^[ \t]*/)[0]);
        }

        if (indents.length) {
          return Math.max(...indents.map(indent => getIndentLevel(indent))) + newBaseIndentLevel;
        }

        return newBaseIndentLevel;
      }

      /**
       * @param {string | undefined} str
       * @param {string} whitespace
       */
      function fixIndentation(str, whitespace) {
        if (!isString(str)) {
          return str;
        }

        return str.replace(/\n[ \t]*(?=\S|$)/g, `\n${whitespace}`);
      }

      /**
       * @param {string} input
       * @param {string} searchString
       * @param {string} replaceString
       * @param {number} startIndex
       */
      function replaceIndentation(input, searchString, replaceString, startIndex) {
        const offset = startIndex + 1;
        const stringStart = input.slice(0, offset);
        const stringEnd = input.slice(offset + searchString.length);

        return stringStart + replaceString + stringEnd;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 324, "../../utils/hasBlock": 348, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "style-search": 89 }], 205: [function (require, module, exports) {
      'use strict';

      /* const _importLazy = require('import-lazy'); */

      /* const importLazy = _importLazy(require); */

      /** @type {typeof import('stylelint').rules} */
      const rules = {
        'alpha-value-notation': /* importLazy( */
        require('./alpha-value-notation'),
        'at-rule-allowed-list': /* importLazy( */
        require('./at-rule-allowed-list'),
        'at-rule-disallowed-list': /* importLazy( */
        require('./at-rule-disallowed-list'),
        'at-rule-empty-line-before': /* importLazy( */
        require('./at-rule-empty-line-before'),
        'at-rule-name-case': /* importLazy( */
        require('./at-rule-name-case'),
        'at-rule-name-newline-after': /* importLazy( */
        require('./at-rule-name-newline-after'),
        'at-rule-semicolon-space-before': /* importLazy( */
        require('./at-rule-semicolon-space-before'),
        'at-rule-name-space-after': /* importLazy( */
        require('./at-rule-name-space-after'),
        'at-rule-no-unknown': /* importLazy( */
        require('./at-rule-no-unknown'),
        /* 'at-rule-no-vendor-prefix': importLazy('./at-rule-no-vendor-prefix'),
        */'at-rule-property-required-list': /* importLazy( */
        require('./at-rule-property-required-list'),
        'at-rule-semicolon-newline-after': /* importLazy( */
        require('./at-rule-semicolon-newline-after'),
        'block-closing-brace-empty-line-before': /* importLazy( */
        require('./block-closing-brace-empty-line-before'),
        'block-closing-brace-newline-after': /* importLazy( */
        require('./block-closing-brace-newline-after'),
        'block-closing-brace-newline-before': /* importLazy( */
        require('./block-closing-brace-newline-before'),
        'block-closing-brace-space-after': /* importLazy( */
        require('./block-closing-brace-space-after'),
        'block-closing-brace-space-before': /* importLazy( */
        require('./block-closing-brace-space-before'),
        'block-no-empty': /* importLazy( */
        require('./block-no-empty'),
        'block-opening-brace-newline-after': /* importLazy( */
        require('./block-opening-brace-newline-after'),
        'block-opening-brace-newline-before': /* importLazy( */
        require('./block-opening-brace-newline-before'),
        'block-opening-brace-space-after': /* importLazy( */
        require('./block-opening-brace-space-after'),
        'block-opening-brace-space-before': /* importLazy( */
        require('./block-opening-brace-space-before'),
        'color-function-notation': /* importLazy( */
        require('./color-function-notation'),
        'color-hex-alpha': /* importLazy( */
        require('./color-hex-alpha'),
        'color-hex-case': /* importLazy( */
        require('./color-hex-case'),
        'color-hex-length': /* importLazy( */
        require('./color-hex-length'),
        'color-named': /* importLazy( */
        require('./color-named'),
        'color-no-hex': /* importLazy( */
        require('./color-no-hex'),
        'color-no-invalid-hex': /* importLazy( */
        require('./color-no-invalid-hex'),
        'comment-empty-line-before': /* importLazy( */
        require('./comment-empty-line-before'),
        'comment-no-empty': /* importLazy( */
        require('./comment-no-empty'),
        'comment-pattern': /* importLazy( */
        require('./comment-pattern'),
        'comment-whitespace-inside': /* importLazy( */
        require('./comment-whitespace-inside'),
        'comment-word-disallowed-list': /* importLazy( */
        require('./comment-word-disallowed-list'),
        'custom-media-pattern': /* importLazy( */
        require('./custom-media-pattern'),
        'custom-property-empty-line-before': /* importLazy( */
        require('./custom-property-empty-line-before'),
        'custom-property-no-missing-var-function': /* importLazy( */
        require(
        './custom-property-no-missing-var-function'),

        'custom-property-pattern': /* importLazy( */
        require('./custom-property-pattern'),
        'declaration-bang-space-after': /* importLazy( */
        require('./declaration-bang-space-after'),
        'declaration-bang-space-before': /* importLazy( */
        require('./declaration-bang-space-before'),
        'declaration-block-no-duplicate-custom-properties': /* importLazy( */
        require(
        './declaration-block-no-duplicate-custom-properties'),

        'declaration-block-no-duplicate-properties': /* importLazy( */
        require(
        './declaration-block-no-duplicate-properties'),

        'declaration-block-no-redundant-longhand-properties': /* importLazy( */
        require(
        './declaration-block-no-redundant-longhand-properties'),

        'declaration-block-no-shorthand-property-overrides': /* importLazy( */
        require(
        './declaration-block-no-shorthand-property-overrides'),

        'declaration-block-semicolon-newline-after': /* importLazy( */
        require(
        './declaration-block-semicolon-newline-after'),

        'declaration-block-semicolon-newline-before': /* importLazy( */
        require(
        './declaration-block-semicolon-newline-before'),

        'declaration-block-semicolon-space-after': /* importLazy( */
        require(
        './declaration-block-semicolon-space-after'),

        'declaration-block-semicolon-space-before': /* importLazy( */
        require(
        './declaration-block-semicolon-space-before'),

        'declaration-block-single-line-max-declarations': /* importLazy( */
        require(
        './declaration-block-single-line-max-declarations'),

        'declaration-block-trailing-semicolon': /* importLazy( */
        require('./declaration-block-trailing-semicolon'),
        'declaration-colon-newline-after': /* importLazy( */
        require('./declaration-colon-newline-after'),
        'declaration-colon-space-after': /* importLazy( */
        require('./declaration-colon-space-after'),
        'declaration-colon-space-before': /* importLazy( */
        require('./declaration-colon-space-before'),
        'declaration-empty-line-before': /* importLazy( */
        require('./declaration-empty-line-before'),
        'declaration-no-important': /* importLazy( */
        require('./declaration-no-important'),
        'declaration-property-max-values': /* importLazy( */
        require('./declaration-property-max-values'),
        'declaration-property-unit-allowed-list': /* importLazy( */
        require('./declaration-property-unit-allowed-list'),
        'declaration-property-unit-disallowed-list': /* importLazy( */
        require(
        './declaration-property-unit-disallowed-list'),

        'declaration-property-value-allowed-list': /* importLazy( */
        require(
        './declaration-property-value-allowed-list'),

        'declaration-property-value-disallowed-list': /* importLazy( */
        require(
        './declaration-property-value-disallowed-list'),

        'font-family-no-missing-generic-family-keyword': /* importLazy( */
        require(
        './font-family-no-missing-generic-family-keyword'),

        'font-family-name-quotes': /* importLazy( */
        require('./font-family-name-quotes'),
        'font-family-no-duplicate-names': /* importLazy( */
        require('./font-family-no-duplicate-names'),
        'font-weight-notation': /* importLazy( */
        require('./font-weight-notation'),
        'function-allowed-list': /* importLazy( */
        require('./function-allowed-list'),
        'function-calc-no-unspaced-operator': /* importLazy( */
        require('./function-calc-no-unspaced-operator'),
        'function-comma-newline-after': /* importLazy( */
        require('./function-comma-newline-after'),
        'function-comma-newline-before': /* importLazy( */
        require('./function-comma-newline-before'),
        'function-comma-space-after': /* importLazy( */
        require('./function-comma-space-after'),
        'function-comma-space-before': /* importLazy( */
        require('./function-comma-space-before'),
        'function-disallowed-list': /* importLazy( */
        require('./function-disallowed-list'),
        'function-linear-gradient-no-nonstandard-direction': /* importLazy( */
        require(
        './function-linear-gradient-no-nonstandard-direction'),

        'function-max-empty-lines': /* importLazy( */
        require('./function-max-empty-lines'),
        'function-name-case': /* importLazy( */
        require('./function-name-case'),
        'function-no-unknown': /* importLazy( */
        require('./function-no-unknown'),
        'function-parentheses-newline-inside': /* importLazy( */
        require('./function-parentheses-newline-inside'),
        'function-parentheses-space-inside': /* importLazy( */
        require('./function-parentheses-space-inside'),
        'function-url-no-scheme-relative': /* importLazy( */
        require('./function-url-no-scheme-relative'),
        'function-url-quotes': /* importLazy( */
        require('./function-url-quotes'),
        'function-url-scheme-allowed-list': /* importLazy( */
        require('./function-url-scheme-allowed-list'),
        'function-url-scheme-disallowed-list': /* importLazy( */
        require('./function-url-scheme-disallowed-list'),
        'function-whitespace-after': /* importLazy( */
        require('./function-whitespace-after'),
        'hue-degree-notation': /* importLazy( */
        require('./hue-degree-notation'),
        'import-notation': /* importLazy( */
        require('./import-notation'),
        'keyframe-block-no-duplicate-selectors': /* importLazy( */
        require('./keyframe-block-no-duplicate-selectors'),
        'keyframe-declaration-no-important': /* importLazy( */
        require('./keyframe-declaration-no-important'),
        'keyframes-name-pattern': /* importLazy( */
        require('./keyframes-name-pattern'),
        'length-zero-no-unit': /* importLazy( */
        require('./length-zero-no-unit'),
        linebreaks: /* importLazy( */
        require('./linebreaks'),
        'max-empty-lines': /* importLazy( */
        require('./max-empty-lines'),
        'max-line-length': /* importLazy( */
        require('./max-line-length'),
        'max-nesting-depth': /* importLazy( */
        require('./max-nesting-depth'),
        'media-feature-colon-space-after': /* importLazy( */
        require('./media-feature-colon-space-after'),
        'media-feature-colon-space-before': /* importLazy( */
        require('./media-feature-colon-space-before'),
        'media-feature-name-allowed-list': /* importLazy( */
        require('./media-feature-name-allowed-list'),
        'media-feature-name-case': /* importLazy( */
        require('./media-feature-name-case'),
        'media-feature-name-disallowed-list': /* importLazy( */
        require('./media-feature-name-disallowed-list'),
        'media-feature-name-no-unknown': /* importLazy( */
        require('./media-feature-name-no-unknown'),
        /* 'media-feature-name-no-vendor-prefix': importLazy('./media-feature-name-no-vendor-prefix'),
        */'media-feature-name-value-allowed-list': /* importLazy( */
        require('./media-feature-name-value-allowed-list'),
        'media-feature-parentheses-space-inside': /* importLazy( */
        require('./media-feature-parentheses-space-inside'),
        'media-feature-range-operator-space-after': /* importLazy( */
        require(
        './media-feature-range-operator-space-after'),

        'media-feature-range-operator-space-before': /* importLazy( */
        require(
        './media-feature-range-operator-space-before'),

        'media-query-list-comma-newline-after': /* importLazy( */
        require('./media-query-list-comma-newline-after'),
        'media-query-list-comma-newline-before': /* importLazy( */
        require('./media-query-list-comma-newline-before'),
        'media-query-list-comma-space-after': /* importLazy( */
        require('./media-query-list-comma-space-after'),
        'media-query-list-comma-space-before': /* importLazy( */
        require('./media-query-list-comma-space-before'),
        'named-grid-areas-no-invalid': /* importLazy( */
        require('./named-grid-areas-no-invalid'),
        'no-descending-specificity': /* importLazy( */
        require('./no-descending-specificity'),
        'no-duplicate-at-import-rules': /* importLazy( */
        require('./no-duplicate-at-import-rules'),
        'no-duplicate-selectors': /* importLazy( */
        require('./no-duplicate-selectors'),
        'no-empty-source': /* importLazy( */
        require('./no-empty-source'),
        'no-empty-first-line': /* importLazy( */
        require('./no-empty-first-line'),
        'no-eol-whitespace': /* importLazy( */
        require('./no-eol-whitespace'),
        'no-extra-semicolons': /* importLazy( */
        require('./no-extra-semicolons'),
        'no-invalid-double-slash-comments': /* importLazy( */
        require('./no-invalid-double-slash-comments'),
        'no-invalid-position-at-import-rule': /* importLazy( */
        require('./no-invalid-position-at-import-rule'),
        'no-irregular-whitespace': /* importLazy( */
        require('./no-irregular-whitespace'),
        'no-missing-end-of-source-newline': /* importLazy( */
        require('./no-missing-end-of-source-newline'),
        'no-unknown-animations': /* importLazy( */
        require('./no-unknown-animations'),
        'number-leading-zero': /* importLazy( */
        require('./number-leading-zero'),
        'number-max-precision': /* importLazy( */
        require('./number-max-precision'),
        'number-no-trailing-zeros': /* importLazy( */
        require('./number-no-trailing-zeros'),
        'property-allowed-list': /* importLazy( */
        require('./property-allowed-list'),
        'property-case': /* importLazy( */
        require('./property-case'),
        'property-disallowed-list': /* importLazy( */
        require('./property-disallowed-list'),
        'property-no-unknown': /* importLazy( */
        require('./property-no-unknown'),
        /* 'property-no-vendor-prefix': importLazy('./property-no-vendor-prefix'),
        */'rule-empty-line-before': /* importLazy( */
        require('./rule-empty-line-before'),
        'rule-selector-property-disallowed-list': /* importLazy( */
        require('./rule-selector-property-disallowed-list'),
        'selector-attribute-brackets-space-inside': /* importLazy( */
        require(
        './selector-attribute-brackets-space-inside'),

        'selector-attribute-name-disallowed-list': /* importLazy( */
        require(
        './selector-attribute-name-disallowed-list'),

        'selector-attribute-operator-allowed-list': /* importLazy( */
        require(
        './selector-attribute-operator-allowed-list'),

        'selector-attribute-operator-disallowed-list': /* importLazy( */
        require(
        './selector-attribute-operator-disallowed-list'),

        'selector-attribute-operator-space-after': /* importLazy( */
        require(
        './selector-attribute-operator-space-after'),

        'selector-attribute-operator-space-before': /* importLazy( */
        require(
        './selector-attribute-operator-space-before'),

        'selector-attribute-quotes': /* importLazy( */
        require('./selector-attribute-quotes'),
        'selector-class-pattern': /* importLazy( */
        require('./selector-class-pattern'),
        'selector-combinator-allowed-list': /* importLazy( */
        require('./selector-combinator-allowed-list'),
        'selector-combinator-disallowed-list': /* importLazy( */
        require('./selector-combinator-disallowed-list'),
        'selector-combinator-space-after': /* importLazy( */
        require('./selector-combinator-space-after'),
        'selector-combinator-space-before': /* importLazy( */
        require('./selector-combinator-space-before'),
        'selector-descendant-combinator-no-non-space': /* importLazy( */
        require(
        './selector-descendant-combinator-no-non-space'),

        'selector-disallowed-list': /* importLazy( */
        require('./selector-disallowed-list'),
        'selector-id-pattern': /* importLazy( */
        require('./selector-id-pattern'),
        'selector-list-comma-newline-after': /* importLazy( */
        require('./selector-list-comma-newline-after'),
        'selector-list-comma-newline-before': /* importLazy( */
        require('./selector-list-comma-newline-before'),
        'selector-list-comma-space-after': /* importLazy( */
        require('./selector-list-comma-space-after'),
        'selector-list-comma-space-before': /* importLazy( */
        require('./selector-list-comma-space-before'),
        'selector-max-attribute': /* importLazy( */
        require('./selector-max-attribute'),
        'selector-max-class': /* importLazy( */
        require('./selector-max-class'),
        'selector-max-combinators': /* importLazy( */
        require('./selector-max-combinators'),
        'selector-max-compound-selectors': /* importLazy( */
        require('./selector-max-compound-selectors'),
        'selector-max-empty-lines': /* importLazy( */
        require('./selector-max-empty-lines'),
        'selector-max-id': /* importLazy( */
        require('./selector-max-id'),
        'selector-max-pseudo-class': /* importLazy( */
        require('./selector-max-pseudo-class'),
        'selector-max-specificity': /* importLazy( */
        require('./selector-max-specificity'),
        'selector-max-type': /* importLazy( */
        require('./selector-max-type'),
        'selector-max-universal': /* importLazy( */
        require('./selector-max-universal'),
        'selector-nested-pattern': /* importLazy( */
        require('./selector-nested-pattern'),
        'selector-no-qualifying-type': /* importLazy( */
        require('./selector-no-qualifying-type'),
        /* 'selector-no-vendor-prefix': importLazy('./selector-no-vendor-prefix'),
        */'selector-not-notation': /* importLazy( */
        require('./selector-not-notation'),
        'selector-pseudo-class-allowed-list': /* importLazy( */
        require('./selector-pseudo-class-allowed-list'),
        'selector-pseudo-class-case': /* importLazy( */
        require('./selector-pseudo-class-case'),
        'selector-pseudo-class-disallowed-list': /* importLazy( */
        require('./selector-pseudo-class-disallowed-list'),
        'selector-pseudo-class-no-unknown': /* importLazy( */
        require('./selector-pseudo-class-no-unknown'),
        'selector-pseudo-class-parentheses-space-inside': /* importLazy( */
        require(
        './selector-pseudo-class-parentheses-space-inside'),

        'selector-pseudo-element-allowed-list': /* importLazy( */
        require('./selector-pseudo-element-allowed-list'),
        'selector-pseudo-element-case': /* importLazy( */
        require('./selector-pseudo-element-case'),
        'selector-pseudo-element-colon-notation': /* importLazy( */
        require('./selector-pseudo-element-colon-notation'),
        'selector-pseudo-element-disallowed-list': /* importLazy( */
        require(
        './selector-pseudo-element-disallowed-list'),

        'selector-pseudo-element-no-unknown': /* importLazy( */
        require('./selector-pseudo-element-no-unknown'),
        'selector-type-case': /* importLazy( */
        require('./selector-type-case'),
        'selector-type-no-unknown': /* importLazy( */
        require('./selector-type-no-unknown'),
        'shorthand-property-no-redundant-values': /* importLazy( */
        require('./shorthand-property-no-redundant-values'),
        'string-no-newline': /* importLazy( */
        require('./string-no-newline'),
        'string-quotes': /* importLazy( */
        require('./string-quotes'),
        'time-min-milliseconds': /* importLazy( */
        require('./time-min-milliseconds'),
        'unicode-bom': /* importLazy( */
        require('./unicode-bom'),
        'unit-allowed-list': /* importLazy( */
        require('./unit-allowed-list'),
        'unit-case': /* importLazy( */
        require('./unit-case'),
        'unit-disallowed-list': /* importLazy( */
        require('./unit-disallowed-list'),
        'unit-no-unknown': /* importLazy( */
        require('./unit-no-unknown'),
        'value-keyword-case': /* importLazy( */
        require('./value-keyword-case'),
        'value-list-comma-newline-after': /* importLazy( */
        require('./value-list-comma-newline-after'),
        'value-list-comma-newline-before': /* importLazy( */
        require('./value-list-comma-newline-before'),
        'value-list-comma-space-after': /* importLazy( */
        require('./value-list-comma-space-after'),
        'value-list-comma-space-before': /* importLazy( */
        require('./value-list-comma-space-before'),
        'value-list-max-empty-lines': /* importLazy( */
        require('./value-list-max-empty-lines'),
        /* 'value-no-vendor-prefix': importLazy('./value-no-vendor-prefix'),
        */indentation: /* importLazy( */
        require('./indentation') };


      module.exports = rules;

    }, { "./alpha-value-notation": 114, "./at-rule-allowed-list": 115, "./at-rule-disallowed-list": 116, "./at-rule-empty-line-before": 117, "./at-rule-name-case": 118, "./at-rule-name-newline-after": 119, "./at-rule-name-space-after": 120, "./at-rule-no-unknown": 121, "./at-rule-property-required-list": 122, "./at-rule-semicolon-newline-after": 123, "./at-rule-semicolon-space-before": 124, "./block-closing-brace-empty-line-before": 126, "./block-closing-brace-newline-after": 127, "./block-closing-brace-newline-before": 128, "./block-closing-brace-space-after": 129, "./block-closing-brace-space-before": 130, "./block-no-empty": 131, "./block-opening-brace-newline-after": 132, "./block-opening-brace-newline-before": 133, "./block-opening-brace-space-after": 134, "./block-opening-brace-space-before": 135, "./color-function-notation": 136, "./color-hex-alpha": 137, "./color-hex-case": 138, "./color-hex-length": 139, "./color-named": 141, "./color-no-hex": 142, "./color-no-invalid-hex": 143, "./comment-empty-line-before": 144, "./comment-no-empty": 145, "./comment-pattern": 146, "./comment-whitespace-inside": 147, "./comment-word-disallowed-list": 148, "./custom-media-pattern": 149, "./custom-property-empty-line-before": 150, "./custom-property-no-missing-var-function": 151, "./custom-property-pattern": 152, "./declaration-bang-space-after": 153, "./declaration-bang-space-before": 154, "./declaration-block-no-duplicate-custom-properties": 155, "./declaration-block-no-duplicate-properties": 156, "./declaration-block-no-redundant-longhand-properties": 157, "./declaration-block-no-shorthand-property-overrides": 158, "./declaration-block-semicolon-newline-after": 159, "./declaration-block-semicolon-newline-before": 160, "./declaration-block-semicolon-space-after": 161, "./declaration-block-semicolon-space-before": 162, "./declaration-block-single-line-max-declarations": 163, "./declaration-block-trailing-semicolon": 164, "./declaration-colon-newline-after": 165, "./declaration-colon-space-after": 166, "./declaration-colon-space-before": 167, "./declaration-empty-line-before": 168, "./declaration-no-important": 169, "./declaration-property-max-values": 170, "./declaration-property-unit-allowed-list": 171, "./declaration-property-unit-disallowed-list": 172, "./declaration-property-value-allowed-list": 173, "./declaration-property-value-disallowed-list": 174, "./font-family-name-quotes": 178, "./font-family-no-duplicate-names": 179, "./font-family-no-missing-generic-family-keyword": 180, "./font-weight-notation": 181, "./function-allowed-list": 182, "./function-calc-no-unspaced-operator": 183, "./function-comma-newline-after": 184, "./function-comma-newline-before": 185, "./function-comma-space-after": 186, "./function-comma-space-before": 187, "./function-disallowed-list": 188, "./function-linear-gradient-no-nonstandard-direction": 189, "./function-max-empty-lines": 190, "./function-name-case": 191, "./function-no-unknown": 192, "./function-parentheses-newline-inside": 193, "./function-parentheses-space-inside": 194, "./function-url-no-scheme-relative": 195, "./function-url-quotes": 196, "./function-url-scheme-allowed-list": 197, "./function-url-scheme-disallowed-list": 198, "./function-whitespace-after": 199, "./hue-degree-notation": 202, "./import-notation": 203, "./indentation": 204, "./keyframe-block-no-duplicate-selectors": 206, "./keyframe-declaration-no-important": 207, "./keyframes-name-pattern": 208, "./length-zero-no-unit": 209, "./linebreaks": 210, "./max-empty-lines": 211, "./max-line-length": 212, "./max-nesting-depth": 213, "./media-feature-colon-space-after": 214, "./media-feature-colon-space-before": 215, "./media-feature-name-allowed-list": 216, "./media-feature-name-case": 217, "./media-feature-name-disallowed-list": 218, "./media-feature-name-no-unknown": 219, "./media-feature-name-value-allowed-list": 220, "./media-feature-parentheses-space-inside": 221, "./media-feature-range-operator-space-after": 222, "./media-feature-range-operator-space-before": 223, "./media-query-list-comma-newline-after": 224, "./media-query-list-comma-newline-before": 225, "./media-query-list-comma-space-after": 226, "./media-query-list-comma-space-before": 227, "./named-grid-areas-no-invalid": 230, "./no-descending-specificity": 233, "./no-duplicate-at-import-rules": 234, "./no-duplicate-selectors": 235, "./no-empty-first-line": 236, "./no-empty-source": 237, "./no-eol-whitespace": 238, "./no-extra-semicolons": 239, "./no-invalid-double-slash-comments": 240, "./no-invalid-position-at-import-rule": 241, "./no-irregular-whitespace": 242, "./no-missing-end-of-source-newline": 243, "./no-unknown-animations": 244, "./number-leading-zero": 245, "./number-max-precision": 246, "./number-no-trailing-zeros": 247, "./property-allowed-list": 248, "./property-case": 249, "./property-disallowed-list": 250, "./property-no-unknown": 251, "./rule-empty-line-before": 253, "./rule-selector-property-disallowed-list": 254, "./selector-attribute-brackets-space-inside": 255, "./selector-attribute-name-disallowed-list": 256, "./selector-attribute-operator-allowed-list": 257, "./selector-attribute-operator-disallowed-list": 258, "./selector-attribute-operator-space-after": 259, "./selector-attribute-operator-space-before": 260, "./selector-attribute-quotes": 261, "./selector-class-pattern": 262, "./selector-combinator-allowed-list": 263, "./selector-combinator-disallowed-list": 264, "./selector-combinator-space-after": 265, "./selector-combinator-space-before": 266, "./selector-descendant-combinator-no-non-space": 267, "./selector-disallowed-list": 268, "./selector-id-pattern": 269, "./selector-list-comma-newline-after": 270, "./selector-list-comma-newline-before": 271, "./selector-list-comma-space-after": 272, "./selector-list-comma-space-before": 273, "./selector-max-attribute": 274, "./selector-max-class": 275, "./selector-max-combinators": 276, "./selector-max-compound-selectors": 277, "./selector-max-empty-lines": 278, "./selector-max-id": 279, "./selector-max-pseudo-class": 280, "./selector-max-specificity": 281, "./selector-max-type": 282, "./selector-max-universal": 283, "./selector-nested-pattern": 284, "./selector-no-qualifying-type": 285, "./selector-not-notation": 286, "./selector-pseudo-class-allowed-list": 287, "./selector-pseudo-class-case": 288, "./selector-pseudo-class-disallowed-list": 289, "./selector-pseudo-class-no-unknown": 290, "./selector-pseudo-class-parentheses-space-inside": 291, "./selector-pseudo-element-allowed-list": 292, "./selector-pseudo-element-case": 293, "./selector-pseudo-element-colon-notation": 294, "./selector-pseudo-element-disallowed-list": 295, "./selector-pseudo-element-no-unknown": 296, "./selector-type-case": 297, "./selector-type-no-unknown": 298, "./shorthand-property-no-redundant-values": 302, "./string-no-newline": 303, "./string-quotes": 304, "./time-min-milliseconds": 305, "./unicode-bom": 306, "./unit-allowed-list": 307, "./unit-case": 308, "./unit-disallowed-list": 309, "./unit-no-unknown": 310, "./value-keyword-case": 311, "./value-list-comma-newline-after": 312, "./value-list-comma-newline-before": 313, "./value-list-comma-space-after": 314, "./value-list-comma-space-before": 315, "./value-list-max-empty-lines": 316 }], 206: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'keyframe-block-no-duplicate-selectors';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected duplicate "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/keyframe-block-no-duplicate-selectors' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
            const selectors = new Set();

            atRuleKeyframes.walkRules(keyframeRule => {
              const ruleSelectors = keyframeRule.selectors;

              ruleSelectors.forEach(selector => {
                if (!isStandardSyntaxSelector(selector)) {
                  return;
                }

                const normalizedSelector = selector.toLowerCase();

                const isDuplicate = selectors.has(normalizedSelector);

                if (isDuplicate) {
                  report({
                    message: messages.rejected(selector),
                    node: keyframeRule,
                    result,
                    ruleName,
                    word: selector });


                  return;
                }

                selectors.add(normalizedSelector);
              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxSelector": 392, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 207: [function (require, module, exports) {
      'use strict';

      const getImportantPosition = require('../../utils/getImportantPosition');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { assert } = require('../../utils/validateTypes');

      const ruleName = 'keyframe-declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/keyframe-declaration-no-important' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
            atRuleKeyframes.walkDecls(decl => {
              if (!decl.important) {
                return;
              }

              const pos = getImportantPosition(decl.toString());

              assert(pos);

              report({
                message: messages.rejected,
                node: decl,
                index: pos.index,
                endIndex: pos.endIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/getImportantPosition": 341, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 208: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'keyframes-name-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (keyframeName, pattern) =>
        `Expected keyframe name "${keyframeName}" to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/keyframes-name-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regex = isString(primary) ? new RegExp(primary) : primary;

          root.walkAtRules(/keyframes/i, keyframesNode => {
            const value = keyframesNode.params;

            if (regex.test(value)) {
              return;
            }

            const index = atRuleParamIndex(keyframesNode);
            const endIndex = index + value.length;

            report({
              index,
              endIndex,
              message: messages.expected(value, primary),
              node: keyframesNode,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 209: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getAtRuleParams = require('../../utils/getAtRuleParams');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isMathFunction = require('../../utils/isMathFunction');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setAtRuleParams = require('../../utils/setAtRuleParams');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'length-zero-no-unit';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected unit' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/length-zero-no-unit' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['custom-properties'],
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) return;

          let needsFix;

          /**
           * @param {import('postcss').Node} node
           * @param {number} nodeIndex
           * @param {import('postcss-value-parser').Node} valueNode
           */
          function check(node, nodeIndex, valueNode) {
            const { value, sourceIndex } = valueNode;

            if (isMathFunction(valueNode)) return false;

            if (isFunction(valueNode) && optionsMatches(secondaryOptions, 'ignoreFunctions', value))
            return false;

            if (!isWord(valueNode)) return;

            const numberUnit = valueParser.unit(value);

            if (numberUnit === false) return;

            const { number, unit } = numberUnit;

            if (unit === '') return;

            if (!isLength(unit)) return;

            if (isFraction(unit)) return;

            if (!isZero(number)) return;

            if (context.fix) {
              let regularNumber = number;

              if (regularNumber.startsWith('.')) {
                regularNumber = number.slice(1);
              }

              valueNode.value = regularNumber;
              needsFix = true;

              return;
            }

            const index = nodeIndex + sourceIndex + number.length;
            const endIndex = index + unit.length;

            report({
              index,
              endIndex,
              message: messages.rejected,
              node,
              result,
              ruleName });

          }

          /**
           * @param {import('postcss').AtRule} node
           */
          function checkAtRule(node) {
            if (!isStandardSyntaxAtRule(node)) return;

            needsFix = false;

            const index = atRuleParamIndex(node);
            const parsedValue = valueParser(getAtRuleParams(node));

            parsedValue.walk(valueNode => check(node, index, valueNode));

            if (needsFix) {
              setAtRuleParams(node, parsedValue.toString());
            }
          }

          /**
           * @param {import('postcss').Declaration} node
           */
          function checkDecl(node) {
            needsFix = false;

            const { prop } = node;

            if (isLineHeight(prop)) return;

            if (isFlex(prop)) return;

            if (optionsMatches(secondaryOptions, 'ignore', 'custom-properties') && isCustomProperty(prop))
            return;

            const index = declarationValueIndex(node);
            const parsedValue = valueParser(getDeclarationValue(node));

            parsedValue.walk((valueNode, valueNodeIndex, valueNodes) => {
              if (isLineHeightValue(node, valueNodes, valueNodeIndex)) return;

              return check(node, index, valueNode);
            });

            if (needsFix) {
              setDeclarationValue(node, parsedValue.toString());
            }
          }

          root.walkAtRules(checkAtRule);
          root.walkDecls(checkDecl);
        };
      };

      /**
       * @param {import('postcss').Declaration} decl
       * @param {import('postcss-value-parser').Node[]} nodes
       * @param {number} index
       */
      function isLineHeightValue({ prop }, nodes, index) {
        const lastNode = nodes[index - 1];

        return (
          prop.toLowerCase() === 'font' && lastNode && lastNode.type === 'div' && lastNode.value === '/');

      }

      /**
       * @param {string} prop
       */
      function isLineHeight(prop) {
        return prop.toLowerCase() === 'line-height';
      }

      /**
       * @param {string} prop
       */
      function isFlex(prop) {
        return prop.toLowerCase() === 'flex';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isWord({ type }) {
        return type === 'word';
      }

      /**
       * @param {string} unit
       */
      function isLength(unit) {
        return keywordSets.lengthUnits.has(unit.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isFunction({ type }) {
        return type === 'function';
      }

      /**
       * @param {string} unit
       */
      function isFraction(unit) {
        return unit.toLowerCase() === 'fr';
      }

      /**
       * @param {string} number
       */
      function isZero(number) {
        return Number.parseFloat(number) === 0;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getAtRuleParams": 337, "../../utils/getDeclarationValue": 338, "../../utils/isCustomProperty": 367, "../../utils/isMathFunction": 373, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setAtRuleParams": 411, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 210: [function (require, module, exports) {
      'use strict';

      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'linebreaks';

      const messages = ruleMessages(ruleName, {
        expected: linebreak => `Expected linebreak to be ${linebreak}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/linebreaks' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['unix', 'windows'] });


          if (!validOptions) {
            return;
          }

          const shouldHaveCR = primary === 'windows';

          if (context.fix) {
            root.walk(node => {
              if ('selector' in node) {
                node.selector = fixData(node.selector);
              }

              if ('value' in node) {
                node.value = fixData(node.value);
              }

              if ('text' in node) {
                node.text = fixData(node.text);
              }

              if (node.raws.before) {
                node.raws.before = fixData(node.raws.before);
              }

              if (typeof node.raws.after === 'string') {
                node.raws.after = fixData(node.raws.after);
              }
            });

            if (typeof root.raws.after === 'string') {
              root.raws.after = fixData(root.raws.after);
            }
          } else {
            if (root.source == null) throw new Error('The root node must have a source');

            const lines = root.source.input.css.split('\n');

            for (let [i, line] of lines.entries()) {
              if (i < lines.length - 1 && !line.includes('\r')) {
                line += '\n';
              }

              if (hasError(line)) {
                const lineNum = i + 1;
                const colNum = line.length;

                reportNewlineError(lineNum, colNum);
              }
            }
          }

          /**
           * @param {string} dataToCheck
           */
          function hasError(dataToCheck) {
            const hasNewlineToVerify = /[\r\n]/.test(dataToCheck);
            const hasCR = hasNewlineToVerify ? /\r/.test(dataToCheck) : false;

            return hasNewlineToVerify && hasCR !== shouldHaveCR;
          }

          /**
           * @param {string} data
           */
          function fixData(data) {
            if (data) {
              let res = data.replace(/\r/g, '');

              if (shouldHaveCR) {
                res = res.replace(/\n/g, '\r\n');
              }

              return res;
            }

            return data;
          }

          /**
           * @param {number} line
           * @param {number} column
           */
          function reportNewlineError(line, column) {
            // Creating a node manually helps us to point to empty lines.
            const node = postcss.rule({
              source: {
                start: { line, column, offset: 0 },
                input: new postcss.Input('') } });



            report({
              message: messages.expected(primary),
              node,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss": 77 }], 211: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/max-empty-lines' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        let emptyLines = 0;
        let lastIndex = -1;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNumber },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
          const getChars = replaceEmptyLines.bind(null, primary);

          /**
           * 1. walk nodes & replace enterchar
           * 2. deal with special case.
           */
          if (context.fix) {
            root.walk(node => {
              if (node.type === 'comment' && !ignoreComments) {
                node.raws.left = getChars(node.raws.left);
                node.raws.right = getChars(node.raws.right);
              }

              if (node.raws.before) {
                node.raws.before = getChars(node.raws.before);
              }
            });

            // first node
            const firstNodeRawsBefore = root.first && root.first.raws.before;
            // root raws
            const rootRawsAfter = root.raws.after;

            // not document node
            // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
            if ((root.document && root.document.constructor.name) !== 'Document') {
              if (firstNodeRawsBefore) {
                root.first.raws.before = getChars(firstNodeRawsBefore, true);
              }

              if (rootRawsAfter) {
                // when max setted 0, should be treated as 1 in this situation.
                root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter, true);
              }
            } else if (rootRawsAfter) {
              // `css in js` or `html`
              root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter);
            }

            return;
          }

          emptyLines = 0;
          lastIndex = -1;
          const rootString = root.toString();

          styleSearch(
          {
            source: rootString,
            target: /\r\n/.test(rootString) ? '\r\n' : '\n',
            comments: ignoreComments ? 'skip' : 'check' },

          match => {
            checkMatch(rootString, match.startIndex, match.endIndex, root);
          });


          /**
           * @param {string} source
           * @param {number} matchStartIndex
           * @param {number} matchEndIndex
           * @param {import('postcss').Root} node
           */
          function checkMatch(source, matchStartIndex, matchEndIndex, node) {
            const eof = matchEndIndex === source.length;
            let problem = false;

            // Additional check for beginning of file
            if (!matchStartIndex || lastIndex === matchStartIndex) {
              emptyLines++;
            } else {
              emptyLines = 0;
            }

            lastIndex = matchEndIndex;

            if (emptyLines > primary) problem = true;

            if (!eof && !problem) return;

            if (problem) {
              report({
                message: messages.expected(primary),
                node,
                index: matchStartIndex,
                result,
                ruleName });

            }

            // Additional check for end of file
            if (eof && primary) {
              emptyLines++;

              if (emptyLines > primary && isEofNode(result.root, node)) {
                report({
                  message: messages.expected(primary),
                  node,
                  index: matchEndIndex,
                  result,
                  ruleName });

              }
            }
          }

          /**
           * @param {number} maxLines
           * @param {unknown} str
           * @param {boolean?} isSpecialCase
           */
          function replaceEmptyLines(maxLines, str, isSpecialCase = false) {
            const repeatTimes = isSpecialCase ? maxLines : maxLines + 1;

            if (repeatTimes === 0 || typeof str !== 'string') {
              return '';
            }

            const emptyLFLines = '\n'.repeat(repeatTimes);
            const emptyCRLFLines = '\r\n'.repeat(repeatTimes);

            return /(?:\r\n)+/.test(str) ?
            str.replace(/(\r\n)+/g, $1 => {
              if ($1.length / 2 > repeatTimes) {
                return emptyCRLFLines;
              }

              return $1;
            }) :
            str.replace(/(\n)+/g, $1 => {
              if ($1.length > repeatTimes) {
                return emptyLFLines;
              }

              return $1;
            });
          }
        };
      };

      /**
       * Checks whether the given node is the last node of file.
       * @param {import('stylelint').PostcssResult['root']} document - the document node with `postcss-html` and `postcss-jsx`.
       * @param {import('postcss').Root} root - the root node of css
       */
      function isEofNode(document, root) {
        if (!document || document.constructor.name !== 'Document' || !('type' in document)) {
          return true;
        }

        // In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.
        let after;

        if (root === document.last) {
          after = document.raws && document.raws.codeAfter;
        } else {
          // @ts-expect-error -- TS2345: Argument of type 'Root' is not assignable to parameter of type 'number | ChildNode'.
          const rootIndex = document.index(root);

          const nextNode = document.nodes[rootIndex + 1];

          after = nextNode && nextNode.raws && nextNode.raws.codeBefore;
        }

        return !String(after).trim();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "style-search": 89 }], 212: [function (require, module, exports) {
      'use strict';

      const execall = require('execall');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber, isRegExp, isString, assert } = require('../../utils/validateTypes');

      const ruleName = 'max-line-length';
      const EXCLUDED_PATTERNS = [
      /url\(\s*(\S.*\S)\s*\)/gi, // allow tab, whitespace in url content
      /@import\s+(['"].*['"])/gi];


      const messages = ruleMessages(ruleName, {
        expected: (max) =>
        `Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/max-line-length' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNumber },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['non-comments', 'comments'],
              ignorePattern: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          if (root.source == null) {
            throw new Error('The root node must have a source');
          }

          const ignoreNonComments = optionsMatches(secondaryOptions, 'ignore', 'non-comments');
          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
          const rootString = context.fix ? root.toString() : root.source.input.css;
          // Array of skipped sub strings, i.e `url(...)`, `@import "..."`
          /** @type {Array<[number, number]>} */
          let skippedSubStrings = [];
          let skippedSubStringsIndex = 0;

          for (const pattern of EXCLUDED_PATTERNS)
          for (const match of execall(pattern, rootString)) {
            const subMatch = match.subMatches[0] || '';
            const startOfSubString = match.index + match.match.indexOf(subMatch);

            skippedSubStrings.push([startOfSubString, startOfSubString + subMatch.length]);
            continue;
          }

          skippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]);

          // Check first line
          checkNewline({ endIndex: 0 });
          // Check subsequent lines
          styleSearch({ source: rootString, target: ['\n'], comments: 'check' }, (match) =>
          checkNewline(match));


          /**
           * @param {number} index
           */
          function complain(index) {
            report({
              index,
              result,
              ruleName,
              message: messages.expected(primary),
              node: root });

          }

          /**
           * @param {number} start
           * @param {number} end
           */
          function tryToPopSubString(start, end) {
            const skippedSubString = skippedSubStrings[skippedSubStringsIndex];

            assert(skippedSubString);
            const [startSubString, endSubString] = skippedSubString;

            // Excluded substring does not presented in current line
            if (end < startSubString) {
              return 0;
            }

            // Compute excluded substring size regarding to current line indexes
            const excluded = Math.min(end, endSubString) - Math.max(start, startSubString);

            // Current substring is out of range for next lines
            if (endSubString <= end) {
              skippedSubStringsIndex++;
            }

            return excluded;
          }

          /**
           * @param {import('style-search').StyleSearchMatch | { endIndex: number }} match
           */
          function checkNewline(match) {
            let nextNewlineIndex = rootString.indexOf('\n', match.endIndex);

            if (rootString[nextNewlineIndex - 1] === '\r') {
              nextNewlineIndex -= 1;
            }

            // Accommodate last line
            if (nextNewlineIndex === -1) {
              nextNewlineIndex = rootString.length;
            }

            const rawLineLength = nextNewlineIndex - match.endIndex;
            const excludedLength = skippedSubStrings[skippedSubStringsIndex] ?
            tryToPopSubString(match.endIndex, nextNewlineIndex) :
            0;
            const lineText = rootString.slice(match.endIndex, nextNewlineIndex);

            // Case sensitive ignorePattern match
            if (optionsMatches(secondaryOptions, 'ignorePattern', lineText)) {
              return;
            }

            // If the line's length is less than or equal to the specified
            // max, ignore it ... So anything below is liable to be complained about.
            // **Note that the length of any url arguments or import urls
            // are excluded from the calculation.**
            if (rawLineLength - excludedLength <= primary) {
              return;
            }

            const complaintIndex = nextNewlineIndex - 1;

            if (ignoreComments) {
              if ('insideComment' in match && match.insideComment) {
                return;
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars === '/*' || nextTwoChars === '//') {
                return;
              }
            }

            if (ignoreNonComments) {
              if ('insideComment' in match && match.insideComment) {
                return complain(complaintIndex);
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars !== '/*' && nextTwoChars !== '//') {
                return;
              }

              return complain(complaintIndex);
            }

            // If there are no spaces besides initial (indent) spaces, ignore it
            const lineString = rootString.slice(match.endIndex, nextNewlineIndex);

            if (!lineString.replace(/^\s+/, '').includes(' ')) {
              return;
            }

            return complain(complaintIndex);
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "execall": 10, "style-search": 89 }], 213: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parser = require('postcss-selector-parser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRoot, isRule } = require('../../utils/typeGuards');
      const { isNumber, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'max-nesting-depth';

      const messages = ruleMessages(ruleName, {
        expected: depth => `Expected nesting depth to be no more than ${depth}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/max-nesting-depth' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        /**
         * @param {import('postcss').Node} node
         */
        const isIgnoreAtRule = (node) =>
        isAtRule(node) && optionsMatches(secondaryOptions, 'ignoreAtRules', node.name);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isNumber] },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['blockless-at-rules', 'pseudo-classes'],
              ignoreAtRules: [isString, isRegExp],
              ignorePseudoClasses: [isString, isRegExp] } });




          if (!validOptions) return;

          root.walkRules(checkStatement);
          root.walkAtRules(checkStatement);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function checkStatement(statement) {
            if (isIgnoreAtRule(statement)) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            if (isRule(statement) && !isStandardSyntaxRule(statement)) {
              return;
            }

            const depth = nestingDepth(statement, 0);

            if (depth > primary) {
              report({
                ruleName,
                result,
                node: statement,
                message: messages.expected(primary) });

            }
          }
        };

        /**
         * @param {import('postcss').Node} node
         * @param {number} level
         * @returns {number}
         */
        function nestingDepth(node, level) {
          const parent = node.parent;

          if (parent == null) {
            throw new Error('The parent node must exist');
          }

          if (isIgnoreAtRule(parent)) {
            return 0;
          }

          // The nesting depth level's computation has finished
          // when this function, recursively called, receives
          // a node that is not nested -- a direct child of the
          // root node
          if (isRoot(parent) || isAtRule(parent) && parent.parent && isRoot(parent.parent)) {
            return level;
          }

          /**
           * @param {string} selector
           */
          function containsPseudoClassesOnly(selector) {
            const normalized = parser().processSync(selector, { lossless: false });
            const selectors = normalized.split(',');

            return selectors.every(sel => extractPseudoRule(sel));
          }

          /**
           * @param {string[]} selectors
           * @returns {boolean}
           */
          function containsIgnoredPseudoClassesOnly(selectors) {
            if (!(secondaryOptions && secondaryOptions.ignorePseudoClasses)) return false;

            return selectors.every(selector => {
              const pseudoRule = extractPseudoRule(selector);

              if (!pseudoRule) return false;

              return optionsMatches(secondaryOptions, 'ignorePseudoClasses', pseudoRule);
            });
          }

          if (
          optionsMatches(secondaryOptions, 'ignore', 'blockless-at-rules') &&
          isAtRule(node) &&
          node.every(child => !isDeclaration(child)) ||
          optionsMatches(secondaryOptions, 'ignore', 'pseudo-classes') &&
          isRule(node) &&
          containsPseudoClassesOnly(node.selector) ||
          isRule(node) && containsIgnoredPseudoClassesOnly(node.selectors))
          {
            return nestingDepth(parent, level);
          }

          // Unless any of the conditions above apply, we want to
          // add 1 to the nesting depth level and then check the parent,
          // continuing to add and move up the hierarchy
          // until we hit the root node
          return nestingDepth(parent, level + 1);
        }
      };

      /**
       * @param {string} selector
       * @returns {string | undefined}
       */
      function extractPseudoRule(selector) {
        return selector.startsWith('&:') && selector[2] !== ':' ? selector.slice(2) : undefined;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/hasBlock": 348, "../../utils/isStandardSyntaxRule": 391, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-selector-parser": 27 }], 214: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-colon-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, colonIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of colonIndices.sort((a, b) => b - a)) {
                const beforeColon = params.slice(0, index + 1);
                const afterColon = params.slice(index + 1);

                if (primary === 'always') {
                  params = beforeColon + afterColon.replace(/^\s*/, ' ');
                } else if (primary === 'never') {
                  params = beforeColon + afterColon.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaFeatureColonSpaceChecker": 228 }], 215: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-colon-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, colonIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of colonIndices.sort((a, b) => b - a)) {
                const beforeColon = params.slice(0, index);
                const afterColon = params.slice(index);

                if (primary === 'always') {
                  params = beforeColon.replace(/\s*$/, ' ') + afterColon;
                } else if (primary === 'never') {
                  params = beforeColon.replace(/\s*$/, '') + afterColon;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaFeatureColonSpaceChecker": 228 }], 216: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-name-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (matchesStringOrRegExp(value, primary)) {
                return;
              }

              const index = atRuleParamIndex(atRule) + sourceIndex;
              const endIndex = index + value.length;

              report({
                index,
                endIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/isCustomMediaQuery": 366, "../../utils/isRangeContextMediaFeature": 378, "../../utils/isStandardSyntaxMediaFeatureName": 389, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../rangeContextNodeParser": 252, "postcss-media-query-parser": 22 }], 217: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-name-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            let hasComments = atRule.raws.params && atRule.raws.params.raw;
            const mediaRule = hasComments ? hasComments : atRule.params;

            mediaParser(mediaRule).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              const expectedFeatureName = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

              if (value === expectedFeatureName) {
                return;
              }

              if (context.fix) {
                if (hasComments) {
                  hasComments =
                  hasComments.slice(0, sourceIndex) +
                  expectedFeatureName +
                  hasComments.slice(sourceIndex + expectedFeatureName.length);

                  if (atRule.raws.params == null) {
                    throw new Error('The `AtRuleRaws` node must have a `params` property');
                  }

                  atRule.raws.params.raw = hasComments;
                } else {
                  atRule.params =
                  atRule.params.slice(0, sourceIndex) +
                  expectedFeatureName +
                  atRule.params.slice(sourceIndex + expectedFeatureName.length);
                }

                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.expected(value, expectedFeatureName),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/isCustomMediaQuery": 366, "../../utils/isRangeContextMediaFeature": 378, "../../utils/isStandardSyntaxMediaFeatureName": 389, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../rangeContextNodeParser": 252, "postcss-media-query-parser": 22 }], 218: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-name-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (!matchesStringOrRegExp(value, primary)) {
                return;
              }

              const index = atRuleParamIndex(atRule) + sourceIndex;
              const endIndex = index + value.length;

              report({
                index,
                endIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/isCustomMediaQuery": 366, "../../utils/isRangeContextMediaFeature": 378, "../../utils/isStandardSyntaxMediaFeatureName": 389, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../rangeContextNodeParser": 252, "postcss-media-query-parser": 22 }], 219: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: mediaFeatureName => `Unexpected unknown media feature name "${mediaFeatureName}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-name-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreMediaFeatureNames: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreMediaFeatureNames', value)) {
                return;
              }

              if (vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {
                return;
              }

              const index = atRuleParamIndex(atRule) + sourceIndex;
              const endIndex = index + value.length;

              report({
                index,
                endIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/atRuleParamIndex": 323, "../../utils/isCustomMediaQuery": 366, "../../utils/isRangeContextMediaFeature": 378, "../../utils/isStandardSyntaxMediaFeatureName": 389, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "../rangeContextNodeParser": 252, "postcss-media-query-parser": 22 }], 220: [function (require, module, exports) {
      'use strict';

      const mediaParser = require('postcss-media-query-parser').default;

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const optionsMatches = require('../../utils/optionsMatches');
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString, isRegExp } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'media-feature-name-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (name, value) => `Unexpected value "${value}" for name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-name-value-allowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString, isRegExp)] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature-expression$/i, node => {
              if (!node.nodes) return;

              const mediaFeatureRangeContext = isRangeContextMediaFeature(node.parent.value);

              // Ignore boolean
              if (!node.value.includes(':') && !mediaFeatureRangeContext) {
                return;
              }

              const mediaFeatureNode = node.nodes.find(n => n.type === 'media-feature');

              if (mediaFeatureNode == null) throw new Error('A `media-feature` node must be present');

              let mediaFeatureName;
              let values;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                mediaFeatureName = parsedRangeContext.name.value;
                values = parsedRangeContext.values;
              } else {
                mediaFeatureName = mediaFeatureNode.value;
                const valueNode = node.nodes.find(n => n.type === 'value');

                if (valueNode == null) throw new Error('A `value` node must be present');

                values = [valueNode];
              }

              for (const valueNode of values) {
                const value = valueNode.value;
                const unprefixedMediaFeatureName = vendor.unprefixed(mediaFeatureName);

                const allowedValuesKey = Object.keys(primary).find((featureName) =>
                matchesStringOrRegExp(unprefixedMediaFeatureName, featureName));


                if (allowedValuesKey == null) {
                  return;
                }

                if (optionsMatches(primary, allowedValuesKey, value)) {
                  return;
                }

                const index = atRuleParamIndex(atRule) + valueNode.sourceIndex;
                const endIndex = index + value.length;

                report({
                  index,
                  endIndex,
                  message: messages.rejected(mediaFeatureName, value),
                  node: atRule,
                  ruleName,
                  result });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/isRangeContextMediaFeature": 378, "../../utils/matchesStringOrRegExp": 400, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "../rangeContextNodeParser": 252, "postcss-media-query-parser": 22 }], 221: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'media-feature-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-parentheses-space-inside' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            // If there are comments in the params, the complete string
            // will be at atRule.raws.params.raw
            const params = atRule.raws.params && atRule.raws.params.raw || atRule.params;
            const indexBoost = atRuleParamIndex(atRule);
            /** @type {Array<{ message: string, index: number }>} */
            const problems = [];

            const parsedParams = valueParser(params).walk(node => {
              if (node.type === 'function') {
                const len = valueParser.stringify(node).length;

                if (primary === 'never') {
                  if (/[ \t]/.test(node.before)) {
                    if (context.fix) node.before = '';

                    problems.push({
                      message: messages.rejectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (/[ \t]/.test(node.after)) {
                    if (context.fix) node.after = '';

                    problems.push({
                      message: messages.rejectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                } else if (primary === 'always') {
                  if (node.before === '') {
                    if (context.fix) node.before = ' ';

                    problems.push({
                      message: messages.expectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (node.after === '') {
                    if (context.fix) node.after = ' ';

                    problems.push({
                      message: messages.expectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                }
              }
            });

            if (problems.length) {
              if (context.fix) {
                atRule.params = parsedParams.toString();

                return;
              }

              for (const err of problems) {
                report({
                  message: err.message,
                  node: atRule,
                  index: err.index,
                  result,
                  ruleName });

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 222: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after range operator',
        rejectedAfter: () => 'Unexpected whitespace after range operator' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-range-operator-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            /** @type {number[]} */
            const fixOperatorIndices = [];
            /** @type {((index: number) => void) | null} */
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkAfterOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
                const beforeOperator = params.slice(0, index + 1);
                const afterOperator = params.slice(index + 1);

                if (primary === 'always') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, ' ');
                } else if (primary === 'never') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          /**
           * @param {import('style-search').StyleSearchMatch} match
           * @param {string} params
           * @param {import('postcss').AtRule} node
           * @param {((index: number) => void) | null} fix
           */
          function checkAfterOperator(match, params, node, fix) {
            const endIndex = match.startIndex + match.target.length - 1;

            checker.after({
              source: params,
              index: endIndex,
              err: m => {
                if (fix) {
                  fix(endIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: endIndex + atRuleParamIndex(node) + 1,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../findMediaOperator": 177 }], 223: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before range operator',
        rejectedBefore: () => 'Unexpected whitespace before range operator' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-feature-range-operator-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            /** @type {number[]} */
            const fixOperatorIndices = [];
            /** @type {((index: number) => void) | null} */
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkBeforeOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
                const beforeOperator = params.slice(0, index);
                const afterOperator = params.slice(index);

                if (primary === 'always') {
                  params = beforeOperator.replace(/\s*$/, ' ') + afterOperator;
                } else if (primary === 'never') {
                  params = beforeOperator.replace(/\s*$/, '') + afterOperator;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          /**
           * @param {import('style-search').StyleSearchMatch} match
           * @param {string} params
           * @param {import('postcss').AtRule} node
           * @param {((index: number) => void) | null} fix
           */
          function checkBeforeOperator(match, params, node, fix) {
            // The extra `+ 1` is because the match itself contains
            // the character before the operator
            checker.before({
              source: params,
              index: match.startIndex,
              err: m => {
                if (fix) {
                  fix(match.startIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: match.startIndex - 1 + atRuleParamIndex(node),
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../findMediaOperator": 177 }], 224: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-query-list-comma-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Only check for the newline after the comma, while allowing
          // arbitrary indentation after the newline
          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            allowTrailingComments: primary.startsWith('always'),
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (primary.startsWith('always')) {
                  params = /^\s*\n/.test(afterComma) ?
                  beforeComma + afterComma.replace(/^[^\S\r\n]*/, '') :
                  beforeComma + context.newline + afterComma;
                } else if (primary.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaQueryListCommaWhitespaceChecker": 229 }], 225: [function (require, module, exports) {
      'use strict';

      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-query-list-comma-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaQueryListCommaWhitespaceChecker": 229 }], 226: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-query-list-comma-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (primary.startsWith('always')) {
                  params = beforeComma + afterComma.replace(/^\s*/, ' ');
                } else if (primary.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaQueryListCommaWhitespaceChecker": 229 }], 227: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/media-query-list-comma-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index);
                const afterComma = params.slice(index);

                if (primary.startsWith('always')) {
                  params = beforeComma.replace(/\s*$/, ' ') + afterComma;
                } else if (primary.startsWith('never')) {
                  params = beforeComma.replace(/\s*$/, '') + afterComma;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../mediaQueryListCommaWhitespaceChecker": 229 }], 228: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
       *   fix: ((node: import('postcss').AtRule, index: number) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function mediaFeatureColonSpaceChecker(opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ':' }, match => {
            checkColon(params, match.startIndex, atRule);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkColon(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              const colonIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, colonIndex)) {
                return;
              }

              report({
                message,
                node,
                index: colonIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 323, "../utils/report": 409, "style-search": 89 }], 229: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const { assertString } = require('../utils/validateTypes');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
       *   checkedRuleName: string,
       *   fix?: ((atRule: import('postcss').AtRule, index: number) => boolean) | null | undefined,
       *   allowTrailingComments?: boolean,
       * }} opts
       */
      module.exports = function mediaQueryListCommaWhitespaceChecker(opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ',' }, match => {
            let index = match.startIndex;

            if (opts.allowTrailingComments) {
              // if there is a comment on the same line at after the comma, check the space after the comment.
              let execResult;

              while (execResult = /^[^\S\r\n]*\/\*([\s\S]*?)\*\//.exec(params.slice(index + 1))) {
                assertString(execResult[0]);
                index += execResult[0].length;
              }

              if (execResult = /^([^\S\r\n]*\/\/[\s\S]*?)\r?\n/.exec(params.slice(index + 1))) {
                assertString(execResult[1]);
                index += execResult[1].length;
              }
            }

            checkComma(params, index, atRule);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              const commaIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, commaIndex)) {
                return;
              }

              report({
                message,
                node,
                index: commaIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 323, "../utils/report": 409, "../utils/validateTypes": 418, "style-search": 89 }], 230: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findNotContiguousOrRectangular = require('./utils/findNotContiguousOrRectangular');
      const isRectangular = require('./utils/isRectangular');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'named-grid-areas-no-invalid';

      const messages = ruleMessages(ruleName, {
        expectedToken: () => 'Expected cell token within string',
        expectedSameNumber: () => 'Expected same number of cell tokens in each string',
        expectedRectangle: name => `Expected single filled-in rectangle for "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/named-grid-areas-no-invalid' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(/^(?:grid|grid-template|grid-template-areas)$/i, decl => {
            const { value } = decl;

            if (value.toLowerCase().trim() === 'none') return;

            /** @type {string[][]} */
            const areas = [];
            let reportSent = false;

            valueParser(value).walk(({ sourceIndex, type, value: tokenValue }) => {
              if (type !== 'string') return;

              if (tokenValue === '') {
                complain(messages.expectedToken(), sourceIndex);
                reportSent = true;

                return;
              }

              areas.push(
              tokenValue.
              trim().
              split(' ').
              filter(s => s.length > 0));

            });

            if (reportSent) return;

            if (areas.length === 0) return;

            if (!isRectangular(areas)) {
              complain(messages.expectedSameNumber());

              return;
            }

            const notContiguousOrRectangular = findNotContiguousOrRectangular(areas);

            for (const name of notContiguousOrRectangular.sort()) {
              complain(messages.expectedRectangle(name));
            }

            /**
             * @param {string} message
             * @param {number} [sourceIndex=0]
             */
            function complain(message, sourceIndex = 0) {
              report({
                message,
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "./utils/findNotContiguousOrRectangular": 231, "./utils/isRectangular": 232, "postcss-value-parser": 57 }], 231: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('../../../utils/arrayEqual');

      /**
       *
       * @param {string[][]} areas
       * @param {string} name
       * @returns {boolean}
       */
      function isContiguousAndRectangular(areas, name) {
        const indicesByRow = areas.map(row => {
          const indices = [];
          let idx = row.indexOf(name);

          while (idx !== -1) {
            indices.push(idx);
            idx = row.indexOf(name, idx + 1);
          }

          return indices;
        });

        for (let i = 0; i < indicesByRow.length; i++) {
          for (let j = i + 1; j < indicesByRow.length; j++) {
            const x = indicesByRow[i];
            const y = indicesByRow[j];

            if (x && x.length === 0 || y && y.length === 0) {
              continue;
            }

            if (!arrayEqual(x, y)) {
              return false;
            }
          }
        }

        return true;
      }

      /**
       *
       * @param {string[][]} areas
       * @returns {string[]}
       */
      function namedAreas(areas) {
        const names = new Set(areas.flat());

        names.delete('.');

        return [...names];
      }

      /**
       *
       * @param {string[][]} areas
       * @returns {string[]}
       */
      function findNotContiguousOrRectangular(areas) {
        return namedAreas(areas).filter(name => !isContiguousAndRectangular(areas, name));
      }

      module.exports = findNotContiguousOrRectangular;

    }, { "../../../utils/arrayEqual": 322 }], 232: [function (require, module, exports) {
      'use strict';

      /**
       *
       * @param {string[][]} areas
       * @returns {boolean}
       */
      function isRectangular(areas) {
        const firstArea = areas[0];

        if (firstArea === undefined) return false;

        return areas.every(row => row.length === firstArea.length);
      }

      module.exports = isRectangular;

    }, {}], 233: [function (require, module, exports) {
      'use strict';

      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const { selectorSpecificity: calculate, compare } = require('@csstools/selector-specificity');

      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { assert } = require('../../utils/validateTypes');

      const ruleName = 'no-descending-specificity';

      const messages = ruleMessages(ruleName, {
        rejected: (b, a) => `Expected selector "${b}" to come before selector "${a}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-descending-specificity' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['selectors-within-list'] } });




          if (!validOptions) {
            return;
          }

          const selectorContextLookup = nodeContextLookup();

          root.walkRules(ruleNode => {
            // Ignore nested property `foo: {};`
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Ignores selectors within list of selectors
            if (
            optionsMatches(secondaryOptions, 'ignore', 'selectors-within-list') &&
            ruleNode.selectors.length > 1)
            {
              return;
            }

            const comparisonContext = selectorContextLookup.getContext(
            ruleNode,
            findAtRuleContext(ruleNode));


            for (const selector of ruleNode.selectors) {
              const trimSelector = selector.trim();

              // Ignore `.selector, { }`
              if (trimSelector === '') {
                continue;
              }

              // Resolve any nested selectors before checking
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, s => {
                  if (!isStandardSyntaxSelector(resolvedSelector)) {
                    return;
                  }

                  checkSelector(s, ruleNode, comparisonContext);
                });
              }
            }
          });

          /**
           * @param {import('postcss-selector-parser').Root} selectorNode
           * @param {import('postcss').Rule} ruleNode
           * @param {Map<any, any>} comparisonContext
           */
          function checkSelector(selectorNode, ruleNode, comparisonContext) {
            const selector = selectorNode.toString();
            const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode);
            const selectorSpecificity = calculate(selectorNode);
            const entry = { selector, specificity: selectorSpecificity };

            if (!comparisonContext.has(referenceSelectorNode)) {
              comparisonContext.set(referenceSelectorNode, [entry]);

              return;
            }

            /** @type {Array<typeof entry>} */
            const priorComparableSelectors = comparisonContext.get(referenceSelectorNode);

            for (const priorEntry of priorComparableSelectors) {
              if (compare(selectorSpecificity, priorEntry.specificity) < 0) {
                report({
                  ruleName,
                  result,
                  node: ruleNode,
                  message: messages.rejected(selector, priorEntry.selector),
                  word: selector });

              }
            }

            priorComparableSelectors.push(entry);
          }
        };
      };

      /**
       * @param {import('postcss-selector-parser').Root} selectorNode
       */
      function lastCompoundSelectorWithoutPseudoClasses(selectorNode) {
        const firstChild = selectorNode.nodes[0];

        assert(firstChild);
        const nodesByCombinator = firstChild.split(node => node.type === 'combinator');
        const nodesAfterLastCombinator = nodesByCombinator[nodesByCombinator.length - 1];

        assert(nodesAfterLastCombinator);
        const nodesWithoutPseudoClasses = nodesAfterLastCombinator.
        filter(node => {
          return (
            node.type !== 'pseudo' ||
            node.value.startsWith('::') ||
            keywordSets.pseudoElements.has(node.value.replace(/:/g, '')));

        }).
        join('');

        return nodesWithoutPseudoClasses.toString();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/findAtRuleContext": 333, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/nodeContextLookup": 402, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "@csstools/selector-specificity": 1, "postcss-resolve-nested-selector": 26 }], 234: [function (require, module, exports) {
      'use strict';

      const mediaParser = require('postcss-media-query-parser').default;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'no-duplicate-at-import-rules';

      const messages = ruleMessages(ruleName, {
        rejected: atImport => `Unexpected duplicate @import rule ${atImport}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-duplicate-at-import-rules' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          /** @type {Record<string, string[]>} */
          const imports = {};

          root.walkAtRules(/^import$/i, atRule => {
            const [firstParam, ...restParams] = valueParser(atRule.params).nodes;

            if (!firstParam) {
              return;
            }

            // extract uri from url() if exists
            const uri =
            firstParam.type === 'function' && firstParam.value === 'url' && firstParam.nodes[0] ?
            firstParam.nodes[0].value :
            firstParam.value;

            // extract media queries if any
            const media = (mediaParser(valueParser.stringify(restParams)).nodes || []).
            map(n => n.value.replace(/\s/g, '')).
            filter(n => n.length);

            let importedUris = imports[uri];
            const isDuplicate = media.length ?
            media.some(q => importedUris && importedUris.includes(q)) :
            importedUris;

            if (isDuplicate) {
              report({
                message: messages.rejected(uri),
                node: atRule,
                result,
                ruleName,
                word: atRule.toString() });


              return;
            }

            if (!importedUris) {
              importedUris = imports[uri] = [];
            }

            importedUris.push(...media);
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-media-query-parser": 22, "postcss-value-parser": 57 }], 235: [function (require, module, exports) {
      'use strict';

      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const selectorParser = require('postcss-selector-parser');

      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean } = require('../../utils/validateTypes');

      const ruleName = 'no-duplicate-selectors';

      const messages = ruleMessages(ruleName, {
        rejected: (selector, firstDuplicateLine) =>
        `Unexpected duplicate selector "${selector}", first used at line ${firstDuplicateLine}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-duplicate-selectors' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              disallowInList: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldDisallowDuplicateInList = secondaryOptions && secondaryOptions.disallowInList;

          // The top level of this map will be rule sources.
          // Each source maps to another map, which maps rule parents to a set of selectors.
          // This ensures that selectors are only checked against selectors
          // from other rules that share the same parent and the same source.
          const selectorContextLookup = nodeContextLookup();

          root.walkRules(ruleNode => {
            if (isKeyframeRule(ruleNode)) {
              return;
            }

            const contextSelectorSet = selectorContextLookup.getContext(
            ruleNode,
            findAtRuleContext(ruleNode));

            const resolvedSelectorList = [
            ...new Set(
            ruleNode.selectors.flatMap(selector => resolvedNestedSelector(selector, ruleNode)))];



            const normalizedSelectorList = resolvedSelectorList.map(normalize);

            // Sort the selectors list so that the order of the constituents
            // doesn't matter
            const sortedSelectorList = [...normalizedSelectorList].sort().join(',');

            if (!ruleNode.source) throw new Error('The rule node must have a source');

            if (!ruleNode.source.start) throw new Error('The rule source must have a start position');

            const selectorLine = ruleNode.source.start.line;

            // Complain if the same selector list occurs twice

            let previousDuplicatePosition;
            // When `disallowInList` is true, we must parse `sortedSelectorList` into
            // list items.
            /** @type {string[]} */
            const selectorListParsed = [];

            if (shouldDisallowDuplicateInList) {
              parseSelector(sortedSelectorList, result, ruleNode, selectors => {
                selectors.each(s => {
                  const selector = String(s);

                  selectorListParsed.push(selector);

                  if (contextSelectorSet.get(selector)) {
                    previousDuplicatePosition = contextSelectorSet.get(selector);
                  }
                });
              });
            } else {
              previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);
            }

            if (previousDuplicatePosition) {
              // If the selector isn't nested we can use its raw value; otherwise,
              // we have to approximate something for the message -- which is close enough
              const isNestedSelector = resolvedSelectorList.join(',') !== ruleNode.selectors.join(',');
              const selectorForMessage = isNestedSelector ?
              resolvedSelectorList.join(', ') :
              ruleNode.selector;

              return report({
                result,
                ruleName,
                node: ruleNode,
                message: messages.rejected(selectorForMessage, previousDuplicatePosition),
                word: selectorForMessage });

            }

            const presentedSelectors = new Set();
            const reportedSelectors = new Set();

            // Or complain if one selector list contains the same selector more than once
            for (const selector of ruleNode.selectors) {
              const normalized = normalize(selector);

              if (presentedSelectors.has(normalized)) {
                if (reportedSelectors.has(normalized)) {
                  continue;
                }

                report({
                  result,
                  ruleName,
                  node: ruleNode,
                  message: messages.rejected(selector, selectorLine),
                  word: selector });

                reportedSelectors.add(normalized);
              } else {
                presentedSelectors.add(normalized);
              }
            }

            if (shouldDisallowDuplicateInList) {
              for (const selector of selectorListParsed) {
                // [selectorLine] will not really be accurate for multi-line
                // selectors, such as "bar" in "foo,\nbar {}".
                contextSelectorSet.set(selector, selectorLine);
              }
            } else {
              contextSelectorSet.set(sortedSelectorList, selectorLine);
            }
          });
        };
      };

      /**
       * @param {string} selector
       * @returns {string}
       */
      function normalize(selector) {
        if (!isStandardSyntaxSelector(selector)) {
          return selector;
        }

        return selectorParser().processSync(selector, { lossless: false });
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/findAtRuleContext": 333, "../../utils/isKeyframeRule": 371, "../../utils/isStandardSyntaxSelector": 392, "../../utils/nodeContextLookup": 402, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-resolve-nested-selector": 26, "postcss-selector-parser": 27 }], 236: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-first-line';
      const noEmptyFirstLineTest = /^\s*[\r\n]/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty line' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-empty-first-line' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'. Property 'lang' does not exist on type 'Source'.
          if (!validOptions || root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          if (!rootString.trim()) {
            return;
          }

          if (noEmptyFirstLineTest.test(rootString)) {
            if (context.fix) {
              if (root.first == null) {
                throw new Error('The root node must have the first node.');
              }

              if (root.first.raws.before == null) {
                throw new Error('The first node must have spaces before.');
              }

              root.first.raws.before = root.first.raws.before.trimStart();

              return;
            }

            report({
              message: messages.rejected,
              node: root,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 237: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-source';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty source' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-empty-source' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          if (rootString.trim()) {
            return;
          }

          report({
            message: messages.rejected,
            node: root,
            result,
            ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 238: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const { isAtRule, isComment, isDeclaration, isRule } = require('../../utils/typeGuards');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-eol-whitespace';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected whitespace at end of line' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-eol-whitespace' };


      const whitespacesToReject = new Set([' ', '\t']);

      /**
       * @param {string} str
       * @returns {string}
       */
      function fixString(str) {
        return str.replace(/[ \t]+$/, '');
      }

      /**
       * @param {number} lastEOLIndex
       * @param {string} string
       * @param {{ ignoreEmptyLines?: boolean, isRootFirst?: boolean }} [options]
       * @returns {number}
       */
      function findErrorStartIndex(
      lastEOLIndex,
      string,
      { ignoreEmptyLines, isRootFirst } = {
        ignoreEmptyLines: false,
        isRootFirst: false })

      {
        const eolWhitespaceIndex = lastEOLIndex - 1;

        // If the character before newline is not whitespace, ignore
        if (!whitespacesToReject.has(string.charAt(eolWhitespaceIndex))) {
          return -1;
        }

        if (ignoreEmptyLines) {
          // If there is only whitespace between the previous newline and
          // this newline, ignore
          const beforeNewlineIndex = string.lastIndexOf('\n', eolWhitespaceIndex);

          if (beforeNewlineIndex >= 0 || isRootFirst) {
            const line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);

            if (isOnlyWhitespace(line)) {
              return -1;
            }
          }
        }

        return eolWhitespaceIndex;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['empty-lines'] } });




          if (!validOptions) {
            return;
          }

          const ignoreEmptyLines = optionsMatches(secondaryOptions, 'ignore', 'empty-lines');

          if (context.fix) {
            fix(root);
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          /**
           * @param {number} index
           */
          const reportFromIndex = index => {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          };

          eachEolWhitespace(rootString, reportFromIndex, true);

          const errorIndex = findErrorStartIndex(rootString.length, rootString, {
            ignoreEmptyLines,
            isRootFirst: true });


          if (errorIndex > -1) {
            reportFromIndex(errorIndex);
          }

          /**
           * Iterate each whitespace at the end of each line of the given string.
           * @param {string} string - the source code string
           * @param {(index: number) => void} callback - callback the whitespace index at the end of each line.
           * @param {boolean} isRootFirst - set `true` if the given string is the first token of the root.
           * @returns {void}
           */
          function eachEolWhitespace(string, callback, isRootFirst) {
            styleSearch(
            {
              source: string,
              target: ['\n', '\r'],
              comments: 'check' },

            match => {
              const index = findErrorStartIndex(match.startIndex, string, {
                ignoreEmptyLines,
                isRootFirst });


              if (index > -1) {
                callback(index);
              }
            });

          }

          /**
           * @param {import('postcss').Root} rootNode
           */
          function fix(rootNode) {
            let isRootFirst = true;

            rootNode.walk(node => {
              fixText(
              node.raws.before,
              fixed => {
                node.raws.before = fixed;
              },
              isRootFirst);

              isRootFirst = false;

              if (isAtRule(node)) {
                fixText(node.raws.afterName, fixed => {
                  node.raws.afterName = fixed;
                });

                const rawsParams = node.raws.params;

                if (rawsParams) {
                  fixText(rawsParams.raw, fixed => {
                    rawsParams.raw = fixed;
                  });
                } else {
                  fixText(node.params, fixed => {
                    node.params = fixed;
                  });
                }
              }

              if (isRule(node)) {
                const rawsSelector = node.raws.selector;

                if (rawsSelector) {
                  fixText(rawsSelector.raw, fixed => {
                    rawsSelector.raw = fixed;
                  });
                } else {
                  fixText(node.selector, fixed => {
                    node.selector = fixed;
                  });
                }
              }

              if (isAtRule(node) || isRule(node) || isDeclaration(node)) {
                fixText(node.raws.between, fixed => {
                  node.raws.between = fixed;
                });
              }

              if (isDeclaration(node)) {
                const rawsValue = node.raws.value;

                if (rawsValue) {
                  fixText(rawsValue.raw, fixed => {
                    rawsValue.raw = fixed;
                  });
                } else {
                  fixText(node.value, fixed => {
                    node.value = fixed;
                  });
                }
              }

              if (isComment(node)) {
                fixText(node.raws.left, fixed => {
                  node.raws.left = fixed;
                });

                if (!isStandardSyntaxComment(node)) {
                  node.raws.right = node.raws.right && fixString(node.raws.right);
                } else {
                  fixText(node.raws.right, fixed => {
                    node.raws.right = fixed;
                  });
                }

                fixText(node.text, fixed => {
                  node.text = fixed;
                });
              }

              if (isAtRule(node) || isRule(node)) {
                fixText(node.raws.after, fixed => {
                  node.raws.after = fixed;
                });
              }
            });

            fixText(
            rootNode.raws.after,
            fixed => {
              rootNode.raws.after = fixed;
            },
            isRootFirst);


            if (typeof rootNode.raws.after === 'string') {
              const lastEOL = Math.max(
              rootNode.raws.after.lastIndexOf('\n'),
              rootNode.raws.after.lastIndexOf('\r'));


              if (lastEOL !== rootNode.raws.after.length - 1) {
                rootNode.raws.after =
                rootNode.raws.after.slice(0, lastEOL + 1) +
                fixString(rootNode.raws.after.slice(lastEOL + 1));
              }
            }
          }

          /**
           * @param {string | undefined} value
           * @param {(text: string) => void} fixFn
           * @param {boolean} isRootFirst
           */
          function fixText(value, fixFn, isRootFirst = false) {
            if (!value) {
              return;
            }

            let fixed = '';
            let lastIndex = 0;

            eachEolWhitespace(
            value,
            index => {
              const newlineIndex = index + 1;

              fixed += fixString(value.slice(lastIndex, newlineIndex));
              lastIndex = newlineIndex;
            },
            isRootFirst);


            if (lastIndex) {
              fixed += value.slice(lastIndex);
              fixFn(fixed);
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isOnlyWhitespace": 376, "../../utils/isStandardSyntaxComment": 385, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "style-search": 89 }], 239: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-extra-semicolons';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected extra semicolon' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-extra-semicolons' };


      /**
       * @param {import('postcss').Node} node
       * @returns {number}
       */
      function getOffsetByNode(node) {
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Document | Container<ChildNode>'
        if (node.parent && node.parent.document) {
          return 0;
        }

        const root = node.root();

        if (!root.source) throw new Error('The root node must have a source');

        if (!node.source) throw new Error('The node must have a source');

        if (!node.source.start) throw new Error('The source must have a start position');

        const string = root.source.input.css;
        const nodeColumn = node.source.start.column;
        const nodeLine = node.source.start.line;
        let line = 1;
        let column = 1;
        let index = 0;

        for (let i = 0; i < string.length; i++) {
          if (column === nodeColumn && nodeLine === line) {
            index = i;
            break;
          }

          if (string[i] === '\n') {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }

        return index;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          if (root.raws.after && root.raws.after.trim().length !== 0) {
            const rawAfterRoot = root.raws.after;

            /** @type {number[]} */
            const fixSemiIndices = [];

            styleSearch({ source: rawAfterRoot, target: ';' }, match => {
              if (context.fix) {
                fixSemiIndices.push(match.startIndex);

                return;
              }

              if (!root.source) throw new Error('The root node must have a source');

              complain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);
            });

            // fix
            if (fixSemiIndices.length) {
              root.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);
            }
          }

          root.walk(node => {
            if (node.type === 'atrule' && !isStandardSyntaxAtRule(node)) {
              return;
            }

            if (node.type === 'rule' && !isStandardSyntaxRule(node)) {
              return;
            }

            if (node.raws.before && node.raws.before.trim().length !== 0) {
              const rawBeforeNode = node.raws.before;
              const allowedSemi = 0;

              const rawBeforeIndexStart = 0;

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawBeforeNode, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex - rawBeforeIndexStart);

                  return;
                }

                complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.before = removeIndices(rawBeforeNode, fixSemiIndices);
              }
            }

            if (typeof node.raws.after === 'string' && node.raws.after.trim().length !== 0) {
              const rawAfterNode = node.raws.after;

              /**
               * If the last child is a Less mixin followed by more than one semicolon,
               * node.raws.after will be populated with that semicolon.
               * Since we ignore Less mixins, exit here
               */
              if (
              'last' in node &&
              node.last &&
              node.last.type === 'atrule' &&
              !isStandardSyntaxAtRule(node.last))
              {
                return;
              }

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawAfterNode, target: ';' }, match => {
                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                1 -
                rawAfterNode.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.after = removeIndices(rawAfterNode, fixSemiIndices);
              }
            }

            if (typeof node.raws.ownSemicolon === 'string') {
              const rawOwnSemicolon = node.raws.ownSemicolon;
              const allowedSemi = 0;

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawOwnSemicolon, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                rawOwnSemicolon.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);
              }
            }
          });

          /**
           * @param {number} index
           */
          function complain(index) {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          }

          /**
           * @param {string} str
           * @param {number[]} indices
           * @returns {string}
           */
          function removeIndices(str, indices) {
            for (const index of indices.reverse()) {
              str = str.slice(0, index) + str.slice(index + 1);
            }

            return str;
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 382, "../../utils/isStandardSyntaxRule": 391, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "style-search": 89 }], 240: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-invalid-double-slash-comments';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected double-slash CSS comment' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-invalid-double-slash-comments' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.startsWith('//')) {
              report({
                message: messages.rejected,
                node: decl,
                result,
                ruleName,
                word: decl.toString() });

            }
          });

          root.walkRules(ruleNode => {
            for (const selector of ruleNode.selectors) {
              if (selector.startsWith('//')) {
                report({
                  message: messages.rejected,
                  node: ruleNode,
                  result,
                  ruleName,
                  word: ruleNode.toString() });

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 241: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'no-invalid-position-at-import-rule';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected invalid position @import rule' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-invalid-position-at-import-rule' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, options) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: options,
            possible: {
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          let invalidPosition = false;

          root.walk(node => {
            const nodeName = 'name' in node && node.name && node.name.toLowerCase() || '';

            if (
            node.type === 'atrule' &&
            nodeName !== 'charset' &&
            nodeName !== 'import' &&
            nodeName !== 'layer' &&
            !optionsMatches(options, 'ignoreAtRules', node.name) &&
            isStandardSyntaxAtRule(node) ||
            node.type === 'rule' && isStandardSyntaxRule(node))
            {
              invalidPosition = true;

              return;
            }

            if (node.type === 'atrule' && nodeName === 'import' && invalidPosition) {
              report({
                message: messages.rejected,
                node,
                result,
                ruleName,
                word: node.toString() });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 382, "../../utils/isStandardSyntaxRule": 391, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 242: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-irregular-whitespace';

      const messages = ruleMessages(ruleName, {
        unexpected: 'Unexpected irregular whitespace' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-irregular-whitespace' };


      const IRREGULAR_WHITESPACES = [
      '\u000B', // Line Tabulation (\v) - <VT>
      '\u000C', // Form Feed (\f) - <FF>
      '\u00A0', // No-Break Space - <NBSP>
      '\u0085', // Next Line
      '\u1680', // Ogham Space Mark
      '\u180E', // Mongolian Vowel Separator - <MVS>
      '\uFEFF', // Zero Width No-Break Space - <BOM>
      '\u2000', // En Quad
      '\u2001', // Em Quad
      '\u2002', // En Space - <ENSP>
      '\u2003', // Em Space - <EMSP>
      '\u2004', // Tree-Per-Em
      '\u2005', // Four-Per-Em
      '\u2006', // Six-Per-Em
      '\u2007', // Figure Space
      '\u2008', // Punctuation Space - <PUNCSP>
      '\u2009', // Thin Space
      '\u200A', // Hair Space
      '\u200B', // Zero Width Space - <ZWSP>
      '\u2028', // Line Separator
      '\u2029', // Paragraph Separator
      '\u202F', // Narrow No-Break Space
      '\u205F', // Medium Mathematical Space
      '\u3000' // Ideographic Space
      ];

      const IRREGULAR_WHITESPACES_PATTERN = new RegExp(`([${IRREGULAR_WHITESPACES.join('')}])`);

      /**
       * @param {string} str
       * @returns {string | null}
       */
      const findIrregularWhitespace = str => {
        const result = IRREGULAR_WHITESPACES_PATTERN.exec(str);

        return result && result[1] || null;
      };

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss').Node} node
           * @param {string | undefined} value
           */
          const validate = (node, value) => {
            const issue = value && findIrregularWhitespace(value);

            if (issue) {
              report({
                ruleName,
                result,
                message: messages.unexpected,
                node,
                word: issue });

            }
          };

          root.walkAtRules(atRule => {
            validate(atRule, atRule.name);
            validate(atRule, atRule.params);
            validate(atRule, atRule.raws.before);
            validate(atRule, atRule.raws.after);
            validate(atRule, atRule.raws.afterName);
            validate(atRule, atRule.raws.between);
          });

          root.walkRules(ruleNode => {
            validate(ruleNode, ruleNode.selector);
            validate(ruleNode, ruleNode.raws.before);
            validate(ruleNode, ruleNode.raws.after);
            validate(ruleNode, ruleNode.raws.between);
          });

          root.walkDecls(decl => {
            validate(decl, decl.prop);
            validate(decl, decl.value);
            validate(decl, decl.raws.before);
            validate(decl, decl.raws.between);
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 243: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-missing-end-of-source-newline';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing end-of-source newline' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-missing-end-of-source-newline' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          if (root.source == null) {
            throw new Error('The root node must have a source property');
          }

          // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'.
          if (root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;

          if (!rootString.trim() || rootString.endsWith('\n')) {
            return;
          }

          // Fix
          if (context.fix) {
            root.raws.after = context.newline;

            return;
          }

          report({
            message: messages.rejected,
            node: root,
            index: rootString.length - 1,
            result,
            ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 244: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findAnimationName = require('../../utils/findAnimationName');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-unknown-animations';

      const messages = ruleMessages(ruleName, {
        rejected: animationName => `Unexpected unknown animation name "${animationName}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/no-unknown-animations' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          const declaredAnimations = new Set();

          root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule => {
            declaredAnimations.add(atRule.params);
          });

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'animation' || decl.prop.toLowerCase() === 'animation-name') {
              const animationNames = findAnimationName(decl.value);

              if (animationNames.length === 0) {
                return;
              }

              for (const animationNameNode of animationNames) {
                if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {
                  continue;
                }

                if (declaredAnimations.has(animationNameNode.value)) {
                  continue;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(animationNameNode.value),
                  node: decl,
                  index: declarationValueIndex(decl) + animationNameNode.sourceIndex });

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/findAnimationName": 332, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 245: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'number-leading-zero';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a leading zero',
        rejected: 'Unexpected leading zero' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/number-leading-zero' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params);
          });

          root.walkDecls(decl => check(decl, decl.value));

          /**
           * @param {import('postcss').AtRule | import('postcss').Declaration} node
           * @param {string} value
           */
          function check(node, value) {
            /** @type {Array<{ startIndex: number, endIndex: number }>} */
            const neverFixPositions = [];
            /** @type {Array<{ index: number }>} */
            const alwaysFixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              // Check leading zero
              if (primary === 'always') {
                const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value);

                if (match == null || match[0] == null || match[1] == null) {
                  return;
                }

                // The regexp above consists of 2 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-.5" as an input
                // for regex. And we need the index of ".5".
                const capturingGroupIndex = match[0].length - match[1].length;

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  alwaysFixPositions.unshift({
                    index });


                  return;
                }

                const baseIndex =
                node.type === 'atrule' ? atRuleParamIndex(node) : declarationValueIndex(node);

                complain(messages.expected, node, baseIndex + index);
              }

              if (primary === 'never') {
                const match = /(?:\D|^)(0+)(\.\d+)/.exec(valueNode.value);

                if (match == null || match[0] == null || match[1] == null || match[2] == null) {
                  return;
                }

                // The regexp above consists of 3 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-00.5"
                // as an input for regex. And we need the index of "00".
                const capturingGroupIndex = match[0].length - (match[1].length + match[2].length);

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  neverFixPositions.unshift({
                    startIndex: index,
                    // match[1].length is the length of our matched zero(s)
                    endIndex: index + match[1].length });


                  return;
                }

                const baseIndex =
                node.type === 'atrule' ? atRuleParamIndex(node) : declarationValueIndex(node);

                complain(messages.rejected, node, baseIndex + index);
              }
            });

            if (alwaysFixPositions.length) {
              for (const fixPosition of alwaysFixPositions) {
                const index = fixPosition.index;

                if (node.type === 'atrule') {
                  node.params = addLeadingZero(node.params, index);
                } else {
                  node.value = addLeadingZero(node.value, index);
                }
              }
            }

            if (neverFixPositions.length) {
              for (const fixPosition of neverFixPositions) {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeLeadingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeLeadingZeros(node.value, startIndex, endIndex);
                }
              }
            }
          }

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           */
          function complain(message, node, index) {
            report({
              result,
              ruleName,
              message,
              node,
              index });

          }
        };
      };

      /**
       * @param {string} input
       * @param {number} index
       * @returns {string}
       */
      function addLeadingZero(input, index) {
        // eslint-disable-next-line prefer-template
        return input.slice(0, index) + '0' + input.slice(index);
      }

      /**
       * @param {string} input
       * @param {number} startIndex
       * @param {number} endIndex
       * @returns {string}
       */
      function removeLeadingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 246: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'number-max-precision';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/number-max-precision' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isNumber] },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignoreUnits: [isString, isRegExp] } });




          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params);
          });

          root.walkDecls(decl => check(decl, decl.value));

          /**
           * @param {import('postcss').AtRule | import('postcss').Declaration} node
           * @param {string} value
           */
          function check(node, value) {
            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            const prop = 'prop' in node ? node.prop : undefined;

            if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
              return;
            }

            valueParser(value).walk(valueNode => {
              const unit = getUnitFromValueNode(valueNode);

              if (optionsMatches(secondaryOptions, 'ignoreUnits', unit)) {
                return;
              }

              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\d*\.(\d+)/.exec(valueNode.value);

              if (match == null || match[0] == null || match[1] == null) {
                return;
              }

              if (match[1].length <= primary) {
                return;
              }

              const baseIndex =
              node.type === 'atrule' ? atRuleParamIndex(node) : declarationValueIndex(node);
              const actual = Number.parseFloat(match[0]);

              report({
                result,
                ruleName,
                node,
                index: baseIndex + valueNode.sourceIndex + match.index,
                message: messages.expected(actual, actual.toFixed(primary)) });

            });
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getUnitFromValueNode": 347, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 247: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'number-no-trailing-zeros';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected trailing zero(s)' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/number-no-trailing-zeros' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params);
          });

          root.walkDecls(decl => check(decl, decl.value));

          /**
           * @param {import('postcss').AtRule | import('postcss').Declaration} node
           * @param {string} value
           */
          function check(node, value) {
            /** @type {Array<{ startIndex: number, endIndex: number }>} */
            const fixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\.(\d{0,100}?)(0+)(?:\D|$)/.exec(valueNode.value);

              // match[1] is any numbers between the decimal and our trailing zero, could be empty
              // match[2] is our trailing zero(s)
              if (match == null || match[1] == null || match[2] == null) {
                return;
              }

              // our index is:
              //  the index of our valueNode +
              //  the index of our match +
              //  1 for our decimal +
              //  the length of our potential non-zero number match (match[1])
              const index = valueNode.sourceIndex + match.index + 1 + match[1].length;

              // our startIndex is identical to our index except when we have only
              // trailing zeros after our decimal. in that case we don't need the decimal
              // either so we move our index back by 1.
              const startIndex = match[1].length > 0 ? index : index - 1;

              // our end index is our original index + the length of our trailing zeros
              const endIndex = index + match[2].length;

              if (context.fix) {
                fixPositions.unshift({
                  startIndex,
                  endIndex });


                return;
              }

              const baseIndex =
              node.type === 'atrule' ? atRuleParamIndex(node) : declarationValueIndex(node);

              report({
                message: messages.rejected,
                node,
                // this is the index of the _first_ trailing zero
                index: baseIndex + index,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              for (const fixPosition of fixPositions) {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeTrailingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeTrailingZeros(node.value, startIndex, endIndex);
                }
              }
            }
          }
        };
      };

      /**
       * @param {string} input
       * @param {number} startIndex
       * @param {number} endIndex
       * @returns {string}
       */
      function removeTrailingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 248: [function (require, module, exports) {
      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/property-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            // either the prefix or unprefixed version is in the list
            if (matchesStringOrRegExp([prop, vendor.unprefixed(prop)], primary)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 249: [function (require, module, exports) {
      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const optionsMatches = require('../../utils/optionsMatches');
      const { isRegExp, isString } = require('../../utils/validateTypes');
      const { isRule } = require('../../utils/typeGuards');

      const ruleName = 'property-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/property-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['lower', 'upper'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreSelectors: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            const { parent } = decl;

            if (!parent) throw new Error('A parent node must be present');

            if (isRule(parent)) {
              const { selector } = parent;

              if (selector && optionsMatches(secondaryOptions, 'ignoreSelectors', selector)) {
                return;
              }
            }

            const expectedProp = primary === 'lower' ? prop.toLowerCase() : prop.toUpperCase();

            if (prop === expectedProp) {
              return;
            }

            if (context.fix) {
              decl.prop = expectedProp;

              return;
            }

            report({
              message: messages.expected(prop, expectedProp),
              node: decl,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 250: [function (require, module, exports) {
      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/property-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            // either the prefix or unprefixed version is in the list
            if (!matchesStringOrRegExp([prop, vendor.unprefixed(prop)], primary)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxProperty": 390, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 251: [function (require, module, exports) {
      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const properties = require('known-css-properties').all;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const { isAtRule, isRule } = require('../../utils/typeGuards');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isBoolean, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected unknown property "${property}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/property-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        const allValidProperties = new Set(properties);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [isString, isRegExp],
              checkPrefixed: [isBoolean],
              ignoreSelectors: [isString, isRegExp],
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldCheckPrefixed = secondaryOptions && secondaryOptions.checkPrefixed;

          root.walkDecls(checkStatement);

          /**
           * @param {import('postcss').Declaration} decl
           */
          function checkStatement(decl) {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!shouldCheckPrefixed && vendor.prefix(prop)) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
              return;
            }

            const parent = decl.parent;

            if (
            parent &&
            isRule(parent) &&
            optionsMatches(secondaryOptions, 'ignoreSelectors', parent.selector))
            {
              return;
            }

            /** @type {import('postcss').Node | undefined} */
            let node = parent;

            while (node && node.type !== 'root') {
              if (isAtRule(node) && optionsMatches(secondaryOptions, 'ignoreAtRules', node.name)) {
                return;
              }

              node = node.parent;
            }

            if (allValidProperties.has(prop.toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName,
              word: prop });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 367, "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/isStandardSyntaxProperty": 390, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/typeGuards": 414, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "known-css-properties": 18 }], 252: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const { assert } = require('../utils/validateTypes');

      const rangeOperators = new Set(['>=', '<=', '>', '<', '=']);

      /**
       * @param {string} name
       * @returns {boolean}
       */
      function isRangeContextName(name) {
        // When the node is like "(width > 10em)" or "(10em < width)"
        // Regex is needed because the name can either be in the first or second position
        return /^(?!--)\D/.test(name) || /^--./.test(name);
      }

      /**
       * @typedef {{ value: string, sourceIndex: number }} RangeContextNode
       *
       * @param {import('postcss-media-query-parser').Node} node
       * @returns {{ name: RangeContextNode, values: RangeContextNode[] }}
       */
      module.exports = function rangeContextNodeParser(node) {
        /** @type {import('postcss-value-parser').WordNode | undefined} */
        let nameNode;

        /** @type {import('postcss-value-parser').WordNode[]} */
        const valueNodes = [];

        valueParser(node.value).walk(valueNode => {
          if (valueNode.type !== 'word') return;

          if (rangeOperators.has(valueNode.value)) return;

          if (nameNode == null && isRangeContextName(valueNode.value)) {
            nameNode = valueNode;

            return;
          }

          valueNodes.push(valueNode);
        });

        assert(nameNode);

        return {
          name: {
            value: nameNode.value,
            sourceIndex: node.sourceIndex + nameNode.sourceIndex },


          values: valueNodes.map(valueNode => ({
            value: valueNode.value,
            sourceIndex: node.sourceIndex + valueNode.sourceIndex })) };


      };

    }, { "../utils/validateTypes": 418, "postcss-value-parser": 57 }], 253: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterSingleLineComment = require('../../utils/isAfterSingleLineComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before rule',
        rejected: 'Unexpected empty line before rule' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/rule-empty-line-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never', 'always-multi-line', 'never-multi-line'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['after-comment', 'first-nested', 'inside-block'],
              except: [
              'after-rule',
              'after-single-line-comment',
              'first-nested',
              'inside-block-and-after-rule',
              'inside-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          const expectation = /** @type {string} */primary;

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Ignore the first node
            if (isFirstNodeOfRoot(ruleNode)) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment')) {
              const prevNode = ruleNode.prev();

              if (prevNode && prevNode.type === 'comment') {
                return;
              }
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(ruleNode)) {
              return;
            }

            const isNested = ruleNode.parent && ruleNode.parent.type !== 'root';

            // Optionally ignore the expectation if inside a block
            if (optionsMatches(secondaryOptions, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Ignore if the expectation is for multiple and the rule is single-line
            if (expectation.includes('multi-line') && isSingleLineString(ruleNode.toString())) {
              return;
            }

            let expectEmptyLineBefore = expectation.includes('always');

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(ruleNode) ||
            optionsMatches(secondaryOptions, 'except', 'after-rule') && isAfterRule(ruleNode) ||
            optionsMatches(secondaryOptions, 'except', 'inside-block-and-after-rule') &&
            isNested &&
            isAfterRule(ruleNode) ||
            optionsMatches(secondaryOptions, 'except', 'after-single-line-comment') &&
            isAfterSingleLineComment(ruleNode) ||
            optionsMatches(secondaryOptions, 'except', 'inside-block') && isNested)
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(ruleNode.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              const newline = context.newline;

              if (typeof newline !== 'string') {
                throw new Error(`The "newline" property must be a string: ${newline}`);
              }

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(ruleNode, newline);
              } else {
                removeEmptyLinesBefore(ruleNode, newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: ruleNode,
              result,
              ruleName });

          });
        };
      };

      /**
       * @param {import('postcss').Rule} ruleNode
       * @returns {boolean}
       */
      function isAfterRule(ruleNode) {
        const prevNode = getPreviousNonSharedLineCommentNode(ruleNode);

        return prevNode != null && prevNode.type === 'rule';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 320, "../../utils/getPreviousNonSharedLineCommentNode": 344, "../../utils/hasEmptyLine": 350, "../../utils/isAfterSingleLineComment": 357, "../../utils/isFirstNested": 369, "../../utils/isFirstNodeOfRoot": 370, "../../utils/isSingleLineString": 381, "../../utils/isStandardSyntaxRule": 391, "../../utils/optionsMatches": 403, "../../utils/removeEmptyLinesBefore": 408, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 254: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const { isString, isRegExp } = require('../../utils/validateTypes');

      const ruleName = 'rule-selector-property-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, selector) => `Unexpected property "${property}" for selector "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/rule-selector-property-disallowed-list' };


      /** @type {import('stylelint').Rule<Record<string, string | RegExp | Array<string | RegExp>>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [validateObjectWithArrayProps(isString, isRegExp)] });


          if (!validOptions) {
            return;
          }

          const selectors = Object.keys(primary);

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selectorKey = selectors.find((selector) =>
            matchesStringOrRegExp(ruleNode.selector, selector));


            if (!selectorKey) {
              return;
            }

            const disallowedProperties = primary[selectorKey];

            if (!disallowedProperties) {
              return;
            }

            for (const node of ruleNode.nodes) {
              const isDisallowedProperty =
              node.type === 'decl' && matchesStringOrRegExp(node.prop, disallowedProperties);

              if (isDisallowedProperty) {
                report({
                  message: messages.rejected(node.prop, ruleNode.selector),
                  node,
                  result,
                  ruleName });

              }
            }
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 255: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-brackets-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "["',
        rejectedOpening: 'Unexpected whitespace after "["',
        expectedClosing: 'Expected single space before "]"',
        rejectedClosing: 'Unexpected whitespace before "]"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-brackets-space-inside' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[')) {
              return;
            }

            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            let hasFixed;
            const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeSelectorString = attributeNode.toString();

                styleSearch({ source: attributeSelectorString, target: '[' }, match => {
                  const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex + 1;

                  if (nextCharIsSpace && primary === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.rejectedOpening, index);
                  }

                  if (!nextCharIsSpace && primary === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.expectedOpening, index);
                  }
                });

                styleSearch({ source: attributeSelectorString, target: ']' }, match => {
                  const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex - 1;

                  if (prevCharIsSpace && primary === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.rejectedClosing, index);
                  }

                  if (!prevCharIsSpace && primary === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.expectedClosing, index);
                  }
                });
              });
            });

            if (hasFixed && fixedSelector) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }

            /**
             * @param {string} message
             * @param {number} index
             */
            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };

        /**
         * @param {import('postcss-selector-parser').Attribute} attributeNode
         */
        function fixBefore(attributeNode) {
          const spacesAttribute = attributeNode.raws.spaces && attributeNode.raws.spaces.attribute;
          const rawAttrBefore = spacesAttribute && spacesAttribute.before;

          /** @type {{ attrBefore: string, setAttrBefore: (fixed: string) => void }} */
          const { attrBefore, setAttrBefore } = rawAttrBefore ?
          {
            attrBefore: rawAttrBefore,
            setAttrBefore(fixed) {
              spacesAttribute.before = fixed;
            } } :

          {
            attrBefore:
            attributeNode.spaces.attribute && attributeNode.spaces.attribute.before || '',
            setAttrBefore(fixed) {
              if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};

              attributeNode.spaces.attribute.before = fixed;
            } };


          if (primary === 'always') {
            setAttrBefore(attrBefore.replace(/^\s*/, ' '));
          } else if (primary === 'never') {
            setAttrBefore(attrBefore.replace(/^\s*/, ''));
          }
        }

        /**
         * @param {import('postcss-selector-parser').Attribute} attributeNode
         */
        function fixAfter(attributeNode) {
          const key = attributeNode.operator ?
          attributeNode.insensitive ?
          'insensitive' :
          'value' :
          'attribute';

          const rawSpaces = attributeNode.raws.spaces && attributeNode.raws.spaces[key];
          const rawAfter = rawSpaces && rawSpaces.after;

          const spaces = attributeNode.spaces[key];

          /** @type {{ after: string, setAfter: (fixed: string) => void }} */
          const { after, setAfter } = rawAfter ?
          {
            after: rawAfter,
            setAfter(fixed) {
              rawSpaces.after = fixed;
            } } :

          {
            after: spaces && spaces.after || '',
            setAfter(fixed) {
              if (!attributeNode.spaces[key]) attributeNode.spaces[key] = {};

              // @ts-expect-error -- TS2532: Object is possibly 'undefined'.
              attributeNode.spaces[key].after = fixed;
            } };


          if (primary === 'always') {
            setAfter(after.replace(/\s*$/, ' '));
          } else if (primary === 'never') {
            setAfter(after.replace(/\s*$/, ''));
          }
        }
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "style-search": 89 }], 256: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected name "${name}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-name-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeName = attributeNode.qualifiedAttribute;

                if (!matchesStringOrRegExp(attributeName, primary)) {
                  return;
                }

                report({
                  message: messages.rejected(attributeName),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('attribute'),
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 257: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-operator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-operator-allowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && primaryValues.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 258: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-operator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-operator-disallowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && !primaryValues.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 259: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: operator => `Expected single space after "${operator}"`,
        rejectedAfter: operator => `Unexpected whitespace after "${operator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-operator-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const checker = whitespaceChecker('space', primary, messages);
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            checkBeforeOperator: false,
            fix: context.fix ?
            attributeNode => {
              /** @type {{ operatorAfter: string, setOperatorAfter: (fixed: string) => void }} */
              const { operatorAfter, setOperatorAfter } = (() => {
                const rawOperator = attributeNode.raws.operator;

                if (rawOperator) {
                  return {
                    operatorAfter: rawOperator.slice(
                    attributeNode.operator ? attributeNode.operator.length : 0),

                    setOperatorAfter(fixed) {
                      delete attributeNode.raws.operator;

                      if (!attributeNode.raws.spaces) attributeNode.raws.spaces = {};

                      if (!attributeNode.raws.spaces.operator)
                      attributeNode.raws.spaces.operator = {};

                      attributeNode.raws.spaces.operator.after = fixed;
                    } };

                }

                const rawSpacesOperator =
                attributeNode.raws.spaces && attributeNode.raws.spaces.operator;
                const rawOperatorAfter = rawSpacesOperator && rawSpacesOperator.after;

                if (rawOperatorAfter) {
                  return {
                    operatorAfter: rawOperatorAfter,
                    setOperatorAfter(fixed) {
                      rawSpacesOperator.after = fixed;
                    } };

                }

                return {
                  operatorAfter:
                  attributeNode.spaces.operator && attributeNode.spaces.operator.after || '',
                  setOperatorAfter(fixed) {
                    if (!attributeNode.spaces.operator) attributeNode.spaces.operator = {};

                    attributeNode.spaces.operator.after = fixed;
                  } };

              })();

              if (primary === 'always') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (primary === 'never') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ''));

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorAttributeOperatorSpaceChecker": 299 }], 260: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}"`,
        rejectedBefore: operator => `Unexpected whitespace before "${operator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-operator-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            checkBeforeOperator: true,
            fix: context.fix ?
            attributeNode => {
              const rawAttr = attributeNode.raws.spaces && attributeNode.raws.spaces.attribute;
              const rawAttrAfter = rawAttr && rawAttr.after;

              /** @type {{ attrAfter: string, setAttrAfter: (fixed: string) => void }} */
              const { attrAfter, setAttrAfter } = rawAttrAfter ?
              {
                attrAfter: rawAttrAfter,
                setAttrAfter(fixed) {
                  rawAttr.after = fixed;
                } } :

              {
                attrAfter:
                attributeNode.spaces.attribute && attributeNode.spaces.attribute.after || '',
                setAttrAfter(fixed) {
                  if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};

                  attributeNode.spaces.attribute.after = fixed;
                } };


              if (primary === 'always') {
                setAttrAfter(attrAfter.replace(/\s*$/, ' '));

                return true;
              }

              if (primary === 'never') {
                setAttrAfter(attrAfter.replace(/\s*$/, ''));

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorAttributeOperatorSpaceChecker": 299 }], 261: [function (require, module, exports) {
      'use strict';

      const getRuleSelector = require('../../utils/getRuleSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { assertString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-quotes';

      const messages = ruleMessages(ruleName, {
        expected: value => `Expected quotes around "${value}"`,
        rejected: value => `Unexpected quotes around "${value}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-attribute-quotes' };


      const acceptedQuoteMark = '"';

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(getRuleSelector(ruleNode), result, ruleNode, selectorTree => {
              let selectorFixed = false;

              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.operator) {
                  return;
                }

                if (!attributeNode.quoted && primary === 'always') {
                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = acceptedQuoteMark;
                  } else {
                    assertString(attributeNode.value);
                    complain(
                    messages.expected(attributeNode.value),
                    attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                  }
                }

                if (attributeNode.quoted && primary === 'never') {
                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = null;
                  } else {
                    assertString(attributeNode.value);
                    complain(
                    messages.rejected(attributeNode.value),
                    attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                  }
                }
              });

              if (selectorFixed) {
                ruleNode.selector = selectorTree.toString();
              }
            });

            /**
             * @param {string} message
             * @param {number} index
             */
            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/getRuleSelector": 345, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 262: [function (require, module, exports) {
      'use strict';

      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolveNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-class-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected class selector ".${selectorValue}" to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-class-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isRegExp, isString] },

          {
            actual: secondaryOptions,
            possible: {
              resolveNestedSelectors: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /** @type {boolean} */
          const shouldResolveNestedSelectors =
          secondaryOptions && secondaryOptions.resolveNestedSelectors;
          /** @type {RegExp} */
          const normalizedPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkRules(ruleNode => {
            const selector = ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            // Only bother resolving selectors that have an interpolating &
            if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {
              for (const nestedSelector of resolveNestedSelector(selector, ruleNode)) {
                if (!isStandardSyntaxSelector(nestedSelector)) {
                  continue;
                }

                parseSelector(nestedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
              }
            } else {
              parseSelector(selector, result, ruleNode, s => checkSelector(s, ruleNode));
            }
          });

          /**
           * @param {import('postcss-selector-parser').Root} fullSelector
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(fullSelector, ruleNode) {
            fullSelector.walkClasses(classNode => {
              const value = classNode.value;
              const sourceIndex = classNode.sourceIndex;

              if (normalizedPattern.test(value)) {
                return;
              }

              report({
                result,
                ruleName,
                message: messages.expected(value, primary),
                node: ruleNode,
                index: sourceIndex });

            });
          }
        };
      };

      /**
       * An "interpolating ampersand" means an "&" used to interpolate
       * within another simple selector, rather than an "&" that
       * stands on its own as a simple selector.
       *
       * @param {string} selector
       * @returns {boolean}
       */
      function hasInterpolatingAmpersand(selector) {
        for (const [i, char] of Array.from(selector).entries()) {
          if (char !== '&') {
            continue;
          }

          const prevChar = selector.charAt(i - 1);

          if (prevChar && !isCombinator(prevChar)) {
            return true;
          }

          const nextChar = selector.charAt(i + 1);

          if (nextChar && !isCombinator(nextChar)) {
            return true;
          }
        }

        return false;
      }

      /**
       * @param {string} x
       * @returns {boolean}
       */
      function isCombinator(x) {
        return /[\s+>~]/.test(x);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isKeyframeSelector": 372, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-resolve-nested-selector": 26 }], 263: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-combinator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-combinator-allowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (primary.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      };

      /**
       * @param {string} value
       * @returns {string}
       */
      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 384, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 264: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-combinator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-combinator-disallowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (!primary.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      };

      /**
       * @param {string} value
       * @returns {string}
       */
      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 384, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 265: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: combinator => `Expected single space after "${combinator}"`,
        rejectedAfter: combinator => `Unexpected whitespace after "${combinator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-combinator-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            locationType: 'after',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (primary === 'always') {
                combinator.spaces.after = ' ';

                return true;
              }

              if (primary === 'never') {
                combinator.spaces.after = '';

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorCombinatorSpaceChecker": 300 }], 266: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: combinator => `Expected single space before "${combinator}"`,
        rejectedBefore: combinator => `Unexpected whitespace before "${combinator}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-combinator-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            locationType: 'before',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (primary === 'always') {
                combinator.spaces.before = ' ';

                return true;
              }

              if (primary === 'never') {
                combinator.spaces.before = '';

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorCombinatorSpaceChecker": 300 }], 267: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-descendant-combinator-no-non-space';

      const messages = ruleMessages(ruleName, {
        rejected: nonSpaceCharacter => `Unexpected "${nonSpaceCharacter}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-descendant-combinator-no-non-space' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            let hasFixed = false;
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            // Return early for selectors containing comments
            // TODO: renable when parser and stylelint are compatible
            if (selector.includes('/*')) return;

            const fixedSelector = parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (combinatorNode.value !== ' ') {
                  return;
                }

                const value = combinatorNode.toString();

                if (
                value.includes('  ') ||
                value.includes('\t') ||
                value.includes('\n') ||
                value.includes('\r'))
                {
                  if (context.fix && /^\s+$/.test(value)) {
                    hasFixed = true;

                    if (!combinatorNode.raws) combinatorNode.raws = {};

                    combinatorNode.raws.value = ' ';
                    combinatorNode.rawSpaceBefore = combinatorNode.rawSpaceBefore.replace(/^\s+/, '');
                    combinatorNode.rawSpaceAfter = combinatorNode.rawSpaceAfter.replace(/\s+$/, '');

                    return;
                  }

                  report({
                    result,
                    ruleName,
                    message: messages.rejected(value),
                    node: ruleNode,
                    index: combinatorNode.sourceIndex });

                }
              });
            });

            if (hasFixed && fixedSelector) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 268: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected selector "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!matchesStringOrRegExp(selector, primary)) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.rejected(selector),
              node: ruleNode });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 269: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-id-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected ID selector "#${selectorValue}" to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-id-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          /** @type {RegExp} */
          const normalizedPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walk(selectorNode => {
                if (selectorNode.type !== 'id') {
                  return;
                }

                const value = selectorNode.value;
                const sourceIndex = selectorNode.sourceIndex;

                if (normalizedPattern.test(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.expected(value, primary),
                  node: ruleNode,
                  index: sourceIndex });

              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 270: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-list-comma-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Get raw selector so we can allow end-of-line comments, e.g.
            // a, /* comment */
            // b {}
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            /** @type {number[]} */
            const fixIndices = [];

            styleSearch(
            {
              source: selector,
              target: ',',
              functionArguments: 'skip' },

            match => {
              const nextChars = selector.slice(match.endIndex);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^\s+\/\//.test(nextChars)) {
                return;
              }

              // If there are spaces and then a comment begins, look for the newline
              const indextoCheckAfter = /^\s+\/\*/.test(nextChars) ?
              selector.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;

              checker.afterOneOnly({
                source: selector,
                index: indextoCheckAfter,
                err: m => {
                  if (context.fix) {
                    fixIndices.push(indextoCheckAfter + 1);

                    return;
                  }

                  report({
                    message: m,
                    node: ruleNode,
                    index: match.startIndex,
                    result,
                    ruleName });

                } });

            });


            if (fixIndices.length) {
              let fixedSelector = selector;

              for (const index of fixIndices.sort((a, b) => b - a)) {
                const beforeSelector = fixedSelector.slice(0, index);
                let afterSelector = fixedSelector.slice(index);

                if (primary.startsWith('always')) {
                  afterSelector = context.newline + afterSelector;
                } else if (primary.startsWith('never-multi-line')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                fixedSelector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = fixedSelector;
              } else {
                ruleNode.selector = fixedSelector;
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "style-search": 89 }], 271: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-list-comma-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Rule, number[]> | undefined} */
          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (primary.startsWith('always')) {
                  const spaceIndex = beforeSelector.search(/\s+$/);

                  if (spaceIndex >= 0) {
                    beforeSelector =
                    beforeSelector.slice(0, spaceIndex) +
                    context.newline +
                    beforeSelector.slice(spaceIndex);
                  } else {
                    beforeSelector += context.newline;
                  }
                } else if (primary === 'never-multi-line') {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorListCommaWhitespaceChecker": 301 }], 272: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-list-comma-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Rule, number[]> | undefined} */
          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeSelector = selector.slice(0, index + 1);
                let afterSelector = selector.slice(index + 1);

                if (primary.startsWith('always')) {
                  afterSelector = afterSelector.replace(/^\s*/, ' ');
                } else if (primary.startsWith('never')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorListCommaWhitespaceChecker": 301 }], 273: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-list-comma-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Rule, number[]> | undefined} */
          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (primary.includes('always')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, ' ');
                } else if (primary.includes('never')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../selectorListCommaWhitespaceChecker": 301 }], 274: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-attribute';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} attribute ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-attribute' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNonNegativeInteger },

          {
            actual: secondaryOptions,
            possible: {
              ignoreAttributes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type !== 'attribute') {
                // Not an attribute node -> ignore
                return total;
              }

              if (optionsMatches(secondaryOptions, 'ignoreAttributes', childNode.attribute)) {
                // it's an attribute that is supposed to be ignored
                return total;
              }

              total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-resolve-nested-selector": 26 }], 275: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${max === 1 ? 'class' : 'classes'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-class' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          /**
           *  @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           *  @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'class') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26 }], 276: [function (require, module, exports) {
      'use strict';

      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-combinators';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${
        max === 1 ? 'combinator' : 'combinators'
        }` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-combinators' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'combinator') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26 }], 277: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-compound-selectors';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} compound ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-compound-selectors' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          /**
           * Finds actual selectors in selectorNode object and checks them.
           *
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            let compoundCount = 1;

            selectorNode.each(childNode => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              // Compound selectors are separated by combinators, so increase count when meeting one
              if (childNode.type === 'combinator') {
                compoundCount++;
              }
            });

            if (
            selectorNode.type !== 'root' &&
            selectorNode.type !== 'pseudo' &&
            compoundCount > primary)
            {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Using `.selectors` gets us each selector if there is a comma separated set
            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                // Process each resolved selector with `checkSelector` via postcss-selector-parser
                parseSelector(resolvedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26 }], 278: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-empty-lines' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const maxAdjacentNewlines = primary + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkRules(ruleNode => {
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            if (context.fix) {
              const newSelectorString = selector.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = newSelectorString;
              } else {
                ruleNode.selector = newSelectorString;
              }
            } else if (
            violatedLFNewLinesRegex.test(selector) ||
            violatedCRLFNewLinesRegex.test(selector))
            {
              report({
                message: messages.expected(primary),
                node: ruleNode,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 279: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-id';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ID ${max === 1 ? 'selector' : 'selectors'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-id' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNonNegativeInteger },

          {
            actual: secondaryOptions,
            possible: {
              ignoreContextFunctionalPseudoClasses: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes that are not part of ignored functional pseudo-classes
              if (
              childNode.type === 'selector' ||
              isContextFunctionalPseudoClass(childNode) &&
              !isIgnoredContextFunctionalPseudoClass(childNode))
              {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'id') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          /**
           * @param {import('postcss-selector-parser').Node} node
           * @returns {boolean}
           */
          function isIgnoredContextFunctionalPseudoClass(node) {
            return (
              node.type === 'pseudo' &&
              optionsMatches(secondaryOptions, 'ignoreContextFunctionalPseudoClasses', node.value));

          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-resolve-nested-selector": 26 }], 280: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-pseudo-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} pseudo-${max === 1 ? 'class' : 'classes'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-pseudo-class' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              // Exclude pseudo elements from the count
              if (
              childNode.type === 'pseudo' && (
              childNode.value.includes('::') ||
              keywordSets.levelOneAndTwoPseudoElements.has(childNode.value.toLowerCase().slice(1))))
              {
                return total;
              }

              if (childNode.type === 'pseudo') {
                total += 1;
              }

              return total;
            }, 0);

            if (count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, selectorTree => {
                  checkSelector(selectorTree, ruleNode);
                });
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26 }], 281: [function (require, module, exports) {
      'use strict';

      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const { selectorSpecificity, compare } = require('@csstools/selector-specificity');

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString, assertNumber } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-specificity';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) => `Expected "${selector}" to have a specificity no more than "${max}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-specificity' };


      /** @typedef {import('@csstools/selector-specificity').Specificity} Specificity */

      /**
       * Return a zero specificity. We need a new instance each time so that it can mutated.
       *
       * @returns {Specificity}
       */
      const zeroSpecificity = () => ({ a: 0, b: 0, c: 0 });

      /**
       * Calculate the sum of given specificiies.
       *
       * @param {Specificity[]} specificities
       * @returns {Specificity}
       */
      const specificitySum = specificities => {
        const sum = zeroSpecificity();

        for (const { a, b, c } of specificities) {
          sum.a += a;
          sum.b += b;
          sum.c += c;
        }

        return sum;
      };

      /** @type {import('stylelint').Rule<string>} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            // Check that the max specificity is in the form "a,b,c"
            spec => isString(spec) && /^\d+,\d+,\d+$/.test(spec)] },


          {
            actual: secondaryOptions,
            possible: {
              ignoreSelectors: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /**
           * Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value).
           *
           * @param {import('postcss-selector-parser').Node} node
           * @returns {Specificity}
           */
          const simpleSpecificity = node => {
            if (optionsMatches(secondaryOptions, 'ignoreSelectors', node.toString())) {
              return zeroSpecificity();
            }

            return selectorSpecificity(node);
          };

          /**
           * Calculate the the specificity of the most specific direct child.
           *
           * @param {import('postcss-selector-parser').Container<unknown>} node
           * @returns {Specificity}
           */
          const maxChildSpecificity = (node) =>
          node.reduce((maxSpec, child) => {
            const childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define

            return compare(childSpecificity, maxSpec) > 0 ? childSpecificity : maxSpec;
          }, zeroSpecificity());

          /**
           * Calculate the specificity of a pseudo selector including own value and children.
           *
           * @param {import('postcss-selector-parser').Pseudo} node
           * @returns {Specificity}
           */
          const pseudoSpecificity = node => {
            // `node.toString()` includes children which should be processed separately,
            // so use `node.value` instead
            const ownValue = node.value.toLowerCase();

            if (ownValue === ':where') {
              return zeroSpecificity();
            }

            let ownSpecificity;

            if (optionsMatches(secondaryOptions, 'ignoreSelectors', ownValue)) {
              ownSpecificity = zeroSpecificity();
            } else if (keywordSets.aNPlusBOfSNotationPseudoClasses.has(ownValue.replace(/^:/, ''))) {
              // TODO: We need to support `<complex-selector-list>` in `ignoreSelectors`. E.g. `:nth-child(even of .foo)`.
              return selectorSpecificity(node);
            } else {
              ownSpecificity = selectorSpecificity(node.clone({ nodes: [] }));
            }

            return specificitySum([ownSpecificity, maxChildSpecificity(node)]);
          };

          /**
           * @param {import('postcss-selector-parser').Node} node
           * @returns {boolean}
           */
          const shouldSkipPseudoClassArgument = node => {
            // postcss-selector-parser includes the arguments to nth-child() functions
            // as "tags", so we need to ignore them ourselves.
            // The fake-tag's "parent" is actually a selector node, whose parent
            // should be the :nth-child pseudo node.
            const parentNode = node.parent && node.parent.parent;

            if (parentNode && parentNode.type === 'pseudo' && parentNode.value) {
              const pseudoClass = parentNode.value.toLowerCase().replace(/^:/, '');

              return (
                keywordSets.aNPlusBNotationPseudoClasses.has(pseudoClass) ||
                keywordSets.linguisticPseudoClasses.has(pseudoClass));

            }

            return false;
          };

          /**
           * Calculate the specificity of a node parsed by `postcss-selector-parser`.
           *
           * @param {import('postcss-selector-parser').Node} node
           * @returns {Specificity}
           */
          const nodeSpecificity = node => {
            if (shouldSkipPseudoClassArgument(node)) {
              return zeroSpecificity();
            }

            switch (node.type) {
              case 'attribute':
              case 'class':
              case 'id':
              case 'tag':
                return simpleSpecificity(node);
              case 'pseudo':
                return pseudoSpecificity(node);
              case 'selector':
                // Calculate the sum of all the direct children
                return specificitySum(node.map(n => nodeSpecificity(n)));
              default:
                return zeroSpecificity();}

          };

          const [a, b, c] = primary.split(',').map(s => Number.parseFloat(s));

          assertNumber(a);
          assertNumber(b);
          assertNumber(c);

          const maxSpecificity = { a, b, c };

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Using `.selectors` gets us each selector in the eventuality we have a comma separated set
            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                // Skip non-standard syntax selectors
                if (!isStandardSyntaxSelector(resolvedSelector)) {
                  continue;
                }

                parseSelector(resolvedSelector, result, ruleNode, selectorTree => {
                  // Check if the selector specificity exceeds the allowed maximum
                  if (compare(maxChildSpecificity(selectorTree), maxSpecificity) > 0) {
                    report({
                      ruleName,
                      result,
                      node: ruleNode,
                      message: messages.expected(resolvedSelector, primary),
                      word: selector });

                  }
                });
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "@csstools/selector-specificity": 1, "postcss-resolve-nested-selector": 26 }], 282: [function (require, module, exports) {
      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-type';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} type ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-type' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNonNegativeInteger },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['descendant', 'child', 'compounded', 'next-sibling'],
              ignoreTypes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreDescendant = optionsMatches(secondaryOptions, 'ignore', 'descendant');
          const ignoreChild = optionsMatches(secondaryOptions, 'ignore', 'child');
          const ignoreCompounded = optionsMatches(secondaryOptions, 'ignore', 'compounded');
          const ignoreNextSibling = optionsMatches(secondaryOptions, 'ignore', 'next-sibling');

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (optionsMatches(secondaryOptions, 'ignoreTypes', childNode.value)) {
                return total;
              }

              if (ignoreDescendant && hasDescendantCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreChild && hasChildCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreCompounded && hasCompoundSelector(childNode)) {
                return total;
              }

              if (ignoreNextSibling && hasNextSiblingCombinator(childNode)) {
                return total;
              }

              if (childNode.type === 'tag' && !isStandardSyntaxTypeSelector(childNode)) {
                return total;
              }

              return childNode.type === 'tag' ? total + 1 : total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                if (!isStandardSyntaxSelector(resolvedSelector)) {
                  continue;
                }

                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      /** @typedef {import('postcss-selector-parser').Node} SelectorNode */

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function hasDescendantCombinatorBefore(node) {
        if (!node.parent) return false;

        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(n => isDescendantCombinator(n));
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function hasChildCombinatorBefore(node) {
        if (!node.parent) return false;

        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(n => isChildCombinator(n));
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function hasCompoundSelector(node) {
        if (node.prev() && !isCombinator(node.prev())) {
          return true;
        }

        return node.next() && !isCombinator(node.next());
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function hasNextSiblingCombinator(node) {
        return node.prev() && isNextSiblingCombinator(node.prev());
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function isCombinator(node) {
        if (!node) return false;

        return node.type === 'combinator';
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function isDescendantCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && isString(node.value) && isOnlyWhitespace(node.value);
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function isChildCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && node.value === '>';
      }

      /**
       * @param {SelectorNode} node
       * @returns {boolean}
       */
      function isNextSiblingCombinator(node) {
        return isCombinator(node) && node.value === '+';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 361, "../../utils/isKeyframeSelector": 372, "../../utils/isNonNegativeInteger": 374, "../../utils/isOnlyWhitespace": 376, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/isStandardSyntaxTypeSelector": 393, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-resolve-nested-selector": 26 }], 283: [function (require, module, exports) {
      'use strict';

      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const selectorParser = require('postcss-selector-parser');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-universal';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} universal ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-max-universal' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss-selector-parser').Container<unknown>} selectorNode
           * @param {import('postcss').Rule} ruleNode
           */
          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              // All logical combinations will be resolved as nested selector in `postcss-resolve-nested-selector`
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'universal') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > primary) {
              const selector = selectorNode.toString();

              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selector, primary),
                word: selector });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            /** @type {string[]} */
            const selectors = [];

            selectorParser().
            astSync(ruleNode.selector).
            walk(node => {
              if (node.type === 'selector') {
                selectors.push(String(node).trim());
              }
            });

            for (const selector of selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isNonNegativeInteger": 374, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26, "postcss-selector-parser": 27 }], 284: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-nested-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selector, pattern) =>
        `Expected nested selector "${selector}" to match pattern "${pattern}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-nested-pattern' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkRules(ruleNode => {
            if (ruleNode.parent && ruleNode.parent.type !== 'rule') {
              return;
            }

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (normalizedPattern.test(selector)) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.expected(selector, primary),
              node: ruleNode });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 285: [function (require, module, exports) {
      'use strict';

      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-no-qualifying-type';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected qualifying type selector' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-no-qualifying-type' };


      const selectorCharacters = ['#', '.', '['];

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function isSelectorCharacters(value) {
        return selectorCharacters.some(char => value.includes(char));
      }

      /**
       * @param {import('postcss-selector-parser').Tag} node
       * @returns {Array<import('postcss-selector-parser').Node>}
       */
      function getRightNodes(node) {
        const result = [];

        /** @type {import('postcss-selector-parser').Node} */
        let rightNode = node;

        while (rightNode = rightNode.next()) {
          if (rightNode.type === 'combinator') {
            break;
          }

          if (rightNode.type !== 'id' && rightNode.type !== 'class' && rightNode.type !== 'attribute') {
            continue;
          }

          result.push(rightNode);
        }

        return result;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [true, false] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['attribute', 'class', 'id'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (isKeyframeRule(ruleNode)) {
              return;
            }

            if (!isSelectorCharacters(ruleNode.selector)) {
              return;
            }

            /**
             * @param {import('postcss-selector-parser').Root} selectorAST
             */
            function checkSelector(selectorAST) {
              selectorAST.walkTags(selector => {
                const selectorParent = selector.parent;

                if (selectorParent && selectorParent.nodes.length === 1) {
                  return;
                }

                const selectorNodes = getRightNodes(selector);
                const index = selector.sourceIndex;

                for (const selectorNode of selectorNodes) {
                  if (selectorNode.type === 'id' && !optionsMatches(secondaryOptions, 'ignore', 'id')) {
                    complain(index);
                  }

                  if (
                  selectorNode.type === 'class' &&
                  !optionsMatches(secondaryOptions, 'ignore', 'class'))
                  {
                    complain(index);
                  }

                  if (
                  selectorNode.type === 'attribute' &&
                  !optionsMatches(secondaryOptions, 'ignore', 'attribute'))
                  {
                    complain(index);
                  }
                }
              });
            }

            for (const resolvedSelector of resolvedNestedSelector(ruleNode.selector, ruleNode)) {
              if (!isStandardSyntaxSelector(resolvedSelector)) {
                continue;
              }

              parseSelector(resolvedSelector, result, ruleNode, checkSelector);
            }

            /**
             * @param {number} index
             */
            function complain(index) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.rejected,
                index });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isKeyframeRule": 371, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-resolve-nested-selector": 26 }], 286: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const {
        isPseudoClass,
        isAttribute,
        isClassName,
        isUniversal,
        isIdentifier,
        isTag } =
      require('postcss-selector-parser');
      const { assert } = require('../../utils/validateTypes');

      const ruleName = 'selector-not-notation';
      const messages = ruleMessages(ruleName, {
        expected: type => `Expected ${type} :not() pseudo-class notation` });

      const meta = { url: 'https://stylelint.io/user-guide/rules/list/selector-not-notation' };

      /** @typedef {import('postcss-selector-parser').Node} Node */
      /** @typedef {import('postcss-selector-parser').Selector} Selector */
      /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */

      /**
       * @param {Node} node
       * @returns {boolean}
       */
      const isSimpleSelector = (node) =>
      isPseudoClass(node) ||
      isAttribute(node) ||
      isClassName(node) ||
      isUniversal(node) ||
      isIdentifier(node) ||
      isTag(node);

      /**
       * @param {Node} node
       * @returns {node is Pseudo}
       */
      const isNot = (node) =>
      isPseudoClass(node) && node.value !== undefined && node.value.toLowerCase() === ':not';

      /**
       * @param {Selector[]} list
       * @returns {boolean}
       */
      const isSimple = list => {
        if (list.length > 1) return false;

        assert(list[0], 'list is never empty');
        const [first, second] = list[0].nodes;

        if (!first) return true;

        if (second) return false;

        return isSimpleSelector(first) && !isNot(first);
      };

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['simple', 'complex'] });


          if (!validOptions) return;

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) return;

            const selector = ruleNode.selector;

            if (!selector.includes(':not(')) return;

            if (!isStandardSyntaxSelector(selector)) return;

            const fixedSelector = parseSelector(selector, result, ruleNode, container => {
              container.walkPseudos(pseudo => {
                if (!isNot(pseudo)) return;

                if (primary === 'complex') {
                  const prev = pseudo.prev();
                  const hasConsecutiveNot = prev && isNot(prev);

                  if (!hasConsecutiveNot) return;

                  if (context.fix) return fixComplex(prev);
                } else {
                  const selectors = pseudo.nodes;

                  if (isSimple(selectors)) return;

                  const mustFix =
                  context.fix &&
                  selectors.length > 1 &&
                  selectors[1] && (
                  selectors[1].nodes.length === 0 ||
                  selectors.every(({ nodes }) => nodes.length === 1));

                  if (mustFix) return fixSimple(pseudo);
                }

                report({
                  message: messages.expected(primary),
                  node: ruleNode,
                  index: pseudo.sourceIndex,
                  result,
                  ruleName });

              });
            });

            if (context.fix && fixedSelector) {
              ruleNode.selector = fixedSelector;
            }
          });
        };
      };

      /**
       * @param {Pseudo} not
       */
      function fixSimple(not) {
        const simpleSelectors = not.nodes.
        filter(({ nodes }) => nodes[0] && isSimpleSelector(nodes[0])).
        map(s => {
          assert(s.nodes[0]);
          s.nodes[0].rawSpaceBefore = '';
          s.nodes[0].rawSpaceAfter = '';

          return s;
        });
        const firstSelector = simpleSelectors.shift();

        assert(firstSelector);
        assert(not.parent);

        not.empty();
        not.nodes.push(firstSelector);

        for (const s of simpleSelectors) {
          const last = not.parent.last;

          not.parent.insertAfter(last, last.clone({ nodes: [s] }));
        }
      }

      /**
       * @param {Pseudo} previousNot
       */
      function fixComplex(previousNot) {
        const indentAndTrimRight = /** @type {Selector[]} */selectors => {
          for (const s of selectors) {
            assert(s.nodes[0]);
            s.nodes[0].rawSpaceBefore = ' ';
            s.nodes[0].rawSpaceAfter = '';
          }
        };
        const [head, ...tail] = previousNot.nodes;
        let node = previousNot.next();

        if (head == null || head.nodes.length === 0) return;

        assert(head.nodes[0]);
        head.nodes[0].rawSpaceBefore = '';
        head.nodes[0].rawSpaceAfter = '';
        indentAndTrimRight(tail);

        while (isNot(node)) {
          const selectors = node.nodes;
          const prev = node;

          indentAndTrimRight(selectors);
          previousNot.nodes = previousNot.nodes.concat(selectors);
          node = node.next();
          prev.remove();
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-selector-parser": 27 }], 287: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-class-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 288: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-class-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            const fixedSelector = parseSelector(
            ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector,
            result,
            ruleNode,
            selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudo = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudo)) {
                  return;
                }

                if (
                pseudo.includes('::') ||
                keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudo =
                primary === 'lower' ? pseudo.toLowerCase() : pseudo.toUpperCase();

                if (pseudo === expectedPseudo) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudo;

                  return;
                }

                report({
                  message: messages.expected(pseudo, expectedPseudo),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });


            if (context.fix && fixedSelector) {
              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = fixedSelector;
              } else {
                ruleNode.selector = fixedSelector;
              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 289: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-class-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements

                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 290: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomSelector = require('../../utils/isCustomSelector');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-class selector "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-class-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignorePseudoClasses: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /**
           * @param {string} selector
           * @param {import('postcss').ChildNode} node
           */
          function check(selector, node) {
            parseSelector(selector, result, node, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                if (isCustomSelector(value)) {
                  return;
                }

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                if (optionsMatches(secondaryOptions, 'ignorePseudoClasses', pseudoNode.value.slice(1))) {
                  return;
                }

                let index = null;
                const name = value.slice(1).toLowerCase();

                if (node.type === 'atrule' && node.name === 'page') {
                  if (keywordSets.atRulePagePseudoClasses.has(name)) {
                    return;
                  }

                  index = atRuleParamIndex(node) + pseudoNode.sourceIndex;
                } else {
                  if (
                  vendor.prefix(name) ||
                  keywordSets.pseudoClasses.has(name) ||
                  keywordSets.pseudoElements.has(name))
                  {
                    return;
                  }

                  /** @type {import('postcss-selector-parser').Base} */
                  let prevPseudoElement = pseudoNode;

                  do {
                    prevPseudoElement = /** @type {import('postcss-selector-parser').Base} */
                    prevPseudoElement.prev();


                    if (prevPseudoElement && prevPseudoElement.value.slice(0, 2) === '::') {
                      break;
                    }
                  } while (prevPseudoElement);

                  if (prevPseudoElement) {
                    const prevPseudoElementValue = prevPseudoElement.value.toLowerCase().slice(2);

                    if (
                    keywordSets.webkitScrollbarPseudoElements.has(prevPseudoElementValue) &&
                    keywordSets.webkitScrollbarPseudoClasses.has(name))
                    {
                      return;
                    }
                  }

                  index = pseudoNode.sourceIndex;
                }

                report({
                  message: messages.rejected(value),
                  node,
                  index,
                  ruleName,
                  result,
                  word: value });

              });
            });
          }

          root.walk(node => {
            let selector = null;

            if (node.type === 'rule') {
              if (!isStandardSyntaxRule(node)) {
                return;
              }

              selector = node.selector;
            } else if (node.type === 'atrule' && node.name === 'page' && node.params) {
              if (!isStandardSyntaxAtRule(node)) {
                return;
              }

              selector = node.params;
            }

            // Return if selector empty, it is meaning node type is not a rule or a at-rule

            if (!selector) {
              return;
            }

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            check(selector, node);
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/atRuleParamIndex": 323, "../../utils/isCustomSelector": 368, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 291: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-class-parentheses-space-inside' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('(')) {
              return;
            }

            let hasFixed = false;
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;
            const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                if (!pseudoNode.length) {
                  return;
                }

                const paramString = pseudoNode.map(node => String(node)).join(',');
                const nextCharIsSpace = paramString.startsWith(' ');
                const openIndex = pseudoNode.sourceIndex + pseudoNode.value.length + 1;

                if (nextCharIsSpace && primary === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, '');
                  } else {
                    complain(messages.rejectedOpening, openIndex);
                  }
                }

                if (!nextCharIsSpace && primary === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedOpening, openIndex);
                  }
                }

                const prevCharIsSpace = paramString.endsWith(' ');
                const closeIndex = openIndex + paramString.length - 1;

                if (prevCharIsSpace && primary === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, '');
                  } else {
                    complain(messages.rejectedClosing, closeIndex);
                  }
                }

                if (!prevCharIsSpace && primary === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedClosing, closeIndex);
                  }
                }
              });
            });

            if (hasFixed && fixedSelector) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }

            /**
             * @param {string} message
             * @param {number} index
             */
            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };
      };

      /**
       * @param {import('postcss-selector-parser').Container} node
       * @param {string} value
       * @returns {void}
       */
      function setFirstNodeSpaceBefore(node, value) {
        const target = node.first;

        if (target.type === 'selector') {
          setFirstNodeSpaceBefore(target, value);
        } else {
          target.spaces.before = value;
        }
      }

      /**
       * @param {import('postcss-selector-parser').Container} node
       * @param {string} value
       * @returns {void}
       */
      function setLastNodeSpaceAfter(node, value) {
        const target = node.last;

        if (target.type === 'selector') {
          setLastNodeSpaceAfter(target, value);
        } else {
          target.spaces.after = value;
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 292: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-element-allowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 293: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const transformSelector = require('../../utils/transformSelector');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-element-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            transformSelector(result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudoElement = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudoElement)) {
                  return;
                }

                if (
                !pseudoElement.includes('::') &&
                !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudoElement =
                primary === 'lower' ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase();

                if (pseudoElement === expectedPseudoElement) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudoElement;

                  return;
                }

                report({
                  message: messages.expected(pseudoElement, expectedPseudoElement),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/transformSelector": 413, "../../utils/validateOptions": 417 }], 294: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-colon-notation';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} colon pseudo-element notation` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-element-colon-notation' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['single', 'double'] });


          if (!validOptions) {
            return;
          }

          let fixedColon = '';

          if (primary === 'single') {
            fixedColon = ':';
          } else if (primary === 'double') {
            fixedColon = '::';
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            // get out early if no pseudo elements or classes
            if (!selector.includes(':')) {
              return;
            }

            const fixedSelector = parseSelector(selector, result, ruleNode, selectors => {
              selectors.walkPseudos(pseudo => {
                const pseudoElement = pseudo.value.replace(/:/g, '');

                if (!keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase())) {
                  return;
                }

                const isDouble = pseudo.value.startsWith('::');

                if (primary === 'single' && !isDouble) {
                  return;
                }

                if (primary === 'double' && isDouble) {
                  return;
                }

                if (context.fix) {
                  pseudo.replaceWith(pseudo.clone({ value: fixedColon + pseudoElement }));

                  return;
                }

                report({
                  message: messages.expected(primary),
                  node: ruleNode,
                  index: pseudo.sourceIndex,
                  result,
                  ruleName });

              });
            });

            if (context.fix && fixedSelector) {
              ruleNode.selector = fixedSelector;
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 295: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-element-disallowed-list' };


      /** @type {import('stylelint').Rule<string | RegExp | Array<string | RegExp>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), primary)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 391, "../../utils/matchesStringOrRegExp": 400, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 296: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-element selector "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-pseudo-element-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignorePseudoElements: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                // Ignore pseudo-classes
                if (value.slice(0, 2) !== '::') {
                  return;
                }

                if (optionsMatches(secondaryOptions, 'ignorePseudoElements', pseudoNode.value.slice(2))) {
                  return;
                }

                const name = value.slice(2);

                if (vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {
                  return;
                }

                report({
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result,
                  word: value });

              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxSelector": 392, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419 }], 297: [function (require, module, exports) {
      'use strict';

      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const keywordSets = require('../../reference/keywordSets');

      const ruleName = 'selector-type-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-type-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['lower', 'upper'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreTypes: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            let hasComments = ruleNode.raws.selector && ruleNode.raws.selector.raw;
            const selector = hasComments ? hasComments : ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorAST => {
              selectorAST.walkTags(tag => {
                if (!isStandardSyntaxTypeSelector(tag)) {
                  return;
                }

                if (keywordSets.validMixedCaseSvgElements.has(tag.value)) {
                  return;
                }

                if (optionsMatches(secondaryOptions, 'ignoreTypes', tag.value)) {
                  return;
                }

                const sourceIndex = tag.sourceIndex;
                const value = tag.value;

                const expectedValue = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

                if (value === expectedValue) {
                  return;
                }

                if (context.fix) {
                  if (hasComments) {
                    hasComments =
                    hasComments.slice(0, sourceIndex) +
                    expectedValue +
                    hasComments.slice(sourceIndex + value.length);

                    if (ruleNode.raws.selector == null) {
                      throw new Error('The `raw` property must be present');
                    }

                    ruleNode.raws.selector.raw = hasComments;
                  } else {
                    ruleNode.selector =
                    ruleNode.selector.slice(0, sourceIndex) +
                    expectedValue +
                    ruleNode.selector.slice(sourceIndex + value.length);
                  }

                  return;
                }

                report({
                  message: messages.expected(value, expectedValue),
                  node: ruleNode,
                  index: sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isKeyframeSelector": 372, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxTypeSelector": 393, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 298: [function (require, module, exports) {
      'use strict';

      const isCustomElement = require('../../utils/isCustomElement');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const keywordSets = require('../../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const svgTags = require('svg-tags');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-type-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown type selector "${selector}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/selector-type-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignore: ['custom-elements', 'default-namespace'],
              ignoreNamespaces: [isString, isRegExp],
              ignoreTypes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            const selector = ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkTags(tagNode => {
                if (!isStandardSyntaxTypeSelector(tagNode)) {
                  return;
                }

                if (
                optionsMatches(secondaryOptions, 'ignore', 'custom-elements') &&
                isCustomElement(tagNode.value))
                {
                  return;
                }

                if (
                optionsMatches(secondaryOptions, 'ignore', 'default-namespace') &&
                !(typeof tagNode.namespace === 'string'))
                {
                  return;
                }

                if (optionsMatches(secondaryOptions, 'ignoreNamespaces', tagNode.namespace)) {
                  return;
                }

                if (optionsMatches(secondaryOptions, 'ignoreTypes', tagNode.value)) {
                  return;
                }

                const tagName = tagNode.value;
                const tagNameLowerCase = tagName.toLowerCase();

                if (
                keywordSets.standardHtmlTags.has(tagNameLowerCase) ||
                // SVG tags are case-sensitive
                svgTags.includes(tagName) ||
                keywordSets.nonStandardHtmlTags.has(tagNameLowerCase) ||
                mathMLTags.includes(tagNameLowerCase))
                {
                  return;
                }

                report({
                  message: messages.rejected(tagName),
                  node: ruleNode,
                  index: tagNode.sourceIndex,
                  ruleName,
                  result,
                  word: tagName });

              });
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/isCustomElement": 364, "../../utils/isKeyframeSelector": 372, "../../utils/isStandardSyntaxRule": 391, "../../utils/isStandardSyntaxTypeSelector": 393, "../../utils/optionsMatches": 403, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "mathml-tag-names": 19, "svg-tags": 431 }], 299: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
       *   checkedRuleName: string,
       *   checkBeforeOperator: boolean,
       *   fix: ((attributeNode: import('postcss-selector-parser').Attribute) => boolean) | null,
       * }} options
       * @returns {void}
       */
      module.exports = function selectorAttributeOperatorSpaceChecker(options) {
        options.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
            return;
          }

          let hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, options.result, rule, selectorTree => {
            selectorTree.walkAttributes(attributeNode => {
              const operator = attributeNode.operator;

              if (!operator) {
                return;
              }

              const attributeNodeString = attributeNode.toString();

              styleSearch({ source: attributeNodeString, target: operator }, match => {
                const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;

                checkOperator(attributeNodeString, index, rule, attributeNode, operator);
              });
            });
          });

          if (hasFixed && fixedSelector) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }

          /**
           * @param {string} source
           * @param {number} index
           * @param {import('postcss').Node} node
           * @param {import('postcss-selector-parser').Attribute} attributeNode
           * @param {string} operator
           */
          function checkOperator(source, index, node, attributeNode, operator) {
            options.locationChecker({
              source,
              index,
              err: msg => {
                if (options.fix && options.fix(attributeNode)) {
                  hasFixed = true;

                  return;
                }

                report({
                  message: msg.replace(
                  options.checkBeforeOperator ?
                  operator.charAt(0) :
                  operator.charAt(operator.length - 1),
                  operator),

                  node,
                  index: attributeNode.sourceIndex + index,
                  result: options.result,
                  ruleName: options.checkedRuleName });

              } });

          }
        });
      };

    }, { "../utils/isStandardSyntaxRule": 391, "../utils/parseSelector": 404, "../utils/report": 409, "style-search": 89 }], 300: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxCombinator = require('../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');

      /**
       * @typedef {(args: { source: string, index: number, errTarget: string, err: (message: string) => void }) => void} LocationChecker
       *
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: LocationChecker,
       *   locationType: 'before' | 'after',
       *   checkedRuleName: string,
       *   fix: ((combinator: import('postcss-selector-parser').Combinator) => boolean) | null,
       * }} opts
       * @returns {void}
       */
      module.exports = function selectorCombinatorSpaceChecker(opts) {
        let hasFixed;

        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, opts.result, rule, selectorTree => {
            selectorTree.walkCombinators(node => {
              // Ignore non-standard combinators
              if (!isStandardSyntaxCombinator(node)) {
                return;
              }

              // Ignore spaced descendant combinator
              if (/\s/.test(node.value)) {
                return;
              }

              // Check the exist of node in prev of the combinator.
              // in case some that aren't the first begin with combinators (nesting syntax)
              if (opts.locationType === 'before' && !node.prev()) {
                return;
              }

              const parentParentNode = node.parent && node.parent.parent;

              // Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`
              if (parentParentNode && parentParentNode.type === 'pseudo') {
                return;
              }

              const sourceIndex = node.sourceIndex;
              const index =
              node.value.length > 1 && opts.locationType === 'before' ?
              sourceIndex :
              sourceIndex + node.value.length - 1;

              check(selector, node, index, rule, sourceIndex);
            });
          });

          if (hasFixed && fixedSelector) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }
        });

        /**
         * @param {string} source
         * @param {import('postcss-selector-parser').Combinator} combinator
         * @param {number} index
         * @param {import('postcss').Node} node
         * @param {number} sourceIndex
         */
        function check(source, combinator, index, node, sourceIndex) {
          opts.locationChecker({
            source,
            index,
            errTarget: combinator.value,
            err: message => {
              if (opts.fix && opts.fix(combinator)) {
                hasFixed = true;

                return;
              }

              report({
                message,
                node,
                index: sourceIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxCombinator": 384, "../utils/isStandardSyntaxRule": 391, "../utils/parseSelector": 404, "../utils/report": 409 }], 301: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
       *   checkedRuleName: string,
       *   fix: ((rule: import('postcss').Rule, index: number) => boolean) | null,
       * }} opts
       * @returns {void}
       */
      module.exports = function selectorListCommaWhitespaceChecker(opts) {
        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          styleSearch(
          {
            source: selector,
            target: ',',
            functionArguments: 'skip' },

          match => {
            checkDelimiter(selector, match.startIndex, rule);
          });

        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').Rule} node
         */
        function checkDelimiter(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxRule": 391, "../utils/report": 409, "style-search": 89 }], 302: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'shorthand-property-no-redundant-values';

      const messages = ruleMessages(ruleName, {
        rejected: (unexpected, expected) =>
        `Unexpected longhand value '${unexpected}' instead of '${expected}'` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/shorthand-property-no-redundant-values' };


      const propertiesWithShorthandNotation = new Set([
      'margin',
      'padding',
      'border-color',
      'border-radius',
      'border-style',
      'border-width',
      'grid-gap']);


      const ignoredCharacters = ['+', '*', '/', '(', ')', '$', '@', '--', 'var('];

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function hasIgnoredCharacters(value) {
        return ignoredCharacters.some(char => value.includes(char));
      }

      /**
       * @param {string} property
       * @returns {boolean}
       */
      function isShorthandProperty(property) {
        return propertiesWithShorthandNotation.has(property);
      }

      /**
       * @param {string} top
       * @param {string} right
       * @param {string} bottom
       * @param {string} left
       * @returns {string[]}
       */
      function canCondense(top, right, bottom, left) {
        const lowerTop = top.toLowerCase();
        const lowerRight = right.toLowerCase();
        const lowerBottom = bottom && bottom.toLowerCase();
        const lowerLeft = left && left.toLowerCase();

        if (canCondenseToOneValue(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top];
        }

        if (canCondenseToTwoValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right];
        }

        if (canCondenseToThreeValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right, bottom];
        }

        return [top, right, bottom, left];
      }

      /**
       * @param {string} top
       * @param {string} right
       * @param {string} bottom
       * @param {string} left
       * @returns {boolean}
       */
      function canCondenseToOneValue(top, right, bottom, left) {
        if (top !== right) {
          return false;
        }

        return top === bottom && (bottom === left || !left) || !bottom && !left;
      }

      /**
       * @param {string} top
       * @param {string} right
       * @param {string} bottom
       * @param {string} left
       * @returns {boolean}
       */
      function canCondenseToTwoValues(top, right, bottom, left) {
        return top === bottom && right === left || top === bottom && !left && top !== right;
      }

      /**
       * @param {string} _top
       * @param {string} right
       * @param {string} _bottom
       * @param {string} left
       * @returns {boolean}
       */
      function canCondenseToThreeValues(_top, right, _bottom, left) {
        return right === left;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
              return;
            }

            const prop = decl.prop;
            const value = decl.value;

            const normalizedProp = vendor.unprefixed(prop.toLowerCase());

            if (hasIgnoredCharacters(value) || !isShorthandProperty(normalizedProp)) {
              return;
            }

            /** @type {string[]} */
            const valuesToShorthand = [];

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'word') {
                return;
              }

              valuesToShorthand.push(valueParser.stringify(valueNode));
            });

            if (valuesToShorthand.length <= 1 || valuesToShorthand.length > 4) {
              return;
            }

            const shortestForm = canCondense(
            valuesToShorthand[0] || '',
            valuesToShorthand[1] || '',
            valuesToShorthand[2] || '',
            valuesToShorthand[3] || '');

            const shortestFormString = shortestForm.filter(Boolean).join(' ');
            const valuesFormString = valuesToShorthand.join(' ');

            if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
              return;
            }

            if (context.fix) {
              decl.value = decl.value.replace(value, shortestFormString);
            } else {
              report({
                message: messages.rejected(value, shortestFormString),
                node: decl,
                result,
                ruleName });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/isStandardSyntaxProperty": 390, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/vendor": 419, "postcss-value-parser": 57 }], 303: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'string-no-newline';
      const reNewLine = /\r?\n/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected newline in string' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/string-no-newline' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          /**
           * @param {import('postcss').Rule} ruleNode
           * @returns {void}
           */
          function checkRule(ruleNode) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(ruleNode.selector)) {
              return;
            }

            if (!isStandardSyntaxSelector(ruleNode.selector)) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const match = reNewLine.exec(attributeNode.value || '');

                if (!match) {
                  return;
                }

                const openIndex = [
                // length of our attribute
                attributeNode.attribute,
                // length of our operator , ie '='
                attributeNode.operator || '',
                // length of the contents before newline
                match.input.slice(0, match.index)].
                reduce(
                (index, str) => index + str.length,
                // index of the start of our attribute node in our source
                // plus 1 for the opening quotation mark
                attributeNode.sourceIndex + 1);


                report({
                  message: messages.rejected,
                  node: ruleNode,
                  index: openIndex,
                  result,
                  ruleName });

              });
            });
          }

          /**
           * @template {import('postcss').AtRule | import('postcss').Declaration} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function checkDeclOrAtRule(node, value, getIndex) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(value)) {
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'string') {
                return;
              }

              const match = reNewLine.exec(valueNode.value);

              if (!match) {
                return;
              }

              const openIndex = [
              // length of the quote
              valueNode.quote,
              // length of the contents before newline
              match.input.slice(0, match.index)].
              reduce((index, str) => index + str.length, valueNode.sourceIndex);

              report({
                message: messages.rejected,
                node,
                index: getIndex(node) + openIndex,
                result,
                ruleName });

            });
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxSelector": 392, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 304: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isBoolean, assertString } = require('../../utils/validateTypes');

      const ruleName = 'string-quotes';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} quotes` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/string-quotes' };


      const singleQuote = `'`;
      const doubleQuote = `"`;

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const correctQuote = primary === 'single' ? singleQuote : doubleQuote;
        const erroneousQuote = primary === 'single' ? doubleQuote : singleQuote;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['single', 'double'] },

          {
            actual: secondaryOptions,
            possible: {
              avoidEscape: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const avoidEscape =
          secondaryOptions && secondaryOptions.avoidEscape !== undefined ?
          secondaryOptions.avoidEscape :
          true;

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          /**
           * @param {import('postcss').Rule} ruleNode
           * @returns {void}
           */
          function checkRule(ruleNode) {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            /** @type {number[]} */
            const fixPositions = [];

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              let selectorFixed = false;

              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.quoted) {
                  return;
                }

                if (attributeNode.quoteMark === correctQuote && avoidEscape) {
                  assertString(attributeNode.value);
                  const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                  const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                  if (needsOtherEscape) {
                    return;
                  }

                  if (needsCorrectEscape) {
                    if (context.fix) {
                      selectorFixed = true;
                      attributeNode.quoteMark = erroneousQuote;
                    } else {
                      report({
                        message: messages.expected(primary === 'single' ? 'double' : primary),
                        node: ruleNode,
                        index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                        result,
                        ruleName });

                    }
                  }
                }

                if (attributeNode.quoteMark === erroneousQuote) {
                  if (avoidEscape) {
                    assertString(attributeNode.value);
                    const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                    const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                    if (needsOtherEscape) {
                      if (context.fix) {
                        selectorFixed = true;
                        attributeNode.quoteMark = correctQuote;
                      } else {
                        report({
                          message: messages.expected(primary),
                          node: ruleNode,
                          index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                          result,
                          ruleName });

                      }

                      return;
                    }

                    if (needsCorrectEscape) {
                      return;
                    }
                  }

                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = correctQuote;
                  } else {
                    report({
                      message: messages.expected(primary),
                      node: ruleNode,
                      index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                      result,
                      ruleName });

                  }
                }
              });

              if (selectorFixed) {
                ruleNode.selector = selectorTree.toString();
              }
            });

            for (const fixIndex of fixPositions) {
              ruleNode.selector = replaceQuote(ruleNode.selector, fixIndex, correctQuote);
            }
          }

          /**
           * @template {import('postcss').AtRule | import('postcss').Declaration} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function checkDeclOrAtRule(node, value, getIndex) {
            /** @type {number[]} */
            const fixPositions = [];

            // Get out quickly if there are no erroneous quotes
            if (!value.includes(erroneousQuote)) {
              return;
            }

            if (node.type === 'atrule' && node.name === 'charset') {
              // allow @charset rules to have double quotes, in spite of the configuration
              // TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {
                const needsEscape = valueNode.value.includes(correctQuote);

                if (avoidEscape && needsEscape) {
                  // don't consider this an error
                  return;
                }

                const openIndex = valueNode.sourceIndex;

                // we currently don't fix escapes
                if (context.fix && !needsEscape) {
                  const closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;

                  fixPositions.push(openIndex, closeIndex);
                } else {
                  report({
                    message: messages.expected(primary),
                    node,
                    index: getIndex(node) + openIndex,
                    result,
                    ruleName });

                }
              }
            });

            for (const fixIndex of fixPositions) {
              if (node.type === 'atrule') {
                node.params = replaceQuote(node.params, fixIndex, correctQuote);
              } else {
                node.value = replaceQuote(node.value, fixIndex, correctQuote);
              }
            }
          }
        };
      };

      /**
       * @param {string} string
       * @param {number} index
       * @param {string} replace
       * @returns {string}
       */
      function replaceQuote(string, index, replace) {
        return string.substring(0, index) + replace + string.substring(index + replace.length);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/isStandardSyntaxRule": 391, "../../utils/parseSelector": 404, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 305: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'time-min-milliseconds';

      const messages = ruleMessages(ruleName, {
        expected: time => `Expected a minimum of ${time} milliseconds` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/time-min-milliseconds' };


      const DELAY_PROPERTIES = new Set(['animation-delay', 'transition-delay']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNumber },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['delay'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const minimum = /** @type {number} */primary;

          root.walkDecls(decl => {
            const propertyName = vendor.unprefixed(decl.prop.toLowerCase());

            if (
            keywordSets.longhandTimeProperties.has(propertyName) &&
            !isIgnoredProperty(propertyName) &&
            !isAcceptableTime(decl.value))
            {
              complain(decl);
            }

            if (keywordSets.shorthandTimeProperties.has(propertyName)) {
              const valueListList = postcss.list.comma(decl.value);

              for (const valueListString of valueListList) {
                const valueList = postcss.list.space(valueListString);

                if (optionsMatches(secondaryOptions, 'ignore', 'delay')) {
                  // Check only duration time values
                  const duration = getDuration(valueList);

                  if (duration && !isAcceptableTime(duration)) {
                    complain(decl, decl.value.indexOf(duration));
                  }
                } else {
                  // Check all time values
                  for (const value of valueList) {
                    if (!isAcceptableTime(value)) {
                      complain(decl, decl.value.indexOf(value));
                    }
                  }
                }
              }
            }
          });

          /**
           * Get the duration within an `animation` or `transition` shorthand property value.
           *
           * @param {string[]} valueList
           * @returns {string | undefined}
           */
          function getDuration(valueList) {
            for (const value of valueList) {
              const parsedTime = valueParser.unit(value);

              if (!parsedTime) continue;

              // The first numeric value in an animation shorthand is the duration.
              return value;
            }

            return undefined;
          }

          /**
           * @param {string} propertyName
           * @returns {boolean}
           */
          function isIgnoredProperty(propertyName) {
            if (
            optionsMatches(secondaryOptions, 'ignore', 'delay') &&
            DELAY_PROPERTIES.has(propertyName))
            {
              return true;
            }

            return false;
          }

          /**
           * @param {string} time
           * @returns {boolean}
           */
          function isAcceptableTime(time) {
            const parsedTime = valueParser.unit(time);

            if (!parsedTime) return true;

            const numTime = Number(parsedTime.number);

            if (numTime <= 0) {
              return true;
            }

            const unit = parsedTime.unit.toLowerCase();

            if (unit === 'ms' && numTime < minimum) {
              return false;
            }

            if (unit === 's' && numTime * 1000 < minimum) {
              return false;
            }

            return true;
          }

          /**
           * @param {import('postcss').Declaration} decl
           * @param {number} [offset]
           * @returns {void}
           */
          function complain(decl, offset = 0) {
            report({
              result,
              ruleName,
              message: messages.expected(minimum),
              index: declarationValueIndex(decl) + offset,
              node: decl });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss": 77, "postcss-value-parser": 57 }], 306: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'unicode-bom';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected Unicode BOM',
        rejected: 'Unexpected Unicode BOM' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/unicode-bom' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (
          !validOptions ||
          !root.source ||
          // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'.
          root.source.inline ||
          // @ts-expect-error -- TS2339: Property 'lang' does not exist on type 'Source'.
          root.source.lang === 'object-literal' ||
          // Ignore HTML documents
          // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
          root.document !== undefined)
          {
            return;
          }

          const { hasBOM } = root.source.input;

          if (primary === 'always' && !hasBOM) {
            report({
              result,
              ruleName,
              message: messages.expected,
              node: root,
              line: 1 });

          }

          if (primary === 'never' && hasBOM) {
            report({
              result,
              ruleName,
              message: messages.rejected,
              node: root,
              line: 1 });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417 }], 307: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/unit-allowed-list' };


      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isString] },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignoreFunctions: [isString, isRegExp],
              ignoreProperties: [validateObjectWithArrayProps(isString, isRegExp)] } });




          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          /**
           * @template {import('postcss').AtRule | import('postcss').Declaration} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            valueParser(value).walk(valueNode => {
              if (valueNode.type === 'function') {
                const valueLowerCase = valueNode.value.toLowerCase();

                // Ignore wrong units within `url` function
                if (valueLowerCase === 'url') {
                  return false;
                }

                if (optionsMatches(secondaryOptions, 'ignoreFunctions', valueLowerCase)) {
                  return false;
                }
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit || unit && primaryValues.includes(unit.toLowerCase())) {
                return;
              }

              if (
              'prop' in node &&
              secondaryOptions &&
              optionsMatches(secondaryOptions.ignoreProperties, unit.toLowerCase(), node.prop))
              {
                return;
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getUnitFromValueNode": 347, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 308: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/unit-case' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          /**
           * @template {import('postcss').AtRule | import('postcss').Declaration} T
           * @param {T} node
           * @param {string} checkedValue
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function check(node, checkedValue, getIndex) {
            /** @type {Array<{ index: number, message: string }>} */
            const problems = [];

            /**
             * @param {import('postcss-value-parser').Node} valueNode
             * @returns {boolean}
             */
            function processValue(valueNode) {
              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return false;
              }

              const expectedUnit = primary === 'lower' ? unit.toLowerCase() : unit.toUpperCase();

              if (unit === expectedUnit) {
                return false;
              }

              problems.push({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.expected(unit, expectedUnit) });


              return true;
            }

            const parsedValue = valueParser(checkedValue).walk(valueNode => {
              // Ignore wrong units within `url` function
              let needFix = false;
              const value = valueNode.value;

              if (valueNode.type === 'function' && value.toLowerCase() === 'url') {
                return false;
              }

              if (value.includes('*')) {
                value.split('*').some(val => {
                  return processValue(_extends({},
                  valueNode, {
                    sourceIndex: value.indexOf(val) + val.length + 1,
                    value: val }));

                });
              }

              needFix = processValue(valueNode);

              if (needFix && context.fix) {
                valueNode.value = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();
              }
            });

            if (problems.length) {
              if (context.fix) {
                if ('name' in node && node.name === 'media') {
                  node.params = parsedValue.toString();
                } else if ('value' in node) {
                  node.value = parsedValue.toString();
                }
              } else {
                for (const err of problems) {
                  report({
                    index: err.index,
                    message: err.message,
                    node,
                    result,
                    ruleName });

                }
              }
            }
          }

          root.walkAtRules(atRule => {
            if (!/^media$/i.test(atRule.name) && !('variable' in atRule)) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getUnitFromValueNode": 347, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "postcss-value-parser": 57 }], 309: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/unit-disallowed-list' };


      /**
       * a function to retrieve only the media feature name
       * could be externalized in an utils function if needed in other code
       *
       * @param {import('postcss-media-query-parser').Child} mediaFeatureNode
       * @returns {string | undefined}
       */
      const getMediaFeatureName = mediaFeatureNode => {
        const value = mediaFeatureNode.value.toLowerCase();

        const match = /((?:-?\w*)*)/.exec(value);

        return match ? match[1] : undefined;
      };

      /** @type {import('stylelint').Rule<string | string[]>} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isString] },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [validateObjectWithArrayProps(isString, isRegExp)],
              ignoreMediaFeatureNames: [validateObjectWithArrayProps(isString, isRegExp)] } });




          if (!validOptions) {
            return;
          }

          const primaryValues = [primary].flat();

          /**
           * @param {import('postcss').Node} node
           * @param {number} nodeIndex
           * @param {import('postcss-value-parser').Node} valueNode
           * @param {string | undefined} input
           * @param {Record<string, unknown>} options
           * @returns {void}
           */
          function check(node, nodeIndex, valueNode, input, options) {
            const unit = getUnitFromValueNode(valueNode);

            // There is not unit or it is not configured as a problem
            if (!unit || unit && !primaryValues.includes(unit.toLowerCase())) {
              return;
            }

            // The unit has an ignore option for the specific input
            if (optionsMatches(options, unit.toLowerCase(), input)) {
              return;
            }

            report({
              index: nodeIndex + valueNode.sourceIndex,
              message: messages.rejected(unit),
              node,
              result,
              ruleName });

          }

          /**
           * @template {import('postcss').AtRule} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function checkMedia(node, value, getIndex) {
            mediaParser(node.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const mediaName = getMediaFeatureName(mediaFeatureNode);
              const parentValue = mediaFeatureNode.parent.value;

              valueParser(value).walk(valueNode => {
                // Ignore all non-word valueNode and
                // the values not included in the parentValue string
                if (valueNode.type !== 'word' || !parentValue.includes(valueNode.value)) {
                  return;
                }

                check(
                node,
                getIndex(node),
                valueNode,
                mediaName,
                secondaryOptions ? secondaryOptions.ignoreMediaFeatureNames : {});

              });
            });
          }

          /**
           * @template {import('postcss').Declaration} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function checkDecl(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');

            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              check(
              node,
              getIndex(node),
              valueNode,
              node.prop,
              secondaryOptions ? secondaryOptions.ignoreProperties : {});

            });
          }

          root.walkAtRules(/^media$/i, atRule => checkMedia(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => checkDecl(decl, decl.value, declarationValueIndex));
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getUnitFromValueNode": 347, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateObjectWithArrayProps": 415, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-media-query-parser": 22, "postcss-value-parser": 57 }], 310: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString, assert } = require('../../utils/validateTypes');

      const ruleName = 'unit-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unknown unit "${unit}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/unit-no-unknown' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreUnits: [isString, isRegExp],
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /**
           * @template {import('postcss').AtRule | import('postcss').Declaration} T
           * @param {T} node
           * @param {string} value
           * @param {(node: T) => number} getIndex
           * @returns {void}
           */
          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            const parsedValue = valueParser(value);

            parsedValue.walk(valueNode => {
              // Ignore wrong units within `url` function
              // and within functions listed in the `ignoreFunctions` option
              if (
              valueNode.type === 'function' && (
              valueNode.value.toLowerCase() === 'url' ||
              optionsMatches(secondaryOptions, 'ignoreFunctions', valueNode.value)))
              {
                return false;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreUnits', unit)) {
                return;
              }

              if (keywordSets.units.has(unit.toLowerCase()) && unit.toLowerCase() !== 'x') {
                return;
              }

              if (unit.toLowerCase() === 'x') {
                if (
                node.type === 'atrule' &&
                node.name === 'media' &&
                node.params.toLowerCase().includes('resolution'))
                {
                  let ignoreUnit = false;

                  mediaParser(node.params).walk((mediaNode, _i, mediaNodes) => {
                    const lastMediaNode = mediaNodes[mediaNodes.length - 1];

                    if (
                    mediaNode.value.toLowerCase().includes('resolution') &&
                    lastMediaNode &&
                    lastMediaNode.sourceIndex === valueNode.sourceIndex)
                    {
                      ignoreUnit = true;

                      return false;
                    }
                  });

                  if (ignoreUnit) {
                    return;
                  }
                }

                if (node.type === 'decl') {
                  if (node.prop.toLowerCase() === 'image-resolution') {
                    return;
                  }

                  if (/^(?:-webkit-)?image-set[\s(]/i.test(value)) {
                    const imageSet = parsedValue.nodes.find(
                    n => vendor.unprefixed(n.value) === 'image-set');


                    assert(imageSet);
                    assert('nodes' in imageSet);
                    const imageSetLastNode = imageSet.nodes[imageSet.nodes.length - 1];

                    assert(imageSetLastNode);
                    const imageSetValueLastIndex = imageSetLastNode.sourceIndex;

                    if (imageSetValueLastIndex >= valueNode.sourceIndex) {
                      return;
                    }
                  }
                }
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            check(decl, decl.value, declarationValueIndex);
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/atRuleParamIndex": 323, "../../utils/declarationValueIndex": 330, "../../utils/getUnitFromValueNode": 347, "../../utils/isStandardSyntaxAtRule": 382, "../../utils/isStandardSyntaxDeclaration": 386, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "../../utils/vendor": 419, "postcss-media-query-parser": 22, "postcss-value-parser": 57 }], 311: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isCounterIncrementCustomIdentValue = require('../../utils/isCounterIncrementCustomIdentValue');
      const isCounterResetCustomIdentValue = require('../../utils/isCounterResetCustomIdentValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isBoolean, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'value-keyword-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-keyword-case' };


      // Operators are interpreted as "words" by the value parser, so we want to make sure to ignore them.
      const ignoredCharacters = new Set(['+', '-', '/', '*', '%']);
      const gridRowProps = new Set(['grid-row', 'grid-row-start', 'grid-row-end']);
      const gridColumnProps = new Set(['grid-column', 'grid-column-start', 'grid-column-end']);

      const mapLowercaseKeywordsToCamelCase = new Map();

      for (const func of keywordSets.camelCaseKeywords) {
        mapLowercaseKeywordsToCamelCase.set(func.toLowerCase(), func);
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['lower', 'upper'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignoreKeywords: [isString, isRegExp],
              ignoreFunctions: [isString, isRegExp],
              camelCaseSvgKeywords: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const propLowerCase = decl.prop.toLowerCase();
            const value = decl.value;

            const parsed = valueParser(getDeclarationValue(decl));

            let needFix = false;

            parsed.walk(node => {
              const valueLowerCase = node.value.toLowerCase();

              // Ignore system colors
              if (keywordSets.systemColors.has(valueLowerCase)) {
                return;
              }

              // Ignore keywords within `url` and `var` function
              if (
              node.type === 'function' && (
              valueLowerCase === 'url' ||
              valueLowerCase === 'var' ||
              valueLowerCase === 'counter' ||
              valueLowerCase === 'counters' ||
              valueLowerCase === 'attr'))
              {
                return false;
              }

              // ignore keywords within ignoreFunctions functions

              if (
              node.type === 'function' &&
              optionsMatches(secondaryOptions, 'ignoreFunctions', valueLowerCase))
              {
                return false;
              }

              const keyword = node.value;

              // Ignore css variables, and hex values, and math operators, and sass interpolation
              if (
              node.type !== 'word' ||
              !isStandardSyntaxValue(node.value) ||
              value.includes('#') ||
              ignoredCharacters.has(keyword) ||
              getUnitFromValueNode(node))
              {
                return;
              }

              if (
              propLowerCase === 'animation' &&
              !keywordSets.animationShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'animation-name' &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font' &&
              !keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font-family' &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'counter-increment' &&
              isCounterIncrementCustomIdentValue(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'counter-reset' && isCounterResetCustomIdentValue(valueLowerCase)) {
                return;
              }

              if (gridRowProps.has(propLowerCase) && !keywordSets.gridRowKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              gridColumnProps.has(propLowerCase) &&
              !keywordSets.gridColumnKeywords.has(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'grid-area' && !keywordSets.gridAreaKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              propLowerCase === 'list-style' &&
              !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'list-style-type' &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreKeywords', keyword)) {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
                return;
              }

              const keywordLowerCase = keyword.toLocaleLowerCase();
              let expectedKeyword = null;

              /** @type {boolean} */
              const camelCaseSvgKeywords =
              secondaryOptions && secondaryOptions.camelCaseSvgKeywords || false;

              if (
              primary === 'lower' &&
              mapLowercaseKeywordsToCamelCase.has(keywordLowerCase) &&
              camelCaseSvgKeywords)
              {
                expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase);
              } else if (primary === 'lower') {
                expectedKeyword = keyword.toLowerCase();
              } else {
                expectedKeyword = keyword.toUpperCase();
              }

              if (keyword === expectedKeyword) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedKeyword;

                return;
              }

              report({
                message: messages.expected(keyword, expectedKeyword),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              decl.value = parsed.toString();
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../reference/keywordSets": 107, "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/getUnitFromValueNode": 347, "../../utils/isCounterIncrementCustomIdentValue": 362, "../../utils/isCounterResetCustomIdentValue": 363, "../../utils/isStandardSyntaxValue": 395, "../../utils/optionsMatches": 403, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418, "postcss-value-parser": 57 }], 312: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-list-comma-newline-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Declaration, number[]> | undefined} */
          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null,
            determineIndex: (declString, match) => {
              const nextChars = declString.substring(match.endIndex, declString.length);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^[ \t]*\/\//.test(nextChars)) {
                return false;
              }

              // If there are spaces and then a comment begins, look for the newline
              return /^[ \t]*\/\*/.test(nextChars) ?
              declString.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;
            } });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => a - b).reverse()) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (primary.startsWith('always')) {
                  afterValue = context.newline + afterValue;
                } else if (primary.startsWith('never-multi-line')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../valueListCommaWhitespaceChecker": 317 }], 313: [function (require, module, exports) {
      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-list-comma-newline-before' };


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 410, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../valueListCommaWhitespaceChecker": 317 }], 314: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-list-comma-space-after' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Declaration, number[]> | undefined} */
          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => b - a)) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (primary.startsWith('always')) {
                  afterValue = afterValue.replace(/^\s*/, ' ');
                } else if (primary.startsWith('never')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../valueListCommaWhitespaceChecker": 317 }], 315: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-list-comma-space-before' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').Declaration, number[]> | undefined} */
          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => b - a)) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                let beforeValue = value.slice(0, valueIndex);
                const afterValue = value.slice(valueIndex);

                if (primary.startsWith('always')) {
                  beforeValue = beforeValue.replace(/\s*$/, ' ');
                } else if (primary.startsWith('never')) {
                  beforeValue = beforeValue.replace(/\s*$/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 330, "../../utils/getDeclarationValue": 338, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/whitespaceChecker": 420, "../valueListCommaWhitespaceChecker": 317 }], 316: [function (require, module, exports) {
      'use strict';

      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'value-list-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      const meta = {
        url: 'https://stylelint.io/user-guide/rules/list/value-list-max-empty-lines' };


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const maxAdjacentNewlines = primary + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            const value = getDeclarationValue(decl);

            if (context.fix) {
              const newValueString = value.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              setDeclarationValue(decl, newValueString);
            } else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {
              report({
                message: messages.expected(primary),
                node: decl,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = meta;
      module.exports = rule;

    }, { "../../utils/getDeclarationValue": 338, "../../utils/report": 409, "../../utils/ruleMessages": 410, "../../utils/setDeclarationValue": 412, "../../utils/validateOptions": 417, "../../utils/validateTypes": 418 }], 317: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../utils/isStandardSyntaxProperty');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void }) => void,
       *   checkedRuleName: string,
       *   fix?: ((node: import('postcss').Declaration, index: number) => boolean) | null,
       *   determineIndex?: (declString: string, match: import('style-search').StyleSearchMatch) => number | false,
       * }} opts
       */
      module.exports = function valueListCommaWhitespaceChecker(opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
            return;
          }

          const declString = decl.toString();

          styleSearch(
          {
            source: declString,
            target: ',',
            functionArguments: 'skip' },

          match => {
            const indexToCheckAfter = opts.determineIndex ?
            opts.determineIndex(declString, match) :
            match.startIndex;

            if (indexToCheckAfter === false) {
              return;
            }

            checkComma(declString, indexToCheckAfter, decl);
          });

        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').Declaration} node
         * @returns {void}
         */
        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxDeclaration": 386, "../utils/isStandardSyntaxProperty": 390, "../utils/report": 409, "style-search": 89 }], 318: [function (require, module, exports) {
      'use strict';

      /* const debug = require('debug')('stylelint:standalone'); */
      /* const fastGlob = require('fast-glob'); */
      /* const fs = require('fs'); */
      /* const globby = require('globby'); */
      /* const normalizePath = require('normalize-path'); */
      /* const path = require('path'); */

      const createStylelint = require('./createStylelint');
      const createStylelintResult = require('./createStylelintResult');
      /* const FileCache = require('./utils/FileCache'); */
      /* const filterFilePaths = require('./utils/filterFilePaths'); */
      const formatters = require('./formatters');
      const getFileIgnorer = require('./utils/getFileIgnorer');
      const getFormatterOptionsText = require('./utils/getFormatterOptionsText');
      /* const hash = require('./utils/hash'); */
      /* const NoFilesFoundError = require('./utils/noFilesFoundError'); */
      const AllFilesIgnoredError = require('./utils/allFilesIgnoredError');
      const { assert } = require('./utils/validateTypes');
      /* const pkg = require('../package.json'); */
      const prepareReturnValue = require('./prepareReturnValue');

      const ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];
      /* const writeFileAtomic = require('write-file-atomic'); */

      /** @typedef {import('stylelint').LinterOptions} LinterOptions */
      /** @typedef {import('stylelint').LinterResult} LinterResult */
      /** @typedef {import('stylelint').LintResult} StylelintResult */
      /** @typedef {import('stylelint').Formatter} Formatter */
      /** @typedef {import('stylelint').FormatterType} FormatterType */

      /**
       *
       * @param {LinterOptions} options
       * @returns {Promise<LinterResult>}
       */
      async function standalone({
        allowEmptyInput = false,
        cache: useCache = false,
        cacheLocation,
        code,
        codeFilename,
        config,
        configBasedir,
        configFile,
        customSyntax,
        cwd = process.cwd(),
        disableDefaultIgnores,
        files,
        fix,
        formatter,
        globbyOptions,
        ignoreDisables,
        ignorePath,
        ignorePattern,
        maxWarnings,
        quiet,
        reportDescriptionlessDisables,
        reportInvalidScopeDisables,
        reportNeedlessDisables,
        syntax })
      {
        /** @type {FileCache} */
        let fileCache;
        const startTime = Date.now();

        const isValidCode = typeof code === 'string';

        if (!files && !isValidCode || files && (code || isValidCode)) {
          return Promise.reject(
          new Error('You must pass stylelint a `files` glob or a `code` string, though not both'));

        }

        // The ignorer will be used to filter file paths after the glob is checked,
        // before any files are actually read

        /** @type {import('ignore').Ignore} */
        let ignorer;

        try {
          /* ignorer = getFileIgnorer({ cwd, ignorePath, ignorePattern }); */
        } catch (error) {
          return Promise.reject(error);
        }

        /** @type {Formatter} */
        let formatterFunction;

        try {
          formatterFunction = getFormatterFunction(formatter);
        } catch (error) {
          return Promise.reject(error);
        }

        const stylelint = createStylelint({
          config,
          configFile,
          configBasedir,
          cwd,
          ignoreDisables,
          ignorePath,
          reportNeedlessDisables,
          reportInvalidScopeDisables,
          reportDescriptionlessDisables,
          syntax,
          customSyntax,
          fix,
          quiet });


        if (!files) {
          const absoluteCodeFilename =
          codeFilename !== undefined && ! /* path.isAbsolute(codeFilename) */
          true ?
          path.join(cwd, codeFilename) :
          codeFilename;

          // if file is ignored, return nothing
          if (
          absoluteCodeFilename /* &&
          !filterFilePaths(ignorer, [path.relative(cwd, absoluteCodeFilename)]).length */ &&
          false)
          {
            return prepareReturnValue([], maxWarnings, formatterFunction, cwd);
          }

          let stylelintResult;

          try {
            const postcssResult = await stylelint._lintSource({
              code,
              codeFilename: absoluteCodeFilename });


            stylelintResult = await stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);
          } catch (error) {
            stylelintResult = await handleError(stylelint, error);
          }

          const postcssResult = stylelintResult._postcssResult;
          const returnValue = prepareReturnValue([stylelintResult], maxWarnings, formatterFunction, cwd);

          if (
          fix &&
          postcssResult &&
          !postcssResult.stylelint.ignored &&
          !postcssResult.stylelint.ruleDisableFix)
          {
            returnValue.output =
            !postcssResult.stylelint.disableWritingFix && postcssResult.opts ?
            // If we're fixing, the output should be the fixed code
            postcssResult.root.toString(postcssResult.opts.syntax) :
            // If the writing of the fix is disabled, the input code is returned as-is
            code;
          }

          return returnValue;
        }

        /* let fileList = [files].flat().map((entry) => {
        	const globCWD = (globbyOptions && globbyOptions.cwd) || cwd;
        	const absolutePath = !path.isAbsolute(entry)
        		? path.join(globCWD, entry)
        		: path.normalize(entry);
        		if (fs.existsSync(absolutePath)) {
        		// This path points to a file. Return an escaped path to avoid globbing
        		return fastGlob.escapePath(normalizePath(entry));
        	}
        		return entry;
        });
        	if (!disableDefaultIgnores) {
        	fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map((glob) => `!${glob}`));
        }
        	if (useCache) {
        	const stylelintVersion = pkg.version;
        	const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);
        		fileCache = new FileCache(cacheLocation, cwd, hashOfConfig);
        } else {
        	// No need to calculate hash here, we just want to delete cache file.
        	fileCache = new FileCache(cacheLocation, cwd);
        	// Remove cache file if cache option is disabled
        	fileCache.destroy();
        }
        	const effectiveGlobbyOptions = {
        	cwd,
        	...(globbyOptions || {}),
        	absolute: true,
        };
        	const globCWD = effectiveGlobbyOptions.cwd;
        	let filePaths = await globby(fileList, effectiveGlobbyOptions);
        // Record the length of filePaths before ignore operation
        // Prevent prompting "No files matching the pattern 'xx' were found." when .stylelintignore ignore all input files
        const filePathsLengthBeforeIgnore = filePaths.length;
        	// The ignorer filter needs to check paths relative to cwd
        filePaths = filterFilePaths(
        	ignorer,
        	filePaths.map((p) => path.relative(globCWD, p)),
        );
        	let stylelintResults;
        	if (filePaths.length) {
        	let absoluteFilePaths = filePaths.map((filePath) => {
        		const absoluteFilepath = !path.isAbsolute(filePath)
        			? path.join(globCWD, filePath)
        			: path.normalize(filePath);
        			return absoluteFilepath;
        	});
        		if (useCache) {
        		absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));
        	}
        		const getStylelintResults = absoluteFilePaths.map(async (absoluteFilepath) => {
        		debug(`Processing ${absoluteFilepath}`);
        			try {
        			const postcssResult = await stylelint._lintSource({
        				filePath: absoluteFilepath,
        			});
        				if (postcssResult.stylelint.stylelintError && useCache) {
        				debug(`${absoluteFilepath} contains linting errors and will not be cached.`);
        				fileCache.removeEntry(absoluteFilepath);
        			}
        				
        			if (
        				postcssResult.root &&
        				postcssResult.opts &&
        				!postcssResult.stylelint.ignored &&
        				fix &&
        				!postcssResult.stylelint.disableWritingFix
        			) {
        				const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);
        					if (
        					postcssResult.root &&
        					postcssResult.root.source &&
        					postcssResult.root.source.input.css !== fixedCss
        				) {
        					await writeFileAtomic(absoluteFilepath, fixedCss);
        				}
        			}
        				return stylelint._createStylelintResult(postcssResult, absoluteFilepath);
        		} catch (error) {
        			// On any error, we should not cache the lint result
        			fileCache.removeEntry(absoluteFilepath);
        				return handleError(stylelint, error, absoluteFilepath);
        		}
        	});
        		stylelintResults = await Promise.all(getStylelintResults);
        } else if (allowEmptyInput) {
        	stylelintResults = await Promise.all([]);
        } else if (filePathsLengthBeforeIgnore) {
        	// All input files ignored
        	stylelintResults = await Promise.reject(new AllFilesIgnoredError());
        } else {
        	stylelintResults = await Promise.reject(new NoFilesFoundError(fileList));
        }
        	if (useCache) {
        	fileCache.reconcile();
        }
        	const result = prepareReturnValue(stylelintResults, maxWarnings, formatterFunction, cwd);
        	debug(`Linting complete in ${Date.now() - startTime}ms`);
        	return result; */

























      }

      /**
       * @param {FormatterType | Formatter | undefined} selected
       * @returns {Formatter}
       */
      function getFormatterFunction(selected) {
        if (typeof selected === 'string') {
          const formatterFunction = formatters[selected];

          if (formatterFunction === undefined) {
            throw new Error(
            `You must use a valid formatter option: ${getFormatterOptionsText()} or a function`);

          }

          return formatterFunction;
        }

        if (typeof selected === 'function') {
          return selected;
        }

        assert(formatters.json);

        return formatters.json;
      }

      /**
       * @param {import('stylelint').InternalApi} stylelint
       * @param {any} error
       * @param {string} [filePath]
       * @return {Promise<StylelintResult>}
       */
      function handleError(stylelint, error, filePath = undefined) {
        if (error.name === 'CssSyntaxError') {
          return createStylelintResult(stylelint, undefined, filePath, error);
        }

        throw error;
      }

      module.exports = /** @type {typeof import('stylelint').lint} */standalone;

    }, { "./createStylelint": 93, "./createStylelintResult": 94, "./formatters": 96, "./prepareReturnValue": 106, "./utils/allFilesIgnoredError": 321, "./utils/getFileIgnorer": 339, "./utils/getFormatterOptionsText": 340, "./utils/validateTypes": 418 }], 319: [function (require, module, exports) {
      'use strict';

      /**
       * Add an empty line after a node. Mutates the node.
       *
       * @template {import('postcss').Rule | import('postcss').AtRule} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function addEmptyLineAfter(node, newline) {
        const { raws } = node;

        if (typeof raws.after !== 'string') {
          return node;
        }

        const spaces = raws.after.split(';');
        const after = spaces[spaces.length - 1] || '';

        if (!/\r?\n/.test(after)) {
          raws.after += newline.repeat(2);
        } else {
          raws.after = raws.after.replace(/(\r?\n)/, `${newline}$1`);
        }

        return node;
      };

    }, {}], 320: [function (require, module, exports) {
      'use strict';

      /**
       * Add an empty line before a node. Mutates the node.
       *
       * @template {import('postcss').ChildNode} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function addEmptyLineBefore(node, newline) {
        const { raws } = node;

        if (typeof raws.before !== 'string') {
          return node;
        }

        raws.before = !/\r?\n/.test(raws.before) ?
        newline.repeat(2) + raws.before :
        raws.before.replace(/(\r?\n)/, `${newline}$1`);

        return node;
      };

    }, {}], 321: [function (require, module, exports) {
      'use strict';

      class AllFilesIgnoredError extends Error {
        constructor() {
          super();

          this.message = `All input files were ignored because of the ignore pattern. Either change your input, ignore pattern or use "--allow-empty-input" to allow no inputs`;
        }}


      module.exports = AllFilesIgnoredError;

    }, {}], 322: [function (require, module, exports) {
      'use strict';

      /**
       * Tests if two arrays are equal.
       *
       * @param {unknown} a
       * @param {unknown} b
       * @returns {boolean}
       */
      module.exports = function arrayEqual(a, b) {
        if (!Array.isArray(a) || !Array.isArray(b)) return false;

        if (a.length !== b.length) return false;

        return a.every((elem, index) => elem === b[index]);
      };

    }, {}], 323: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {number}
       */
      module.exports = function (atRule) {
        // Initial 1 is for the `@`
        let index = 1 + atRule.name.length;

        if (atRule.raws.afterName) {
          index += atRule.raws.afterName.length;
        }

        return index;
      };

    }, {}], 324: [function (require, module, exports) {
      'use strict';

      const { isAtRule, isRule } = require('./typeGuards');

      /**
       * @param {import('postcss').Container} statement
       * @returns {string}
       */
      module.exports = function beforeBlockString(statement, { noRawBefore } = { noRawBefore: false }) {
        let result = '';

        const before = statement.raws.before || '';

        if (!noRawBefore) {
          result += before;
        }

        if (isRule(statement)) {
          result += statement.selector;
        } else if (isAtRule(statement)) {
          result += `@${statement.name}${statement.raws.afterName || ''}${statement.params}`;
        } else {
          return '';
        }

        result += statement.raws.between || '';

        return result;
      };

    }, { "./typeGuards": 414 }], 325: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('./beforeBlockString');
      const hasBlock = require('./hasBlock');
      const rawNodeString = require('./rawNodeString');

      /**
       * Return a CSS statement's block -- the string that starts and `{` and ends with `}`.
       *
       * If the statement has no block (e.g. `@import url(foo.css);`), returns an empty string.
       *
       * @param {import('postcss').Container} statement
       * @returns {string}
       */
      module.exports = function blockString(statement) {
        if (!hasBlock(statement)) {
          return '';
        }

        return rawNodeString(statement).slice(beforeBlockString(statement).length);
      };

    }, { "./beforeBlockString": 324, "./hasBlock": 348, "./rawNodeString": 406 }], 326: [function (require, module, exports) {
      'use strict';

      /**
       * @param {string} source
       *
       * @returns {string}
       */
      module.exports = function (source, blurChar = ' ') {
        return source.replace(/[#@{}]+/g, blurChar);
      };

    }, {}], 327: [function (require, module, exports) {
      'use strict';

      const normalizeRuleSettings = require('../normalizeRuleSettings');
      const Result = require('postcss/lib/result');
      const rules = require('../rules');

      /**
       * Useful for third-party code (e.g. plugins) to run a PostCSS Root
       * against a specific rule and do something with the warnings
       * @template T
       * @template {Object} O
       * @param {{
      		ruleName: string,
      		ruleSettings: import('stylelint').ConfigRuleSettings<T, O>,
      		root: import('postcss').Root,
      	}} options
       * @param {(warning: import('postcss').Warning) => void} callback
       * @returns {void}
       */
      function checkAgainstRule(options, callback) {
        if (!options)
        throw new Error(
        "checkAgainstRule requires an options object with 'ruleName', 'ruleSettings', and 'root' properties");


        if (!callback) throw new Error('checkAgainstRule requires a callback');

        if (!options.ruleName) throw new Error("checkAgainstRule requires a 'ruleName' option");

        const rule = rules[options.ruleName];

        if (!rule) throw new Error(`Rule '${options.ruleName}' does not exist`);

        if (!options.ruleSettings) throw new Error("checkAgainstRule requires a 'ruleSettings' option");

        if (!options.root) throw new Error("checkAgainstRule requires a 'root' option");

        const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName);

        if (!settings) {
          return;
        }

        // @ts-expect-error - this error should not occur with PostCSS 8
        const tmpPostcssResult = new Result();

        rule(settings[0], /** @type {O} */settings[1], {})(options.root, tmpPostcssResult);

        for (const warning of tmpPostcssResult.warnings()) callback(warning);
      }

      module.exports = /** @type {typeof import('stylelint').utils.checkAgainstRule} */
      checkAgainstRule;


    }, { "../normalizeRuleSettings": 104, "../rules": 205, "postcss/lib/result": 80 }], 328: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').ConfigurationError} ConfigurationError */

      /**
       * Create configurationError from text and set CLI exit code
       * @param {string} text
       * @returns {ConfigurationError}
       */
      module.exports = function (text) {
        const err = /** @type {ConfigurationError} */new Error(text);

        err.code = 78;

        return err;
      };

    }, {}], 329: [function (require, module, exports) {
      'use strict';

      const { isString } = require('./validateTypes');

      /** @typedef {false | { match: string, pattern: string, substring: string }} ReturnValue */

      /**
       * Checks if a string contains a value. The comparison value can be a string or
       * an array of strings.
       *
       * Any strings starting and ending with `/` are ignored. Use the
       * matchesStringOrRegExp() util to match regexes.
       *
       * @template {unknown} T
       * @param {string} input
       * @param {T | T[]} comparison
       * @returns {ReturnValue}
       */
      module.exports = function containsString(input, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstString(input, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstString(input, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       * @param {string} value
       * @param {unknown} comparison
       * @returns {ReturnValue}
       */
      function testAgainstString(value, comparison) {
        if (!comparison) return false;

        if (!isString(comparison)) return false;

        if (comparison.startsWith('/') && comparison.endsWith('/')) {
          return false;
        }

        if (value.includes(comparison)) {
          return { match: value, pattern: comparison, substring: comparison };
        }

        return false;
      }

    }, { "./validateTypes": 418 }], 330: [function (require, module, exports) {
      'use strict';

      /**
       * Get the index of a declaration's value
       *
       * @param {import('postcss').Declaration} decl
       * @returns {number}
       */
      module.exports = function declarationValueIndex(decl) {
        const raws = decl.raws;

        return [
        // @ts-expect-error -- TS2571: Object is of type 'unknown'.
        raws.prop && raws.prop.prefix,
        // @ts-expect-error -- TS2571: Object is of type 'unknown'.
        raws.prop && raws.prop.raw || decl.prop,
        // @ts-expect-error -- TS2571: Object is of type 'unknown'.
        raws.prop && raws.prop.suffix,
        raws.between || ':',
        // @ts-expect-error -- TS2339: Property 'prefix' does not exist on type '{ value: string; raw: string; }'.
        raws.value && raws.value.prefix].
        reduce((count, str) => {
          if (str) {
            return count + str.length;
          }

          return count;
        }, 0);
      };

    }, {}], 331: [function (require, module, exports) {
      'use strict';

      const { isRoot, isAtRule, isRule } = require('./typeGuards');

      /** @typedef {import('postcss').Root} Root */
      /** @typedef {import('postcss').Root} Document */
      /** @typedef {import('postcss').Node} PostcssNode */
      /** @typedef {import('postcss').Container} PostcssContainerNode */
      /** @typedef {import('postcss').Declaration} Declaration */
      /** @typedef {(callbackFn: (decl: Declaration, index: number, decls: Declaration[]) => void) => void} EachDeclaration */

      /**
       * @param {PostcssNode} node
       * @returns {node is PostcssContainerNode}
       */
      function isContainerNode(node) {
        return isRule(node) || isAtRule(node) || isRoot(node);
      }

      /**
       * In order to accommodate nested blocks (postcss-nested),
       * we need to run a shallow loop (instead of eachDecl() or eachRule(),
       * which loop recursively) and allow each nested block to accumulate
       * its own list of properties -- so that a property in a nested rule
       * does not conflict with the same property in the parent rule
       * executes a provided function once for each declaration block.
       *
       * @param {Root | Document} root - root element of file.
       * @param {(eachDecl: EachDeclaration) => void} callback - Function to execute for each declaration block
       *
       * @returns {void}
       */
      module.exports = function eachDeclarationBlock(root, callback) {
        /**
         * @param {PostcssNode} statement
         *
         * @returns {void}
         */
        function each(statement) {
          if (!isContainerNode(statement)) return;

          if (statement.nodes && statement.nodes.length) {
            /** @type {Declaration[]} */
            const decls = [];

            for (const node of statement.nodes) {
              if (node.type === 'decl') {
                decls.push(node);
              }

              each(node);
            }

            if (decls.length) {
              callback(decls.forEach.bind(decls));
            }
          }
        }

        each(root);
      };

    }, { "./typeGuards": 414 }], 332: [function (require, module, exports) {
      'use strict';

      const getUnitFromValueNode = require('./getUnitFromValueNode');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isVariable = require('./isVariable');
      const keywordSets = require('../reference/keywordSets');
      const postcssValueParser = require('postcss-value-parser');

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       * Get the animation name within an `animation` shorthand property value.
       *
       * @param {string} value
       *
       * @returns {Node[]}
       */
      module.exports = function findAnimationName(value) {
        /** @type {Node[]} */
        const animationNames = [];

        const valueNodes = postcssValueParser(value);
        const { nodes } = valueNodes;

        // Handle `inherit`, `initial` and etc
        if (
        nodes.length === 1 &&
        nodes[0] &&
        keywordSets.basicKeywords.has(nodes[0].value.toLowerCase()))
        {
          return [nodes[0]];
        }

        valueNodes.walk(valueNode => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (valueNode.type !== 'word') {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non-standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other animation parts
          if (keywordSets.animationShorthandKeywords.has(valueLowerCase)) {
            return;
          }

          // Ignore numbers with units
          const unit = getUnitFromValueNode(valueNode);

          if (unit || unit === '') {
            return;
          }

          animationNames.push(valueNode);
        });

        return animationNames;
      };

    }, { "../reference/keywordSets": 107, "./getUnitFromValueNode": 347, "./isStandardSyntaxValue": 395, "./isVariable": 398, "postcss-value-parser": 57 }], 333: [function (require, module, exports) {
      'use strict';

      const { isAtRule, isRule } = require('./typeGuards');

      /**
       * Find the at-rule in which a rule is nested.
       *
       * Returns `null` if the rule is not nested within an at-rule.
       *
       * @param {import('postcss').Rule} rule
       * @returns {null | import('postcss').AtRule}
       */
      module.exports = function findAtRuleContext(rule) {
        const parent = rule.parent;

        if (!parent) {
          return null;
        }

        if (isAtRule(parent)) {
          return parent;
        }

        if (isRule(parent)) {
          return findAtRuleContext(parent);
        }

        return null;
      };

    }, { "./typeGuards": 414 }], 334: [function (require, module, exports) {
      'use strict';

      const postcssValueParser = require('postcss-value-parser');

      const isNumbery = require('./isNumbery');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isValidFontSize = require('./isValidFontSize');
      const isVariable = require('./isVariable');
      const { assert } = require('./validateTypes');
      const keywordSets = require('../reference/keywordSets');

      const nodeTypesToCheck = new Set(['word', 'string', 'space', 'div']);

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       *
       * @param {Node} firstNode
       * @param {Node} secondNode
       * @param {string | null} charactersBetween
       *
       * @returns {Node}
       */
      function joinValueNodes(firstNode, secondNode, charactersBetween) {
        firstNode.value = firstNode.value + charactersBetween + secondNode.value;

        return firstNode;
      }

      /**
       * Get the font-families within a `font` shorthand property value.
       *
       * @param {string} value
       * @returns {Node[]} Collection font-family nodes
       */
      module.exports = function findFontFamily(value) {
        /** @type {Node[]} */
        const fontFamilies = [];

        const valueNodes = postcssValueParser(value);
        const { nodes: children } = valueNodes;

        // Handle `inherit`, `initial` and etc
        if (
        children.length === 1 &&
        children[0] &&
        keywordSets.basicKeywords.has(children[0].value.toLowerCase()))
        {
          return [children[0]];
        }

        let needMergeNodesByValue = false;
        /** @type {string | null} */
        let mergeCharacters = null;

        valueNodes.walk((valueNode, index, nodes) => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (!nodeTypesToCheck.has(valueNode.type)) {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other font parts
          if (
          keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
          !keywordSets.fontFamilyKeywords.has(valueLowerCase))
          {
            return;
          }

          // Ignore font-sizes
          if (isValidFontSize(valueNode.value)) {
            return;
          }

          const prevNode = nodes[index - 1];
          const prevPrevNode = nodes[index - 2];

          // Ignore anything come after a <font-size>/, because it's a line-height
          if (prevNode && prevNode.value === '/' && prevPrevNode && isValidFontSize(prevPrevNode.value)) {
            return;
          }

          // Ignore number values
          if (isNumbery(valueLowerCase)) {
            return;
          }

          // Detect when a space or comma is dividing a list of font-families, and save the joining character.
          if (
          (valueNode.type === 'space' || valueNode.type === 'div' && valueNode.value !== ',') &&
          fontFamilies.length !== 0)
          {
            needMergeNodesByValue = true;
            mergeCharacters = valueNode.value;

            return;
          }

          if (valueNode.type === 'space' || valueNode.type === 'div') {
            return;
          }

          const fontFamily = valueNode;

          if (needMergeNodesByValue) {
            const lastFontFamily = fontFamilies[fontFamilies.length - 1];

            assert(lastFontFamily);
            joinValueNodes(lastFontFamily, fontFamily, mergeCharacters);
            needMergeNodesByValue = false;
            mergeCharacters = null;
          } else {
            fontFamilies.push(fontFamily);
          }
        });

        return fontFamilies;
      };

    }, { "../reference/keywordSets": 107, "./isNumbery": 375, "./isStandardSyntaxValue": 395, "./isValidFontSize": 396, "./isVariable": 398, "./validateTypes": 418, "postcss-value-parser": 57 }], 335: [function (require, module, exports) {
      'use strict';

      /**
       * Convert the specified value to an array. If an array is specified, the array is returned as-is.
       *
       * @template T
       * @param {T | T[] | undefined | null} value
       * @returns {T[] | undefined}
       */
      module.exports = function flattenArray(value) {
        if (value == null) {
          return;
        }

        return Array.isArray(value) ? value : [value];
      };

    }, {}], 336: [function (require, module, exports) {
      'use strict';

      const balancedMatch = require('balanced-match');
      const valueParser = require('postcss-value-parser');

      const { assert, isString, isRegExp } = require('./validateTypes');

      /**
       * Search a CSS string for functions by name.
       * For every match, invoke the callback, passing the function's
       * "argument(s) string" (whatever is inside the parentheses)
       * as an argument.
       *
       * Callback will be called once for every matching function found,
       * with the function's "argument(s) string" and its starting index
       * as the arguments.
       *
       * @param {string} source
       * @param {string | RegExp} functionName
       * @param {(expression: string, expressionIndex: number) => void} callback
       * @returns {void}
       */
      module.exports = function functionArgumentsSearch(source, functionName, callback) {
        valueParser(source).walk(node => {
          if (node.type !== 'function') return;

          const { value } = node;

          if (isString(functionName) && value !== functionName) return;

          if (isRegExp(functionName) && !functionName.test(node.value)) return;

          const parensMatch = balancedMatch('(', ')', source.slice(node.sourceIndex));

          assert(parensMatch);

          const expression = parensMatch.body;
          const parenLength = 1; // == '('
          const expressionIndex = node.sourceIndex + value.length + parenLength;

          callback(expression, expressionIndex);
        });
      };

    }, { "./validateTypes": 418, "balanced-match": 422, "postcss-value-parser": 57 }], 337: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {string}
       */
      module.exports = function getAtRuleParams(atRule) {
        const raws = atRule.raws;

        return raws.params && raws.params.raw || atRule.params;
      };

    }, {}], 338: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Declaration} decl
       * @returns {string}
       */
      module.exports = function getDeclarationValue(decl) {
        const raws = decl.raws;

        return raws.value && raws.value.raw || decl.value;
      };

    }, {}], 339: [function (require, module, exports) {
      'use strict';
      // Try to get file ignorer from '.stylelintignore'

      const fs = require('fs');
      const path = require('path');
      const { default: ignore } = require('ignore');

      const isPathNotFoundError = require('./isPathNotFoundError');

      const DEFAULT_IGNORE_FILENAME = '.stylelintignore';

      /**
       * @param {{ cwd: string, ignorePath?: string, ignorePattern?: string[] }} options
       * @return {import('ignore').Ignore}
       */
      module.exports = function getFileIgnorer(options) {
        const ignoreFilePath = options.ignorePath || DEFAULT_IGNORE_FILENAME;
        const absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath) ?
        ignoreFilePath :
        path.resolve(options.cwd, ignoreFilePath);
        let ignoreText = '';

        try {
          ignoreText = fs.readFileSync(absoluteIgnoreFilePath, 'utf8');
        } catch (readError) {
          if (!isPathNotFoundError(readError)) {
            throw readError;
          }
        }

        return ignore().
        add(ignoreText).
        add(options.ignorePattern || []);
      };

    }, { "./isPathNotFoundError": 377, "fs": undefined, "ignore": 14, "path": undefined }], 340: [function (require, module, exports) {
      'use strict';

      const formatters = require('../formatters');

      /**
       * @param {{ useOr?: boolean }} [options={}]
       * @returns {string}
       */
      module.exports = function getFormatterOptionsText(options = {}) {
        let output = Object.keys(formatters).
        map(name => `"${name}"`).
        join(', ');

        if (options.useOr) {
          output = output.replace(/, ([a-z"]+)$/u, ' or $1');
        }

        return output;
      };

    }, { "../formatters": 96 }], 341: [function (require, module, exports) {
      'use strict';

      /**
       * Returns a position of `!important` (or `! important` including whitespaces)
       * from the specified CSS source code. If not found, returns `undefined`.
       *
       * @param {string} source
       * @returns {{ index: number, endIndex: number } | undefined}
       */
      module.exports = function getImportantPosition(source) {
        const pattern = /!\s*important\b/gi;
        const match = pattern.exec(source);

        if (!match) return;

        return { index: match.index, endIndex: pattern.lastIndex };
      };

    }, {}], 342: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node | void} node
       */
      function getNodeLine(node) {
        return node && node.source && node.source.start && node.source.start.line;
      }

      /**
       * @param {Node | void} node
       * @returns {Node | void}
       */
      module.exports = function getNextNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        /** @type {Node | void} */
        const nextNode = node.next();

        if (!nextNode || nextNode.type !== 'comment') {
          return nextNode;
        }

        if (
        getNodeLine(node) === getNodeLine(nextNode) ||
        getNodeLine(nextNode) === getNodeLine(nextNode.next()))
        {
          return getNextNonSharedLineCommentNode(nextNode);
        }

        return nextNode;
      };

    }, {}], 343: [function (require, module, exports) {
      'use strict';

      const os = require('os');

      // This function simply provides roundabout way of getting os.EOL
      // so we can mock this for Jest tests
      function getOsEl() {
        return os.EOL;
      }

      module.exports = getOsEl;

    }, { "os": undefined }], 344: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node} node
       */
      function getNodeLine(node) {
        return node.source && node.source.start && node.source.start.line;
      }

      /**
       * @param {Node | undefined} node
       * @returns {Node | undefined}
       */
      module.exports = function getPreviousNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        const previousNode = node.prev();

        if (!previousNode || previousNode.type !== 'comment') {
          return previousNode;
        }

        if (getNodeLine(node) === getNodeLine(previousNode)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        const previousNode2 = previousNode.prev();

        if (previousNode2 && getNodeLine(previousNode) === getNodeLine(previousNode2)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        return previousNode;
      };

    }, {}], 345: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Rule} ruleNode
       * @returns {string}
       */
      module.exports = function getRuleSelector(ruleNode) {
        const raws = ruleNode.raws;

        return raws.selector && raws.selector.raw || ruleNode.selector;
      };

    }, {}], 346: [function (require, module, exports) {
      'use strict';

      const { URL } = require('url');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {string} urlString
       */
      module.exports = function (urlString) {
        let protocol = null;

        try {
          protocol = new URL(urlString).protocol;
        } catch (_unused) {
          return null;
        }

        if (protocol === null || typeof protocol === 'undefined') {
          return null;
        }

        const scheme = protocol.slice(0, -1); // strip trailing `:`

        // The URL spec does not require a scheme to be followed by `//`, but checking
        // for it allows this rule to differentiate <scheme>:<hostname> urls from
        // <hostname>:<port> urls. `data:` scheme urls are an exception to this rule.
        const slashIndex = protocol.length;
        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2);
        const isSchemeLessUrl = expectedSlashes !== '//' && scheme !== 'data';

        if (isSchemeLessUrl) {
          return null;
        }

        return scheme;
      };

    }, { "url": undefined }], 347: [function (require, module, exports) {
      'use strict';

      const blurInterpolation = require('./blurInterpolation');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const valueParser = require('postcss-value-parser');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {import('postcss-value-parser').Node} node
       *
       * @returns {string | null}
       */
      module.exports = function (node) {
        if (!node || !node.value) {
          return null;
        }

        // Ignore non-word nodes
        if (node.type !== 'word') {
          return null;
        }

        // Ignore non standard syntax
        if (!isStandardSyntaxValue(node.value)) {
          return null;
        }

        // Ignore HEX
        if (node.value.startsWith('#')) {
          return null;
        }

        // Remove non standard stuff
        const value = blurInterpolation(node.value, '')
        // ignore hack unit
        .replace('\\0', '').
        replace('\\9', '');

        const parsedUnit = valueParser.unit(value);

        if (!parsedUnit) {
          return null;
        }

        return parsedUnit.unit;
      };

    }, { "./blurInterpolation": 326, "./isStandardSyntaxValue": 395, "postcss-value-parser": 57 }], 348: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an block (empty or otherwise).
       *
       * @param {import('postcss').Container} statement
       * @return {boolean} True if `statement` has a block (empty or otherwise)
       */
      module.exports = function hasBlock(statement) {
        return statement.nodes !== undefined;
      };

    }, {}], 349: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an empty block.
       *
       * @param {import('postcss').Rule | import('postcss').AtRule} statement - postcss rule or at-rule node
       * @return {boolean} True if the statement has a block and it is empty
       */
      module.exports = function (statement) {
        return (
          statement.nodes !== undefined && statement.nodes.length === 0 // has block
        ); // and is empty
      };

    }, {}], 350: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string contains at least one empty line
       *
       * @param {string | undefined} string
       * @returns {boolean}
       */
      module.exports = function (string) {
        if (string === '' || string === undefined) return false;

        return /\n[\r\t ]*\n/.test(string);
      };

    }, {}], 351: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a string has interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has interpolation
       */
      module.exports = function (string) {
        // SCSS or Less interpolation
        if (
        hasLessInterpolation(string) ||
        hasScssInterpolation(string) ||
        hasTplInterpolation(string) ||
        hasPsvInterpolation(string))
        {
          return true;
        }

        return false;
      };

    }, { "../utils/hasLessInterpolation": 352, "../utils/hasPsvInterpolation": 353, "../utils/hasScssInterpolation": 354, "../utils/hasTplInterpolation": 355 }], 352: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has less interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has less interpolation
       */
      module.exports = function (string) {
        return /@\{.+?\}/.test(string);
      };

    }, {}], 353: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has postcss-simple-vars interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /\$\(.+?\)/.test(string);
      };

    }, {}], 354: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has scss interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /#\{.+?\}/.test(string);
      };

    }, {}], 355: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has JS template literal interpolation or HTML-like template
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has template literal interpolation
       */
      module.exports = function (string) {
        return /\{.+?\}/.test(string);
      };

    }, {}], 356: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const previousNode = node.prev();

        if (!previousNode || previousNode.type !== 'comment') {
          return false;
        }

        return !isSharedLineComment(previousNode);
      };

    }, { "./isSharedLineComment": 380 }], 357: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      function isAfterSingleLineComment(node) {
        const prevNode = node.prev();

        return (
          prevNode !== undefined &&
          prevNode.type === 'comment' &&
          !isSharedLineComment(prevNode) &&
          prevNode.source &&
          prevNode.source.start &&
          prevNode.source.end &&
          prevNode.source.start.line === prevNode.source.end.line);

      }

      module.exports = isAfterSingleLineComment;

    }, { "./isSharedLineComment": 380 }], 358: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isCustomProperty = require('./isCustomProperty');
      const isStandardSyntaxDeclaration = require('./isStandardSyntaxDeclaration');
      const { isDeclaration } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const prevNode = getPreviousNonSharedLineCommentNode(node);

        return (
          prevNode !== undefined &&
          isDeclaration(prevNode) &&
          isStandardSyntaxDeclaration(prevNode) &&
          !isCustomProperty(prevNode.prop || ''));

      };

    }, { "./getPreviousNonSharedLineCommentNode": 344, "./isCustomProperty": 367, "./isStandardSyntaxDeclaration": 386, "./typeGuards": 414 }], 359: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const hasBlock = require('./hasBlock');
      const { isAtRule } = require('./typeGuards');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (atRule.type !== 'atrule') {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        if (previousNode === undefined) {
          return false;
        }

        return isAtRule(previousNode) && !hasBlock(previousNode) && !hasBlock(atRule);
      };

    }, { "./getPreviousNonSharedLineCommentNode": 344, "./hasBlock": 348, "./typeGuards": 414 }], 360: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('./isBlocklessAtRuleAfterBlocklessAtRule');
      const { isAtRule } = require('./typeGuards');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (!isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        if (previousNode && isAtRule(previousNode)) {
          return previousNode.name === atRule.name;
        }

        return false;
      };

    }, { "./getPreviousNonSharedLineCommentNode": 344, "./isBlocklessAtRuleAfterBlocklessAtRule": 359, "./typeGuards": 414 }], 361: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a node is a context-functional pseudo-class (i.e. either a logical combination
       * or a 'aNPlusBOfSNotationPseudoClasses' / tree-structural pseudo-class)
       *
       * @param {import('postcss-selector-parser').Node} node - postcss-selector-parser node (of type pseudo)
       * @return {node is import('postcss-selector-parser').Pseudo} If `true`, the node is a context-functional pseudo-class
       */
      module.exports = function isContextFunctionalPseudoClass(node) {
        if (node.type === 'pseudo') {
          const normalisedParentName = node.value.toLowerCase().replace(/:+/, '');

          return (
            keywordSets.logicalCombinationsPseudoClasses.has(normalisedParentName) ||
            keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName));

        }

        return false;
      };

    }, { "../reference/keywordSets": 107 }], 362: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterIncrementKeywords.has(valueLowerCase) ||
        Number.isFinite(Number.parseInt(valueLowerCase, 10)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 107 }], 363: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterResetKeywords.has(valueLowerCase) ||
        Number.isFinite(Number.parseInt(valueLowerCase, 10)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 107 }], 364: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const svgTags = require('svg-tags');

      /**
       * Check whether a type selector is a custom element
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (!/^[a-z]/.test(selector)) {
          return false;
        }

        if (!selector.includes('-')) {
          return false;
        }

        const selectorLowerCase = selector.toLowerCase();

        if (selectorLowerCase !== selector) {
          return false;
        }

        if (svgTags.includes(selectorLowerCase)) {
          return false;
        }

        if (keywordSets.standardHtmlTags.has(selectorLowerCase)) {
          return false;
        }

        if (keywordSets.nonStandardHtmlTags.has(selectorLowerCase)) {
          return false;
        }

        if (mathMLTags.includes(selectorLowerCase)) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 107, "mathml-tag-names": 19, "svg-tags": 431 }], 365: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a function is custom / user-defined
       * https://github.com/w3c/css-houdini-drafts/issues/1007
       * @param {string} func
       * @returns {boolean}
       */
      module.exports = function (func) {
        return func.startsWith('--');
      };

    }, {}], 366: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media query is a custom
       * @param {string} mediaQuery
       * @returns {boolean}
       */
      module.exports = function (mediaQuery) {
        return mediaQuery.startsWith('--');
      };

    }, {}], 367: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is a custom one
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        return property.startsWith('--');
      };

    }, {}], 368: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a selector is a custom one
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        return selector.startsWith(':--');
      };

    }, {}], 369: [function (require, module, exports) {
      'use strict';

      const { isComment, hasSource } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} statement
       * @returns {boolean}
       */
      module.exports = function (statement) {
        const parentNode = statement.parent;

        if (parentNode === undefined || parentNode.type === 'root') {
          return false;
        }

        if (statement === parentNode.first) {
          return true;
        }

        /*
         * Search for the statement in the parent's nodes, ignoring comment
         * nodes on the same line as the parent's opening brace.
         */

        const parentNodes = parentNode.nodes;

        if (!parentNodes) {
          return false;
        }

        const firstNode = parentNodes[0];

        if (!firstNode) {
          return false;
        }

        if (
        !isComment(firstNode) ||
        typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n'))
        {
          return false;
        }

        if (!hasSource(firstNode) || !firstNode.source.start) {
          return false;
        }

        const openingBraceLine = firstNode.source.start.line;

        if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
          return false;
        }

        for (const [index, node] of parentNodes.entries()) {
          if (index === 0) {
            continue;
          }

          if (node === statement) {
            return true;
          }

          if (
          !isComment(node) ||
          hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine)
          {
            return false;
          }
        }

        /* istanbul ignore next: Should always return in the loop */
        return false;
      };

    }, { "./typeGuards": 414 }], 370: [function (require, module, exports) {
      'use strict';

      const { isRoot } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        if (isRoot(node)) return false;

        const parentNode = node.parent;

        if (!parentNode) {
          return false;
        }

        return isRoot(parentNode) && node === parentNode.first;
      };

    }, { "./typeGuards": 414 }], 371: [function (require, module, exports) {
      'use strict';

      const { isAtRule } = require('./typeGuards');

      /**
       * Check if a rule is a keyframe one
       *
       * @param {import('postcss').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        const parent = rule.parent;

        if (!parent) {
          return false;
        }

        return isAtRule(parent) && parent.name.toLowerCase() === 'keyframes';
      };

    }, { "./typeGuards": 414 }], 372: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a string is a keyframe selector.
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (keywordSets.keyframeSelectorKeywords.has(selector)) {
          return true;
        }

        // Percentages
        if (/^(?:\d+|\d*\.\d+)%$/.test(selector)) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 107 }], 373: [function (require, module, exports) {
      'use strict';

      const MATH_FUNCTIONS = require('../reference/mathFunctions');

      /**
       * Check whether a node is math function
       *
       * @param {import('postcss-value-parser').Node} node postcss-value-parser node
       * @return {boolean} If `true`, the node is math function
       */
      module.exports = function isMathFunction(node) {
        return node.type === 'function' && MATH_FUNCTIONS.includes(node.value.toLowerCase());
      };

    }, { "../reference/mathFunctions": 108 }], 374: [function (require, module, exports) {
      'use strict';

      /**
       * @param {unknown} value
       */
      module.exports = function isNonNegativeInteger(value) {
        return Number.isInteger(value) && typeof value === 'number' && value >= 0;
      };

    }, {}], 375: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether it's a number or a number-like string:
       * i.e. when coerced to a number it == itself.
       *
       * @param {string | number} value
       */
      module.exports = function (value) {
        /* eslint-disable eqeqeq */
        return value.toString().trim().length !== 0 && Number(value) == value;
        /* eslint-enable eqeqeq */
      };

    }, {}], 376: [function (require, module, exports) {
      'use strict';

      const isWhitespace = require('./isWhitespace');

      /**
       * Returns a Boolean indicating whether the the input string is only whitespace.
       *
       * @param {string} input
       * @returns {boolean}
       */
      module.exports = function (input) {
        let isOnlyWhitespace = true;

        for (const element of input) {
          if (!isWhitespace(element)) {
            isOnlyWhitespace = false;
            break;
          }
        }

        return isOnlyWhitespace;
      };

    }, { "./isWhitespace": 399 }], 377: [function (require, module, exports) {
      'use strict';

      const util = require('util');

      /**
       * @param {unknown} error
       * @returns {error is NodeJS.ErrnoException}
       */
      module.exports = function isPathNotFoundError(error) {
        // @ts-expect-error -- TS2339: Property 'code' does not exist on type 'Error'.
        return util.types.isNativeError(error) && error.code === 'ENOENT';
      };

    }, { "util": undefined }], 378: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature is a range context one
       *
       * @param {string} mediaFeature feature
       * @return {boolean} If `true`, media feature is a range context one
       */
      module.exports = function (mediaFeature) {
        return mediaFeature.includes('=') || mediaFeature.includes('<') || mediaFeature.includes('>');
      };

    }, {}], 379: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is SCSS variable
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))
        if (property.startsWith('$')) {
          return true;
        }

        // SCSS var within a namespace (e.g. namespace.$var: x)
        if (property.includes('.$')) {
          return true;
        }

        return false;
      };

    }, {}], 380: [function (require, module, exports) {
      'use strict';

      const getNextNonSharedLineCommentNode = require('./getNextNonSharedLineCommentNode');
      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const { isRoot, isComment } = require('./typeGuards');

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       *
       * @param {PostcssNode | void} a
       * @param {PostcssNode | void} b
       */
      function nodesShareLines(a, b) {
        const aLine = a && a.source && a.source.end && a.source.end.line;
        const bLine = b && b.source && b.source.start && b.source.start.line;

        return aLine === bLine;
      }

      /**
       * @param {PostcssNode} node
       * @returns {boolean}
       */
      module.exports = function isSharedLineComment(node) {
        if (!isComment(node)) {
          return false;
        }

        const previousNonSharedLineCommentNode = getPreviousNonSharedLineCommentNode(node);

        if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
          return true;
        }

        const nextNonSharedLineCommentNode = getNextNonSharedLineCommentNode(node);

        if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
          return true;
        }

        const parentNode = node.parent;

        // It's a first child and located on the same line as block start
        if (
        parentNode !== undefined &&
        !isRoot(parentNode) &&
        parentNode.index(node) === 0 &&
        node.raws.before !== undefined &&
        !node.raws.before.includes('\n'))
        {
          return true;
        }

        return false;
      };

    }, { "./getNextNonSharedLineCommentNode": 342, "./getPreviousNonSharedLineCommentNode": 344, "./typeGuards": 414 }], 381: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string is a single line (i.e. does not contain
       * any newline characters).
       *
       * @param {string} input
       * @return {boolean}
       */
      module.exports = function (input) {
        return !/[\n\r]/.test(input);
      };

    }, {}], 382: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a at-rule is standard
       *
       * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule postcss at-rule node
       * @return {boolean} If `true`, the declaration is standard
       */
      module.exports = function (atRule) {
        // Ignore scss `@content` inside mixins
        if (!atRule.nodes && atRule.params === '') {
          return false;
        }

        // Ignore Less mixins
        if ('mixin' in atRule && atRule.mixin) {
          return false;
        }

        // Ignore Less detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`
        if (
        'variable' in atRule && atRule.variable ||
        !atRule.nodes && atRule.raws.afterName === '' && atRule.params[0] === '(')
        {
          return false;
        }

        return true;
      };

    }, {}], 383: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxFunction = require('./isStandardSyntaxFunction');

      /**
       * Check whether a function is standard syntax color function
       *
       * @param {import('postcss-value-parser').FunctionNode} node
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxColorFunction(node) {
        if (!isStandardSyntaxFunction(node)) return false;

        // scss can accept a #hex, or $var variables and we need to check all nested fn nodes
        for (const fnNode of node.nodes) {
          if (fnNode.type === 'function') return isStandardSyntaxColorFunction(fnNode);

          if (fnNode.type === 'word' && (fnNode.value.startsWith('#') || fnNode.value.startsWith('$')))
          return false;
        }

        return true;
      };

    }, { "./isStandardSyntaxFunction": 387 }], 384: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a combinator is standard
       *
       * @param {import('postcss-selector-parser').Combinator} node postcss-selector-parser node (of type combinator)
       * @return {boolean} If `true`, the combinator is standard
       */
      module.exports = function (node) {
        // if it's not a combinator, then it's not a standard combinator
        if (node.type !== 'combinator') {
          return false;
        }

        // Ignore reference combinators like `/deep/`
        if (node.value.startsWith('/') || node.value.endsWith('/')) {
          return false;
        }

        // ignore the combinators that are the first or last node in their container
        if (node.parent !== undefined && node.parent !== null) {
          const parent = node.parent;

          if (node === parent.first) {
            return false;
          }

          if (node === parent.last) {
            return false;
          }
        }

        return true;
      };

    }, {}], 385: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Comment} comment
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxComment(comment) {
        // We check both here because the Sass parser uses `raws.inline` to indicate
        // inline comments, while the Less parser uses `inline`.
        if ('inline' in comment) return false;

        if ('inline' in comment.raws) return false;

        return true;
      };

    }, {}], 386: [function (require, module, exports) {
      'use strict';

      const isScssVariable = require('./isScssVariable');
      const { isRoot, isRule } = require('./typeGuards');

      /**
       * @param {string} [lang]
       */
      function isStandardSyntaxLang(lang) {
        return lang && (lang === 'css' || lang === 'custom-template' || lang === 'template-literal');
      }

      /**
       * Check whether a declaration is standard
       *
       * @param {import('postcss').Declaration | import('postcss-less').Declaration} decl
       */
      module.exports = function (decl) {
        const prop = decl.prop;
        const parent = decl.parent;

        // Declarations belong in a declaration block or standard CSS source
        if (
        parent &&
        isRoot(parent) &&
        parent.source &&
        !isStandardSyntaxLang(
        /** @type {import('postcss').Source & {lang?: string}} */parent.source.lang))

        {
          return false;
        }

        // SCSS var; covers map and list declarations
        if (isScssVariable(prop)) {
          return false;
        }

        // Less var (e.g. @var: x), but exclude variable interpolation (e.g. @{var})
        if (prop[0] === '@' && prop[1] !== '{') {
          return false;
        }

        // Less map declaration
        if (parent && parent.type === 'atrule' && parent.raws.afterName === ':') {
          return false;
        }

        // Less map (e.g. #my-map() { myprop: red; })
        if (
        parent &&
        isRule(parent) &&
        parent.selector &&
        parent.selector.startsWith('#') &&
        parent.selector.endsWith('()'))
        {
          return false;
        }

        // Sass nested properties (e.g. border: { style: solid; color: red; })
        if (
        parent &&
        isRule(parent) &&
        parent.selector &&
        parent.selector[parent.selector.length - 1] === ':' &&
        parent.selector.substring(0, 2) !== '--')
        {
          return false;
        }

        // Less &:extend
        if ('extend' in decl && decl.extend) {
          return false;
        }

        return true;
      };

    }, { "./isScssVariable": 379, "./typeGuards": 414 }], 387: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a function is standard
       *
       * @param {import('postcss-value-parser').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        // Function nodes without names are things in parentheses like Sass lists
        if (!node.value) {
          return false;
        }

        if (node.value.startsWith('#{')) {
          return false;
        }

        return true;
      };

    }, {}], 388: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a hex color is standard
       *
       * @param {string} hex
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxHexColor(hex) {
        // Less map usage (e.g. .myclass { color: #colors[somecolor]; })
        if (hex.includes('[')) {
          return false;
        }

        return true;
      };

    }, {}], 389: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature name is standard
       *
       * @param {string} mediaFeatureName
       * @returns {boolean}
       */
      module.exports = function (mediaFeatureName) {
        // SCSS interpolation
        if (/#\{.+?\}|\$.+/.test(mediaFeatureName)) {
          return false;
        }

        return true;
      };

    }, {}], 390: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');
      const isScssVariable = require('./isScssVariable');

      /**
       * Check whether a property is standard
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var
        if (isScssVariable(property)) {
          return false;
        }

        // Less var (e.g. @var: x)
        if (property.startsWith('@')) {
          return false;
        }

        // Less append property value with space (e.g. transform+_: scale(2))
        if (property.endsWith('+') || property.endsWith('+_')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(property)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 351, "./isScssVariable": 379 }], 391: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxSelector = require('../utils/isStandardSyntaxSelector');

      /**
       * Check whether a Node is a standard rule
       *
       * @param {import('postcss').Rule | import('postcss-less').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        if (rule.type !== 'rule') {
          return false;
        }

        // Ignore Less &:extend rule
        if ('extend' in rule && rule.extend) {
          return false;
        }

        if (!isStandardSyntaxSelector(rule.selector)) {
          return false;
        }

        return true;
      };

    }, { "../utils/isStandardSyntaxSelector": 392 }], 392: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a selector is standard
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        // SCSS or Less interpolation
        if (hasInterpolation(selector)) {
          return false;
        }

        // SCSS placeholder selectors
        if (selector.startsWith('%')) {
          return false;
        }

        // SCSS nested properties
        if (selector.endsWith(':')) {
          return false;
        }

        // Less :extend()
        if (/:extend(?:\(.*?\))?/.test(selector)) {
          return false;
        }

        // Less mixin with resolved nested selectors (e.g. .foo().bar or .foo(@a, @b)[bar])
        if (/\.[\w-]+\(.*\).+/.test(selector)) {
          return false;
        }

        // Less non-outputting mixin definition (e.g. .mixin() {})
        if (selector.endsWith(')') && !selector.includes(':')) {
          return false;
        }

        // Less Parametric mixins (e.g. .mixin(@variable: x) {})
        if (/\(@.*\)$/.test(selector)) {
          return false;
        }

        // ERB template tags
        if (selector.includes('<%') || selector.includes('%>')) {
          return false;
        }

        //  SCSS and Less comments
        if (selector.includes('//')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 351 }], 393: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a type selector is standard
       *
       * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)
       * @return {boolean} If `true`, the type selector is standard
       */
      module.exports = function (node) {
        // postcss-selector-parser includes the arguments to nth-child() functions
        // as "tags", so we need to ignore them ourselves.
        // The fake-tag's "parent" is actually a selector node, whose parent
        // should be the :nth-child pseudo node.
        if (!node.parent || !node.parent.parent) {
          return false;
        }

        const _node$parent$parent = node.parent.parent;
        const parentType = _node$parent$parent.type;
        const parentValue = _node$parent$parent.value;

        if (parentValue) {
          const normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');

          if (
          parentType === 'pseudo' && (
          keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.linguisticPseudoClasses.has(normalisedParentName) ||
          keywordSets.shadowTreePseudoElements.has(normalisedParentName)))
          {
            return false;
          }
        }

        // &-bar is a nesting selector combined with a suffix
        if (node.prev() && node.prev().type === 'nesting') {
          return false;
        }

        if (node.value.startsWith('%')) {
          return false;
        }

        // Reference combinators like `/deep/`
        if (node.value.startsWith('/') && node.value.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 107 }], 394: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a URL is standard
       *
       * @param {string} url
       * @returns {boolean}
       */
      module.exports = function (url) {
        if (url.length === 0) {
          return true;
        }

        // Sass interpolation works anywhere
        if (hasScssInterpolation(url) || hasTplInterpolation(url) || hasPsvInterpolation(url)) {
          return false;
        }

        // Inside `'` and `"` work only LESS interpolation
        if (url.startsWith(`'`) && url.endsWith(`'`) || url.startsWith(`"`) && url.endsWith(`"`)) {
          if (hasLessInterpolation(url)) {
            return false;
          }

          return true;
        }

        // Less variable works only at the beginning
        // Check is less variable, allow use '@url/some/path'
        // https://github.com/less/less.js/blob/3.x/lib/less/parser/parser.js#L547
        if (url.startsWith('@') && /^@@?[\w-]+$/.test(url)) {
          return false;
        }

        // In url without quotes scss variable can be everywhere
        // But in this case it is allowed to use only specific characters
        // Also forbidden "/" at the end of url
        if (url.includes('$') && /^[$\s\w+\-,./*'"]+$/.test(url) && !url.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasLessInterpolation": 352, "../utils/hasPsvInterpolation": 353, "../utils/hasScssInterpolation": 354, "../utils/hasTplInterpolation": 355 }], 395: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a value is standard
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        let normalizedValue = value;

        // Ignore operators before variables (example -$variable)
        if (/^[-+*/]/.test(value.charAt(0))) {
          normalizedValue = normalizedValue.slice(1);
        }

        // SCSS variable (example $variable)
        if (normalizedValue.startsWith('$')) {
          return false;
        }

        // SCSS namespace (example namespace.$variable)
        if (/^.+\.\$/.test(value)) {
          return false;
        }

        // Less variable
        if (normalizedValue.startsWith('@')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(normalizedValue)) {
          return false;
        }

        // WebExtension replacement keyword used by Chrome/Firefox
        // more information: https://developer.chrome.com/extensions/i18n
        // and https://github.com/stylelint/stylelint/issues/4707
        if (/__MSG_\S+__/.test(value)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 351 }], 396: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');
      const valueParser = require('postcss-value-parser');

      /**
       * Check if a word is a font-size value.
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        if (!word) {
          return false;
        }

        if (keywordSets.fontSizeKeywords.has(word)) {
          return true;
        }

        const numberUnit = valueParser.unit(word);

        if (!numberUnit) {
          return false;
        }

        const unit = numberUnit.unit;

        if (unit === '%') {
          return true;
        }

        if (keywordSets.lengthUnits.has(unit.toLowerCase())) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 107, "postcss-value-parser": 57 }], 397: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a value is a valid 3, 4, 6 or 8 digit hex
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        return /^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(value);
      };

    }, {}], 398: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a word is a variable i.e var(--custom-property).
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        return word.toLowerCase().startsWith('var(');
      };

    }, {}], 399: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a character is whitespace.
       *
       * @param {string} char
       * @returns {boolean}
       */
      module.exports = function (char) {
        return [' ', '\n', '\t', '\r', '\f'].includes(char);
      };

    }, {}], 400: [function (require, module, exports) {
      'use strict';

      /**
       * Compares a string to a second value that, if it fits a certain convention,
       * is converted to a regular expression before the comparison.
       * If it doesn't fit the convention, then two strings are compared.
       *
       * Any strings starting and ending with `/` are interpreted
       * as regular expressions.
       *
       * @param {string | Array<string>} input
       * @param {string | RegExp | Array<string | RegExp>} comparison
       *
       * @returns {false | {match: string, pattern: (string | RegExp), substring: string}}
       */
      module.exports = function matchesStringOrRegExp(input, comparison) {
        if (!Array.isArray(input)) {
          return testAgainstStringOrRegExpOrArray(input, comparison);
        }

        for (const inputItem of input) {
          const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       * @param {string} value
       * @param {string | RegExp | Array<string | RegExp>} comparison
       */
      function testAgainstStringOrRegExpOrArray(value, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstStringOrRegExp(value, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstStringOrRegExp(value, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      }

      /**
       * @param {string} value
       * @param {string | RegExp} comparison
       */
      function testAgainstStringOrRegExp(value, comparison) {
        // If it's a RegExp, test directly
        if (comparison instanceof RegExp) {
          const match = value.match(comparison);

          return match ? { match: value, pattern: comparison, substring: match[0] || '' } : false;
        }

        // Check if it's RegExp in a string
        const firstComparisonChar = comparison[0];
        const lastComparisonChar = comparison[comparison.length - 1];
        const secondToLastComparisonChar = comparison[comparison.length - 2];

        const comparisonIsRegex =
        firstComparisonChar === '/' && (
        lastComparisonChar === '/' ||
        secondToLastComparisonChar === '/' && lastComparisonChar === 'i');

        const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';

        // If so, create a new RegExp from it
        if (comparisonIsRegex) {
          const valueMatch = hasCaseInsensitiveFlag ?
          value.match(new RegExp(comparison.slice(1, -2), 'i')) :
          value.match(new RegExp(comparison.slice(1, -1)));

          return valueMatch ?
          { match: value, pattern: comparison, substring: valueMatch[0] || '' } :
          false;
        }

        // Otherwise, it's a string. Do a strict comparison
        return value === comparison ? { match: value, pattern: comparison, substring: value } : false;
      }

    }, {}], 401: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       * Get the next non-comment node in a PostCSS AST
       * at or after a given node.
       *
       * @param {PostcssNode | void} startNode
       * @returns {PostcssNode | null}
       */
      module.exports = function nextNonCommentNode(startNode) {
        if (!startNode || !startNode.next) return null;

        if (startNode.type === 'comment') {
          return nextNonCommentNode(startNode.next());
        }

        return startNode;
      };

    }, {}], 402: [function (require, module, exports) {
      'use strict';

      /**
       * Create a collection of Maps that serve to contextualize a given node.
       * This is useful to ensure that you only compare nodes that share a certain
       * context.
       *
       * All nodes are initially contextualized by their input source.
       * From there, you can contextualize them however you want.
       *
       * For a usage example, see `selector-no-descending-specificity`.
       */
      module.exports = function nodeContextLookup() {
        const contextMap = new Map();

        return {
          /**
           * @param {import('postcss').Node} node
           * @param {any[]} subContexts
           * @returns {Map<any, any>}
           */
          getContext(node, ...subContexts) {
            if (!node.source) throw new Error('The node source must be present');

            const nodeSource = node.source.input.from;
            const baseContext = creativeGetMap(contextMap, nodeSource);

            return subContexts.reduce((result, context) => creativeGetMap(result, context), baseContext);
          } };

      };

      /**
       * @param {Map<any, any>} someMap
       * @param {any} someThing
       */
      function creativeGetMap(someMap, someThing) {
        if (!someMap.has(someThing)) {
          someMap.set(someThing, new Map());
        }

        return someMap.get(someThing);
      }

    }, {}], 403: [function (require, module, exports) {
      'use strict';

      const matchesStringOrRegExp = require('./matchesStringOrRegExp');

      /**
       * Check if an options object's propertyName contains a user-defined string or
       * regex that matches the passed in input.
       *
       * @param {{ [x: string]: any; }} options
       * @param {string} propertyName
       * @param {unknown} input
       *
       * @returns {boolean}
       */
      module.exports = function optionsMatches(options, propertyName, input) {
        return Boolean(
        options &&
        options[propertyName] &&
        typeof input === 'string' &&
        matchesStringOrRegExp(input, options[propertyName]));

      };

    }, { "./matchesStringOrRegExp": 400 }], 404: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {string} selector
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Node} node
       * @param {(root: import('postcss-selector-parser').Root) => void} callback
       * @returns {string | undefined}
       */
      module.exports = function parseSelector(selector, result, node, callback) {
        try {
          return selectorParser(callback).processSync(selector);
        } catch (err) {
          result.warn(`Cannot parse selector (${err})`, { node, stylelintType: 'parseError' });

          return undefined;
        }
      };

    }, { "postcss-selector-parser": 27 }], 405: [function (require, module, exports) {
      'use strict';

      /**
       * If `map` already has the given `key`, returns its value. Otherwise, calls
       * `callback`, adds the result to `map` at `key`, and then returns it.
       *
       * @template K
       * @template V
       * @param {Map<K, V>} map
       * @param {K} key
       * @param {() => V} callback
       * @returns {V}
       */
      module.exports = function (map, key, callback) {
        if (map.has(key)) return (/** @type {V} */map.get(key));

        const value = callback();

        map.set(key, value);

        return value;
      };

    }, {}], 406: [function (require, module, exports) {
      'use strict';

      /**
       * Stringify PostCSS node including its raw "before" string.
       *
       * @param {import('postcss').Node} node
       *
       * @returns {string}
       */
      module.exports = function (node) {
        let result = '';

        if (node.raws.before) {
          result += node.raws.before;
        }

        result += node.toString();

        return result;
      };

    }, {}], 407: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @template {import('postcss').Rule | import('postcss').AtRule} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function removeEmptyLinesAfter(node, newline) {
        node.raws.after = node.raws.after ? node.raws.after.replace(/(\r?\n\s*\n)+/g, newline) : '';

        return node;
      };

    }, {}], 408: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @template {import('postcss').Node} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function removeEmptyLinesBefore(node, newline) {
        node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\n)+/g, newline) : '';

        return node;
      };

    }, {}], 409: [function (require, module, exports) {
      'use strict';

      /**
       * Report a problem.
       *
       * This function accounts for `disabledRanges` attached to the result.
       * That is, if the reported problem is within a disabledRange,
       * it is ignored. Otherwise, it is attached to the result as a
       * postcss warning.
       *
       * It also accounts for the rule's severity.
       *
       * You *must* pass *either* a node or a line number.
       *
       * @type {typeof import('stylelint').utils.report}
       */
      module.exports = function report(problem) {
        const { ruleName, result, message, line, node, index, endIndex, word } = problem;

        result.stylelint = result.stylelint || {
          ruleSeverities: {},
          customMessages: {},
          ruleMetadata: {} };


        // In quiet mode, mere warnings are ignored
        if (result.stylelint.quiet && result.stylelint.ruleSeverities[ruleName] !== 'error') {
          return;
        }

        const { start } = node && node.rangeBy({ index, endIndex }) || {};

        // If a line is not passed, use the node.rangeBy method to get the
        // line number that the complaint pertains to
        const startLine = line || start && start.line;

        if (!startLine) {
          throw new Error('You must pass either a node or a line number');
        }

        const { ignoreDisables } = result.stylelint.config || {};

        if (result.stylelint.disabledRanges) {
          const ranges =
          result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all || [];

          for (const range of ranges) {
            if (
            // If the problem is within a disabledRange,
            // and that disabledRange's rules include this one,
            // do not register a warning
            range.start <= startLine && (
            range.end === undefined || range.end >= startLine) && (
            !range.rules || range.rules.includes(ruleName)))
            {
              // Collect disabled warnings
              // Used to report `needlessDisables` in subsequent processing.
              const disabledWarnings =
              result.stylelint.disabledWarnings || (result.stylelint.disabledWarnings = []);

              disabledWarnings.push({
                rule: ruleName,
                line: startLine });


              if (!ignoreDisables) {
                return;
              }

              break;
            }
          }
        }

        const severity = result.stylelint.ruleSeverities && result.stylelint.ruleSeverities[ruleName];

        if (!result.stylelint.stylelintError && severity === 'error') {
          result.stylelint.stylelintError = true;
        }

        /** @type {import('stylelint').WarningOptions} */
        const warningProperties = {
          severity,
          rule: ruleName };


        if (node) {
          warningProperties.node = node;
        }

        if (problem.start) {
          warningProperties.start = problem.start;
        } else if (index) {
          warningProperties.index = index;
        }

        if (problem.end) {
          warningProperties.end = problem.end;
        } else if (endIndex) {
          warningProperties.endIndex = endIndex;
        }

        if (word) {
          warningProperties.word = word;
        }

        const warningMessage =
        result.stylelint.customMessages && result.stylelint.customMessages[ruleName] || message;

        result.warn(warningMessage, warningProperties);
      };

    }, {}], 410: [function (require, module, exports) {
      'use strict';

      /**
       * Given an object of problem messages, return another
       * that provides the same messages postfixed with the rule
       * that has been violated.
       *
       * @template {import('stylelint').RuleMessages} T
       * @template {{[K in keyof T]: T[K]}} R
       * @param {string} ruleName
       * @param {T} messages - Object whose keys are message identifiers
       *   and values are either message strings or functions that return message strings
       * @returns {R} New message object, whose messages will be marked with the rule name
       */
      function ruleMessages(ruleName, messages) {
        /** @typedef {keyof T} K */
        const newMessages = /** @type {R} */{};

        for (const [messageId, messageText] of /** @type {[K, T[K]][]} */Object.entries(messages)) {
          if (typeof messageText === 'string') {
            newMessages[messageId] = /** @type {R[K]} */`${messageText} (${ruleName})`;
          } else {
            newMessages[messageId] = /** @type {R[K]} */
            (...args) => `${messageText(...args)} (${ruleName})`;

          }
        }

        return newMessages;
      }

      module.exports = /** @type {typeof import('stylelint').utils.ruleMessages} */ruleMessages;

    }, {}], 411: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').AtRule} AtRule */

      /**
       * @param {AtRule} atRule
       * @param {string} params
       * @returns {AtRule} The atRulearation that was passed in.
       */
      module.exports = function setAtRuleParams(atRule, params) {
        const raws = atRule.raws;

        if (raws.params) {
          raws.params.raw = params;
        } else {
          atRule.params = params;
        }

        return atRule;
      };

    }, {}], 412: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Declaration} Declaration */

      /**
       * @param {Declaration} decl
       * @param {string} value
       * @returns {Declaration} The declaration that was passed in.
       */
      module.exports = function setDeclarationValue(decl, value) {
        const raws = decl.raws;

        if (raws.value) {
          raws.value.raw = value;
        } else {
          decl.value = value;
        }

        return decl;
      };

    }, {}], 413: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Rule} node
       * @param {(root: import('postcss-selector-parser').Root) => void} callback
       * @returns {string | undefined}
       */
      module.exports = function transformSelector(result, node, callback) {
        try {
          return selectorParser(callback).processSync(node, { updateSelector: true });
        } catch (_unused2) {
          result.warn('Cannot parse selector', { node, stylelintType: 'parseError' });

          return undefined;
        }
      };

    }, { "postcss-selector-parser": 27 }], 414: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */
      /** @typedef {import('postcss').Node} NodeSource */

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Root}
       */
      module.exports.isRoot = function isRoot(node) {
        return node.type === 'root';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Rule}
       */
      module.exports.isRule = function isRule(node) {
        return node.type === 'rule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').AtRule}
       */
      module.exports.isAtRule = function isAtRule(node) {
        return node.type === 'atrule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Comment}
       */
      module.exports.isComment = function isComment(node) {
        return node.type === 'comment';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Declaration}
       */
      module.exports.isDeclaration = function isDeclaration(node) {
        return node.type === 'decl';
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {node is import('postcss-value-parser').FunctionNode}
       */
      module.exports.isValueFunction = function isValueFunction(node) {
        return node.type === 'function';
      };

      /**
       * @param {Node} node
       * @returns {node is (Node & {source: NodeSource})}
       */
      module.exports.hasSource = function hasSource(node) {
        return Boolean(node.source);
      };

    }, {}], 415: [function (require, module, exports) {
      'use strict';

      const { isPlainObject } = require('./validateTypes');

      /**
       * Check whether the variable is an object and all its properties are one or more values
       * that satisfy the specified validator(s):
       *
       * @example
       * ignoreProperties = {
       *   value1: ["item11", "item12", "item13"],
       *   value2: "item2",
       * };
       * validateObjectWithArrayProps(isString)(ignoreProperties);
       * //=> true
       *
       * @typedef {(value: unknown) => boolean} Validator
       * @param {...Validator} validators
       * @returns {Validator}
       */
      module.exports = function validateObjectWithArrayProps(...validators) {
        return value => {
          if (!isPlainObject(value)) {
            return false;
          }

          return Object.values(value).
          flat().
          every(item => validators.some(v => v(item)));
        };
      };

    }, { "./validateTypes": 418 }], 416: [function (require, module, exports) {
      'use strict';

      const { isPlainObject } = require('./validateTypes');

      /**
       * Check whether the variable is an object and all its properties agree with the provided validator.
       *
       * @example
       * config = {
       *   value1: 1,
       *   value2: 2,
       *   value3: 3,
       * };
       * validateObjectWithProps(isNumber)(config);
       * //=> true
       *
       * @param {(value: unknown) => boolean} validator
       * @returns {(value: unknown) => boolean}
       */
      module.exports = validator => value => {
        if (!isPlainObject(value)) {
          return false;
        }

        return Object.values(value).every(item => {
          return validator(item);
        });
      };

    }, { "./validateTypes": 418 }], 417: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('./arrayEqual');
      const { isPlainObject } = require('./validateTypes');

      const IGNORED_OPTIONS = new Set(['severity', 'message', 'reportDisables', 'disableFix']);

      /** @typedef {import('stylelint').RuleOptions} RuleOptions */
      /** @typedef {import('stylelint').RuleOptionsPossible} Possible */
      /** @typedef {import('stylelint').RuleOptionsPossibleFunc} PossibleFunc */

      /**
       * Validate a rule's options.
       *
       * See existing rules for examples.
       *
       * @param {import('stylelint').PostcssResult} result - postcss result
       * @param {string} ruleName
       * @param {...RuleOptions} optionDescriptions - Each optionDescription can
       *   have the following properties:
       *   - `actual` (required): the actual passed option value or object.
       *   - `possible` (required): a schema representation of what values are
       *      valid for those options. `possible` should be an object if the
       *      options are an object, with corresponding keys; if the options are not an
       *      object, `possible` isn't, either. All `possible` value representations
       *      should be **arrays of either values or functions**. Values are === checked
       *      against `actual`. Functions are fed `actual` as an argument and their
       *      return value is interpreted: truthy = valid, falsy = invalid.
       *    - `optional` (optional): If this is `true`, `actual` can be undefined.
       * @return {boolean} Whether or not the options are valid (true = valid)
       */
      function validateOptions(result, ruleName, ...optionDescriptions) {
        let noErrors = true;

        for (const optionDescription of optionDescriptions) {
          validate(optionDescription, ruleName, complain);
        }

        /**
         * @param {string} message
         */
        function complain(message) {
          noErrors = false;
          result.warn(message, {
            stylelintType: 'invalidOption' });

          result.stylelint = result.stylelint || {
            disabledRanges: {},
            ruleSeverities: {},
            customMessages: {},
            ruleMetadata: {} };

          result.stylelint.stylelintError = true;
        }

        return noErrors;
      }

      /**
       * @param {RuleOptions} opts
       * @param {string} ruleName
       * @param {(message: string) => void} complain
       */
      function validate(opts, ruleName, complain) {
        const possible = opts.possible;
        const actual = opts.actual;
        const optional = opts.optional;

        if (actual === null || arrayEqual(actual, [null])) {
          return;
        }

        const nothingPossible =
        possible === undefined || Array.isArray(possible) && possible.length === 0;

        if (nothingPossible && actual === true) {
          return;
        }

        if (actual === undefined) {
          if (nothingPossible || optional) {
            return;
          }

          complain(`Expected option value for rule "${ruleName}"`);

          return;
        }

        if (nothingPossible) {
          if (optional) {
            complain(
            `Incorrect configuration for rule "${ruleName}". Rule should have "possible" values for options validation`);


            return;
          }

          complain(`Unexpected option value ${stringify(actual)} for rule "${ruleName}"`);

          return;
        }

        if (typeof possible === 'function') {
          if (!possible(actual)) {
            complain(`Invalid option ${stringify(actual)} for rule "${ruleName}"`);
          }

          return;
        }

        // If `possible` is an array instead of an object ...
        if (Array.isArray(possible)) {
          for (const a of [actual].flat()) {
            if (isValid(possible, a)) {
              continue;
            }

            complain(`Invalid option value ${stringify(a)} for rule "${ruleName}"`);
          }

          return;
        }

        // If actual is NOT an object ...
        if (!isPlainObject(actual) || typeof actual !== 'object' || actual == null) {
          complain(
          `Invalid option value ${stringify(actual)} for rule "${ruleName}": should be an object`);


          return;
        }

        for (const [optionName, optionValue] of Object.entries(actual)) {
          if (IGNORED_OPTIONS.has(optionName)) {
            continue;
          }

          const possibleValue = possible && possible[optionName];

          if (!possibleValue) {
            complain(`Invalid option name "${optionName}" for rule "${ruleName}"`);

            continue;
          }

          for (const a of [optionValue].flat()) {
            if (isValid(possibleValue, a)) {
              continue;
            }

            complain(`Invalid value ${stringify(a)} for option "${optionName}" of rule "${ruleName}"`);
          }
        }
      }

      /**
       * @param {Possible | Possible[]} possible
       * @param {unknown} actual
       * @returns {boolean}
       */
      function isValid(possible, actual) {
        for (const possibility of [possible].flat()) {
          if (typeof possibility === 'function' && possibility(actual)) {
            return true;
          }

          if (actual === possibility) {
            return true;
          }
        }

        return false;
      }

      /**
       * @param {unknown} value
       * @returns {string}
       */
      function stringify(value) {
        if (typeof value === 'string') {
          return `"${value}"`;
        }

        return `"${JSON.stringify(value)}"`;
      }

      module.exports = /** @type {typeof import('stylelint').utils.validateOptions} */validateOptions;

    }, { "./arrayEqual": 322, "./validateTypes": 418 }], 418: [function (require, module, exports) {
      'use strict';

      const { isPlainObject: _isPlainObject } = require('is-plain-object');

      /**
       * Checks if the value is a boolean or a Boolean object.
       * @param {unknown} value
       * @returns {value is boolean}
       */
      function isBoolean(value) {
        return typeof value === 'boolean' || value instanceof Boolean;
      }

      /**
       * Checks if the value is a function or a Function object.
       * @param {unknown} value
       * @returns {value is Function}
       */
      function isFunction(value) {
        return typeof value === 'function' || value instanceof Function;
      }

      /**
       * Checks if the value is *nullish*.
       * @see https://developer.mozilla.org/en-US/docs/Glossary/Nullish
       * @param {unknown} value
       * @returns {value is null | undefined}
       */
      function isNullish(value) {
        return value == null;
      }

      /**
       * Checks if the value is a number or a Number object.
       * @param {unknown} value
       * @returns {value is number}
       */
      function isNumber(value) {
        return typeof value === 'number' || value instanceof Number;
      }

      /**
       * Checks if the value is a regular expression.
       * @param {unknown} value
       * @returns {value is RegExp}
       */
      function isRegExp(value) {
        return value instanceof RegExp;
      }

      /**
       * Checks if the value is a string or a String object.
       * @param {unknown} value
       * @returns {value is string}
       */
      function isString(value) {
        return typeof value === 'string' || value instanceof String;
      }

      /**
       * Checks if the value is a plain object.
       * @param {unknown} value
       * @returns {value is Record<string, unknown>}
       */
      function isPlainObject(value) {
        return _isPlainObject(value);
      }

      /**
       * Assert that the value is truthy.
       * @param {unknown} value
       * @param {string} [message]
       * @returns {asserts value}
       */
      function assert(value, message = undefined) {
        if (message) {
          // eslint-disable-next-line no-console
          console.assert(value, message);
        } else {
          // eslint-disable-next-line no-console
          console.assert(value);
        }
      }

      /**
       * Assert that the value is a function or a Function object.
       * @param {unknown} value
       * @returns {asserts value is Function}
       */
      function assertFunction(value) {
        // eslint-disable-next-line no-console
        console.assert(isFunction(value), `"${value}" must be a function`);
      }

      /**
       * Assert that the value is a number or a Number object.
       * @param {unknown} value
       * @returns {asserts value is number}
       */
      function assertNumber(value) {
        // eslint-disable-next-line no-console
        console.assert(isNumber(value), `"${value}" must be a number`);
      }

      /**
       * Assert that the value is a string or a String object.
       * @param {unknown} value
       * @returns {asserts value is string}
       */
      function assertString(value) {
        // eslint-disable-next-line no-console
        console.assert(isString(value), `"${value}" must be a string`);
      }

      module.exports = {
        isBoolean,
        isFunction,
        isNullish,
        isNumber,
        isRegExp,
        isString,
        isPlainObject,

        assert,
        assertFunction,
        assertNumber,
        assertString };


    }, { "is-plain-object": 15 }], 419: [function (require, module, exports) {
      'use strict';

      /**
       * Contains helpers for working with vendor prefixes.
       *
       * Copied from https://github.com/postcss/postcss/commit/777c55b5d2a10605313a4972888f4f32005f5ac2
       *
       * @namespace vendor
       */
      module.exports = {
        /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} vendor prefix or empty string
         *
         * @example
         * vendor.prefix('-moz-tab-size') //=> '-moz-'
         * vendor.prefix('tab-size')      //=> ''
         */
        prefix(prop) {
          const match = prop.match(/^(-\w+-)/);

          if (match) {
            return match[0] || '';
          }

          return '';
        },

        /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} String name without vendor prefixes.
         *
         * @example
         * vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */
        unprefixed(prop) {
          return prop.replace(/^-\w+-/, '');
        } };


    }, {}], 420: [function (require, module, exports) {
      'use strict';

      const configurationError = require('./configurationError');
      const isSingleLineString = require('./isSingleLineString');
      const isWhitespace = require('./isWhitespace');
      const { assertFunction, isNullish } = require('./validateTypes');

      /**
       * @typedef {(message: string) => string} MessageFunction
       */

      /**
       * @typedef {Object} Messages
       * @property {MessageFunction} [expectedBefore]
       * @property {MessageFunction} [rejectedBefore]
       * @property {MessageFunction} [expectedAfter]
       * @property {MessageFunction} [rejectedAfter]
       * @property {MessageFunction} [expectedBeforeSingleLine]
       * @property {MessageFunction} [rejectedBeforeSingleLine]
       * @property {MessageFunction} [expectedBeforeMultiLine]
       * @property {MessageFunction} [rejectedBeforeMultiLine]
       * @property {MessageFunction} [expectedAfterSingleLine]
       * @property {MessageFunction} [rejectedAfterSingleLine]
       * @property {MessageFunction} [expectedAfterMultiLine]
       * @property {MessageFunction} [rejectedAfterMultiLine]
       */

      /**
       * @typedef {Object} WhitespaceCheckerArgs
       * @property {string} source - The source string
       * @property {number} index - The index of the character to check before
       * @property {(message: string) => void} err - If a problem is found, this callback
       *   will be invoked with the relevant warning message.
       *   Typically this callback will report() the problem.
       * @property {string} [errTarget] - If a problem is found, this string
       *   will be sent to the relevant warning message.
       * @property {string} [lineCheckStr] - Single- and multi-line checkers
       *   will use this string to determine whether they should proceed,
       *   i.e. if this string is one line only, single-line checkers will check,
       *   multi-line checkers will ignore.
       *   If none is passed, they will use `source`.
       * @property {boolean} [onlyOneChar=false] - Only check *one* character before.
       *   By default, "always-*" checks will look for the `targetWhitespace` one
       *   before and then ensure there is no whitespace two before. This option
       *   bypasses that second check.
       * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation
       *   between the `targetWhitespace` (almost definitely a newline) and the `index`.
       *   With this option, the checker will see if a newline *begins* the whitespace before
       *   the `index`.
       */

      /**
       * @typedef {(args: WhitespaceCheckerArgs) => void} WhitespaceChecker
       */

      /**
       * @typedef {{
       *   before: WhitespaceChecker,
       *   beforeAllowingIndentation: WhitespaceChecker,
       *   after: WhitespaceChecker,
       *   afterOneOnly: WhitespaceChecker,
       * }} WhitespaceCheckers
       */

      /**
       * Create a whitespaceChecker, which exposes the following functions:
       * - `before()`
       * - `beforeAllowingIndentation()`
       * - `after()`
       * - `afterOneOnly()`
       *
       * @param {"space" | "newline"} targetWhitespace - This is a keyword instead
       *   of the actual character (e.g. " ") in order to accommodate
       *   different styles of newline ("\n" vs "\r\n")
       * @param {"always" | "never" | "always-single-line" | "always-multi-line" | "never-single-line" | "never-multi-line"} expectation
       * @param {Messages} messages - An object of message functions;
       *   calling `before*()` or `after*()` and the `expectation` that is passed
       *   determines which message functions are required
       *
       * @returns {WhitespaceCheckers} The checker, with its exposed checking functions
       */
      module.exports = function whitespaceChecker(targetWhitespace, expectation, messages) {
        // Keep track of active arguments in order to avoid passing
        // too much stuff around, making signatures long and confusing.
        // This variable gets reset anytime a checking function is called.
        /** @type {WhitespaceCheckerArgs} */
        let activeArgs;

        /**
         * Check for whitespace *before* a character.
         * @type {WhitespaceChecker}
         */
        function before({
          source,
          index,
          err,
          errTarget,
          lineCheckStr,
          onlyOneChar = false,
          allowIndentation = false })
        {
          activeArgs = {
            source,
            index,
            err,
            errTarget,
            onlyOneChar,
            allowIndentation };


          switch (expectation) {
            case 'always':
              expectBefore();
              break;
            case 'never':
              rejectBefore();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * Check for whitespace *after* a character.
         * @type {WhitespaceChecker}
         */
        function after({ source, index, err, errTarget, lineCheckStr, onlyOneChar = false }) {
          activeArgs = { source, index, err, errTarget, onlyOneChar };

          switch (expectation) {
            case 'always':
              expectAfter();
              break;
            case 'never':
              rejectAfter();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * @type {WhitespaceChecker}
         */
        function beforeAllowingIndentation(obj) {
          before(_extends({}, obj, { allowIndentation: true }));
        }

        function expectBefore(messageFunc = messages.expectedBefore) {
          if (activeArgs.allowIndentation) {
            expectBeforeAllowingIndentation(messageFunc);

            return;
          }

          const _activeArgs = activeArgs;
          const source = _activeArgs.source;
          const index = _activeArgs.index;

          const oneCharBefore = source[index - 1];
          const twoCharsBefore = source[index - 2];

          if (isNullish(oneCharBefore)) {
            return;
          }

          if (
          targetWhitespace === 'space' &&
          oneCharBefore === ' ' && (
          activeArgs.onlyOneChar || isNullish(twoCharsBefore) || !isWhitespace(twoCharsBefore)))
          {
            return;
          }

          assertFunction(messageFunc);
          activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
        }

        function expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {
          const _activeArgs2 = activeArgs;
          const source = _activeArgs2.source;
          const index = _activeArgs2.index;
          const err = _activeArgs2.err;

          const expectedChar = targetWhitespace === 'newline' ? '\n' : undefined;
          let i = index - 1;

          while (source[i] !== expectedChar) {
            if (source[i] === '\t' || source[i] === ' ') {
              i--;
              continue;
            }

            assertFunction(messageFunc);
            err(messageFunc(activeArgs.errTarget || source.charAt(index)));

            return;
          }
        }

        function rejectBefore(messageFunc = messages.rejectedBefore) {
          const _activeArgs3 = activeArgs;
          const source = _activeArgs3.source;
          const index = _activeArgs3.index;

          const oneCharBefore = source[index - 1];

          if (!isNullish(oneCharBefore) && isWhitespace(oneCharBefore)) {
            assertFunction(messageFunc);
            activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
          }
        }

        /**
         * @type {WhitespaceChecker}
         */
        function afterOneOnly(obj) {
          after(_extends({}, obj, { onlyOneChar: true }));
        }

        function expectAfter(messageFunc = messages.expectedAfter) {
          const _activeArgs4 = activeArgs;
          const source = _activeArgs4.source;
          const index = _activeArgs4.index;

          const oneCharAfter = source[index + 1];
          const twoCharsAfter = source[index + 2];
          const threeCharsAfter = source[index + 3];

          if (isNullish(oneCharAfter)) {
            return;
          }

          if (targetWhitespace === 'newline') {
            // If index is followed by a Windows CR-LF ...
            if (
            oneCharAfter === '\r' &&
            twoCharsAfter === '\n' && (
            activeArgs.onlyOneChar || isNullish(threeCharsAfter) || !isWhitespace(threeCharsAfter)))
            {
              return;
            }

            // If index is followed by a Unix LF ...
            if (
            oneCharAfter === '\n' && (
            activeArgs.onlyOneChar || isNullish(twoCharsAfter) || !isWhitespace(twoCharsAfter)))
            {
              return;
            }
          }

          if (
          targetWhitespace === 'space' &&
          oneCharAfter === ' ' && (
          activeArgs.onlyOneChar || isNullish(twoCharsAfter) || !isWhitespace(twoCharsAfter)))
          {
            return;
          }

          assertFunction(messageFunc);
          activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
        }

        function rejectAfter(messageFunc = messages.rejectedAfter) {
          const _activeArgs5 = activeArgs;
          const source = _activeArgs5.source;
          const index = _activeArgs5.index;

          const oneCharAfter = source[index + 1];

          if (!isNullish(oneCharAfter) && isWhitespace(oneCharAfter)) {
            assertFunction(messageFunc);
            activeArgs.err(messageFunc(activeArgs.errTarget || source.charAt(index)));
          }
        }

        return {
          before,
          beforeAllowingIndentation,
          after,
          afterOneOnly };

      };

    }, { "./configurationError": 328, "./isSingleLineString": 381, "./isWhitespace": 399, "./validateTypes": 418 }], 421: [function (require, module, exports) {
      'use strict';

      const validateOptions = require('./utils/validateOptions');
      const { isRegExp, isString } = require('./utils/validateTypes');

      /**
       * @typedef {import('stylelint').PostcssResult} PostcssResult
       * @typedef {import('stylelint').DisableOptions} DisableOptions
       * @typedef {import('stylelint').DisablePropertyName} DisablePropertyName
       * @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult
       */

      /**
       * Validates that the stylelint config for `result` has a valid disable field
       * named `field`, and returns the result in normalized form as well as a
       * `StylelintPostcssResult` for convenience.
       *
       * Returns `null` if no disables should be reported, and automatically reports
       * an invalid configuration. If this returns non-`null`, it guarantees that
       * `result._postcssResult` is defined as well.
       *
       * @param {PostcssResult | undefined} result
       * @param {DisablePropertyName} field
       * @return {[boolean, Required<DisableOptions>, StylelintPostcssResult] | null}
       */
      module.exports = function (result, field) {
        // Files with `CssSyntaxError`s don't have `_postcssResult`s.
        if (!result) return null;

        const stylelintResult = result.stylelint;

        // Files with linting errors may not have configs associated with them.
        if (!stylelintResult.config) return null;

        const rawSettings = stylelintResult.config[field];

        /** @type {boolean} */
        let enabled;
        /** @type {DisableOptions} */
        let options;

        if (Array.isArray(rawSettings)) {
          enabled = rawSettings[0];
          options = rawSettings[1] || {};
        } else {
          enabled = rawSettings || false;
          options = {};
        }

        const validOptions = validateOptions(
        result,
        field,
        {
          actual: enabled,
          possible: [true, false] },

        {
          actual: options,
          possible: {
            except: [isString, isRegExp] } });




        if (!validOptions) return null;

        // If the check is disabled with no exceptions, there's no reason to run
        // it at all.
        if (!enabled && !options.except) return null;

        return [
        enabled,
        {
          except: options.except || [],
          severity: options.severity || stylelintResult.config.defaultSeverity || 'error' },

        stylelintResult];

      };

    }, { "./utils/validateOptions": 417, "./utils/validateTypes": 418 }], 422: [function (require, module, exports) {
      'use strict';
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);

        const r = range(a, b, str);

        return (
          r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length) });


      }

      function maybeMatch(reg, str) {
        const m = str.match(reg);
        return m ? m[0] : null;
      }

      balanced.range = range;
      function range(a, b, str) {
        let begs, beg, left, right, result;
        let ai = str.indexOf(a);
        let bi = str.indexOf(b, ai + 1);
        let i = ai;

        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;

          while (i >= 0 && !result) {
            if (i === ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length === 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }

              bi = str.indexOf(b, i + 1);
            }

            i = ai < bi && ai >= 0 ? ai : bi;
          }

          if (begs.length) {
            result = [left, right];
          }
        }

        return result;
      }

    }, {}], 423: [function (require, module, exports) {
      let stringify = require('./stringify');
      let parse = require('./parse');

      module.exports = { stringify, parse };

    }, { "./parse": 425, "./stringify": 429 }], 424: [function (require, module, exports) {
      module.exports = function liner(tokens) {
        let line = [];
        let result = [line];
        let brackets = 0;
        for (let token of tokens) {
          line.push(token);
          if (token[0] === '(') {
            brackets += 1;
          } else if (token[0] === ')') {
            brackets -= 1;
          } else if (token[0] === 'newline' && brackets === 0) {
            line = [];
            result.push(line);
          }
        }
        return result;
      };

    }, {}], 425: [function (require, module, exports) {
      let { Input } = require('postcss');

      let preprocess = require('./preprocess');
      let tokenizer = require('./tokenize');
      let Parser = require('./parser');
      let liner = require('./liner');

      module.exports = function parse(source, opts) {
        let input = new Input(source, opts);

        let parser = new Parser(input);
        parser.tokens = tokenizer(input);
        parser.parts = preprocess(input, liner(parser.tokens));
        parser.loop();

        return parser.root;
      };

    }, { "./liner": 424, "./parser": 426, "./preprocess": 427, "./tokenize": 430, "postcss": 77 }], 426: [function (require, module, exports) {
      let { Declaration, Comment, AtRule, Rule, Root } = require('postcss');

      module.exports = class Parser {
        constructor(input) {
          this.input = input;

          this.pos = 0;
          this.root = new Root();
          this.current = this.root;
          this.spaces = '';

          this.extraIndent = false;
          this.prevIndent = undefined;
          this.step = undefined;

          this.root.source = { input, start: { line: 1, column: 1 } };
        }

        loop() {
          let part;
          while (this.pos < this.parts.length) {
            part = this.parts[this.pos];

            if (part.comment) {
              this.comment(part);
            } else if (part.atrule) {
              this.atrule(part);
            } else if (part.colon) {
              let next = this.nextNonComment(this.pos);

              if (next.end || next.atrule) {
                this.decl(part);
              } else {
                let moreIndent = next.indent.length > part.indent.length;
                if (!moreIndent) {
                  this.decl(part);
                } else if (moreIndent && next.colon) {
                  this.rule(part);
                } else if (moreIndent && !next.colon) {
                  this.decl(part);
                }
              }
            } else if (part.end) {
              this.root.raws.after = part.before;
            } else {
              this.rule(part);
            }

            this.pos += 1;
          }

          for (let i = this.tokens.length - 1; i >= 0; i--) {
            if (this.tokens[i].length > 3) {
              let last = this.tokens[i];
              this.root.source.end = {
                line: last[4] || last[2],
                column: last[5] || last[3] };

              break;
            }
          }
        }

        comment(part) {
          let token = part.tokens[0];
          let node = new Comment();
          this.init(node, part);
          node.source.end = { line: token[4], column: token[5] };
          this.commentText(node, token);
        }

        atrule(part) {
          let atword = part.tokens[0];
          let params = part.tokens.slice(1);

          let node = new AtRule();
          node.name = atword[1].slice(1);
          this.init(node, part);

          if (node.name === '') this.unnamedAtrule(atword);

          while (!part.end && part.lastComma) {
            this.pos += 1;
            part = this.parts[this.pos];
            params.push(['space', part.before + part.indent]);
            params = params.concat(part.tokens);
          }

          node.raws.afterName = this.firstSpaces(params);
          this.keepTrailingSpace(node, params);
          this.checkSemicolon(params);
          this.checkCurly(params);
          this.raw(node, 'params', params, atword);
        }

        decl(part) {
          let node = new Declaration();
          this.init(node, part);

          let between = '';
          let colon = 0;
          let value = [];
          let prop = '';
          for (let i = 0; i < part.tokens.length; i++) {
            let token = part.tokens[i];
            if (token[0] === ':') {
              between += token[1];
              colon = token;
              value = part.tokens.slice(i + 1);
              break;
            } else if (token[0] === 'comment' || token[0] === 'space') {
              between += token[1];
            } else if (between !== '') {
              this.badProp(token);
            } else {
              prop += token[1];
            }
          }

          if (prop === '') this.unnamedDecl(part.tokens[0]);
          node.prop = prop;

          let next = this.parts[this.pos + 1];

          while (
          !next.end &&
          !next.atrule &&
          !next.colon &&
          next.indent.length > part.indent.length)
          {
            value.push(['space', next.before + next.indent]);
            value = value.concat(next.tokens);
            this.pos += 1;
            next = this.parts[this.pos + 1];
          }

          let last = value[value.length - 1];
          if (last && last[0] === 'comment') {
            value.pop();
            let comment = new Comment();
            this.current.push(comment);
            comment.source = {
              input: this.input,
              start: { line: last[2], column: last[3] },
              end: { line: last[4], column: last[5] } };

            let prev = value[value.length - 1];
            if (prev && prev[0] === 'space') {
              value.pop();
              comment.raws.before = prev[1];
            }
            this.commentText(comment, last);
          }

          for (let i = value.length - 1; i > 0; i--) {
            let t = value[i][0];
            if (t === 'word' && value[i][1] === '!important') {
              node.important = true;
              if (i > 0 && value[i - 1][0] === 'space') {
                node.raws.important = value[i - 1][1] + '!important';
                value.splice(i - 1, 2);
              } else {
                node.raws.important = '!important';
                value.splice(i, 1);
              }
              break;
            } else if (t !== 'space' && t !== 'newline' && t !== 'comment') {
              break;
            }
          }

          node.raws.between = between + this.firstSpaces(value);
          this.checkSemicolon(value);
          this.raw(node, 'value', value, colon);
        }

        rule(part) {
          let node = new Rule();
          this.init(node, part);

          let selector = part.tokens;
          let next = this.parts[this.pos + 1];

          while (!next.end && next.indent.length === part.indent.length) {
            selector.push(['space', next.before + next.indent]);
            selector = selector.concat(next.tokens);
            this.pos += 1;
            next = this.parts[this.pos + 1];
          }

          this.keepTrailingSpace(node, selector);
          this.checkCurly(selector);
          this.raw(node, 'selector', selector);
        }

        /* Helpers */

        indent(part) {
          let indent = part.indent.length;
          let isPrev = typeof this.prevIndent !== 'undefined';

          if (!isPrev && indent) this.indentedFirstLine(part);

          if (!this.step && indent) {
            this.step = indent;
            this.root.raws.indent = part.indent;
          }

          if (isPrev && this.prevIndent !== indent) {
            let diff = indent - this.prevIndent;
            if (diff > 0) {
              if (diff !== this.step) {
                this.wrongIndent(this.prevIndent + this.step, indent, part);
              } else if (this.current.last.push) {
                this.current = this.current.last;
              } else {
                this.extraIndent = '';
                for (let i = 0; i < diff; i++) {
                  this.extraIndent += ' ';
                }
              }
            } else if (diff % this.step !== 0) {
              let m = indent + diff % this.step;
              this.wrongIndent(`${m} or ${m + this.step}`, indent, part);
            } else {
              for (let i = 0; i < -diff / this.step; i++) {
                this.current = this.current.parent;
              }
            }
          }

          this.prevIndent = indent;
        }

        init(node, part) {
          this.indent(part);

          if (!this.current.nodes) this.current.nodes = [];
          this.current.push(node);

          node.raws.before = part.before + part.indent;
          if (this.extraIndent) {
            node.raws.extraIndent = this.extraIndent;
            this.extraIndent = false;
          }
          node.source = {
            start: { line: part.tokens[0][2], column: part.tokens[0][3] },
            input: this.input };

        }

        checkCurly(tokens) {
          for (let token of tokens) {
            if (token[0] === '{') {
              this.error('Unnecessary curly bracket', token[2], token[3]);
            }
          }
        }

        checkSemicolon(tokens) {
          for (let token of tokens) {
            if (token[0] === ';') {
              this.error('Unnecessary semicolon', token[2], token[3]);
            }
          }
        }

        keepTrailingSpace(node, tokens) {
          let lastSpace = tokens[tokens.length - 1];
          if (lastSpace && lastSpace[0] === 'space') {
            tokens.pop();
            node.raws.sssBetween = lastSpace[1];
          }
        }

        firstSpaces(tokens) {
          let result = '';
          for (let i = 0; i < tokens.length; i++) {
            if (tokens[i][0] === 'space' || tokens[i][0] === 'newline') {
              result += tokens.shift()[1];
              i -= 1;
            } else {
              break;
            }
          }
          return result;
        }

        raw(node, prop, tokens, altLast) {
          let token, type;
          let length = tokens.length;
          let value = '';
          let clean = true;
          for (let i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
              clean = false;
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let sss = tokens.reduce((all, i) => all + i[1], '');
            let raw = tokens.reduce((all, i) => {
              if (i[0] === 'comment' && i[6] === 'inline') {
                return all + '/* ' + i[1].slice(2).trim() + ' */';
              } else {
                return all + i[1];
              }
            }, '');
            node.raws[prop] = { value, raw };
            if (sss !== raw) node.raws[prop].sss = sss;
          }
          node[prop] = value;

          let last;
          for (let i = tokens.length - 1; i >= 0; i--) {
            if (tokens[i].length > 2) {
              last = tokens[i];
              break;
            }
          }
          if (!last) last = altLast;

          node.source.end = {
            line: last[4] || last[2],
            column: last[5] || last[3] };

        }

        nextNonComment(pos) {
          let next = pos;
          let part;
          while (next < this.parts.length) {
            next += 1;
            part = this.parts[next];
            if (part.end || !part.comment) break;
          }
          return part;
        }

        commentText(node, token) {
          let text = token[1];
          if (token[6] === 'inline') {
            node.raws.inline = true;
            text = text.slice(2);
          } else {
            text = text.slice(2, -2);
          }

          let match = text.match(/^(\s*)([^]*\S)(\s*)\n?$/);
          if (match) {
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.inlineRight = match[3];
          } else {
            node.text = '';
            node.raws.left = '';
            node.raws.inlineRight = '';
          }
        }

        // Errors

        error(msg, line, column) {
          throw this.input.error(msg, line, column);
        }

        unnamedAtrule(token) {
          this.error('At-rule without name', token[2], token[3]);
        }

        unnamedDecl(token) {
          this.error('Declaration without name', token[2], token[3]);
        }

        indentedFirstLine(part) {
          this.error('First line should not have indent', part.number, 1);
        }

        wrongIndent(expected, real, part) {
          let msg = `Expected ${expected} indent, but get ${real}`;
          this.error(msg, part.number, 1);
        }

        badProp(token) {
          this.error('Unexpected separator in property', token[2], token[3]);
        }};


    }, { "postcss": 77 }], 427: [function (require, module, exports) {
      function indentError(input, l, p) {
        throw input.error('Mixed tabs and spaces are not allowed', l, p + 1);
      }

      module.exports = function preprocess(input, lines) {
        let indentType;
        let prevNumber = 0;
        let parts = lines.map(line => {
          let lastComma = false;
          let comment = false;
          let number = prevNumber + 1;
          let atrule = false;
          let indent = '';
          let tokens = [];
          let colon = false;

          if (line.length > 0) {
            if (line[0][0] === 'space') {
              indent = line[0][1];
              tokens = line.slice(1);
            } else {
              indent = '';
              tokens = line;
            }

            if (!indentType && indent.length) {
              indentType = indent[0] === ' ' ? 'space' : 'tab';
            }
            if (indentType === 'space') {
              if (indent.includes('\t')) {
                indentError(input, number, indent.indexOf('\t'));
              }
            } else if (indentType === 'tab') {
              if (indent.includes(' ')) {
                indentError(input, number, indent.indexOf(' '));
              }
            }

            if (tokens.length) {
              for (let i = tokens.length - 1; i >= 0; i--) {
                let type = tokens[i][0];
                if (type === ',') {
                  lastComma = true;
                  break;
                } else if (type === 'space') {
                  continue;
                } else if (type === 'comment') {
                  continue;
                } else if (type === 'newline') {
                  continue;
                } else {
                  break;
                }
              }
              comment = tokens[0][0] === 'comment';
              atrule = tokens[0][0] === 'at-word';

              let brackets = 0;
              for (let i = 0; i < tokens.length - 1; i++) {
                let type = tokens[i][0];
                let next = tokens[i + 1][0];
                if (type === '(') {
                  brackets += 1;
                } else if (type === ')') {
                  brackets -= 1;
                } else if (
                type === ':' &&
                brackets === 0 && (
                next === 'space' || next === 'newline'))
                {
                  colon = true;
                }
              }
            }

            let last = tokens[tokens.length - 1];
            if (last && last[0] === 'newline') prevNumber = last[2];
          }

          return {
            number,
            indent,
            colon,
            tokens,
            atrule,
            comment,
            lastComma,
            before: '' };

        });

        parts = parts.reduceRight(
        (all, i) => {
          if (!i.tokens.length || i.tokens.every(j => j[0] === 'newline')) {
            let prev = all[0];
            let before = i.indent + i.tokens.map(j => j[1]).join('');
            prev.before = before + prev.before;
          } else {
            all.unshift(i);
          }
          return all;
        },
        [{ end: true, before: '' }]);


        parts.forEach((part, i) => {
          if (i === 0) return;

          let prev = parts[i - 1];
          let last = prev.tokens[prev.tokens.length - 1];
          if (last && last[0] === 'newline') {
            part.before = last[1] + part.before;
            prev.tokens.pop();
          }
        });

        return parts;
      };

    }, {}], 428: [function (require, module, exports) {
      const DEFAULT_RAWS = {
        colon: ': ',
        indent: '  ',
        commentLeft: ' ',
        commentRight: ' ' };


      module.exports = class Stringifier {
        constructor(builder) {
          this.builder = builder;
        }

        stringify(node, semicolon) {
          this[node.type](node, semicolon);
        }

        root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        }

        comment(node) {
          let left = DEFAULT_RAWS.commentLeft;
          let right = DEFAULT_RAWS.commentRight;
          if (this.has(node.raws.left)) left = node.raws.left;

          if (node.raws.inline) {
            if (this.has(node.raws.inlineRight)) {
              right = node.raws.inlineRight;
            } else {
              right = '';
            }
            if (node.raws.extraIndent) {
              this.builder(node.raws.extraIndent);
            }
            this.builder('//' + left + node.text + right, node);
          } else {
            if (this.has(node.raws.right)) right = node.raws.right;
            this.builder('/*' + left + node.text + right + '*/', node);
          }
        }

        decl(node) {
          let between = node.raws.between || DEFAULT_RAWS.colon;
          let string = node.prop + between + this.rawValue(node, 'value');

          if (node.important) {
            string += node.raws.important || ' !important';
          }

          this.builder(string, node);
        }

        rule(node) {
          this.block(node, this.rawValue(node, 'selector'));
        }

        atrule(node) {
          let name = '@' + node.name;
          let params = node.params ? this.rawValue(node, 'params') : '';

          if (this.has(node.raws.afterName)) {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          this.block(node, name + params);
        }

        body(node) {
          let indent = node.root().raws.indent || DEFAULT_RAWS.indent;

          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            let before =
            child.raws.before.replace(/[^\n]*$/, '') + this.indent(node, indent);
            if (child.type === 'comment' && !child.raws.before.includes('\n')) {
              before = child.raws.before;
            }
            if (before) this.builder(before);
            this.stringify(child);
          }
        }

        block(node, start) {
          let between = node.raws.sssBetween || '';
          this.builder(start + between, node, 'start');
          if (this.has(node.nodes)) this.body(node);
        }

        indent(node, step) {
          let result = '';
          while (node.parent) {
            result += step;
            node = node.parent;
          }
          return result;
        }

        has(value) {
          return typeof value !== 'undefined';
        }

        rawValue(node, prop) {
          let value = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.sss || raw.raw;
          } else {
            return value;
          }
        }};


    }, {}], 429: [function (require, module, exports) {
      let Stringifier = require('./stringifier');

      module.exports = function stringify(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      };

    }, { "./stringifier": 428 }], 430: [function (require, module, exports) {
      const SINGLE_QUOTE = "'".charCodeAt(0);
      const DOUBLE_QUOTE = '"'.charCodeAt(0);
      const BACKSLASH = '\\'.charCodeAt(0);
      const SLASH = '/'.charCodeAt(0);
      const NEWLINE = '\n'.charCodeAt(0);
      const SPACE = ' '.charCodeAt(0);
      const FEED = '\f'.charCodeAt(0);
      const TAB = '\t'.charCodeAt(0);
      const CR = '\r'.charCodeAt(0);
      const OPEN_PARENTHESES = '('.charCodeAt(0);
      const CLOSE_PARENTHESES = ')'.charCodeAt(0);
      const OPEN_CURLY = '{'.charCodeAt(0);
      const CLOSE_CURLY = '}'.charCodeAt(0);
      const SEMICOLON = ';'.charCodeAt(0);
      const ASTERICK = '*'.charCodeAt(0);
      const COLON = ':'.charCodeAt(0);
      const AT = '@'.charCodeAt(0);
      const COMMA = ','.charCodeAt(0);

      const RE_AT_END = /[\t\n\f\r "'()/;\\{]/g;
      const RE_NEW_LINE = /[\n\f\r]/g;
      const RE_WORD_END = /[\t\n\f\r !"'(),:;@\\{}]|\/(?=\*)/g;
      const RE_BAD_BRACKET = /.[\n"'(/\\]/;

      module.exports = function tokenize(input) {
        let tokens = [];
        let css = input.css.valueOf();

        let code,
        next,
        quote,
        lines,
        last,
        content,
        escape,
        nextLine,
        nextOffset,
        escaped,
        escapePos,
        prev,
        n;

        let length = css.length;
        let offset = -1;
        let line = 1;
        let pos = 0;

        function unclosed(what) {
          throw input.error('Unclosed ' + what, line, pos - offset);
        }

        while (pos < length) {
          code = css.charCodeAt(pos);

          if (
          code === NEWLINE ||
          code === FEED ||
          code === CR && css.charCodeAt(pos + 1) !== NEWLINE)
          {
            offset = pos;
            line += 1;
          }

          switch (code) {
            case CR:
              if (css.charCodeAt(pos + 1) === NEWLINE) {
                offset = pos;
                line += 1;
                pos += 1;
                tokens.push(['newline', '\r\n', line - 1]);
              } else {
                tokens.push(['newline', '\r', line - 1]);
              }
              break;

            case FEED:
            case NEWLINE:
              tokens.push(['newline', css.slice(pos, pos + 1), line - 1]);
              break;

            case SPACE:
            case TAB:
              next = pos;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === SPACE || code === TAB);

              tokens.push(['space', css.slice(pos, next)]);
              pos = next - 1;
              break;

            case OPEN_CURLY:
              tokens.push(['{', '{', line, pos - offset]);
              break;

            case CLOSE_CURLY:
              tokens.push(['}', '}', line, pos - offset]);
              break;

            case COLON:
              tokens.push([':', ':', line, pos - offset]);
              break;

            case SEMICOLON:
              tokens.push([';', ';', line, pos - offset]);
              break;

            case COMMA:
              tokens.push([',', ',', line, pos - offset]);
              break;

            case OPEN_PARENTHESES:
              prev = tokens.length ? tokens[tokens.length - 1][1] : '';
              n = css.charCodeAt(pos + 1);
              if (
              prev === 'url' &&
              n !== SINGLE_QUOTE &&
              n !== DOUBLE_QUOTE &&
              n !== SPACE &&
              n !== NEWLINE &&
              n !== TAB &&
              n !== FEED &&
              n !== CR)
              {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(')', next + 1);
                  if (next === -1) unclosed('bracket');
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);

                tokens.push([
                'brackets',
                css.slice(pos, next + 1),
                line,
                pos - offset,
                line,
                next - offset]);

                pos = next;
              } else {
                next = css.indexOf(')', pos + 1);
                content = css.slice(pos, next + 1);

                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  tokens.push(['(', '(', line, pos - offset]);
                } else {
                  tokens.push([
                  'brackets',
                  content,
                  line,
                  pos - offset,
                  line,
                  next - offset]);

                  pos = next;
                }
              }

              break;

            case CLOSE_PARENTHESES:
              tokens.push([')', ')', line, pos - offset]);
              break;

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) unclosed('quote');
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              content = css.slice(pos, next + 1);
              lines = content.split('\n');
              last = lines.length - 1;

              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }

              tokens.push([
              'string',
              css.slice(pos, next + 1),
              line,
              pos - offset,
              nextLine,
              next - nextOffset]);


              offset = nextOffset;
              line = nextLine;
              pos = next;
              break;

            case AT:
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              tokens.push([
              'at-word',
              css.slice(pos, next + 1),
              line,
              pos - offset,
              line,
              next - offset]);

              pos = next;
              break;

            case BACKSLASH:
              next = pos;
              escape = true;

              nextLine = line;

              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape = !escape;
              }
              code = css.charCodeAt(next + 1);
              if (escape) {
                if (code === CR && css.charCodeAt(next + 2) === NEWLINE) {
                  next += 2;
                  nextLine += 1;
                  nextOffset = next;
                } else if (code === CR || code === NEWLINE || code === FEED) {
                  next += 1;
                  nextLine += 1;
                  nextOffset = next;
                } else {
                  next += 1;
                }
              }
              tokens.push([
              'word',
              css.slice(pos, next + 1),
              line,
              pos - offset,
              line,
              next - offset]);

              if (nextLine !== line) {
                line = nextLine;
                offset = nextOffset;
              }
              pos = next;
              break;

            default:
              n = css.charCodeAt(pos + 1);

              if (code === SLASH && n === ASTERICK) {
                next = css.indexOf('*/', pos + 2) + 1;
                if (next === 0) unclosed('comment');

                content = css.slice(pos, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                tokens.push([
                'comment',
                content,
                line,
                pos - offset,
                nextLine,
                next - nextOffset]);


                offset = nextOffset;
                line = nextLine;
                pos = next;
              } else if (code === SLASH && n === SLASH) {
                RE_NEW_LINE.lastIndex = pos + 1;
                RE_NEW_LINE.test(css);
                if (RE_NEW_LINE.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_NEW_LINE.lastIndex - 2;
                }

                content = css.slice(pos, next + 1);

                tokens.push([
                'comment',
                content,
                line,
                pos - offset,
                line,
                next - offset,
                'inline']);


                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }

                tokens.push([
                'word',
                css.slice(pos, next + 1),
                line,
                pos - offset,
                line,
                next - offset]);

                pos = next;
              }

              break;}


          pos++;
        }

        return tokens;
      };

    }, {}], 431: [function (require, module, exports) {
      module.exports = require('./svg-tags.json');
    }, { "./svg-tags.json": 432 }], 432: [function (require, module, exports) {
      module.exports = [
      "a",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern"];

    }, {}], 433: [function (require, module, exports) {

      /**
       * Module exports.
       */

      module.exports = deprecate;

      /**
       * Mark that a method should not be used.
       * Returns a modified function which warns once by default.
       *
       * If `localStorage.noDeprecation = true` is set, then it is a no-op.
       *
       * If `localStorage.throwDeprecation = true` is set, then deprecated functions
       * will throw an Error when invoked.
       *
       * If `localStorage.traceDeprecation = true` is set, then deprecated functions
       * will invoke `console.trace()` instead of `console.error()`.
       *
       * @param {Function} fn - the function to deprecate
       * @param {String} msg - the string to print to the console when `fn` is invoked
       * @returns {Function} a new "deprecated" version of `fn`
       * @api public
       */

      function deprecate(fn, msg) {
        if (config('noDeprecation')) {
          return fn;
        }

        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config('throwDeprecation')) {
              throw new Error(msg);
            } else if (config('traceDeprecation')) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }

        return deprecated;
      }

      /**
       * Checks `localStorage` for boolean values for the given `name`.
       *
       * @param {String} name
       * @returns {Boolean}
       * @api private
       */

      function config(name) {
        // accessing global.localStorage can trigger a DOMException in sandboxed iframes
        try {
          if (!global.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === 'true';
      }

    }, {}], "stylelint": [function (require, module, exports) {
      'use strict';

      const checkAgainstRule = require('./utils/checkAgainstRule');
      const createPlugin = require('./createPlugin');
      const createStylelint = require('./createStylelint');
      const formatters = require('./formatters');
      const postcssPlugin = require('./postcssPlugin');
      const report = require('./utils/report');
      const ruleMessages = require('./utils/ruleMessages');
      const rules = require('./rules');
      const standalone = require('./standalone');
      const validateOptions = require('./utils/validateOptions');
      const resolveConfig = require('./resolveConfig');

      /** @type {import('stylelint').PublicApi} */
      const stylelint = Object.assign(postcssPlugin, {
        lint: standalone,
        rules,
        formatters,
        createPlugin,
        resolveConfig,
        createLinter: createStylelint,
        /* utils: { */
        SugarSSParser: require("sugarss/parser"), SugarSS: require("sugarss"), utils: {
          report,
          ruleMessages,
          validateOptions,
          checkAgainstRule } });



      module.exports = stylelint;

    }, { "./createPlugin": 92, "./createStylelint": 93, "./formatters": 96, "./postcssPlugin": 105, "./resolveConfig": 113, "./rules": 205, "./standalone": 318, "./utils/checkAgainstRule": 327, "./utils/report": 409, "./utils/ruleMessages": 410, "./utils/validateOptions": 417, "sugarss": 423, "sugarss/parser": 426 }] }, {}, [])("stylelint");
});})();