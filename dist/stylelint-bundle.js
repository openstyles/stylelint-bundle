/*!= Stylelint v13.8.0 bundle =*/
/* See https://github.com/openstyles/stylelint-bundle */
;(()=>{"use strict";function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function _extends() {_extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};return _extends.apply(this, arguments);}(function (f) {if (typeof exports === "object" && typeof module !== "undefined") {module.exports = f();} else if (typeof define === "function" && define.amd) {define([], f);} else {var g;if (typeof window !== "undefined") {g = window;} else if (typeof global !== "undefined") {g = global;} else if (typeof self !== "undefined") {g = self;} else {g = this;}g.stylelint = f();}})(function () {var define, module, exports;return function () {function r(e, n, t) {function o(i, f) {if (!n[i]) {if (!e[i]) {var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;}var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {var n = e[i][1][r];return o(n || r);}, p, p.exports, r, e, n, t);}return n[i].exports;}for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);return o;}return r;}()({ 1: [function (require, module, exports) {
      'use strict';
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);

        var r = range(a, b, str);

        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length) };

      }

      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }

      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;

        if (ai >= 0 && bi > 0) {
          begs = [];
          left = str.length;

          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }

              bi = str.indexOf(b, i + 1);
            }

            i = ai < bi && ai >= 0 ? ai : bi;
          }

          if (begs.length) {
            result = [left, right];
          }
        }

        return result;
      }

    }, {}], 2: [function (require, module, exports) {
      'use strict';

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;

      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;

        var placeHoldersLen = validLen === len ?
        0 :
        4 - validLen % 4;

        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];

        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ?
        validLen - 4 :
        validLen;

        var i;
        for (i = 0; i < len; i += 4) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 18 |
          revLookup[b64.charCodeAt(i + 1)] << 12 |
          revLookup[b64.charCodeAt(i + 2)] << 6 |
          revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 2) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 2 |
          revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 1) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 10 |
          revLookup[b64.charCodeAt(i + 1)] << 4 |
          revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp =
          (uint8[i] << 16 & 0xFF0000) + (
          uint8[i + 1] << 8 & 0xFF00) + (
          uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(
          lookup[tmp >> 2] +
          lookup[tmp << 4 & 0x3F] +
          '==');

        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(
          lookup[tmp >> 10] +
          lookup[tmp >> 4 & 0x3F] +
          lookup[tmp << 2 & 0x3F] +
          '=');

        }

        return parts.join('');
      }

    }, {}], 3: [function (require, module, exports) {

    }, {}], 4: [function (require, module, exports) {
      (function (Buffer) {(function () {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          /* eslint-disable no-proto */

          'use strict';

          var base64 = require('base64-js');
          var ieee754 = require('ieee754');

          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;

          var K_MAX_LENGTH = 0x7fffffff;
          exports.kMaxLength = K_MAX_LENGTH;

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Print warning and recommend using `buffer` v4.x which has an Object
           *               implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * We report that the browser does not support typed arrays if the are not subclassable
           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
           * for __proto__ and has a buggy typed array implementation.
           */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
          typeof console.error === 'function') {
            console.error(
            'This browser lacks typed array (Uint8Array) support which is required by ' +
            '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');

          }

          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {return 42;} };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }

          Object.defineProperty(Buffer.prototype, 'parent', {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.buffer;
            } });


          Object.defineProperty(Buffer.prototype, 'offset', {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.byteOffset;
            } });


          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new TypeError(
                'The "string" argument must be of type string. Received type number');

              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }

          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          if (typeof Symbol !== 'undefined' && Symbol.species != null &&
          Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false });

          }

          Buffer.poolSize = 8192; // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === 'string') {
              return fromString(value, encodingOrOffset);
            }

            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }

            if (value == null) {
              throw TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
              'or Array-like Object. Received type ' + typeof value);

            }

            if (isInstance(value, ArrayBuffer) ||
            value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }

            if (typeof value === 'number') {
              throw new TypeError(
              'The "value" argument must not be of type number. Received type number');

            }

            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }

            var b = fromObject(value);
            if (b) return b;

            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === 'function') {
              return Buffer.from(
              value[Symbol.toPrimitive]('string'), encodingOrOffset, length);

            }

            throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + typeof value);

          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }

          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ?
              createBuffer(size).fill(fill, encoding) :
              createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding);
          };

          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size);
          };

          function fromString(string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }

            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);

            var actual = buf.write(string, encoding);

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual);
            }

            return buf;
          }

          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }

          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }

            var buf;
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);

              if (buf.length === 0) {
                return buf;
              }

              obj.copy(buf, 0, 0, len);
              return buf;
            }

            if (obj.length !== undefined) {
              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }

            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }

          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
              'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
            }
            return length | 0;
          }

          function SlowBuffer(length) {
            if (+length != length) {// eslint-disable-line eqeqeq
              length = 0;
            }
            return Buffer.alloc(+length);
          }

          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true &&
            b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
          };

          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');

            }

            if (a === b) return 0;

            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;}

          };

          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            if (list.length === 0) {
              return Buffer.alloc(0);
            }

            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }

            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== 'string') {
              throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
              'Received type ' + typeof string);

            }

            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;

            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;}

            }
          }
          Buffer.byteLength = byteLength;

          function slowToString(encoding, start, end) {
            var loweredCase = false;

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0;
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return '';
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return '';
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return '';
            }

            if (!encoding) encoding = 'utf8';

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);

                case 'ascii':
                  return asciiSlice(this, start, end);

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);

                case 'base64':
                  return base64Slice(this, start, end);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;}

            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true;

          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };

          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };

          Buffer.prototype.toLocaleString = Buffer.prototype.toString;

          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };

          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
            if (this.length > max) str += ' ... ';
            return '<Buffer ' + str + '>';
          };

          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. ' +
              'Received type ' + typeof target);

            }

            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }

            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;

            if (this === target) return 0;

            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);

            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1;

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }
            byteOffset = +byteOffset; // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;else
              byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;else
              return -1;
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }

            throw new TypeError('val must be string, number or Buffer');
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }

            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }

            return -1;
          }

          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };

          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }

            var strLen = string.length;

            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }

          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported');

            }

            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;

            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }

            if (!encoding) encoding = 'utf8';

            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);

                case 'ascii':
                  return asciiWrite(this, string, offset, length);

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;}

            }
          };

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0) };

          };

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];

            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 :
              firstByte > 0xDF ? 3 :
              firstByte > 0xBF ? 2 :
              1;

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }}

              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));

            }
            return res;
          }

          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }
            return ret;
          }

          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }

          function hexSlice(buf, start, end) {
            var len = buf.length;

            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;

            var out = '';
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;

            var newBuf = this.subarray(start, end);
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };

          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }

          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            return val;
          };

          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }

            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }

            return val;
          };

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };

          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (this[offset] |
            this[offset + 1] << 8 |
            this[offset + 2] << 16) +
            this[offset + 3] * 0x1000000;
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] * 0x1000000 + (
            this[offset + 1] << 16 |
            this[offset + 2] << 8 |
            this[offset + 3]);
          };

          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] |
            this[offset + 1] << 8 |
            this[offset + 2] << 16 |
            this[offset + 3] << 24;
          };

          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] << 24 |
            this[offset + 1] << 16 |
            this[offset + 2] << 8 |
            this[offset + 3];
          };

          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };

          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };

          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };

          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
            if (end < 0) throw new RangeError('sourceEnd out of bounds');

            // Are we oob?
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;

            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart);

            }

            return len;
          };

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === 'utf8' && code < 128 ||
                encoding === 'latin1') {
                  // Fast path: If `val` fits into a single byte, use that numeric value.
                  val = code;
                }
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }

            if (end <= start) {
              return this;
            }

            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;

            if (!val) val = 0;

            var i;
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ?
              val :
              Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val +
                '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }

            return this;
          };

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

          function base64clean(str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split('=')[0];
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }

          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);

              // is surrogate component
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  }

                  // valid lead
                  leadSurrogate = codePoint;

                  continue;
                }

                // 2 leads in a row
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                }

                // valid surrogate pair
                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }

              leadSurrogate = null;

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(
                codePoint >> 0x6 | 0xC0,
                codePoint & 0x3F | 0x80);

              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(
                codePoint >> 0xC | 0xE0,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80);

              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(
                codePoint >> 0x12 | 0xF0,
                codePoint >> 0xC & 0x3F | 0x80,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80);

              } else {
                throw new Error('Invalid code point');
              }
            }

            return bytes;
          }

          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }
            return byteArray;
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;

              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }

            return byteArray;
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }

          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
          // the `instanceof` check but they should be treated as of that type.
          // See: https://github.com/feross/buffer/issues/166
          function isInstance(obj, type) {
            return obj instanceof type ||
            obj != null && obj.constructor != null && obj.constructor.name != null &&
            obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }

        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "base64-js": 2, "buffer": 4, "ieee754": 11 }], 5: [function (require, module, exports) {
      'use strict';
      const isRegexp = require('is-regexp');

      const flagMap = {
        global: 'g',
        ignoreCase: 'i',
        multiline: 'm',
        dotAll: 's',
        sticky: 'y',
        unicode: 'u' };


      module.exports = (regexp, options = {}) => {
        if (!isRegexp(regexp)) {
          throw new TypeError('Expected a RegExp instance');
        }

        const flags = Object.keys(flagMap).map((flag) =>
        (typeof options[flag] === 'boolean' ? options[flag] : regexp[flag]) ? flagMap[flag] : '').
        join('');

        const clonedRegexp = new RegExp(options.source || regexp.source, flags);

        clonedRegexp.lastIndex = typeof options.lastIndex === 'number' ?
        options.lastIndex :
        regexp.lastIndex;

        return clonedRegexp;
      };

    }, { "is-regexp": 15 }], 6: [function (require, module, exports) {
      /*! https://mths.be/cssesc v3.0.0 by @mathias */
      'use strict';

      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        for (var key in defaults) {
          // `if (defaults.hasOwnProperty(key) {  }` is not needed here, since
          // only recognized option names are used.
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
        }
        return result;
      };

      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexAlwaysEscape = /['"\\]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

      // https://mathiasbynens.be/notes/css-escapes#css
      var cssesc = function cssesc(string, options) {
        options = merge(options, cssesc.options);
        if (options.quotes != 'single' && options.quotes != 'double') {
          options.quotes = 'single';
        }
        var quote = options.quotes == 'double' ? '"' : '\'';
        var isIdentifier = options.isIdentifier;

        var firstChar = string.charAt(0);
        var output = '';
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value = void 0;
          // If its not a printable ASCII character
          if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
              // Its a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // next character is low surrogate
                codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
              } else {
                // Its an unmatched surrogate; only append this code unit, in case
                // the next code unit is the high surrogate of a surrogate pair.
                counter--;
              }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value = '\\' + character;
              } else {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value = '\\' + character;
            } else {
              value = character;
            }
          }
          output += value;
        }

        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
          }
        }

        // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
        // since theyre redundant. Note that this is only possible if the escape
        // sequence isnt preceded by an odd number of backslashes.
        output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
          if ($1 && $1.length % 2) {
            // Its not safe to remove the space, so dont.
            return $0;
          }
          // Strip the space.
          return ($1 || '') + $2;
        });

        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };

      // Expose default options (so they can be overridden globally).
      cssesc.options = {
        'escapeEverything': false,
        'isIdentifier': false,
        'quotes': 'single',
        'wrap': false };


      cssesc.version = '3.0.0';

      module.exports = cssesc;

    }, {}], 7: [function (require, module, exports) {
      'use strict';
      const cloneRegexp = require('clone-regexp');

      module.exports = (regexp, string) => {
        let match;
        const matches = [];
        const clonedRegexp = cloneRegexp(regexp, { lastIndex: 0 });
        const isGlobal = clonedRegexp.global;

        // eslint-disable-next-line no-cond-assign
        while (match = clonedRegexp.exec(string)) {
          matches.push({
            match: match[0],
            subMatches: match.slice(1),
            index: match.index });


          if (!isGlobal) {
            break;
          }
        }

        return matches;
      };

    }, { "clone-regexp": 5 }], 8: [function (require, module, exports) {
      "use strict";
      const peq = new Uint32Array(0x10000);
      const myers_32 = (a, b) => {
        const n = a.length;
        const m = b.length;
        const lst = 1 << n - 1;
        let pv = -1;
        let mv = 0;
        let sc = n;
        let i = n;
        while (i--) {
          peq[a.charCodeAt(i)] |= 1 << i;
        }
        for (i = 0; i < m; i++) {
          let eq = peq[b.charCodeAt(i)];
          const xv = eq | mv;
          eq |= (eq & pv) + pv ^ pv;
          mv |= ~(eq | pv);
          pv &= eq;
          if (mv & lst) {
            sc++;
          }
          if (pv & lst) {
            sc--;
          }
          mv = mv << 1 | 1;
          pv = pv << 1 | ~(xv | mv);
          mv &= xv;
        }
        i = n;
        while (i--) {
          peq[a.charCodeAt(i)] = 0;
        }
        return sc;
      };

      const myers_x = (a, b) => {
        const n = a.length;
        const m = b.length;
        const mhc = [];
        const phc = [];
        const hsize = Math.ceil(n / 32);
        const vsize = Math.ceil(m / 32);
        let score = m;
        for (let i = 0; i < hsize; i++) {
          phc[i] = -1;
          mhc[i] = 0;
        }
        let j = 0;
        for (; j < vsize - 1; j++) {
          let mv = 0;
          let pv = -1;
          const start = j * 32;
          const end = Math.min(32, m) + start;
          for (let k = start; k < end; k++) {
            peq[b.charCodeAt(k)] |= 1 << k;
          }
          score = m;
          for (let i = 0; i < n; i++) {
            const eq = peq[a.charCodeAt(i)];
            const pb = phc[i / 32 | 0] >>> i & 1;
            const mb = mhc[i / 32 | 0] >>> i & 1;
            const xv = eq | mv;
            const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
            let ph = mv | ~(xh | pv);
            let mh = pv & xh;
            if (ph >>> 31 ^ pb) {
              phc[i / 32 | 0] ^= 1 << i;
            }
            if (mh >>> 31 ^ mb) {
              mhc[i / 32 | 0] ^= 1 << i;
            }
            ph = ph << 1 | pb;
            mh = mh << 1 | mb;
            pv = mh | ~(xv | ph);
            mv = ph & xv;
          }
          for (let k = start; k < end; k++) {
            peq[b.charCodeAt(k)] = 0;
          }
        }
        let mv = 0;
        let pv = -1;
        const start = j * 32;
        const end = Math.min(32, m - start) + start;
        for (let k = start; k < end; k++) {
          peq[b.charCodeAt(k)] |= 1 << k;
        }
        score = m;
        for (let i = 0; i < n; i++) {
          const eq = peq[a.charCodeAt(i)];
          const pb = phc[i / 32 | 0] >>> i & 1;
          const mb = mhc[i / 32 | 0] >>> i & 1;
          const xv = eq | mv;
          const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
          let ph = mv | ~(xh | pv);
          let mh = pv & xh;
          score += ph >>> m - 1 & 1;
          score -= mh >>> m - 1 & 1;
          if (ph >>> 31 ^ pb) {
            phc[i / 32 | 0] ^= 1 << i;
          }
          if (mh >>> 31 ^ mb) {
            mhc[i / 32 | 0] ^= 1 << i;
          }
          ph = ph << 1 | pb;
          mh = mh << 1 | mb;
          pv = mh | ~(xv | ph);
          mv = ph & xv;
        }
        for (let k = start; k < end; k++) {
          peq[b.charCodeAt(k)] = 0;
        }
        return score;
      };

      const distance = (a, b) => {
        if (a.length > b.length) {
          const tmp = b;
          b = a;
          a = tmp;
        }
        if (a.length === 0) {
          return b.length;
        }
        if (a.length <= 32) {
          return myers_32(a, b);
        }
        return myers_x(a, b);
      };

      const closest = (str, arr) => {
        let min_distance = Infinity;
        let min_index = 0;
        for (let i = 0; i < arr.length; i++) {
          const dist = distance(str, arr[i]);
          if (dist < min_distance) {
            min_distance = dist;
            min_index = i;
          }
        }
        return arr[min_index];
      };

      module.exports = {
        closest, distance };


    }, {}], 9: [function (require, module, exports) {
      module.exports = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "math",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "slot",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"];


    }, {}], 10: [function (require, module, exports) {
      'use strict';
      module.exports = require('./html-tags.json');

    }, { "./html-tags.json": 9 }], 11: [function (require, module, exports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];

        i += d;

        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
      };

    }, {}], 12: [function (require, module, exports) {
      (function (process) {(function () {
          // A simple implementation of make-array
          function makeArray(subject) {
            return Array.isArray(subject) ?
            subject :
            [subject];
          }

          const EMPTY = '';
          const SPACE = ' ';
          const ESCAPE = '\\';
          const REGEX_TEST_BLANK_LINE = /^\s+$/;
          const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
          const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
          const REGEX_SPLITALL_CRLF = /\r?\n/g;
          // /foo,
          // ./foo,
          // ../foo,
          // .
          // ..
          const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;

          const SLASH = '/';
          const KEY_IGNORE = typeof Symbol !== 'undefined' ?
          Symbol.for('node-ignore')
          /* istanbul ignore next */ :
          'node-ignore';

          const define = (object, key, value) =>
          Object.defineProperty(object, key, { value });

          const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

          // Sanitize the range of a regular expression
          // The cases are complicated, see test cases for details
          const sanitizeRange = range => range.replace(
          REGEX_REGEXP_RANGE,
          (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ?
          match
          // Invalid range (out of order) which is ok for gitignore rules but
          //   fatal for JavaScript regular expression, so eliminate it.
          : EMPTY);


          // See fixtures #59
          const cleanRangeBackSlash = slashes => {
            const { length } = slashes;
            return slashes.slice(0, length - length % 2);
          };

          // > If the pattern ends with a slash,
          // > it is removed for the purpose of the following description,
          // > but it would only find a match with a directory.
          // > In other words, foo/ will match a directory foo and paths underneath it,
          // > but will not match a regular file or a symbolic link foo
          // >  (this is consistent with the way how pathspec works in general in Git).
          // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
          // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
          //      you could use option `mark: true` with `glob`

          // '`foo/`' should not continue with the '`..`'
          const REPLACERS = [

          // > Trailing spaces are ignored unless they are quoted with backslash ("\")
          [
          // (a\ ) -> (a )
          // (a  ) -> (a)
          // (a \ ) -> (a  )
          /\\?\s+$/,
          match => match.indexOf('\\') === 0 ?
          SPACE :
          EMPTY],


          // replace (\ ) with ' '
          [
          /\\\s/g,
          () => SPACE],


          // Escape metacharacters
          // which is written down by users but means special for regular expressions.

          // > There are 12 characters with special meanings:
          // > - the backslash \,
          // > - the caret ^,
          // > - the dollar sign $,
          // > - the period or dot .,
          // > - the vertical bar or pipe symbol |,
          // > - the question mark ?,
          // > - the asterisk or star *,
          // > - the plus sign +,
          // > - the opening parenthesis (,
          // > - the closing parenthesis ),
          // > - and the opening square bracket [,
          // > - the opening curly brace {,
          // > These special characters are often called "metacharacters".
          [
          /[\\$.|*+(){^]/g,
          match => `\\${match}`],


          [
          // > a question mark (?) matches a single character
          /(?!\\)\?/g,
          () => '[^/]'],


          // leading slash
          [

          // > A leading slash matches the beginning of the pathname.
          // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
          // A leading slash matches the beginning of the pathname
          /^\//,
          () => '^'],


          // replace special metacharacter slash after the leading slash
          [
          /\//g,
          () => '\\/'],


          [
          // > A leading "**" followed by a slash means match in all directories.
          // > For example, "**/foo" matches file or directory "foo" anywhere,
          // > the same as pattern "foo".
          // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
          // >   under directory "foo".
          // Notice that the '*'s have been replaced as '\\*'
          /^\^*\\\*\\\*\\\//,

          // '**/foo' <-> 'foo'
          () => '^(?:.*\\/)?'],


          // starting
          [
          // there will be no leading '/'
          //   (which has been replaced by section "leading slash")
          // If starts with '**', adding a '^' to the regular expression also works
          /^(?=[^^])/,
          function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this)
            // > Prior to 2.22.1
            // > If the pattern does not contain a slash /,
            // >   Git treats it as a shell glob pattern
            // Actually, if there is only a trailing slash,
            //   git also treats it as a shell glob pattern

            // After 2.22.1 (compatible but clearer)
            // > If there is a separator at the beginning or middle (or both)
            // > of the pattern, then the pattern is relative to the directory
            // > level of the particular .gitignore file itself.
            // > Otherwise the pattern may also match at any level below
            // > the .gitignore level.
            ? '(?:^|\\/)'

            // > Otherwise, Git treats the pattern as a shell glob suitable for
            // >   consumption by fnmatch(3)
            : '^';
          }],


          // two globstars
          [
          // Use lookahead assertions so that we could match more than one `'/**'`
          /\\\/\\\*\\\*(?=\\\/|$)/g,

          // Zero, one or several directories
          // should not use '*', or it will be replaced by the next replacer

          // Check if it is not the last `'/**'`
          (_, index, str) => index + 6 < str.length

          // case: /**/
          // > A slash followed by two consecutive asterisks then a slash matches
          // >   zero or more directories.
          // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
          // '/**/'
          ? '(?:\\/[^\\/]+)*'

          // case: /**
          // > A trailing `"/**"` matches everything inside.

          // #21: everything inside but it should not include the current folder
          : '\\/.+'],


          // intermediate wildcards
          [
          // Never replace escaped '*'
          // ignore rule '\*' will match the path '*'

          // 'abc.*/' -> go
          // 'abc.*'  -> skip this rule
          /(^|[^\\]+)\\\*(?=.+)/g,

          // '*.js' matches '.js'
          // '*.js' doesn't match 'abc'
          (_, p1) => `${p1}[^\\/]*`],


          [
          // unescape, revert step 3 except for back slash
          // For example, if a user escape a '\\*',
          // after step 3, the result will be '\\\\\\*'
          /\\\\\\(?=[$.|*+(){^])/g,
          () => ESCAPE],


          [
          // '\\\\' -> '\\'
          /\\\\/g,
          () => ESCAPE],


          [
          // > The range notation, e.g. [a-zA-Z],
          // > can be used to match one of the characters in a range.

          // `\` is escaped by step 3
          /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
          (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
          // '\\[bar]' -> '\\\\[bar\\]'
          ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` :
          close === ']' ?
          endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]' :
          '[]'],


          // ending
          [
          // 'js' will not match 'js.'
          // 'ab' will not match 'abc'
          /(?:[^*])$/,

          // WTF!
          // https://git-scm.com/docs/gitignore
          // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
          // which re-fixes #24, #38

          // > If there is a separator at the end of the pattern then the pattern
          // > will only match directories, otherwise the pattern can match both
          // > files and directories.

          // 'js*' will not match 'a.js'
          // 'js/' will not match 'a.js'
          // 'js' will match 'a.js' and 'a.js/'
          match => /\/$/.test(match)
          // foo/ will not match 'foo'
          ? `${match}$`
          // foo matches 'foo' and 'foo/'
          : `${match}(?=$|\\/$)`],


          // trailing wildcard
          [
          /(\^|\\\/)?\\\*$/,
          (_, p1) => {
            const prefix = p1
            // '\^':
            // '/*' does not match EMPTY
            // '/*' does not match everything

            // '\\\/':
            // 'abc/*' does not match 'abc/'
            ? `${p1}[^/]+`

            // 'a*' matches 'a'
            // 'a*' matches 'aa'
            : '[^/]*';

            return `${prefix}(?=$|\\/$)`;
          }]];



          // A simple cache, because an ignore rule only has only one certain meaning
          const regexCache = Object.create(null);

          // @param {pattern}
          const makeRegex = (pattern, negative, ignorecase) => {
            const r = regexCache[pattern];
            if (r) {
              return r;
            }

            // const replacers = negative
            //   ? NEGATIVE_REPLACERS
            //   : POSITIVE_REPLACERS

            const source = REPLACERS.reduce(
            (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
            pattern);


            return regexCache[pattern] = ignorecase ?
            new RegExp(source, 'i') :
            new RegExp(source);
          };

          const isString = subject => typeof subject === 'string';

          // > A blank line matches no files, so it can serve as a separator for readability.
          const checkPattern = pattern => pattern &&
          isString(pattern) &&
          !REGEX_TEST_BLANK_LINE.test(pattern)

          // > A line starting with # serves as a comment.
          && pattern.indexOf('#') !== 0;

          const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

          class IgnoreRule {
            constructor(
            origin,
            pattern,
            negative,
            regex)
            {
              this.origin = origin;
              this.pattern = pattern;
              this.negative = negative;
              this.regex = regex;
            }}


          const createRule = (pattern, ignorecase) => {
            const origin = pattern;
            let negative = false;

            // > An optional prefix "!" which negates the pattern;
            if (pattern.indexOf('!') === 0) {
              negative = true;
              pattern = pattern.substr(1);
            }

            pattern = pattern
            // > Put a backslash ("\") in front of the first "!" for patterns that
            // >   begin with a literal "!", for example, `"\!important!.txt"`.
            .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
            // > Put a backslash ("\") in front of the first hash for patterns that
            // >   begin with a hash.
            .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');

            const regex = makeRegex(pattern, negative, ignorecase);

            return new IgnoreRule(
            origin,
            pattern,
            negative,
            regex);

          };

          const throwError = (message, Ctor) => {
            throw new Ctor(message);
          };

          const checkPath = (path, originalPath, doThrow) => {
            if (!isString(path)) {
              return doThrow(
              `path must be a string, but got \`${originalPath}\``,
              TypeError);

            }

            // We don't know if we should ignore EMPTY, so throw
            if (!path) {
              return doThrow(`path must not be empty`, TypeError);
            }

            // Check if it is a relative path
            if (checkPath.isNotRelative(path)) {
              const r = '`path.relative()`d';
              return doThrow(
              `path should be a ${r} string, but got "${originalPath}"`,
              RangeError);

            }

            return true;
          };

          const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

          checkPath.isNotRelative = isNotRelative;
          checkPath.convert = p => p;

          class Ignore {
            constructor({
              ignorecase = true } =
            {}) {
              this._rules = [];
              this._ignorecase = ignorecase;
              define(this, KEY_IGNORE, true);
              this._initCache();
            }

            _initCache() {
              this._ignoreCache = Object.create(null);
              this._testCache = Object.create(null);
            }

            _addPattern(pattern) {
              // #32
              if (pattern && pattern[KEY_IGNORE]) {
                this._rules = this._rules.concat(pattern._rules);
                this._added = true;
                return;
              }

              if (checkPattern(pattern)) {
                const rule = createRule(pattern, this._ignorecase);
                this._added = true;
                this._rules.push(rule);
              }
            }

            // @param {Array<string> | string | Ignore} pattern
            add(pattern) {
              this._added = false;

              makeArray(
              isString(pattern) ?
              splitPattern(pattern) :
              pattern).
              forEach(this._addPattern, this);

              // Some rules have just added to the ignore,
              // making the behavior changed.
              if (this._added) {
                this._initCache();
              }

              return this;
            }

            // legacy
            addPattern(pattern) {
              return this.add(pattern);
            }

            //          |           ignored : unignored
            // negative |   0:0   |   0:1   |   1:0   |   1:1
            // -------- | ------- | ------- | ------- | --------
            //     0    |  TEST   |  TEST   |  SKIP   |    X
            //     1    |  TESTIF |  SKIP   |  TEST   |    X

            // - SKIP: always skip
            // - TEST: always test
            // - TESTIF: only test if checkUnignored
            // - X: that never happen

            // @param {boolean} whether should check if the path is unignored,
            //   setting `checkUnignored` to `false` could reduce additional
            //   path matching.

            // @returns {TestResult} true if a file is ignored
            _testOne(path, checkUnignored) {
              let ignored = false;
              let unignored = false;

              this._rules.forEach(rule => {
                const { negative } = rule;
                if (
                unignored === negative && ignored !== unignored ||
                negative && !ignored && !unignored && !checkUnignored)
                {
                  return;
                }

                const matched = rule.regex.test(path);

                if (matched) {
                  ignored = !negative;
                  unignored = negative;
                }
              });

              return {
                ignored,
                unignored };

            }

            // @returns {TestResult}
            _test(originalPath, cache, checkUnignored, slices) {
              const path = originalPath
              // Supports nullable path
              && checkPath.convert(originalPath);

              checkPath(path, originalPath, throwError);

              return this._t(path, cache, checkUnignored, slices);
            }

            _t(path, cache, checkUnignored, slices) {
              if (path in cache) {
                return cache[path];
              }

              if (!slices) {
                // path/to/a.js
                // ['path', 'to', 'a.js']
                slices = path.split(SLASH);
              }

              slices.pop();

              // If the path has no parent directory, just test it
              if (!slices.length) {
                return cache[path] = this._testOne(path, checkUnignored);
              }

              const parent = this._t(
              slices.join(SLASH) + SLASH,
              cache,
              checkUnignored,
              slices);


              // If the path contains a parent directory, check the parent first
              return cache[path] = parent.ignored
              // > It is not possible to re-include a file if a parent directory of
              // >   that file is excluded.
              ? parent :
              this._testOne(path, checkUnignored);
            }

            ignores(path) {
              return this._test(path, this._ignoreCache, false).ignored;
            }

            createFilter() {
              return path => !this.ignores(path);
            }

            filter(paths) {
              return makeArray(paths).filter(this.createFilter());
            }

            // @returns {TestResult}
            test(path) {
              return this._test(path, this._testCache, true);
            }}


          const factory = options => new Ignore(options);

          const returnFalse = () => false;

          const isPathValid = (path) =>
          checkPath(path && checkPath.convert(path), path, returnFalse);

          factory.isPathValid = isPathValid;

          // Fixes typescript
          factory.default = factory;

          module.exports = factory;

          // Windows
          // --------------------------------------------------------------
          /* istanbul ignore if  */
          if (
          // Detect `process` so that it can run in browsers.
          typeof process !== 'undefined' && (

          process.env && process.env.IGNORE_TEST_WIN32 ||
          process.platform === 'win32'))

          {
            /* eslint no-control-regex: "off" */
            const makePosix = str => /^\\\\\?\\/.test(str) ||
            /["<>|\u0000-\u001F]+/u.test(str) ?
            str :
            str.replace(/\\/g, '/');

            checkPath.convert = makePosix;

            // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
            // 'd:\\foo'
            const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
            checkPath.isNotRelative = (path) =>
            REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) ||
            isNotRelative(path);
          }

        }).call(this);}).call(this, require('_process'));
    }, { "_process": 160 }], 13: [function (require, module, exports) {
      'use strict';
      const lazy = (importedModule, importFn, moduleId) =>
      importedModule === undefined ? importFn(moduleId) : importedModule;

      module.exports = importFn => {
        return moduleId => {
          let importedModule;

          const handler = {
            get: (target, property) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.get(importedModule, property);
            },
            apply: (target, thisArgument, argumentsList) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.apply(importedModule, thisArgument, argumentsList);
            },
            construct: (target, argumentsList) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.construct(importedModule, argumentsList);
            } };


          // eslint-disable-next-line prefer-arrow-callback
          return new Proxy(function () {}, handler);
        };
      };

    }, {}], 14: [function (require, module, exports) {
      module.exports = function (ary, item) {
        var i = -1,indexes = [];
        while ((i = ary.indexOf(item, i + 1)) !== -1)
        indexes.push(i);
        return indexes;
      };

    }, {}], 15: [function (require, module, exports) {
      'use strict';

      module.exports = input => Object.prototype.toString.call(input) === '[object RegExp]';

    }, {}], 16: [function (require, module, exports) {
      module.exports = {
        "properties": [
        "accelerator",
        "-wap-accesskey",
        "align-content",
        "-webkit-align-content",
        "align-items",
        "-webkit-align-items",
        "align-self",
        "-webkit-align-self",
        "alignment-baseline",
        "all",
        "alt",
        "-webkit-alt",
        "animation",
        "animation-delay",
        "-moz-animation-delay",
        "-ms-animation-delay",
        "-webkit-animation-delay",
        "animation-direction",
        "-moz-animation-direction",
        "-ms-animation-direction",
        "-webkit-animation-direction",
        "animation-duration",
        "-moz-animation-duration",
        "-ms-animation-duration",
        "-webkit-animation-duration",
        "animation-fill-mode",
        "-moz-animation-fill-mode",
        "-ms-animation-fill-mode",
        "-webkit-animation-fill-mode",
        "animation-iteration-count",
        "-moz-animation-iteration-count",
        "-ms-animation-iteration-count",
        "-webkit-animation-iteration-count",
        "-moz-animation",
        "-ms-animation",
        "animation-name",
        "-moz-animation-name",
        "-ms-animation-name",
        "-webkit-animation-name",
        "animation-play-state",
        "-moz-animation-play-state",
        "-ms-animation-play-state",
        "-webkit-animation-play-state",
        "animation-timing-function",
        "-moz-animation-timing-function",
        "-ms-animation-timing-function",
        "-webkit-animation-timing-function",
        "-webkit-animation-trigger",
        "-webkit-animation",
        "-webkit-app-region",
        "appearance",
        "-moz-appearance",
        "-webkit-appearance",
        "aspect-ratio",
        "-webkit-aspect-ratio",
        "audio-level",
        "azimuth",
        "backdrop-filter",
        "-webkit-backdrop-filter",
        "backface-visibility",
        "-moz-backface-visibility",
        "-ms-backface-visibility",
        "-webkit-backface-visibility",
        "background",
        "background-attachment",
        "-webkit-background-attachment",
        "background-blend-mode",
        "background-clip",
        "-moz-background-clip",
        "-webkit-background-clip",
        "background-color",
        "-webkit-background-color",
        "-webkit-background-composite",
        "background-image",
        "-webkit-background-image",
        "-moz-background-inline-policy",
        "background-origin",
        "-moz-background-origin",
        "-webkit-background-origin",
        "background-position",
        "-webkit-background-position",
        "background-position-x",
        "-webkit-background-position-x",
        "background-position-y",
        "-webkit-background-position-y",
        "background-repeat",
        "-webkit-background-repeat",
        "background-repeat-x",
        "background-repeat-y",
        "background-size",
        "-moz-background-size",
        "-webkit-background-size",
        "-webkit-background",
        "baseline-shift",
        "baseline-source",
        "behavior",
        "-moz-binding",
        "block-ellipsis",
        "-ms-block-progression",
        "block-size",
        "block-step",
        "block-step-align",
        "block-step-insert",
        "block-step-round",
        "block-step-size",
        "bookmark-label",
        "bookmark-level",
        "bookmark-state",
        "border",
        "-webkit-border-after-color",
        "-webkit-border-after-style",
        "-webkit-border-after",
        "-webkit-border-after-width",
        "-webkit-border-before-color",
        "-webkit-border-before-style",
        "-webkit-border-before",
        "-webkit-border-before-width",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "-moz-border-bottom-colors",
        "border-bottom-left-radius",
        "-webkit-border-bottom-left-radius",
        "border-bottom-right-radius",
        "-webkit-border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-boundary",
        "border-collapse",
        "border-color",
        "-moz-border-end-color",
        "-webkit-border-end-color",
        "border-end-end-radius",
        "-moz-border-end",
        "border-end-start-radius",
        "-moz-border-end-style",
        "-webkit-border-end-style",
        "-webkit-border-end",
        "-moz-border-end-width",
        "-webkit-border-end-width",
        "-webkit-border-fit",
        "-webkit-border-horizontal-spacing",
        "border-image",
        "-moz-border-image",
        "-o-border-image",
        "border-image-outset",
        "-webkit-border-image-outset",
        "border-image-repeat",
        "-webkit-border-image-repeat",
        "border-image-slice",
        "-webkit-border-image-slice",
        "border-image-source",
        "-webkit-border-image-source",
        "-webkit-border-image",
        "border-image-width",
        "-webkit-border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "-moz-border-left-colors",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "-moz-border-radius-bottomleft",
        "-moz-border-radius-bottomright",
        "-moz-border-radius",
        "-moz-border-radius-topleft",
        "-moz-border-radius-topright",
        "-webkit-border-radius",
        "border-right",
        "border-right-color",
        "-moz-border-right-colors",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "-moz-border-start-color",
        "-webkit-border-start-color",
        "border-start-end-radius",
        "-moz-border-start",
        "border-start-start-radius",
        "-moz-border-start-style",
        "-webkit-border-start-style",
        "-webkit-border-start",
        "-moz-border-start-width",
        "-webkit-border-start-width",
        "border-style",
        "border-top",
        "border-top-color",
        "-moz-border-top-colors",
        "border-top-left-radius",
        "-webkit-border-top-left-radius",
        "border-top-right-radius",
        "-webkit-border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "-webkit-border-vertical-spacing",
        "border-width",
        "bottom",
        "-moz-box-align",
        "-webkit-box-align",
        "box-decoration-break",
        "-webkit-box-decoration-break",
        "-moz-box-direction",
        "-webkit-box-direction",
        "-webkit-box-flex-group",
        "-moz-box-flex",
        "-webkit-box-flex",
        "-webkit-box-lines",
        "-moz-box-ordinal-group",
        "-webkit-box-ordinal-group",
        "-moz-box-orient",
        "-webkit-box-orient",
        "-moz-box-pack",
        "-webkit-box-pack",
        "-webkit-box-reflect",
        "box-shadow",
        "-moz-box-shadow",
        "-webkit-box-shadow",
        "box-sizing",
        "-moz-box-sizing",
        "-webkit-box-sizing",
        "box-snap",
        "break-after",
        "break-before",
        "break-inside",
        "buffered-rendering",
        "caption-side",
        "caret",
        "caret-color",
        "caret-shape",
        "chains",
        "clear",
        "clip",
        "clip-path",
        "-webkit-clip-path",
        "clip-rule",
        "color",
        "color-adjust",
        "-webkit-color-correction",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "color-scheme",
        "-webkit-column-axis",
        "-webkit-column-break-after",
        "-webkit-column-break-before",
        "-webkit-column-break-inside",
        "column-count",
        "-moz-column-count",
        "-webkit-column-count",
        "column-fill",
        "-moz-column-fill",
        "-webkit-column-fill",
        "column-gap",
        "-moz-column-gap",
        "-webkit-column-gap",
        "column-progression",
        "-webkit-column-progression",
        "column-rule",
        "column-rule-color",
        "-moz-column-rule-color",
        "-webkit-column-rule-color",
        "-moz-column-rule",
        "column-rule-style",
        "-moz-column-rule-style",
        "-webkit-column-rule-style",
        "-webkit-column-rule",
        "column-rule-width",
        "-moz-column-rule-width",
        "-webkit-column-rule-width",
        "column-span",
        "-moz-column-span",
        "-webkit-column-span",
        "column-width",
        "-moz-column-width",
        "-webkit-column-width",
        "columns",
        "-moz-columns",
        "-webkit-columns",
        "-webkit-composition-fill-color",
        "-webkit-composition-frame-color",
        "contain",
        "contain-intrinsic-size",
        "content",
        "content-visibility",
        "-ms-content-zoom-chaining",
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min",
        "-ms-content-zoom-limit",
        "-ms-content-zoom-snap",
        "-ms-content-zoom-snap-points",
        "-ms-content-zoom-snap-type",
        "-ms-content-zooming",
        "continue",
        "counter-increment",
        "counter-reset",
        "counter-set",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "-webkit-cursor-visibility",
        "cx",
        "cy",
        "d",
        "-apple-dashboard-region",
        "-webkit-dashboard-region",
        "direction",
        "display",
        "display-align",
        "dominant-baseline",
        "elevation",
        "empty-cells",
        "enable-background",
        "fill",
        "fill-break",
        "fill-color",
        "fill-image",
        "fill-opacity",
        "fill-origin",
        "fill-position",
        "fill-repeat",
        "fill-rule",
        "fill-size",
        "filter",
        "-ms-filter",
        "-webkit-filter",
        "flex",
        "-ms-flex-align",
        "-webkit-flex-align",
        "flex-basis",
        "-webkit-flex-basis",
        "flex-direction",
        "-ms-flex-direction",
        "-webkit-flex-direction",
        "flex-flow",
        "-ms-flex-flow",
        "-webkit-flex-flow",
        "flex-grow",
        "-webkit-flex-grow",
        "-ms-flex-item-align",
        "-webkit-flex-item-align",
        "-ms-flex-line-pack",
        "-webkit-flex-line-pack",
        "-ms-flex",
        "-ms-flex-negative",
        "-ms-flex-order",
        "-webkit-flex-order",
        "-ms-flex-pack",
        "-webkit-flex-pack",
        "-ms-flex-positive",
        "-ms-flex-preferred-size",
        "flex-shrink",
        "-webkit-flex-shrink",
        "-webkit-flex",
        "flex-wrap",
        "-ms-flex-wrap",
        "-webkit-flex-wrap",
        "float",
        "float-defer",
        "-moz-float-edge",
        "float-offset",
        "float-reference",
        "flood-color",
        "flood-opacity",
        "flow",
        "flow-from",
        "-ms-flow-from",
        "-webkit-flow-from",
        "flow-into",
        "-ms-flow-into",
        "-webkit-flow-into",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "-moz-font-feature-settings",
        "-ms-font-feature-settings",
        "-webkit-font-feature-settings",
        "font-kerning",
        "-webkit-font-kerning",
        "font-language-override",
        "-moz-font-language-override",
        "font-optical-sizing",
        "font-palette",
        "font-size",
        "font-size-adjust",
        "-webkit-font-size-delta",
        "-webkit-font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-synthesis-small-caps",
        "font-synthesis-style",
        "font-synthesis-weight",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-emoji",
        "font-variant-ligatures",
        "-webkit-font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "footnote-display",
        "footnote-policy",
        "-moz-force-broken-image-icon",
        "forced-color-adjust",
        "gap",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "grid",
        "-webkit-grid-after",
        "grid-area",
        "grid-auto-columns",
        "-webkit-grid-auto-columns",
        "grid-auto-flow",
        "-webkit-grid-auto-flow",
        "grid-auto-rows",
        "-webkit-grid-auto-rows",
        "-webkit-grid-before",
        "grid-column",
        "-ms-grid-column-align",
        "grid-column-end",
        "grid-column-gap",
        "-ms-grid-column",
        "-ms-grid-column-span",
        "grid-column-start",
        "-webkit-grid-column",
        "-ms-grid-columns",
        "-webkit-grid-columns",
        "-webkit-grid-end",
        "grid-gap",
        "grid-row",
        "-ms-grid-row-align",
        "grid-row-end",
        "grid-row-gap",
        "-ms-grid-row",
        "-ms-grid-row-span",
        "grid-row-start",
        "-webkit-grid-row",
        "-ms-grid-rows",
        "-webkit-grid-rows",
        "-webkit-grid-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "-ms-high-contrast-adjust",
        "-webkit-highlight",
        "hyphenate-character",
        "-webkit-hyphenate-character",
        "-webkit-hyphenate-limit-after",
        "-webkit-hyphenate-limit-before",
        "hyphenate-limit-chars",
        "-ms-hyphenate-limit-chars",
        "hyphenate-limit-last",
        "hyphenate-limit-lines",
        "-ms-hyphenate-limit-lines",
        "-webkit-hyphenate-limit-lines",
        "hyphenate-limit-zone",
        "-ms-hyphenate-limit-zone",
        "hyphens",
        "-moz-hyphens",
        "-ms-hyphens",
        "-webkit-hyphens",
        "image-orientation",
        "-moz-image-region",
        "image-rendering",
        "image-resolution",
        "-ms-ime-align",
        "ime-mode",
        "inherits",
        "initial-letter",
        "initial-letter-align",
        "-webkit-initial-letter",
        "initial-letter-wrap",
        "initial-value",
        "inline-size",
        "inline-sizing",
        "input-format",
        "-wap-input-format",
        "-wap-input-required",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "-ms-interpolation-mode",
        "isolation",
        "justify-content",
        "-webkit-justify-content",
        "justify-items",
        "justify-self",
        "-webkit-justify-self",
        "kerning",
        "layout-flow",
        "layout-grid",
        "layout-grid-char",
        "layout-grid-line",
        "layout-grid-mode",
        "layout-grid-type",
        "leading-trim",
        "left",
        "letter-spacing",
        "lighting-color",
        "-webkit-line-align",
        "-webkit-line-box-contain",
        "line-break",
        "-webkit-line-break",
        "line-clamp",
        "-webkit-line-clamp",
        "line-grid",
        "-webkit-line-grid-snap",
        "-webkit-line-grid",
        "line-height",
        "line-height-step",
        "line-increment",
        "line-padding",
        "line-snap",
        "-webkit-line-snap",
        "-o-link",
        "-o-link-source",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "-webkit-locale",
        "-webkit-logical-height",
        "-webkit-logical-width",
        "margin",
        "-webkit-margin-after-collapse",
        "-webkit-margin-after",
        "-webkit-margin-before-collapse",
        "-webkit-margin-before",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "-webkit-margin-bottom-collapse",
        "margin-break",
        "-webkit-margin-collapse",
        "-moz-margin-end",
        "-webkit-margin-end",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "-moz-margin-start",
        "-webkit-margin-start",
        "margin-top",
        "-webkit-margin-top-collapse",
        "margin-trim",
        "marker",
        "marker-end",
        "marker-knockout-left",
        "marker-knockout-right",
        "marker-mid",
        "marker-offset",
        "marker-pattern",
        "marker-segment",
        "marker-side",
        "marker-start",
        "marks",
        "-wap-marquee-dir",
        "-webkit-marquee-direction",
        "-webkit-marquee-increment",
        "-wap-marquee-loop",
        "-webkit-marquee-repetition",
        "-wap-marquee-speed",
        "-webkit-marquee-speed",
        "-wap-marquee-style",
        "-webkit-marquee-style",
        "-webkit-marquee",
        "mask",
        "-webkit-mask-attachment",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "-webkit-mask-box-image-outset",
        "-webkit-mask-box-image-repeat",
        "-webkit-mask-box-image-slice",
        "-webkit-mask-box-image-source",
        "-webkit-mask-box-image",
        "-webkit-mask-box-image-width",
        "mask-clip",
        "-webkit-mask-clip",
        "mask-composite",
        "-webkit-mask-composite",
        "mask-image",
        "-webkit-mask-image",
        "mask-mode",
        "mask-origin",
        "-webkit-mask-origin",
        "mask-position",
        "-webkit-mask-position",
        "mask-position-x",
        "-webkit-mask-position-x",
        "mask-position-y",
        "-webkit-mask-position-y",
        "mask-repeat",
        "-webkit-mask-repeat",
        "-webkit-mask-repeat-x",
        "-webkit-mask-repeat-y",
        "mask-size",
        "-webkit-mask-size",
        "mask-source-type",
        "-webkit-mask-source-type",
        "mask-type",
        "-webkit-mask",
        "-webkit-match-nearest-mail-blockquote-color",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-lines",
        "-webkit-max-logical-height",
        "-webkit-max-logical-width",
        "max-width",
        "max-zoom",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "-webkit-min-logical-height",
        "-webkit-min-logical-width",
        "min-width",
        "min-zoom",
        "mix-blend-mode",
        "motion",
        "motion-offset",
        "motion-path",
        "motion-rotation",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "-webkit-nbsp-mode",
        "object-fit",
        "-o-object-fit",
        "object-position",
        "-o-object-position",
        "offset",
        "offset-anchor",
        "offset-block-end",
        "offset-block-start",
        "offset-distance",
        "offset-inline-end",
        "offset-inline-start",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "offset-rotation",
        "opacity",
        "-moz-opacity",
        "-webkit-opacity",
        "order",
        "-webkit-order",
        "-moz-orient",
        "orientation",
        "orphans",
        "-moz-osx-font-smoothing",
        "outline",
        "outline-color",
        "-moz-outline-color",
        "-moz-outline",
        "outline-offset",
        "-moz-outline-offset",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "outline-style",
        "-moz-outline-style",
        "outline-width",
        "-moz-outline-width",
        "overflow",
        "overflow-anchor",
        "overflow-block",
        "overflow-clip-margin",
        "overflow-inline",
        "-webkit-overflow-scrolling",
        "-ms-overflow-style",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "overscroll-behavior",
        "overscroll-behavior-block",
        "overscroll-behavior-inline",
        "overscroll-behavior-x",
        "overscroll-behavior-y",
        "padding",
        "-webkit-padding-after",
        "-webkit-padding-before",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "-moz-padding-end",
        "-webkit-padding-end",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "-moz-padding-start",
        "-webkit-padding-start",
        "padding-top",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-orientation",
        "paint-order",
        "pause",
        "pause-after",
        "pause-before",
        "pen-action",
        "perspective",
        "-moz-perspective",
        "-ms-perspective",
        "perspective-origin",
        "-moz-perspective-origin",
        "-ms-perspective-origin",
        "-webkit-perspective-origin",
        "perspective-origin-x",
        "-webkit-perspective-origin-x",
        "perspective-origin-y",
        "-webkit-perspective-origin-y",
        "-webkit-perspective",
        "pitch",
        "pitch-range",
        "place-content",
        "place-items",
        "place-self",
        "play-during",
        "pointer-events",
        "position",
        "-webkit-print-color-adjust",
        "property-name",
        "quotes",
        "r",
        "-webkit-region-break-after",
        "-webkit-region-break-before",
        "-webkit-region-break-inside",
        "region-fragment",
        "-webkit-region-fragment",
        "-webkit-region-overflow",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "richness",
        "right",
        "rotate",
        "row-gap",
        "-webkit-rtl-ordering",
        "ruby-align",
        "ruby-merge",
        "ruby-overhang",
        "ruby-position",
        "-webkit-ruby-position",
        "running",
        "rx",
        "ry",
        "scale",
        "scroll-behavior",
        "-ms-scroll-chaining",
        "-ms-scroll-limit",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-max",
        "-ms-scroll-limit-y-min",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "-ms-scroll-rails",
        "scroll-snap-align",
        "scroll-snap-coordinate",
        "-webkit-scroll-snap-coordinate",
        "scroll-snap-destination",
        "-webkit-scroll-snap-destination",
        "scroll-snap-margin",
        "scroll-snap-margin-bottom",
        "scroll-snap-margin-left",
        "scroll-snap-margin-right",
        "scroll-snap-margin-top",
        "scroll-snap-points-x",
        "-ms-scroll-snap-points-x",
        "-webkit-scroll-snap-points-x",
        "scroll-snap-points-y",
        "-ms-scroll-snap-points-y",
        "-webkit-scroll-snap-points-y",
        "scroll-snap-stop",
        "scroll-snap-type",
        "-ms-scroll-snap-type",
        "-webkit-scroll-snap-type",
        "scroll-snap-type-x",
        "scroll-snap-type-y",
        "-ms-scroll-snap-x",
        "-ms-scroll-snap-y",
        "-ms-scroll-translation",
        "scrollbar-arrow-color",
        "scrollbar-base-color",
        "scrollbar-color",
        "scrollbar-dark-shadow-color",
        "scrollbar-darkshadow-color",
        "scrollbar-face-color",
        "scrollbar-gutter",
        "scrollbar-highlight-color",
        "scrollbar-shadow-color",
        "scrollbar-track-color",
        "scrollbar-width",
        "scrollbar3d-light-color",
        "scrollbar3dlight-color",
        "shape-image-threshold",
        "-webkit-shape-image-threshold",
        "shape-inside",
        "-webkit-shape-inside",
        "shape-margin",
        "-webkit-shape-margin",
        "shape-outside",
        "-webkit-shape-outside",
        "-webkit-shape-padding",
        "shape-rendering",
        "size",
        "snap-height",
        "solid-color",
        "solid-opacity",
        "spatial-navigation-action",
        "spatial-navigation-contain",
        "spatial-navigation-function",
        "speak",
        "speak-as",
        "speak-header",
        "speak-numeral",
        "speak-punctuation",
        "speech-rate",
        "src",
        "-moz-stack-sizing",
        "stop-color",
        "stop-opacity",
        "stress",
        "string-set",
        "stroke",
        "stroke-align",
        "stroke-alignment",
        "stroke-break",
        "stroke-color",
        "stroke-dash-corner",
        "stroke-dash-justify",
        "stroke-dashadjust",
        "stroke-dasharray",
        "stroke-dashcorner",
        "stroke-dashoffset",
        "stroke-image",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-origin",
        "stroke-position",
        "stroke-repeat",
        "stroke-size",
        "stroke-width",
        "supported-color-schemes",
        "-webkit-svg-shadow",
        "syntax",
        "tab-size",
        "-moz-tab-size",
        "-o-tab-size",
        "-o-table-baseline",
        "table-layout",
        "-webkit-tap-highlight-color",
        "text-align",
        "text-align-all",
        "text-align-last",
        "-moz-text-align-last",
        "text-anchor",
        "text-autospace",
        "-moz-text-blink",
        "-ms-text-combine-horizontal",
        "text-combine-upright",
        "-webkit-text-combine",
        "text-decoration",
        "text-decoration-blink",
        "text-decoration-color",
        "-moz-text-decoration-color",
        "-webkit-text-decoration-color",
        "text-decoration-line",
        "-moz-text-decoration-line",
        "text-decoration-line-through",
        "-webkit-text-decoration-line",
        "text-decoration-none",
        "text-decoration-overline",
        "text-decoration-skip",
        "text-decoration-skip-box",
        "text-decoration-skip-ink",
        "text-decoration-skip-inset",
        "text-decoration-skip-self",
        "text-decoration-skip-spaces",
        "-webkit-text-decoration-skip",
        "text-decoration-style",
        "-moz-text-decoration-style",
        "-webkit-text-decoration-style",
        "text-decoration-thickness",
        "text-decoration-underline",
        "-webkit-text-decoration",
        "-webkit-text-decorations-in-effect",
        "text-edge",
        "text-emphasis",
        "text-emphasis-color",
        "-webkit-text-emphasis-color",
        "text-emphasis-position",
        "-webkit-text-emphasis-position",
        "text-emphasis-skip",
        "text-emphasis-style",
        "-webkit-text-emphasis-style",
        "-webkit-text-emphasis",
        "-webkit-text-fill-color",
        "text-group-align",
        "text-indent",
        "text-justify",
        "text-justify-trim",
        "text-kashida",
        "text-kashida-space",
        "text-line-through",
        "text-line-through-color",
        "text-line-through-mode",
        "text-line-through-style",
        "text-line-through-width",
        "text-orientation",
        "-webkit-text-orientation",
        "text-overflow",
        "text-overline",
        "text-overline-color",
        "text-overline-mode",
        "text-overline-style",
        "text-overline-width",
        "text-rendering",
        "-webkit-text-security",
        "text-shadow",
        "text-size-adjust",
        "-moz-text-size-adjust",
        "-ms-text-size-adjust",
        "-webkit-text-size-adjust",
        "text-space-collapse",
        "text-space-trim",
        "text-spacing",
        "-webkit-text-stroke-color",
        "-webkit-text-stroke",
        "-webkit-text-stroke-width",
        "text-transform",
        "text-underline",
        "text-underline-color",
        "text-underline-mode",
        "text-underline-offset",
        "text-underline-position",
        "-webkit-text-underline-position",
        "text-underline-style",
        "text-underline-width",
        "text-wrap",
        "-webkit-text-zoom",
        "top",
        "touch-action",
        "touch-action-delay",
        "-ms-touch-action",
        "-webkit-touch-callout",
        "-ms-touch-select",
        "transform",
        "transform-box",
        "-moz-transform",
        "-ms-transform",
        "-o-transform",
        "transform-origin",
        "-moz-transform-origin",
        "-ms-transform-origin",
        "-o-transform-origin",
        "-webkit-transform-origin",
        "transform-origin-x",
        "-webkit-transform-origin-x",
        "transform-origin-y",
        "-webkit-transform-origin-y",
        "transform-origin-z",
        "-webkit-transform-origin-z",
        "transform-style",
        "-moz-transform-style",
        "-ms-transform-style",
        "-webkit-transform-style",
        "-webkit-transform",
        "transition",
        "transition-delay",
        "-moz-transition-delay",
        "-ms-transition-delay",
        "-o-transition-delay",
        "-webkit-transition-delay",
        "transition-duration",
        "-moz-transition-duration",
        "-ms-transition-duration",
        "-o-transition-duration",
        "-webkit-transition-duration",
        "-moz-transition",
        "-ms-transition",
        "-o-transition",
        "transition-property",
        "-moz-transition-property",
        "-ms-transition-property",
        "-o-transition-property",
        "-webkit-transition-property",
        "transition-timing-function",
        "-moz-transition-timing-function",
        "-ms-transition-timing-function",
        "-o-transition-timing-function",
        "-webkit-transition-timing-function",
        "-webkit-transition",
        "translate",
        "uc-alt-skin",
        "uc-skin",
        "unicode-bidi",
        "unicode-range",
        "-webkit-user-drag",
        "-moz-user-focus",
        "-moz-user-input",
        "-moz-user-modify",
        "-webkit-user-modify",
        "user-select",
        "-moz-user-select",
        "-ms-user-select",
        "-webkit-user-select",
        "user-zoom",
        "vector-effect",
        "vertical-align",
        "viewport-fill",
        "viewport-fill-opacity",
        "viewport-fit",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "volume",
        "white-space",
        "-webkit-widget-region",
        "widows",
        "width",
        "will-change",
        "-moz-window-dragging",
        "-moz-window-shadow",
        "word-boundary-detection",
        "word-boundary-expansion",
        "word-break",
        "word-spacing",
        "word-wrap",
        "wrap-after",
        "wrap-before",
        "wrap-flow",
        "-ms-wrap-flow",
        "-webkit-wrap-flow",
        "wrap-inside",
        "-ms-wrap-margin",
        "-webkit-wrap-margin",
        "-webkit-wrap-padding",
        "-webkit-wrap-shape-inside",
        "-webkit-wrap-shape-outside",
        "wrap-through",
        "-ms-wrap-through",
        "-webkit-wrap-through",
        "-webkit-wrap",
        "writing-mode",
        "-webkit-writing-mode",
        "x",
        "y",
        "z-index",
        "zoom"] };


    }, {}], 17: [function (require, module, exports) {
      module.exports.all = require('./data/all.json').properties;

    }, { "./data/all.json": 16 }], 18: [function (require, module, exports) {
      var hashClear = require('./_hashClear'),
      hashDelete = require('./_hashDelete'),
      hashGet = require('./_hashGet'),
      hashHas = require('./_hashHas'),
      hashSet = require('./_hashSet');

      /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Hash(entries) {
        var index = -1,
        length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `Hash`.
      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;

      module.exports = Hash;

    }, { "./_hashClear": 36, "./_hashDelete": 37, "./_hashGet": 38, "./_hashHas": 39, "./_hashSet": 40 }], 19: [function (require, module, exports) {
      var listCacheClear = require('./_listCacheClear'),
      listCacheDelete = require('./_listCacheDelete'),
      listCacheGet = require('./_listCacheGet'),
      listCacheHas = require('./_listCacheHas'),
      listCacheSet = require('./_listCacheSet');

      /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function ListCache(entries) {
        var index = -1,
        length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `ListCache`.
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;

      module.exports = ListCache;

    }, { "./_listCacheClear": 44, "./_listCacheDelete": 45, "./_listCacheGet": 46, "./_listCacheHas": 47, "./_listCacheSet": 48 }], 20: [function (require, module, exports) {
      var getNative = require('./_getNative'),
      root = require('./_root');

      /* Built-in method references that are verified to be native. */
      var Map = getNative(root, 'Map');

      module.exports = Map;

    }, { "./_getNative": 33, "./_root": 57 }], 21: [function (require, module, exports) {
      var mapCacheClear = require('./_mapCacheClear'),
      mapCacheDelete = require('./_mapCacheDelete'),
      mapCacheGet = require('./_mapCacheGet'),
      mapCacheHas = require('./_mapCacheHas'),
      mapCacheSet = require('./_mapCacheSet');

      /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function MapCache(entries) {
        var index = -1,
        length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      // Add methods to `MapCache`.
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;

      module.exports = MapCache;

    }, { "./_mapCacheClear": 49, "./_mapCacheDelete": 50, "./_mapCacheGet": 51, "./_mapCacheHas": 52, "./_mapCacheSet": 53 }], 22: [function (require, module, exports) {
      var root = require('./_root');

      /** Built-in value references. */
      var Symbol = root.Symbol;

      module.exports = Symbol;

    }, { "./_root": 57 }], 23: [function (require, module, exports) {
      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      module.exports = arrayMap;

    }, {}], 24: [function (require, module, exports) {
      var eq = require('./eq');

      /**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }

      module.exports = assocIndexOf;

    }, { "./eq": 61 }], 25: [function (require, module, exports) {
      var castPath = require('./_castPath'),
      toKey = require('./_toKey');

      /**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */
      function baseGet(object, path) {
        path = castPath(path, object);

        var index = 0,
        length = path.length;

        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined;
      }

      module.exports = baseGet;

    }, { "./_castPath": 29, "./_toKey": 59 }], 26: [function (require, module, exports) {
      var Symbol = require('./_Symbol'),
      getRawTag = require('./_getRawTag'),
      objectToString = require('./_objectToString');

      /** `Object#toString` result references. */
      var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

      /** Built-in value references. */
      var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ?
        getRawTag(value) :
        objectToString(value);
      }

      module.exports = baseGetTag;

    }, { "./_Symbol": 22, "./_getRawTag": 34, "./_objectToString": 56 }], 27: [function (require, module, exports) {
      var isFunction = require('./isFunction'),
      isMasked = require('./_isMasked'),
      isObject = require('./isObject'),
      toSource = require('./_toSource');

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used for built-in method references. */
      var funcProto = Function.prototype,
      objectProto = Object.prototype;

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Used to detect if a method is native. */
      var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').
      replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');


      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

      module.exports = baseIsNative;

    }, { "./_isMasked": 43, "./_toSource": 60, "./isFunction": 64, "./isObject": 65 }], 28: [function (require, module, exports) {
      var Symbol = require('./_Symbol'),
      arrayMap = require('./_arrayMap'),
      isArray = require('./isArray'),
      isSymbol = require('./isSymbol');

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0;

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value;
        }
        if (isArray(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return arrayMap(value, baseToString) + '';
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }
        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      module.exports = baseToString;

    }, { "./_Symbol": 22, "./_arrayMap": 23, "./isArray": 63, "./isSymbol": 67 }], 29: [function (require, module, exports) {
      var isArray = require('./isArray'),
      isKey = require('./_isKey'),
      stringToPath = require('./_stringToPath'),
      toString = require('./toString');

      /**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }

      module.exports = castPath;

    }, { "./_isKey": 41, "./_stringToPath": 58, "./isArray": 63, "./toString": 70 }], 30: [function (require, module, exports) {
      var root = require('./_root');

      /** Used to detect overreaching core-js shims. */
      var coreJsData = root['__core-js_shared__'];

      module.exports = coreJsData;

    }, { "./_root": 57 }], 31: [function (require, module, exports) {
      (function (global) {(function () {
          /** Detect free variable `global` from Node.js. */
          var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

          module.exports = freeGlobal;

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 32: [function (require, module, exports) {
      var isKeyable = require('./_isKeyable');

      /**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ?
        data[typeof key == 'string' ? 'string' : 'hash'] :
        data.map;
      }

      module.exports = getMapData;

    }, { "./_isKeyable": 42 }], 33: [function (require, module, exports) {
      var baseIsNative = require('./_baseIsNative'),
      getValue = require('./_getValue');

      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
      }

      module.exports = getNative;

    }, { "./_baseIsNative": 27, "./_getValue": 35 }], 34: [function (require, module, exports) {
      var Symbol = require('./_Symbol');

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /** Built-in value references. */
      var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

      module.exports = getRawTag;

    }, { "./_Symbol": 22 }], 35: [function (require, module, exports) {
      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

      module.exports = getValue;

    }, {}], 36: [function (require, module, exports) {
      var nativeCreate = require('./_nativeCreate');

      /**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

      module.exports = hashClear;

    }, { "./_nativeCreate": 55 }], 37: [function (require, module, exports) {
      /**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = hashDelete;

    }, {}], 38: [function (require, module, exports) {
      var nativeCreate = require('./_nativeCreate');

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
      }

      module.exports = hashGet;

    }, { "./_nativeCreate": 55 }], 39: [function (require, module, exports) {
      var nativeCreate = require('./_nativeCreate');

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
      }

      module.exports = hashHas;

    }, { "./_nativeCreate": 55 }], 40: [function (require, module, exports) {
      var nativeCreate = require('./_nativeCreate');

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        return this;
      }

      module.exports = hashSet;

    }, { "./_nativeCreate": 55 }], 41: [function (require, module, exports) {
      var isArray = require('./isArray'),
      isSymbol = require('./isSymbol');

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

      /**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        object != null && value in Object(object);
      }

      module.exports = isKey;

    }, { "./isArray": 63, "./isSymbol": 67 }], 42: [function (require, module, exports) {
      /**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */
      function isKeyable(value) {
        var type = typeof value;
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ?
        value !== '__proto__' :
        value === null;
      }

      module.exports = isKeyable;

    }, {}], 43: [function (require, module, exports) {
      var coreJsData = require('./_coreJsData');

      /** Used to detect methods masquerading as native. */
      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();

      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }

      module.exports = isMasked;

    }, { "./_coreJsData": 30 }], 44: [function (require, module, exports) {
      /**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

      module.exports = listCacheClear;

    }, {}], 45: [function (require, module, exports) {
      var assocIndexOf = require('./_assocIndexOf');

      /** Used for built-in method references. */
      var arrayProto = Array.prototype;

      /** Built-in value references. */
      var splice = arrayProto.splice;

      /**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function listCacheDelete(key) {
        var data = this.__data__,
        index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }

      module.exports = listCacheDelete;

    }, { "./_assocIndexOf": 24 }], 46: [function (require, module, exports) {
      var assocIndexOf = require('./_assocIndexOf');

      /**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function listCacheGet(key) {
        var data = this.__data__,
        index = assocIndexOf(data, key);

        return index < 0 ? undefined : data[index][1];
      }

      module.exports = listCacheGet;

    }, { "./_assocIndexOf": 24 }], 47: [function (require, module, exports) {
      var assocIndexOf = require('./_assocIndexOf');

      /**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

      module.exports = listCacheHas;

    }, { "./_assocIndexOf": 24 }], 48: [function (require, module, exports) {
      var assocIndexOf = require('./_assocIndexOf');

      /**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */
      function listCacheSet(key, value) {
        var data = this.__data__,
        index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }

      module.exports = listCacheSet;

    }, { "./_assocIndexOf": 24 }], 49: [function (require, module, exports) {
      var Hash = require('./_Hash'),
      ListCache = require('./_ListCache'),
      Map = require('./_Map');

      /**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash(),
          'map': new (Map || ListCache)(),
          'string': new Hash() };

      }

      module.exports = mapCacheClear;

    }, { "./_Hash": 18, "./_ListCache": 19, "./_Map": 20 }], 50: [function (require, module, exports) {
      var getMapData = require('./_getMapData');

      /**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

      module.exports = mapCacheDelete;

    }, { "./_getMapData": 32 }], 51: [function (require, module, exports) {
      var getMapData = require('./_getMapData');

      /**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

      module.exports = mapCacheGet;

    }, { "./_getMapData": 32 }], 52: [function (require, module, exports) {
      var getMapData = require('./_getMapData');

      /**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

      module.exports = mapCacheHas;

    }, { "./_getMapData": 32 }], 53: [function (require, module, exports) {
      var getMapData = require('./_getMapData');

      /**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */
      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
        size = data.size;

        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

      module.exports = mapCacheSet;

    }, { "./_getMapData": 32 }], 54: [function (require, module, exports) {
      var memoize = require('./memoize');

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */
      function memoizeCapped(func) {
        var result = memoize(func, function (key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });

        var cache = result.cache;
        return result;
      }

      module.exports = memoizeCapped;

    }, { "./memoize": 69 }], 55: [function (require, module, exports) {
      var getNative = require('./_getNative');

      /* Built-in method references that are verified to be native. */
      var nativeCreate = getNative(Object, 'create');

      module.exports = nativeCreate;

    }, { "./_getNative": 33 }], 56: [function (require, module, exports) {
      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      module.exports = objectToString;

    }, {}], 57: [function (require, module, exports) {
      var freeGlobal = require('./_freeGlobal');

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      module.exports = root;

    }, { "./_freeGlobal": 31 }], 58: [function (require, module, exports) {
      var memoizeCapped = require('./_memoizeCapped');

      /** Used to match property names within property paths. */
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */
      var stringToPath = memoizeCapped(function (string) {
        var result = [];
        if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
        string.replace(rePropName, function (match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
        });
        return result;
      });

      module.exports = stringToPath;

    }, { "./_memoizeCapped": 54 }], 59: [function (require, module, exports) {
      var isSymbol = require('./isSymbol');

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0;

      /**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */
      function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
          return value;
        }
        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }

      module.exports = toKey;

    }, { "./isSymbol": 67 }], 60: [function (require, module, exports) {
      /** Used for built-in method references. */
      var funcProto = Function.prototype;

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return func + '';
          } catch (e) {}
        }
        return '';
      }

      module.exports = toSource;

    }, {}], 61: [function (require, module, exports) {
      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }

      module.exports = eq;

    }, {}], 62: [function (require, module, exports) {
      var baseGet = require('./_baseGet');

      /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */
      function get(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path);
        return result === undefined ? defaultValue : result;
      }

      module.exports = get;

    }, { "./_baseGet": 25 }], 63: [function (require, module, exports) {
      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */
      var isArray = Array.isArray;

      module.exports = isArray;

    }, {}], 64: [function (require, module, exports) {
      var baseGetTag = require('./_baseGetTag'),
      isObject = require('./isObject');

      /** `Object#toString` result references. */
      var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

      module.exports = isFunction;

    }, { "./_baseGetTag": 26, "./isObject": 65 }], 65: [function (require, module, exports) {
      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
      }

      module.exports = isObject;

    }, {}], 66: [function (require, module, exports) {
      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && typeof value == 'object';
      }

      module.exports = isObjectLike;

    }, {}], 67: [function (require, module, exports) {
      var baseGetTag = require('./_baseGetTag'),
      isObjectLike = require('./isObjectLike');

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]';

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return typeof value == 'symbol' ||
        isObjectLike(value) && baseGetTag(value) == symbolTag;
      }

      module.exports = isSymbol;

    }, { "./_baseGetTag": 26, "./isObjectLike": 66 }], 68: [function (require, module, exports) {
      (function (global) {(function () {
          /**
           * @license
           * Lodash <https://lodash.com/>
           * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
           * Released under MIT license <https://lodash.com/license>
           * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
           * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
           */
          ;(function () {

            /** Used as a safe reference for `undefined` in pre-ES5 environments. */
            var undefined;

            /** Used as the semantic version number. */
            var VERSION = '4.17.20';

            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200;

            /** Error message constants. */
            var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
            FUNC_ERROR_TEXT = 'Expected a function';

            /** Used to stand-in for `undefined` hash values. */
            var HASH_UNDEFINED = '__lodash_hash_undefined__';

            /** Used as the maximum memoize cache size. */
            var MAX_MEMOIZE_SIZE = 500;

            /** Used as the internal argument placeholder. */
            var PLACEHOLDER = '__lodash_placeholder__';

            /** Used to compose bitmasks for cloning. */
            var CLONE_DEEP_FLAG = 1,
            CLONE_FLAT_FLAG = 2,
            CLONE_SYMBOLS_FLAG = 4;

            /** Used to compose bitmasks for value comparisons. */
            var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;

            /** Used to compose bitmasks for function metadata. */
            var WRAP_BIND_FLAG = 1,
            WRAP_BIND_KEY_FLAG = 2,
            WRAP_CURRY_BOUND_FLAG = 4,
            WRAP_CURRY_FLAG = 8,
            WRAP_CURRY_RIGHT_FLAG = 16,
            WRAP_PARTIAL_FLAG = 32,
            WRAP_PARTIAL_RIGHT_FLAG = 64,
            WRAP_ARY_FLAG = 128,
            WRAP_REARG_FLAG = 256,
            WRAP_FLIP_FLAG = 512;

            /** Used as default options for `_.truncate`. */
            var DEFAULT_TRUNC_LENGTH = 30,
            DEFAULT_TRUNC_OMISSION = '...';

            /** Used to detect hot functions by number of calls within a span of milliseconds. */
            var HOT_COUNT = 800,
            HOT_SPAN = 16;

            /** Used to indicate the type of lazy iteratees. */
            var LAZY_FILTER_FLAG = 1,
            LAZY_MAP_FLAG = 2,
            LAZY_WHILE_FLAG = 3;

            /** Used as references for various `Number` constants. */
            var INFINITY = 1 / 0,
            MAX_SAFE_INTEGER = 9007199254740991,
            MAX_INTEGER = 1.7976931348623157e+308,
            NAN = 0 / 0;

            /** Used as references for the maximum length and index of an array. */
            var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

            /** Used to associate wrap methods with their bit flags. */
            var wrapFlags = [
            ['ary', WRAP_ARY_FLAG],
            ['bind', WRAP_BIND_FLAG],
            ['bindKey', WRAP_BIND_KEY_FLAG],
            ['curry', WRAP_CURRY_FLAG],
            ['curryRight', WRAP_CURRY_RIGHT_FLAG],
            ['flip', WRAP_FLIP_FLAG],
            ['partial', WRAP_PARTIAL_FLAG],
            ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
            ['rearg', WRAP_REARG_FLAG]];


            /** `Object#toString` result references. */
            var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            domExcTag = '[object DOMException]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]',
            weakSetTag = '[object WeakSet]';

            var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

            /** Used to match empty string literals in compiled template source. */
            var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

            /** Used to match HTML entities and HTML characters. */
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
            reUnescapedHtml = /[&<>"']/g,
            reHasEscapedHtml = RegExp(reEscapedHtml.source),
            reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

            /** Used to match template delimiters. */
            var reEscape = /<%-([\s\S]+?)%>/g,
            reEvaluate = /<%([\s\S]+?)%>/g,
            reInterpolate = /<%=([\s\S]+?)%>/g;

            /** Used to match property names within property paths. */
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

            /**
             * Used to match `RegExp`
             * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
             */
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source);

            /** Used to match leading and trailing whitespace. */
            var reTrim = /^\s+|\s+$/g,
            reTrimStart = /^\s+/,
            reTrimEnd = /\s+$/;

            /** Used to match wrap detail comments. */
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
            reSplitDetails = /,? & /;

            /** Used to match words composed of alphanumeric characters. */
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

            /** Used to match backslashes in property paths. */
            var reEscapeChar = /\\(\\)?/g;

            /**
             * Used to match
             * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
             */
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

            /** Used to match `RegExp` flags from their coerced string values. */
            var reFlags = /\w*$/;

            /** Used to detect bad signed hexadecimal string values. */
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

            /** Used to detect binary string values. */
            var reIsBinary = /^0b[01]+$/i;

            /** Used to detect host constructors (Safari). */
            var reIsHostCtor = /^\[object .+?Constructor\]$/;

            /** Used to detect octal string values. */
            var reIsOctal = /^0o[0-7]+$/i;

            /** Used to detect unsigned integer values. */
            var reIsUint = /^(?:0|[1-9]\d*)$/;

            /** Used to match Latin Unicode letters (excluding mathematical operators). */
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

            /** Used to ensure capturing order of template delimiters. */
            var reNoMatch = /($^)/;

            /** Used to match unescaped characters in compiled string literals. */
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

            /** Used to compose unicode character classes. */
            var rsAstralRange = '\\ud800-\\udfff',
            rsComboMarksRange = '\\u0300-\\u036f',
            reComboHalfMarksRange = '\\ufe20-\\ufe2f',
            rsComboSymbolsRange = '\\u20d0-\\u20ff',
            rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
            rsDingbatRange = '\\u2700-\\u27bf',
            rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
            rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
            rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
            rsPunctuationRange = '\\u2000-\\u206f',
            rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
            rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
            rsVarRange = '\\ufe0e\\ufe0f',
            rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

            /** Used to compose unicode capture groups. */
            var rsApos = "['\u2019]",
            rsAstral = '[' + rsAstralRange + ']',
            rsBreak = '[' + rsBreakRange + ']',
            rsCombo = '[' + rsComboRange + ']',
            rsDigits = '\\d+',
            rsDingbat = '[' + rsDingbatRange + ']',
            rsLower = '[' + rsLowerRange + ']',
            rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
            rsFitz = '\\ud83c[\\udffb-\\udfff]',
            rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
            rsNonAstral = '[^' + rsAstralRange + ']',
            rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
            rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
            rsUpper = '[' + rsUpperRange + ']',
            rsZWJ = '\\u200d';

            /** Used to compose unicode regexes. */
            var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
            rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
            rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
            rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
            reOptMod = rsModifier + '?',
            rsOptVar = '[' + rsVarRange + ']?',
            rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
            rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
            rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
            rsSeq = rsOptVar + reOptMod + rsOptJoin,
            rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
            rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

            /** Used to match apostrophes. */
            var reApos = RegExp(rsApos, 'g');

            /**
             * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
             * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
             */
            var reComboMark = RegExp(rsCombo, 'g');

            /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
            var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

            /** Used to match complex or compound words. */
            var reUnicodeWord = RegExp([
            rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
            rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
            rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
            rsUpper + '+' + rsOptContrUpper,
            rsOrdUpper,
            rsOrdLower,
            rsDigits,
            rsEmoji].
            join('|'), 'g');

            /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
            var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

            /** Used to detect strings that need a more robust regexp to match words. */
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

            /** Used to assign default `context` object properties. */
            var contextProps = [
            'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
            'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
            'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
            'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
            '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];


            /** Used to make template sourceURLs easier to identify. */
            var templateCounter = -1;

            /** Used to identify `toStringTag` values of typed arrays. */
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
            typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
            typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
            typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
            typedArrayTags[errorTag] = typedArrayTags[funcTag] =
            typedArrayTags[mapTag] = typedArrayTags[numberTag] =
            typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
            typedArrayTags[setTag] = typedArrayTags[stringTag] =
            typedArrayTags[weakMapTag] = false;

            /** Used to identify `toStringTag` values supported by `_.clone`. */
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] =
            cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
            cloneableTags[boolTag] = cloneableTags[dateTag] =
            cloneableTags[float32Tag] = cloneableTags[float64Tag] =
            cloneableTags[int8Tag] = cloneableTags[int16Tag] =
            cloneableTags[int32Tag] = cloneableTags[mapTag] =
            cloneableTags[numberTag] = cloneableTags[objectTag] =
            cloneableTags[regexpTag] = cloneableTags[setTag] =
            cloneableTags[stringTag] = cloneableTags[symbolTag] =
            cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] =
            cloneableTags[weakMapTag] = false;

            /** Used to map Latin Unicode letters to basic Latin letters. */
            var deburredLetters = {
              // Latin-1 Supplement block.
              '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
              '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
              '\xc7': 'C', '\xe7': 'c',
              '\xd0': 'D', '\xf0': 'd',
              '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
              '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
              '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
              '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
              '\xd1': 'N', '\xf1': 'n',
              '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
              '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
              '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
              '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
              '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
              '\xc6': 'Ae', '\xe6': 'ae',
              '\xde': 'Th', '\xfe': 'th',
              '\xdf': 'ss',
              // Latin Extended-A block.
              '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
              '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
              '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
              '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
              '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
              '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
              '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
              '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
              '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
              '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
              '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
              '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
              '\u0134': 'J', '\u0135': 'j',
              '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
              '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
              '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
              '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
              '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
              '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
              '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
              '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
              '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
              '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
              '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
              '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
              '\u0163': 't', '\u0165': 't', '\u0167': 't',
              '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
              '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
              '\u0174': 'W', '\u0175': 'w',
              '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
              '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
              '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
              '\u0132': 'IJ', '\u0133': 'ij',
              '\u0152': 'Oe', '\u0153': 'oe',
              '\u0149': "'n", '\u017f': 's' };


            /** Used to map characters to HTML entities. */
            var htmlEscapes = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;' };


            /** Used to map HTML entities to characters. */
            var htmlUnescapes = {
              '&amp;': '&',
              '&lt;': '<',
              '&gt;': '>',
              '&quot;': '"',
              '&#39;': "'" };


            /** Used to escape characters for inclusion in compiled string literals. */
            var stringEscapes = {
              '\\': '\\',
              "'": "'",
              '\n': 'n',
              '\r': 'r',
              '\u2028': 'u2028',
              '\u2029': 'u2029' };


            /** Built-in method references without a dependency on `root`. */
            var freeParseFloat = parseFloat,
            freeParseInt = parseInt;

            /** Detect free variable `global` from Node.js. */
            var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

            /** Detect free variable `self`. */
            var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

            /** Used as a reference to the global object. */
            var root = freeGlobal || freeSelf || Function('return this')();

            /** Detect free variable `exports`. */
            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

            /** Detect free variable `module`. */
            var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

            /** Detect the popular CommonJS extension `module.exports`. */
            var moduleExports = freeModule && freeModule.exports === freeExports;

            /** Detect free variable `process` from Node.js. */
            var freeProcess = moduleExports && freeGlobal.process;

            /** Used to access faster Node.js helpers. */
            var nodeUtil = function () {
              try {
                // Use `util.types` for Node.js 10+.
                var types = freeModule && freeModule.require && freeModule.require('util').types;

                if (types) {
                  return types;
                }

                // Legacy `process.binding('util')` for Node.js < 10.
                return freeProcess && freeProcess.binding && freeProcess.binding('util');
              } catch (e) {}
            }();

            /* Node.js helper references. */
            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
            nodeIsDate = nodeUtil && nodeUtil.isDate,
            nodeIsMap = nodeUtil && nodeUtil.isMap,
            nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
            nodeIsSet = nodeUtil && nodeUtil.isSet,
            nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

            /*--------------------------------------------------------------------------*/

            /**
             * A faster alternative to `Function#apply`, this function invokes `func`
             * with the `this` binding of `thisArg` and the arguments of `args`.
             *
             * @private
             * @param {Function} func The function to invoke.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} args The arguments to invoke `func` with.
             * @returns {*} Returns the result of `func`.
             */
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:return func.call(thisArg);
                case 1:return func.call(thisArg, args[0]);
                case 2:return func.call(thisArg, args[0], args[1]);
                case 3:return func.call(thisArg, args[0], args[1], args[2]);}

              return func.apply(thisArg, args);
            }

            /**
             * A specialized version of `baseAggregator` for arrays.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} setter The function to set `accumulator` values.
             * @param {Function} iteratee The iteratee to transform keys.
             * @param {Object} accumulator The initial aggregated object.
             * @returns {Function} Returns `accumulator`.
             */
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index = -1,
              length = array == null ? 0 : array.length;

              while (++index < length) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }

            /**
             * A specialized version of `_.forEach` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEach(array, iteratee) {
              var index = -1,
              length = array == null ? 0 : array.length;

              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }

            /**
             * A specialized version of `_.forEachRight` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns `array`.
             */
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;

              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }

            /**
             * A specialized version of `_.every` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if all elements pass the predicate check,
             *  else `false`.
             */
            function arrayEvery(array, predicate) {
              var index = -1,
              length = array == null ? 0 : array.length;

              while (++index < length) {
                if (!predicate(array[index], index, array)) {
                  return false;
                }
              }
              return true;
            }

            /**
             * A specialized version of `_.filter` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {Array} Returns the new filtered array.
             */
            function arrayFilter(array, predicate) {
              var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }

            /**
             * A specialized version of `_.includes` for arrays without support for
             * specifying an index to search from.
             *
             * @private
             * @param {Array} [array] The array to inspect.
             * @param {*} target The value to search for.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }

            /**
             * This function is like `arrayIncludes` except that it accepts a comparator.
             *
             * @private
             * @param {Array} [array] The array to inspect.
             * @param {*} target The value to search for.
             * @param {Function} comparator The comparator invoked per element.
             * @returns {boolean} Returns `true` if `target` is found, else `false`.
             */
            function arrayIncludesWith(array, value, comparator) {
              var index = -1,
              length = array == null ? 0 : array.length;

              while (++index < length) {
                if (comparator(value, array[index])) {
                  return true;
                }
              }
              return false;
            }

            /**
             * A specialized version of `_.map` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the new mapped array.
             */
            function arrayMap(array, iteratee) {
              var index = -1,
              length = array == null ? 0 : array.length,
              result = Array(length);

              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }

            /**
             * Appends the elements of `values` to `array`.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {Array} values The values to append.
             * @returns {Array} Returns `array`.
             */
            function arrayPush(array, values) {
              var index = -1,
              length = values.length,
              offset = array.length;

              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }

            /**
             * A specialized version of `_.reduce` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} [accumulator] The initial value.
             * @param {boolean} [initAccum] Specify using the first element of `array` as
             *  the initial value.
             * @returns {*} Returns the accumulated value.
             */
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1,
              length = array == null ? 0 : array.length;

              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }

            /**
             * A specialized version of `_.reduceRight` for arrays without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} [accumulator] The initial value.
             * @param {boolean} [initAccum] Specify using the last element of `array` as
             *  the initial value.
             * @returns {*} Returns the accumulated value.
             */
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }

            /**
             * A specialized version of `_.some` for arrays without support for iteratee
             * shorthands.
             *
             * @private
             * @param {Array} [array] The array to iterate over.
             * @param {Function} predicate The function invoked per iteration.
             * @returns {boolean} Returns `true` if any element passes the predicate check,
             *  else `false`.
             */
            function arraySome(array, predicate) {
              var index = -1,
              length = array == null ? 0 : array.length;

              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }

            /**
             * Gets the size of an ASCII `string`.
             *
             * @private
             * @param {string} string The string inspect.
             * @returns {number} Returns the string size.
             */
            var asciiSize = baseProperty('length');

            /**
             * Converts an ASCII `string` to an array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the converted array.
             */
            function asciiToArray(string) {
              return string.split('');
            }

            /**
             * Splits an ASCII `string` into an array of its words.
             *
             * @private
             * @param {string} The string to inspect.
             * @returns {Array} Returns the words of `string`.
             */
            function asciiWords(string) {
              return string.match(reAsciiWord) || [];
            }

            /**
             * The base implementation of methods like `_.findKey` and `_.findLastKey`,
             * without support for iteratee shorthands, which iterates over `collection`
             * using `eachFunc`.
             *
             * @private
             * @param {Array|Object} collection The collection to inspect.
             * @param {Function} predicate The function invoked per iteration.
             * @param {Function} eachFunc The function to iterate over `collection`.
             * @returns {*} Returns the found element or its key, else `undefined`.
             */
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }

            /**
             * The base implementation of `_.findIndex` and `_.findLastIndex` without
             * support for iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {Function} predicate The function invoked per iteration.
             * @param {number} fromIndex The index to search from.
             * @param {boolean} [fromRight] Specify iterating from right to left.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length,
              index = fromIndex + (fromRight ? 1 : -1);

              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }

            /**
             * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOf(array, value, fromIndex) {
              return value === value ?
              strictIndexOf(array, value, fromIndex) :
              baseFindIndex(array, baseIsNaN, fromIndex);
            }

            /**
             * This function is like `baseIndexOf` except that it accepts a comparator.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @param {Function} comparator The comparator invoked per element.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index = fromIndex - 1,
              length = array.length;

              while (++index < length) {
                if (comparator(array[index], value)) {
                  return index;
                }
              }
              return -1;
            }

            /**
             * The base implementation of `_.isNaN` without support for number objects.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
             */
            function baseIsNaN(value) {
              return value !== value;
            }

            /**
             * The base implementation of `_.mean` and `_.meanBy` without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {number} Returns the mean.
             */
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN;
            }

            /**
             * The base implementation of `_.property` without support for deep paths.
             *
             * @private
             * @param {string} key The key of the property to get.
             * @returns {Function} Returns the new accessor function.
             */
            function baseProperty(key) {
              return function (object) {
                return object == null ? undefined : object[key];
              };
            }

            /**
             * The base implementation of `_.propertyOf` without support for deep paths.
             *
             * @private
             * @param {Object} object The object to query.
             * @returns {Function} Returns the new accessor function.
             */
            function basePropertyOf(object) {
              return function (key) {
                return object == null ? undefined : object[key];
              };
            }

            /**
             * The base implementation of `_.reduce` and `_.reduceRight`, without support
             * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
             *
             * @private
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @param {*} accumulator The initial value.
             * @param {boolean} initAccum Specify using the first or last element of
             *  `collection` as the initial value.
             * @param {Function} eachFunc The function to iterate over `collection`.
             * @returns {*} Returns the accumulated value.
             */
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function (value, index, collection) {
                accumulator = initAccum ? (
                initAccum = false, value) :
                iteratee(accumulator, value, index, collection);
              });
              return accumulator;
            }

            /**
             * The base implementation of `_.sortBy` which uses `comparer` to define the
             * sort order of `array` and replaces criteria objects with their corresponding
             * values.
             *
             * @private
             * @param {Array} array The array to sort.
             * @param {Function} comparer The function to define sort order.
             * @returns {Array} Returns `array`.
             */
            function baseSortBy(array, comparer) {
              var length = array.length;

              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }

            /**
             * The base implementation of `_.sum` and `_.sumBy` without support for
             * iteratee shorthands.
             *
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {number} Returns the sum.
             */
            function baseSum(array, iteratee) {
              var result,
              index = -1,
              length = array.length;

              while (++index < length) {
                var current = iteratee(array[index]);
                if (current !== undefined) {
                  result = result === undefined ? current : result + current;
                }
              }
              return result;
            }

            /**
             * The base implementation of `_.times` without support for iteratee shorthands
             * or max array length checks.
             *
             * @private
             * @param {number} n The number of times to invoke `iteratee`.
             * @param {Function} iteratee The function invoked per iteration.
             * @returns {Array} Returns the array of results.
             */
            function baseTimes(n, iteratee) {
              var index = -1,
              result = Array(n);

              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }

            /**
             * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
             * of key-value pairs for `object` corresponding to the property names of `props`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array} props The property names to get values for.
             * @returns {Object} Returns the key-value pairs.
             */
            function baseToPairs(object, props) {
              return arrayMap(props, function (key) {
                return [key, object[key]];
              });
            }

            /**
             * The base implementation of `_.unary` without support for storing metadata.
             *
             * @private
             * @param {Function} func The function to cap arguments for.
             * @returns {Function} Returns the new capped function.
             */
            function baseUnary(func) {
              return function (value) {
                return func(value);
              };
            }

            /**
             * The base implementation of `_.values` and `_.valuesIn` which creates an
             * array of `object` property values corresponding to the property names
             * of `props`.
             *
             * @private
             * @param {Object} object The object to query.
             * @param {Array} props The property names to get values for.
             * @returns {Object} Returns the array of property values.
             */
            function baseValues(object, props) {
              return arrayMap(props, function (key) {
                return object[key];
              });
            }

            /**
             * Checks if a `cache` value for `key` exists.
             *
             * @private
             * @param {Object} cache The cache to query.
             * @param {string} key The key of the entry to check.
             * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
             */
            function cacheHas(cache, key) {
              return cache.has(key);
            }

            /**
             * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
             * that is not found in the character symbols.
             *
             * @private
             * @param {Array} strSymbols The string symbols to inspect.
             * @param {Array} chrSymbols The character symbols to find.
             * @returns {number} Returns the index of the first unmatched string symbol.
             */
            function charsStartIndex(strSymbols, chrSymbols) {
              var index = -1,
              length = strSymbols.length;

              while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
              return index;
            }

            /**
             * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
             * that is not found in the character symbols.
             *
             * @private
             * @param {Array} strSymbols The string symbols to inspect.
             * @param {Array} chrSymbols The character symbols to find.
             * @returns {number} Returns the index of the last unmatched string symbol.
             */
            function charsEndIndex(strSymbols, chrSymbols) {
              var index = strSymbols.length;

              while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
              return index;
            }

            /**
             * Gets the number of `placeholder` occurrences in `array`.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} placeholder The placeholder to search for.
             * @returns {number} Returns the placeholder count.
             */
            function countHolders(array, placeholder) {
              var length = array.length,
              result = 0;

              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }

            /**
             * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
             * letters to basic Latin letters.
             *
             * @private
             * @param {string} letter The matched letter to deburr.
             * @returns {string} Returns the deburred letter.
             */
            var deburrLetter = basePropertyOf(deburredLetters);

            /**
             * Used by `_.escape` to convert characters to HTML entities.
             *
             * @private
             * @param {string} chr The matched character to escape.
             * @returns {string} Returns the escaped character.
             */
            var escapeHtmlChar = basePropertyOf(htmlEscapes);

            /**
             * Used by `_.template` to escape characters for inclusion in compiled string literals.
             *
             * @private
             * @param {string} chr The matched character to escape.
             * @returns {string} Returns the escaped character.
             */
            function escapeStringChar(chr) {
              return '\\' + stringEscapes[chr];
            }

            /**
             * Gets the value at `key` of `object`.
             *
             * @private
             * @param {Object} [object] The object to query.
             * @param {string} key The key of the property to get.
             * @returns {*} Returns the property value.
             */
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }

            /**
             * Checks if `string` contains Unicode symbols.
             *
             * @private
             * @param {string} string The string to inspect.
             * @returns {boolean} Returns `true` if a symbol is found, else `false`.
             */
            function hasUnicode(string) {
              return reHasUnicode.test(string);
            }

            /**
             * Checks if `string` contains a word composed of Unicode symbols.
             *
             * @private
             * @param {string} string The string to inspect.
             * @returns {boolean} Returns `true` if a word is found, else `false`.
             */
            function hasUnicodeWord(string) {
              return reHasUnicodeWord.test(string);
            }

            /**
             * Converts `iterator` to an array.
             *
             * @private
             * @param {Object} iterator The iterator to convert.
             * @returns {Array} Returns the converted array.
             */
            function iteratorToArray(iterator) {
              var data,
              result = [];

              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }

            /**
             * Converts `map` to its key-value pairs.
             *
             * @private
             * @param {Object} map The map to convert.
             * @returns {Array} Returns the key-value pairs.
             */
            function mapToArray(map) {
              var index = -1,
              result = Array(map.size);

              map.forEach(function (value, key) {
                result[++index] = [key, value];
              });
              return result;
            }

            /**
             * Creates a unary function that invokes `func` with its argument transformed.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @param {Function} transform The argument transform.
             * @returns {Function} Returns the new function.
             */
            function overArg(func, transform) {
              return function (arg) {
                return func(transform(arg));
              };
            }

            /**
             * Replaces all `placeholder` elements in `array` with an internal placeholder
             * and returns an array of their indexes.
             *
             * @private
             * @param {Array} array The array to modify.
             * @param {*} placeholder The placeholder to replace.
             * @returns {Array} Returns the new array of placeholder indexes.
             */
            function replaceHolders(array, placeholder) {
              var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }

            /**
             * Converts `set` to an array of its values.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the values.
             */
            function setToArray(set) {
              var index = -1,
              result = Array(set.size);

              set.forEach(function (value) {
                result[++index] = value;
              });
              return result;
            }

            /**
             * Converts `set` to its value-value pairs.
             *
             * @private
             * @param {Object} set The set to convert.
             * @returns {Array} Returns the value-value pairs.
             */
            function setToPairs(set) {
              var index = -1,
              result = Array(set.size);

              set.forEach(function (value) {
                result[++index] = [value, value];
              });
              return result;
            }

            /**
             * A specialized version of `_.indexOf` which performs strict equality
             * comparisons of values, i.e. `===`.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function strictIndexOf(array, value, fromIndex) {
              var index = fromIndex - 1,
              length = array.length;

              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }

            /**
             * A specialized version of `_.lastIndexOf` which performs strict equality
             * comparisons of values, i.e. `===`.
             *
             * @private
             * @param {Array} array The array to inspect.
             * @param {*} value The value to search for.
             * @param {number} fromIndex The index to search from.
             * @returns {number} Returns the index of the matched value, else `-1`.
             */
            function strictLastIndexOf(array, value, fromIndex) {
              var index = fromIndex + 1;
              while (index--) {
                if (array[index] === value) {
                  return index;
                }
              }
              return index;
            }

            /**
             * Gets the number of symbols in `string`.
             *
             * @private
             * @param {string} string The string to inspect.
             * @returns {number} Returns the string size.
             */
            function stringSize(string) {
              return hasUnicode(string) ?
              unicodeSize(string) :
              asciiSize(string);
            }

            /**
             * Converts `string` to an array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the converted array.
             */
            function stringToArray(string) {
              return hasUnicode(string) ?
              unicodeToArray(string) :
              asciiToArray(string);
            }

            /**
             * Used by `_.unescape` to convert HTML entities to characters.
             *
             * @private
             * @param {string} chr The matched character to unescape.
             * @returns {string} Returns the unescaped character.
             */
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

            /**
             * Gets the size of a Unicode `string`.
             *
             * @private
             * @param {string} string The string inspect.
             * @returns {number} Returns the string size.
             */
            function unicodeSize(string) {
              var result = reUnicode.lastIndex = 0;
              while (reUnicode.test(string)) {
                ++result;
              }
              return result;
            }

            /**
             * Converts a Unicode `string` to an array.
             *
             * @private
             * @param {string} string The string to convert.
             * @returns {Array} Returns the converted array.
             */
            function unicodeToArray(string) {
              return string.match(reUnicode) || [];
            }

            /**
             * Splits a Unicode `string` into an array of its words.
             *
             * @private
             * @param {string} The string to inspect.
             * @returns {Array} Returns the words of `string`.
             */
            function unicodeWords(string) {
              return string.match(reUnicodeWord) || [];
            }

            /*--------------------------------------------------------------------------*/

            /**
             * Create a new pristine `lodash` function using the `context` object.
             *
             * @static
             * @memberOf _
             * @since 1.1.0
             * @category Util
             * @param {Object} [context=root] The context object.
             * @returns {Function} Returns a new `lodash` function.
             * @example
             *
             * _.mixin({ 'foo': _.constant('foo') });
             *
             * var lodash = _.runInContext();
             * lodash.mixin({ 'bar': lodash.constant('bar') });
             *
             * _.isFunction(_.foo);
             * // => true
             * _.isFunction(_.bar);
             * // => false
             *
             * lodash.isFunction(lodash.foo);
             * // => false
             * lodash.isFunction(lodash.bar);
             * // => true
             *
             * // Create a suped-up `defer` in Node.js.
             * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
             */
            var runInContext = function runInContext(context) {
              context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

              /** Built-in constructor references. */
              var Array = context.Array,
              Date = context.Date,
              Error = context.Error,
              Function = context.Function,
              Math = context.Math,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;

              /** Used for built-in method references. */
              var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;

              /** Used to detect overreaching core-js shims. */
              var coreJsData = context['__core-js_shared__'];

              /** Used to resolve the decompiled source of functions. */
              var funcToString = funcProto.toString;

              /** Used to check objects for own properties. */
              var hasOwnProperty = objectProto.hasOwnProperty;

              /** Used to generate unique IDs. */
              var idCounter = 0;

              /** Used to detect methods masquerading as native. */
              var maskSrcKey = function () {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                return uid ? 'Symbol(src)_1.' + uid : '';
              }();

              /**
               * Used to resolve the
               * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
               * of values.
               */
              var nativeObjectToString = objectProto.toString;

              /** Used to infer the `Object` constructor. */
              var objectCtorString = funcToString.call(Object);

              /** Used to restore the original `_` reference in `_.noConflict`. */
              var oldDash = root._;

              /** Used to detect if a method is native. */
              var reIsNative = RegExp('^' +
              funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').
              replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');


              /** Built-in value references. */
              var Buffer = moduleExports ? context.Buffer : undefined,
              Symbol = context.Symbol,
              Uint8Array = context.Uint8Array,
              allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
              getPrototype = overArg(Object.getPrototypeOf, Object),
              objectCreate = Object.create,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice,
              spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
              symIterator = Symbol ? Symbol.iterator : undefined,
              symToStringTag = Symbol ? Symbol.toStringTag : undefined;

              var defineProperty = function () {
                try {
                  var func = getNative(Object, 'defineProperty');
                  func({}, '', {});
                  return func;
                } catch (e) {}
              }();

              /** Mocked built-ins. */
              var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
              ctxNow = Date && Date.now !== root.Date.now && Date.now,
              ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

              /* Built-in method references for those with the same name as other `lodash` methods. */
              var nativeCeil = Math.ceil,
              nativeFloor = Math.floor,
              nativeGetSymbols = Object.getOwnPropertySymbols,
              nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
              nativeIsFinite = context.isFinite,
              nativeJoin = arrayProto.join,
              nativeKeys = overArg(Object.keys, Object),
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeNow = Date.now,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random,
              nativeReverse = arrayProto.reverse;

              /* Built-in method references that are verified to be native. */
              var DataView = getNative(context, 'DataView'),
              Map = getNative(context, 'Map'),
              Promise = getNative(context, 'Promise'),
              Set = getNative(context, 'Set'),
              WeakMap = getNative(context, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');

              /** Used to store function metadata. */
              var metaMap = WeakMap && new WeakMap();

              /** Used to lookup unminified function names. */
              var realNames = {};

              /** Used to detect maps, sets, and weakmaps. */
              var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);

              /** Used to convert symbols to primitives and strings. */
              var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;

              /*------------------------------------------------------------------------*/

              /**
               * Creates a `lodash` object which wraps `value` to enable implicit method
               * chain sequences. Methods that operate on and return arrays, collections,
               * and functions can be chained together. Methods that retrieve a single value
               * or may return a primitive value will automatically end the chain sequence
               * and return the unwrapped value. Otherwise, the value must be unwrapped
               * with `_#value`.
               *
               * Explicit chain sequences, which must be unwrapped with `_#value`, may be
               * enabled using `_.chain`.
               *
               * The execution of chained methods is lazy, that is, it's deferred until
               * `_#value` is implicitly or explicitly called.
               *
               * Lazy evaluation allows several methods to support shortcut fusion.
               * Shortcut fusion is an optimization to merge iteratee calls; this avoids
               * the creation of intermediate arrays and can greatly reduce the number of
               * iteratee executions. Sections of a chain sequence qualify for shortcut
               * fusion if the section is applied to an array and iteratees accept only
               * one argument. The heuristic for whether a section qualifies for shortcut
               * fusion is subject to change.
               *
               * Chaining is supported in custom builds as long as the `_#value` method is
               * directly or indirectly included in the build.
               *
               * In addition to lodash methods, wrappers have `Array` and `String` methods.
               *
               * The wrapper `Array` methods are:
               * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
               *
               * The wrapper `String` methods are:
               * `replace` and `split`
               *
               * The wrapper methods that support shortcut fusion are:
               * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
               * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
               * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
               *
               * The chainable wrapper methods are:
               * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
               * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
               * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
               * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
               * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
               * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
               * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
               * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
               * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
               * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
               * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
               * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
               * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
               * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
               * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
               * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
               * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
               * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
               * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
               * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
               * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
               * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
               * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
               * `zipObject`, `zipObjectDeep`, and `zipWith`
               *
               * The wrapper methods that are **not** chainable by default are:
               * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
               * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
               * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
               * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
               * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
               * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
               * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
               * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
               * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
               * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
               * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
               * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
               * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
               * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
               * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
               * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
               * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
               * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
               * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
               * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
               * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
               * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
               * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
               * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
               * `upperFirst`, `value`, and `words`
               *
               * @name _
               * @constructor
               * @category Seq
               * @param {*} value The value to wrap in a `lodash` instance.
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * var wrapped = _([1, 2, 3]);
               *
               * // Returns an unwrapped value.
               * wrapped.reduce(_.add);
               * // => 6
               *
               * // Returns a wrapped value.
               * var squares = wrapped.map(square);
               *
               * _.isArray(squares);
               * // => false
               *
               * _.isArray(squares.value());
               * // => true
               */
              function lodash(value) {
                if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }

              /**
               * The base implementation of `_.create` without support for assigning
               * properties to the created object.
               *
               * @private
               * @param {Object} proto The object to inherit from.
               * @returns {Object} Returns the new object.
               */
              var baseCreate = function () {
                function object() {}
                return function (proto) {
                  if (!isObject(proto)) {
                    return {};
                  }
                  if (objectCreate) {
                    return objectCreate(proto);
                  }
                  object.prototype = proto;
                  var result = new object();
                  object.prototype = undefined;
                  return result;
                };
              }();

              /**
               * The function whose prototype chain sequence wrappers inherit from.
               *
               * @private
               */
              function baseLodash() {
                // No operation performed.
              }

              /**
               * The base constructor for creating `lodash` wrapper objects.
               *
               * @private
               * @param {*} value The value to wrap.
               * @param {boolean} [chainAll] Enable explicit method chain sequences.
               */
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined;
              }

              /**
               * By default, the template delimiters used by lodash are like those in
               * embedded Ruby (ERB) as well as ES2015 template strings. Change the
               * following template settings to use alternative delimiters.
               *
               * @static
               * @memberOf _
               * @type {Object}
               */
              lodash.templateSettings = {

                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                'escape': reEscape,

                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                'evaluate': reEvaluate,

                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                'interpolate': reInterpolate,

                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type {string}
                 */
                'variable': '',

                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type {Object}
                 */
                'imports': {

                  /**
                   * A reference to the `lodash` function.
                   *
                   * @memberOf _.templateSettings.imports
                   * @type {Function}
                   */
                  '_': lodash } };



              // Ensure wrappers are instances of `baseLodash`.
              lodash.prototype = baseLodash.prototype;
              lodash.prototype.constructor = lodash;

              LodashWrapper.prototype = baseCreate(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;

              /*------------------------------------------------------------------------*/

              /**
               * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
               *
               * @private
               * @constructor
               * @param {*} value The value to wrap.
               */
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }

              /**
               * Creates a clone of the lazy wrapper object.
               *
               * @private
               * @name clone
               * @memberOf LazyWrapper
               * @returns {Object} Returns the cloned `LazyWrapper` object.
               */
              function lazyClone() {
                var result = new LazyWrapper(this.__wrapped__);
                result.__actions__ = copyArray(this.__actions__);
                result.__dir__ = this.__dir__;
                result.__filtered__ = this.__filtered__;
                result.__iteratees__ = copyArray(this.__iteratees__);
                result.__takeCount__ = this.__takeCount__;
                result.__views__ = copyArray(this.__views__);
                return result;
              }

              /**
               * Reverses the direction of lazy iteration.
               *
               * @private
               * @name reverse
               * @memberOf LazyWrapper
               * @returns {Object} Returns the new reversed `LazyWrapper` object.
               */
              function lazyReverse() {
                if (this.__filtered__) {
                  var result = new LazyWrapper(this);
                  result.__dir__ = -1;
                  result.__filtered__ = true;
                } else {
                  result = this.clone();
                  result.__dir__ *= -1;
                }
                return result;
              }

              /**
               * Extracts the unwrapped value from its lazy wrapper.
               *
               * @private
               * @name value
               * @memberOf LazyWrapper
               * @returns {*} Returns the unwrapped value.
               */
              function lazyValue() {
                var array = this.__wrapped__.value(),
                dir = this.__dir__,
                isArr = isArray(array),
                isRight = dir < 0,
                arrLength = isArr ? array.length : 0,
                view = getView(0, arrLength, this.__views__),
                start = view.start,
                end = view.end,
                length = end - start,
                index = isRight ? end : start - 1,
                iteratees = this.__iteratees__,
                iterLength = iteratees.length,
                resIndex = 0,
                takeCount = nativeMin(length, this.__takeCount__);

                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result = [];

                outer:
                while (length-- && resIndex < takeCount) {
                  index += dir;

                  var iterIndex = -1,
                  value = array[index];

                  while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex],
                    iteratee = data.iteratee,
                    type = data.type,
                    computed = iteratee(value);

                    if (type == LAZY_MAP_FLAG) {
                      value = computed;
                    } else if (!computed) {
                      if (type == LAZY_FILTER_FLAG) {
                        continue outer;
                      } else {
                        break outer;
                      }
                    }
                  }
                  result[resIndex++] = value;
                }
                return result;
              }

              // Ensure `LazyWrapper` is an instance of `baseLodash`.
              LazyWrapper.prototype = baseCreate(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;

              /*------------------------------------------------------------------------*/

              /**
               * Creates a hash object.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */
              function Hash(entries) {
                var index = -1,
                length = entries == null ? 0 : entries.length;

                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }

              /**
               * Removes all key-value entries from the hash.
               *
               * @private
               * @name clear
               * @memberOf Hash
               */
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }

              /**
               * Removes `key` and its value from the hash.
               *
               * @private
               * @name delete
               * @memberOf Hash
               * @param {Object} hash The hash to modify.
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }

              /**
               * Gets the hash value for `key`.
               *
               * @private
               * @name get
               * @memberOf Hash
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? undefined : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : undefined;
              }

              /**
               * Checks if a hash value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf Hash
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
              }

              /**
               * Sets the hash `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf Hash
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the hash instance.
               */
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                return this;
              }

              // Add methods to `Hash`.
              Hash.prototype.clear = hashClear;
              Hash.prototype['delete'] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;

              /*------------------------------------------------------------------------*/

              /**
               * Creates an list cache object.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */
              function ListCache(entries) {
                var index = -1,
                length = entries == null ? 0 : entries.length;

                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }

              /**
               * Removes all key-value entries from the list cache.
               *
               * @private
               * @name clear
               * @memberOf ListCache
               */
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }

              /**
               * Removes `key` and its value from the list cache.
               *
               * @private
               * @name delete
               * @memberOf ListCache
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */
              function listCacheDelete(key) {
                var data = this.__data__,
                index = assocIndexOf(data, key);

                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }

              /**
               * Gets the list cache value for `key`.
               *
               * @private
               * @name get
               * @memberOf ListCache
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */
              function listCacheGet(key) {
                var data = this.__data__,
                index = assocIndexOf(data, key);

                return index < 0 ? undefined : data[index][1];
              }

              /**
               * Checks if a list cache value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf ListCache
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }

              /**
               * Sets the list cache `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf ListCache
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the list cache instance.
               */
              function listCacheSet(key, value) {
                var data = this.__data__,
                index = assocIndexOf(data, key);

                if (index < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }

              // Add methods to `ListCache`.
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype['delete'] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;

              /*------------------------------------------------------------------------*/

              /**
               * Creates a map cache object to store key-value pairs.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */
              function MapCache(entries) {
                var index = -1,
                length = entries == null ? 0 : entries.length;

                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }

              /**
               * Removes all key-value entries from the map.
               *
               * @private
               * @name clear
               * @memberOf MapCache
               */
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  'hash': new Hash(),
                  'map': new (Map || ListCache)(),
                  'string': new Hash() };

              }

              /**
               * Removes `key` and its value from the map.
               *
               * @private
               * @name delete
               * @memberOf MapCache
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */
              function mapCacheDelete(key) {
                var result = getMapData(this, key)['delete'](key);
                this.size -= result ? 1 : 0;
                return result;
              }

              /**
               * Gets the map value for `key`.
               *
               * @private
               * @name get
               * @memberOf MapCache
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }

              /**
               * Checks if a map value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf MapCache
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }

              /**
               * Sets the map `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf MapCache
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the map cache instance.
               */
              function mapCacheSet(key, value) {
                var data = getMapData(this, key),
                size = data.size;

                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }

              // Add methods to `MapCache`.
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype['delete'] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;

              /*------------------------------------------------------------------------*/

              /**
               *
               * Creates an array cache object to store unique values.
               *
               * @private
               * @constructor
               * @param {Array} [values] The values to cache.
               */
              function SetCache(values) {
                var index = -1,
                length = values == null ? 0 : values.length;

                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }

              /**
               * Adds `value` to the array cache.
               *
               * @private
               * @name add
               * @memberOf SetCache
               * @alias push
               * @param {*} value The value to cache.
               * @returns {Object} Returns the cache instance.
               */
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }

              /**
               * Checks if `value` is in the array cache.
               *
               * @private
               * @name has
               * @memberOf SetCache
               * @param {*} value The value to search for.
               * @returns {number} Returns `true` if `value` is found, else `false`.
               */
              function setCacheHas(value) {
                return this.__data__.has(value);
              }

              // Add methods to `SetCache`.
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;

              /*------------------------------------------------------------------------*/

              /**
               * Creates a stack cache object to store key-value pairs.
               *
               * @private
               * @constructor
               * @param {Array} [entries] The key-value pairs to cache.
               */
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }

              /**
               * Removes all key-value entries from the stack.
               *
               * @private
               * @name clear
               * @memberOf Stack
               */
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }

              /**
               * Removes `key` and its value from the stack.
               *
               * @private
               * @name delete
               * @memberOf Stack
               * @param {string} key The key of the value to remove.
               * @returns {boolean} Returns `true` if the entry was removed, else `false`.
               */
              function stackDelete(key) {
                var data = this.__data__,
                result = data['delete'](key);

                this.size = data.size;
                return result;
              }

              /**
               * Gets the stack value for `key`.
               *
               * @private
               * @name get
               * @memberOf Stack
               * @param {string} key The key of the value to get.
               * @returns {*} Returns the entry value.
               */
              function stackGet(key) {
                return this.__data__.get(key);
              }

              /**
               * Checks if a stack value for `key` exists.
               *
               * @private
               * @name has
               * @memberOf Stack
               * @param {string} key The key of the entry to check.
               * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
               */
              function stackHas(key) {
                return this.__data__.has(key);
              }

              /**
               * Sets the stack `key` to `value`.
               *
               * @private
               * @name set
               * @memberOf Stack
               * @param {string} key The key of the value to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns the stack cache instance.
               */
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }

              // Add methods to `Stack`.
              Stack.prototype.clear = stackClear;
              Stack.prototype['delete'] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;

              /*------------------------------------------------------------------------*/

              /**
               * Creates an array of the enumerable property names of the array-like `value`.
               *
               * @private
               * @param {*} value The value to query.
               * @param {boolean} inherited Specify returning inherited property names.
               * @returns {Array} Returns the array of property names.
               */
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value),
                isArg = !isArr && isArguments(value),
                isBuff = !isArr && !isArg && isBuffer(value),
                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                skipIndexes = isArr || isArg || isBuff || isType,
                result = skipIndexes ? baseTimes(value.length, String) : [],
                length = result.length;

                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (
                  // Safari 9 has enumerable `arguments.length` in strict mode.
                  key == 'length' ||
                  // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == 'offset' || key == 'parent') ||
                  // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
                  // Skip index properties.
                  isIndex(key, length))))
                  {
                    result.push(key);
                  }
                }
                return result;
              }

              /**
               * A specialized version of `_.sample` for arrays.
               *
               * @private
               * @param {Array} array The array to sample.
               * @returns {*} Returns the random element.
               */
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined;
              }

              /**
               * A specialized version of `_.sampleSize` for arrays.
               *
               * @private
               * @param {Array} array The array to sample.
               * @param {number} n The number of elements to sample.
               * @returns {Array} Returns the random elements.
               */
              function arraySampleSize(array, n) {
                return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
              }

              /**
               * A specialized version of `_.shuffle` for arrays.
               *
               * @private
               * @param {Array} array The array to shuffle.
               * @returns {Array} Returns the new shuffled array.
               */
              function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
              }

              /**
               * This function is like `assignValue` except that it doesn't assign
               * `undefined` values.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {string} key The key of the property to assign.
               * @param {*} value The value to assign.
               */
              function assignMergeValue(object, key, value) {
                if (value !== undefined && !eq(object[key], value) ||
                value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }

              /**
               * Assigns `value` to `key` of `object` if the existing value is not equivalent
               * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {string} key The key of the property to assign.
               * @param {*} value The value to assign.
               */
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                value === undefined && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }

              /**
               * Gets the index at which the `key` is found in `array` of key-value pairs.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {*} key The key to search for.
               * @returns {number} Returns the index of the matched value, else `-1`.
               */
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }

              /**
               * Aggregates elements of `collection` on `accumulator` with keys transformed
               * by `iteratee` and values set by `setter`.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} setter The function to set `accumulator` values.
               * @param {Function} iteratee The iteratee to transform keys.
               * @param {Object} accumulator The initial aggregated object.
               * @returns {Function} Returns `accumulator`.
               */
              function baseAggregator(collection, setter, iteratee, accumulator) {
                baseEach(collection, function (value, key, collection) {
                  setter(accumulator, value, iteratee(value), collection);
                });
                return accumulator;
              }

              /**
               * The base implementation of `_.assign` without support for multiple sources
               * or `customizer` functions.
               *
               * @private
               * @param {Object} object The destination object.
               * @param {Object} source The source object.
               * @returns {Object} Returns `object`.
               */
              function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
              }

              /**
               * The base implementation of `_.assignIn` without support for multiple sources
               * or `customizer` functions.
               *
               * @private
               * @param {Object} object The destination object.
               * @param {Object} source The source object.
               * @returns {Object} Returns `object`.
               */
              function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
              }

              /**
               * The base implementation of `assignValue` and `assignMergeValue` without
               * value checks.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {string} key The key of the property to assign.
               * @param {*} value The value to assign.
               */
              function baseAssignValue(object, key, value) {
                if (key == '__proto__' && defineProperty) {
                  defineProperty(object, key, {
                    'configurable': true,
                    'enumerable': true,
                    'value': value,
                    'writable': true });

                } else {
                  object[key] = value;
                }
              }

              /**
               * The base implementation of `_.at` without support for individual paths.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {string[]} paths The property paths to pick.
               * @returns {Array} Returns the picked elements.
               */
              function baseAt(object, paths) {
                var index = -1,
                length = paths.length,
                result = Array(length),
                skip = object == null;

                while (++index < length) {
                  result[index] = skip ? undefined : get(object, paths[index]);
                }
                return result;
              }

              /**
               * The base implementation of `_.clamp` which doesn't coerce arguments.
               *
               * @private
               * @param {number} number The number to clamp.
               * @param {number} [lower] The lower bound.
               * @param {number} upper The upper bound.
               * @returns {number} Returns the clamped number.
               */
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }

              /**
               * The base implementation of `_.clone` and `_.cloneDeep` which tracks
               * traversed objects.
               *
               * @private
               * @param {*} value The value to clone.
               * @param {boolean} bitmask The bitmask flags.
               *  1 - Deep clone
               *  2 - Flatten inherited properties
               *  4 - Clone symbols
               * @param {Function} [customizer] The function to customize cloning.
               * @param {string} [key] The key of `value`.
               * @param {Object} [object] The parent object of `value`.
               * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
               * @returns {*} Returns the cloned value.
               */
              function baseClone(value, bitmask, customizer, key, object, stack) {
                var result,
                isDeep = bitmask & CLONE_DEEP_FLAG,
                isFlat = bitmask & CLONE_FLAT_FLAG,
                isFull = bitmask & CLONE_SYMBOLS_FLAG;

                if (customizer) {
                  result = object ? customizer(value, key, object, stack) : customizer(value);
                }
                if (result !== undefined) {
                  return result;
                }
                if (!isObject(value)) {
                  return value;
                }
                var isArr = isArray(value);
                if (isArr) {
                  result = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray(value, result);
                  }
                } else {
                  var tag = getTag(value),
                  isFunc = tag == funcTag || tag == genTag;

                  if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                  }
                  if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = isFlat || isFunc ? {} : initCloneObject(value);
                    if (!isDeep) {
                      return isFlat ?
                      copySymbolsIn(value, baseAssignIn(result, value)) :
                      copySymbols(value, baseAssign(result, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, isDeep);
                  }
                }
                // Check for circular references and return its corresponding clone.
                stack || (stack = new Stack());
                var stacked = stack.get(value);
                if (stacked) {
                  return stacked;
                }
                stack.set(value, result);

                if (isSet(value)) {
                  value.forEach(function (subValue) {
                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                  });
                } else if (isMap(value)) {
                  value.forEach(function (subValue, key) {
                    result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                  });
                }

                var keysFunc = isFull ?
                isFlat ? getAllKeysIn : getAllKeys :
                isFlat ? keysIn : keys;

                var props = isArr ? undefined : keysFunc(value);
                arrayEach(props || value, function (subValue, key) {
                  if (props) {
                    key = subValue;
                    subValue = value[key];
                  }
                  // Recursively populate clone (susceptible to call stack limits).
                  assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                });
                return result;
              }

              /**
               * The base implementation of `_.conforms` which doesn't clone `source`.
               *
               * @private
               * @param {Object} source The object of property predicates to conform to.
               * @returns {Function} Returns the new spec function.
               */
              function baseConforms(source) {
                var props = keys(source);
                return function (object) {
                  return baseConformsTo(object, source, props);
                };
              }

              /**
               * The base implementation of `_.conformsTo` which accepts `props` to check.
               *
               * @private
               * @param {Object} object The object to inspect.
               * @param {Object} source The object of property predicates to conform to.
               * @returns {boolean} Returns `true` if `object` conforms, else `false`.
               */
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (length--) {
                  var key = props[length],
                  predicate = source[key],
                  value = object[key];

                  if (value === undefined && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }

              /**
               * The base implementation of `_.delay` and `_.defer` which accepts `args`
               * to provide to `func`.
               *
               * @private
               * @param {Function} func The function to delay.
               * @param {number} wait The number of milliseconds to delay invocation.
               * @param {Array} args The arguments to provide to `func`.
               * @returns {number|Object} Returns the timer id or timeout object.
               */
              function baseDelay(func, wait, args) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return setTimeout(function () {func.apply(undefined, args);}, wait);
              }

              /**
               * The base implementation of methods like `_.difference` without support
               * for excluding multiple arrays or iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {Array} values The values to exclude.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of filtered values.
               */
              function baseDifference(array, values, iteratee, comparator) {
                var index = -1,
                includes = arrayIncludes,
                isCommon = true,
                length = array.length,
                result = [],
                valuesLength = values.length;

                if (!length) {
                  return result;
                }
                if (iteratee) {
                  values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                  includes = arrayIncludesWith;
                  isCommon = false;
                } else
                if (values.length >= LARGE_ARRAY_SIZE) {
                  includes = cacheHas;
                  isCommon = false;
                  values = new SetCache(values);
                }
                outer:
                while (++index < length) {
                  var value = array[index],
                  computed = iteratee == null ? value : iteratee(value);

                  value = comparator || value !== 0 ? value : 0;
                  if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                      if (values[valuesIndex] === computed) {
                        continue outer;
                      }
                    }
                    result.push(value);
                  } else
                  if (!includes(values, computed, comparator)) {
                    result.push(value);
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.forEach` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array|Object} Returns `collection`.
               */
              var baseEach = createBaseEach(baseForOwn);

              /**
               * The base implementation of `_.forEachRight` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array|Object} Returns `collection`.
               */
              var baseEachRight = createBaseEach(baseForOwnRight, true);

              /**
               * The base implementation of `_.every` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {boolean} Returns `true` if all elements pass the predicate check,
               *  else `false`
               */
              function baseEvery(collection, predicate) {
                var result = true;
                baseEach(collection, function (value, index, collection) {
                  result = !!predicate(value, index, collection);
                  return result;
                });
                return result;
              }

              /**
               * The base implementation of methods like `_.max` and `_.min` which accepts a
               * `comparator` to determine the extremum value.
               *
               * @private
               * @param {Array} array The array to iterate over.
               * @param {Function} iteratee The iteratee invoked per iteration.
               * @param {Function} comparator The comparator used to compare values.
               * @returns {*} Returns the extremum value.
               */
              function baseExtremum(array, iteratee, comparator) {
                var index = -1,
                length = array.length;

                while (++index < length) {
                  var value = array[index],
                  current = iteratee(value);

                  if (current != null && (computed === undefined ?
                  current === current && !isSymbol(current) :
                  comparator(current, computed)))
                  {
                    var computed = current,
                    result = value;
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.fill` without an iteratee call guard.
               *
               * @private
               * @param {Array} array The array to fill.
               * @param {*} value The value to fill `array` with.
               * @param {number} [start=0] The start position.
               * @param {number} [end=array.length] The end position.
               * @returns {Array} Returns `array`.
               */
              function baseFill(array, value, start, end) {
                var length = array.length;

                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }

              /**
               * The base implementation of `_.filter` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {Array} Returns the new filtered array.
               */
              function baseFilter(collection, predicate) {
                var result = [];
                baseEach(collection, function (value, index, collection) {
                  if (predicate(value, index, collection)) {
                    result.push(value);
                  }
                });
                return result;
              }

              /**
               * The base implementation of `_.flatten` with support for restricting flattening.
               *
               * @private
               * @param {Array} array The array to flatten.
               * @param {number} depth The maximum recursion depth.
               * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
               * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
               * @param {Array} [result=[]] The initial result value.
               * @returns {Array} Returns the new flattened array.
               */
              function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1,
                length = array.length;

                predicate || (predicate = isFlattenable);
                result || (result = []);

                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      // Recursively flatten arrays (susceptible to call stack limits).
                      baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                      arrayPush(result, value);
                    }
                  } else if (!isStrict) {
                    result[result.length] = value;
                  }
                }
                return result;
              }

              /**
               * The base implementation of `baseForOwn` which iterates over `object`
               * properties returned by `keysFunc` and invokes `iteratee` for each property.
               * Iteratee functions may exit iteration early by explicitly returning `false`.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {Function} keysFunc The function to get the keys of `object`.
               * @returns {Object} Returns `object`.
               */
              var baseFor = createBaseFor();

              /**
               * This function is like `baseFor` except that it iterates over properties
               * in the opposite order.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @param {Function} keysFunc The function to get the keys of `object`.
               * @returns {Object} Returns `object`.
               */
              var baseForRight = createBaseFor(true);

              /**
               * The base implementation of `_.forOwn` without support for iteratee shorthands.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Object} Returns `object`.
               */
              function baseForOwn(object, iteratee) {
                return object && baseFor(object, iteratee, keys);
              }

              /**
               * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Object} Returns `object`.
               */
              function baseForOwnRight(object, iteratee) {
                return object && baseForRight(object, iteratee, keys);
              }

              /**
               * The base implementation of `_.functions` which creates an array of
               * `object` function property names filtered from `props`.
               *
               * @private
               * @param {Object} object The object to inspect.
               * @param {Array} props The property names to filter.
               * @returns {Array} Returns the function names.
               */
              function baseFunctions(object, props) {
                return arrayFilter(props, function (key) {
                  return isFunction(object[key]);
                });
              }

              /**
               * The base implementation of `_.get` without support for default values.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array|string} path The path of the property to get.
               * @returns {*} Returns the resolved value.
               */
              function baseGet(object, path) {
                path = castPath(path, object);

                var index = 0,
                length = path.length;

                while (object != null && index < length) {
                  object = object[toKey(path[index++])];
                }
                return index && index == length ? object : undefined;
              }

              /**
               * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
               * `keysFunc` and `symbolsFunc` to get the enumerable property names and
               * symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Function} keysFunc The function to get the keys of `object`.
               * @param {Function} symbolsFunc The function to get the symbols of `object`.
               * @returns {Array} Returns the array of property names and symbols.
               */
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
              }

              /**
               * The base implementation of `getTag` without fallbacks for buggy environments.
               *
               * @private
               * @param {*} value The value to query.
               * @returns {string} Returns the `toStringTag`.
               */
              function baseGetTag(value) {
                if (value == null) {
                  return value === undefined ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ?
                getRawTag(value) :
                objectToString(value);
              }

              /**
               * The base implementation of `_.gt` which doesn't coerce arguments.
               *
               * @private
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is greater than `other`,
               *  else `false`.
               */
              function baseGt(value, other) {
                return value > other;
              }

              /**
               * The base implementation of `_.has` without support for deep paths.
               *
               * @private
               * @param {Object} [object] The object to query.
               * @param {Array|string} key The key to check.
               * @returns {boolean} Returns `true` if `key` exists, else `false`.
               */
              function baseHas(object, key) {
                return object != null && hasOwnProperty.call(object, key);
              }

              /**
               * The base implementation of `_.hasIn` without support for deep paths.
               *
               * @private
               * @param {Object} [object] The object to query.
               * @param {Array|string} key The key to check.
               * @returns {boolean} Returns `true` if `key` exists, else `false`.
               */
              function baseHasIn(object, key) {
                return object != null && key in Object(object);
              }

              /**
               * The base implementation of `_.inRange` which doesn't coerce arguments.
               *
               * @private
               * @param {number} number The number to check.
               * @param {number} start The start of the range.
               * @param {number} end The end of the range.
               * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
               */
              function baseInRange(number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end);
              }

              /**
               * The base implementation of methods like `_.intersection`, without support
               * for iteratee shorthands, that accepts an array of arrays to inspect.
               *
               * @private
               * @param {Array} arrays The arrays to inspect.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of shared values.
               */
              function baseIntersection(arrays, iteratee, comparator) {
                var includes = comparator ? arrayIncludesWith : arrayIncludes,
                length = arrays[0].length,
                othLength = arrays.length,
                othIndex = othLength,
                caches = Array(othLength),
                maxLength = Infinity,
                result = [];

                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                  }
                  maxLength = nativeMin(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ?
                  new SetCache(othIndex && array) :
                  undefined;
                }
                array = arrays[0];

                var index = -1,
                seen = caches[0];

                outer:
                while (++index < length && result.length < maxLength) {
                  var value = array[index],
                  computed = iteratee ? iteratee(value) : value;

                  value = comparator || value !== 0 ? value : 0;
                  if (!(seen ?
                  cacheHas(seen, computed) :
                  includes(result, computed, comparator)))
                  {
                    othIndex = othLength;
                    while (--othIndex) {
                      var cache = caches[othIndex];
                      if (!(cache ?
                      cacheHas(cache, computed) :
                      includes(arrays[othIndex], computed, comparator)))
                      {
                        continue outer;
                      }
                    }
                    if (seen) {
                      seen.push(computed);
                    }
                    result.push(value);
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.invert` and `_.invertBy` which inverts
               * `object` with values transformed by `iteratee` and set by `setter`.
               *
               * @private
               * @param {Object} object The object to iterate over.
               * @param {Function} setter The function to set `accumulator` values.
               * @param {Function} iteratee The iteratee to transform values.
               * @param {Object} accumulator The initial inverted object.
               * @returns {Function} Returns `accumulator`.
               */
              function baseInverter(object, setter, iteratee, accumulator) {
                baseForOwn(object, function (value, key, object) {
                  setter(accumulator, iteratee(value), key, object);
                });
                return accumulator;
              }

              /**
               * The base implementation of `_.invoke` without support for individual
               * method arguments.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array|string} path The path of the method to invoke.
               * @param {Array} args The arguments to invoke the method with.
               * @returns {*} Returns the result of the invoked method.
               */
              function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined : apply(func, object, args);
              }

              /**
               * The base implementation of `_.isArguments`.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an `arguments` object,
               */
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }

              /**
               * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
               */
              function baseIsArrayBuffer(value) {
                return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
              }

              /**
               * The base implementation of `_.isDate` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
               */
              function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
              }

              /**
               * The base implementation of `_.isEqual` which supports partial comparisons
               * and tracks traversed objects.
               *
               * @private
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @param {boolean} bitmask The bitmask flags.
               *  1 - Unordered comparison
               *  2 - Partial comparison
               * @param {Function} [customizer] The function to customize comparisons.
               * @param {Object} [stack] Tracks traversed `value` and `other` objects.
               * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
               */
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }

              /**
               * A specialized version of `baseIsEqual` for arrays and objects which performs
               * deep comparisons and tracks traversed objects enabling objects with circular
               * references to be compared.
               *
               * @private
               * @param {Object} object The object to compare.
               * @param {Object} other The other object to compare.
               * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
               * @param {Function} customizer The function to customize comparisons.
               * @param {Function} equalFunc The function to determine equivalents of values.
               * @param {Object} [stack] Tracks traversed `object` and `other` objects.
               * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
               */
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = objIsArr ? arrayTag : getTag(object),
                othTag = othIsArr ? arrayTag : getTag(other);

                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;

                var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;

                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ?
                  equalArrays(object, other, bitmask, customizer, equalFunc, stack) :
                  equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;

                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }

              /**
               * The base implementation of `_.isMap` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a map, else `false`.
               */
              function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
              }

              /**
               * The base implementation of `_.isMatch` without support for iteratee shorthands.
               *
               * @private
               * @param {Object} object The object to inspect.
               * @param {Object} source The object of property values to match.
               * @param {Array} matchData The property names, values, and compare flags to match.
               * @param {Function} [customizer] The function to customize comparisons.
               * @returns {boolean} Returns `true` if `object` is a match, else `false`.
               */
              function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length,
                length = index,
                noCustomizer = !customizer;

                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (index--) {
                  var data = matchData[index];
                  if (noCustomizer && data[2] ?
                  data[1] !== object[data[0]] :
                  !(data[0] in object))
                  {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];

                  if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === undefined ?
                    baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) :
                    result))
                    {
                      return false;
                    }
                  }
                }
                return true;
              }

              /**
               * The base implementation of `_.isNative` without bad shim checks.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a native function,
               *  else `false`.
               */
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }

              /**
               * The base implementation of `_.isRegExp` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
               */
              function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
              }

              /**
               * The base implementation of `_.isSet` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a set, else `false`.
               */
              function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
              }

              /**
               * The base implementation of `_.isTypedArray` without Node.js optimizations.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
               */
              function baseIsTypedArray(value) {
                return isObjectLike(value) &&
                isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }

              /**
               * The base implementation of `_.iteratee`.
               *
               * @private
               * @param {*} [value=_.identity] The value to convert to an iteratee.
               * @returns {Function} Returns the iteratee.
               */
              function baseIteratee(value) {
                // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                if (typeof value == 'function') {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == 'object') {
                  return isArray(value) ?
                  baseMatchesProperty(value[0], value[1]) :
                  baseMatches(value);
                }
                return property(value);
              }

              /**
               * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               */
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               */
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object),
                result = [];

                for (var key in object) {
                  if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.lt` which doesn't coerce arguments.
               *
               * @private
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is less than `other`,
               *  else `false`.
               */
              function baseLt(value, other) {
                return value < other;
              }

              /**
               * The base implementation of `_.map` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} iteratee The function invoked per iteration.
               * @returns {Array} Returns the new mapped array.
               */
              function baseMap(collection, iteratee) {
                var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];

                baseEach(collection, function (value, key, collection) {
                  result[++index] = iteratee(value, key, collection);
                });
                return result;
              }

              /**
               * The base implementation of `_.matches` which doesn't clone `source`.
               *
               * @private
               * @param {Object} source The object of property values to match.
               * @returns {Function} Returns the new spec function.
               */
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function (object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }

              /**
               * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
               *
               * @private
               * @param {string} path The path of the property to get.
               * @param {*} srcValue The value to match.
               * @returns {Function} Returns the new spec function.
               */
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function (object) {
                  var objValue = get(object, path);
                  return objValue === undefined && objValue === srcValue ?
                  hasIn(object, path) :
                  baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
              }

              /**
               * The base implementation of `_.merge` without support for multiple sources.
               *
               * @private
               * @param {Object} object The destination object.
               * @param {Object} source The source object.
               * @param {number} srcIndex The index of `source`.
               * @param {Function} [customizer] The function to customize merged values.
               * @param {Object} [stack] Tracks traversed source values and their merged
               *  counterparts.
               */
              function baseMerge(object, source, srcIndex, customizer, stack) {
                if (object === source) {
                  return;
                }
                baseFor(source, function (srcValue, key) {
                  stack || (stack = new Stack());
                  if (isObject(srcValue)) {
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                  } else
                  {
                    var newValue = customizer ?
                    customizer(safeGet(object, key), srcValue, key + '', object, source, stack) :
                    undefined;

                    if (newValue === undefined) {
                      newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                  }
                }, keysIn);
              }

              /**
               * A specialized version of `baseMerge` for arrays and objects which performs
               * deep merges and tracks traversed objects enabling objects with circular
               * references to be merged.
               *
               * @private
               * @param {Object} object The destination object.
               * @param {Object} source The source object.
               * @param {string} key The key of the value to merge.
               * @param {number} srcIndex The index of `source`.
               * @param {Function} mergeFunc The function to merge values.
               * @param {Function} [customizer] The function to customize assigned values.
               * @param {Object} [stack] Tracks traversed source values and their merged
               *  counterparts.
               */
              function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                var objValue = safeGet(object, key),
                srcValue = safeGet(source, key),
                stacked = stack.get(srcValue);

                if (stacked) {
                  assignMergeValue(object, key, stacked);
                  return;
                }
                var newValue = customizer ?
                customizer(objValue, srcValue, key + '', object, source, stack) :
                undefined;

                var isCommon = newValue === undefined;

                if (isCommon) {
                  var isArr = isArray(srcValue),
                  isBuff = !isArr && isBuffer(srcValue),
                  isTyped = !isArr && !isBuff && isTypedArray(srcValue);

                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray(objValue)) {
                      newValue = objValue;
                    } else
                    if (isArrayLikeObject(objValue)) {
                      newValue = copyArray(objValue);
                    } else
                    if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer(srcValue, true);
                    } else
                    if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray(srcValue, true);
                    } else
                    {
                      newValue = [];
                    }
                  } else
                  if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    newValue = objValue;
                    if (isArguments(objValue)) {
                      newValue = toPlainObject(objValue);
                    } else
                    if (!isObject(objValue) || isFunction(objValue)) {
                      newValue = initCloneObject(srcValue);
                    }
                  } else
                  {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                  stack['delete'](srcValue);
                }
                assignMergeValue(object, key, newValue);
              }

              /**
               * The base implementation of `_.nth` which doesn't coerce arguments.
               *
               * @private
               * @param {Array} array The array to query.
               * @param {number} n The index of the element to return.
               * @returns {*} Returns the nth element of `array`.
               */
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex(n, length) ? array[n] : undefined;
              }

              /**
               * The base implementation of `_.orderBy` without param guards.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
               * @param {string[]} orders The sort orders of `iteratees`.
               * @returns {Array} Returns the new sorted array.
               */
              function baseOrderBy(collection, iteratees, orders) {
                if (iteratees.length) {
                  iteratees = arrayMap(iteratees, function (iteratee) {
                    if (isArray(iteratee)) {
                      return function (value) {
                        return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                      };
                    }
                    return iteratee;
                  });
                } else {
                  iteratees = [identity];
                }

                var index = -1;
                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

                var result = baseMap(collection, function (value, key, collection) {
                  var criteria = arrayMap(iteratees, function (iteratee) {
                    return iteratee(value);
                  });
                  return { 'criteria': criteria, 'index': ++index, 'value': value };
                });

                return baseSortBy(result, function (object, other) {
                  return compareMultiple(object, other, orders);
                });
              }

              /**
               * The base implementation of `_.pick` without support for individual
               * property identifiers.
               *
               * @private
               * @param {Object} object The source object.
               * @param {string[]} paths The property paths to pick.
               * @returns {Object} Returns the new object.
               */
              function basePick(object, paths) {
                return basePickBy(object, paths, function (value, path) {
                  return hasIn(object, path);
                });
              }

              /**
               * The base implementation of  `_.pickBy` without support for iteratee shorthands.
               *
               * @private
               * @param {Object} object The source object.
               * @param {string[]} paths The property paths to pick.
               * @param {Function} predicate The function invoked per property.
               * @returns {Object} Returns the new object.
               */
              function basePickBy(object, paths, predicate) {
                var index = -1,
                length = paths.length,
                result = {};

                while (++index < length) {
                  var path = paths[index],
                  value = baseGet(object, path);

                  if (predicate(value, path)) {
                    baseSet(result, castPath(path, object), value);
                  }
                }
                return result;
              }

              /**
               * A specialized version of `baseProperty` which supports deep paths.
               *
               * @private
               * @param {Array|string} path The path of the property to get.
               * @returns {Function} Returns the new accessor function.
               */
              function basePropertyDeep(path) {
                return function (object) {
                  return baseGet(object, path);
                };
              }

              /**
               * The base implementation of `_.pullAllBy` without support for iteratee
               * shorthands.
               *
               * @private
               * @param {Array} array The array to modify.
               * @param {Array} values The values to remove.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns `array`.
               */
              function basePullAll(array, values, iteratee, comparator) {
                var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                index = -1,
                length = values.length,
                seen = array;

                if (array === values) {
                  values = copyArray(values);
                }
                if (iteratee) {
                  seen = arrayMap(array, baseUnary(iteratee));
                }
                while (++index < length) {
                  var fromIndex = 0,
                  value = values[index],
                  computed = iteratee ? iteratee(value) : value;

                  while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                      splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                  }
                }
                return array;
              }

              /**
               * The base implementation of `_.pullAt` without support for individual
               * indexes or capturing the removed elements.
               *
               * @private
               * @param {Array} array The array to modify.
               * @param {number[]} indexes The indexes of elements to remove.
               * @returns {Array} Returns `array`.
               */
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0,
                lastIndex = length - 1;

                while (length--) {
                  var index = indexes[length];
                  if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) {
                      splice.call(array, index, 1);
                    } else {
                      baseUnset(array, index);
                    }
                  }
                }
                return array;
              }

              /**
               * The base implementation of `_.random` without support for returning
               * floating-point numbers.
               *
               * @private
               * @param {number} lower The lower bound.
               * @param {number} upper The upper bound.
               * @returns {number} Returns the random number.
               */
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }

              /**
               * The base implementation of `_.range` and `_.rangeRight` which doesn't
               * coerce arguments.
               *
               * @private
               * @param {number} start The start of the range.
               * @param {number} end The end of the range.
               * @param {number} step The value to increment or decrement by.
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Array} Returns the range of numbers.
               */
              function baseRange(start, end, step, fromRight) {
                var index = -1,
                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                result = Array(length);

                while (length--) {
                  result[fromRight ? length : ++index] = start;
                  start += step;
                }
                return result;
              }

              /**
               * The base implementation of `_.repeat` which doesn't coerce arguments.
               *
               * @private
               * @param {string} string The string to repeat.
               * @param {number} n The number of times to repeat the string.
               * @returns {string} Returns the repeated string.
               */
              function baseRepeat(string, n) {
                var result = '';
                if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                  return result;
                }
                // Leverage the exponentiation by squaring algorithm for a faster repeat.
                // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                do {
                  if (n % 2) {
                    result += string;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string += string;
                  }
                } while (n);

                return result;
              }

              /**
               * The base implementation of `_.rest` which doesn't validate or coerce arguments.
               *
               * @private
               * @param {Function} func The function to apply a rest parameter to.
               * @param {number} [start=func.length-1] The start position of the rest parameter.
               * @returns {Function} Returns the new function.
               */
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + '');
              }

              /**
               * The base implementation of `_.sample`.
               *
               * @private
               * @param {Array|Object} collection The collection to sample.
               * @returns {*} Returns the random element.
               */
              function baseSample(collection) {
                return arraySample(values(collection));
              }

              /**
               * The base implementation of `_.sampleSize` without param guards.
               *
               * @private
               * @param {Array|Object} collection The collection to sample.
               * @param {number} n The number of elements to sample.
               * @returns {Array} Returns the random elements.
               */
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }

              /**
               * The base implementation of `_.set`.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to set.
               * @param {*} value The value to set.
               * @param {Function} [customizer] The function to customize path creation.
               * @returns {Object} Returns `object`.
               */
              function baseSet(object, path, value, customizer) {
                if (!isObject(object)) {
                  return object;
                }
                path = castPath(path, object);

                var index = -1,
                length = path.length,
                lastIndex = length - 1,
                nested = object;

                while (nested != null && ++index < length) {
                  var key = toKey(path[index]),
                  newValue = value;

                  if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                    return object;
                  }

                  if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                    if (newValue === undefined) {
                      newValue = isObject(objValue) ?
                      objValue :
                      isIndex(path[index + 1]) ? [] : {};
                    }
                  }
                  assignValue(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }

              /**
               * The base implementation of `setData` without support for hot loop shorting.
               *
               * @private
               * @param {Function} func The function to associate metadata with.
               * @param {*} data The metadata.
               * @returns {Function} Returns `func`.
               */
              var baseSetData = !metaMap ? identity : function (func, data) {
                metaMap.set(func, data);
                return func;
              };

              /**
               * The base implementation of `setToString` without support for hot loop shorting.
               *
               * @private
               * @param {Function} func The function to modify.
               * @param {Function} string The `toString` result.
               * @returns {Function} Returns `func`.
               */
              var baseSetToString = !defineProperty ? identity : function (func, string) {
                return defineProperty(func, 'toString', {
                  'configurable': true,
                  'enumerable': false,
                  'value': constant(string),
                  'writable': true });

              };

              /**
               * The base implementation of `_.shuffle`.
               *
               * @private
               * @param {Array|Object} collection The collection to shuffle.
               * @returns {Array} Returns the new shuffled array.
               */
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }

              /**
               * The base implementation of `_.slice` without an iteratee call guard.
               *
               * @private
               * @param {Array} array The array to slice.
               * @param {number} [start=0] The start position.
               * @param {number} [end=array.length] The end position.
               * @returns {Array} Returns the slice of `array`.
               */
              function baseSlice(array, start, end) {
                var index = -1,
                length = array.length;

                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;

                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }

              /**
               * The base implementation of `_.some` without support for iteratee shorthands.
               *
               * @private
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} predicate The function invoked per iteration.
               * @returns {boolean} Returns `true` if any element passes the predicate check,
               *  else `false`.
               */
              function baseSome(collection, predicate) {
                var result;

                baseEach(collection, function (value, index, collection) {
                  result = predicate(value, index, collection);
                  return !result;
                });
                return !!result;
              }

              /**
               * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
               * performs a binary search of `array` to determine the index at which `value`
               * should be inserted into `array` in order to maintain its sort order.
               *
               * @private
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @param {boolean} [retHighest] Specify returning the highest qualified index.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               */
              function baseSortedIndex(array, value, retHighest) {
                var low = 0,
                high = array == null ? low : array.length;

                if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1,
                    computed = array[mid];

                    if (computed !== null && !isSymbol(computed) && (
                    retHighest ? computed <= value : computed < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity, retHighest);
              }

              /**
               * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
               * which invokes `iteratee` for `value` and each element of `array` to compute
               * their sort ranking. The iteratee is invoked with one argument; (value).
               *
               * @private
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @param {Function} iteratee The iteratee invoked per element.
               * @param {boolean} [retHighest] Specify returning the highest qualified index.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               */
              function baseSortedIndexBy(array, value, iteratee, retHighest) {
                var low = 0,
                high = array == null ? 0 : array.length;
                if (high === 0) {
                  return 0;
                }

                value = iteratee(value);
                var valIsNaN = value !== value,
                valIsNull = value === null,
                valIsSymbol = isSymbol(value),
                valIsUndefined = value === undefined;

                while (low < high) {
                  var mid = nativeFloor((low + high) / 2),
                  computed = iteratee(array[mid]),
                  othIsDefined = computed !== undefined,
                  othIsNull = computed === null,
                  othIsReflexive = computed === computed,
                  othIsSymbol = isSymbol(computed);

                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed <= value : computed < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
              }

              /**
               * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
               * support for iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @returns {Array} Returns the new duplicate free array.
               */
              function baseSortedUniq(array, iteratee) {
                var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];

                while (++index < length) {
                  var value = array[index],
                  computed = iteratee ? iteratee(value) : value;

                  if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.toNumber` which doesn't ensure correct
               * conversions of binary, hexadecimal, or octal string values.
               *
               * @private
               * @param {*} value The value to process.
               * @returns {number} Returns the number.
               */
              function baseToNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                return +value;
              }

              /**
               * The base implementation of `_.toString` which doesn't convert nullish
               * values to empty strings.
               *
               * @private
               * @param {*} value The value to process.
               * @returns {string} Returns the string.
               */
              function baseToString(value) {
                // Exit early for strings to avoid a performance hit in some environments.
                if (typeof value == 'string') {
                  return value;
                }
                if (isArray(value)) {
                  // Recursively convert values (susceptible to call stack limits).
                  return arrayMap(value, baseToString) + '';
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : '';
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }

              /**
               * The base implementation of `_.uniqBy` without support for iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new duplicate free array.
               */
              function baseUniq(array, iteratee, comparator) {
                var index = -1,
                includes = arrayIncludes,
                length = array.length,
                isCommon = true,
                result = [],
                seen = result;

                if (comparator) {
                  isCommon = false;
                  includes = arrayIncludesWith;
                } else
                if (length >= LARGE_ARRAY_SIZE) {
                  var set = iteratee ? null : createSet(array);
                  if (set) {
                    return setToArray(set);
                  }
                  isCommon = false;
                  includes = cacheHas;
                  seen = new SetCache();
                } else
                {
                  seen = iteratee ? [] : result;
                }
                outer:
                while (++index < length) {
                  var value = array[index],
                  computed = iteratee ? iteratee(value) : value;

                  value = comparator || value !== 0 ? value : 0;
                  if (isCommon && computed === computed) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                      if (seen[seenIndex] === computed) {
                        continue outer;
                      }
                    }
                    if (iteratee) {
                      seen.push(computed);
                    }
                    result.push(value);
                  } else
                  if (!includes(seen, computed, comparator)) {
                    if (seen !== result) {
                      seen.push(computed);
                    }
                    result.push(value);
                  }
                }
                return result;
              }

              /**
               * The base implementation of `_.unset`.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {Array|string} path The property path to unset.
               * @returns {boolean} Returns `true` if the property is deleted, else `false`.
               */
              function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
              }

              /**
               * The base implementation of `_.update`.
               *
               * @private
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to update.
               * @param {Function} updater The function to produce the updated value.
               * @param {Function} [customizer] The function to customize path creation.
               * @returns {Object} Returns `object`.
               */
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
              }

              /**
               * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
               * without support for iteratee shorthands.
               *
               * @private
               * @param {Array} array The array to query.
               * @param {Function} predicate The function invoked per iteration.
               * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Array} Returns the slice of `array`.
               */
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length,
                index = fromRight ? length : -1;

                while ((fromRight ? index-- : ++index < length) &&
                predicate(array[index], index, array)) {}

                return isDrop ?
                baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) :
                baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
              }

              /**
               * The base implementation of `wrapperValue` which returns the result of
               * performing a sequence of actions on the unwrapped `value`, where each
               * successive action is supplied the return value of the previous.
               *
               * @private
               * @param {*} value The unwrapped value.
               * @param {Array} actions Actions to perform to resolve the unwrapped value.
               * @returns {*} Returns the resolved value.
               */
              function baseWrapperValue(value, actions) {
                var result = value;
                if (result instanceof LazyWrapper) {
                  result = result.value();
                }
                return arrayReduce(actions, function (result, action) {
                  return action.func.apply(action.thisArg, arrayPush([result], action.args));
                }, result);
              }

              /**
               * The base implementation of methods like `_.xor`, without support for
               * iteratee shorthands, that accepts an array of arrays to inspect.
               *
               * @private
               * @param {Array} arrays The arrays to inspect.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of values.
               */
              function baseXor(arrays, iteratee, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index = -1,
                result = Array(length);

                while (++index < length) {
                  var array = arrays[index],
                  othIndex = -1;

                  while (++othIndex < length) {
                    if (othIndex != index) {
                      result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                    }
                  }
                }
                return baseUniq(baseFlatten(result, 1), iteratee, comparator);
              }

              /**
               * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
               *
               * @private
               * @param {Array} props The property identifiers.
               * @param {Array} values The property values.
               * @param {Function} assignFunc The function to assign values.
               * @returns {Object} Returns the new object.
               */
              function baseZipObject(props, values, assignFunc) {
                var index = -1,
                length = props.length,
                valsLength = values.length,
                result = {};

                while (++index < length) {
                  var value = index < valsLength ? values[index] : undefined;
                  assignFunc(result, props[index], value);
                }
                return result;
              }

              /**
               * Casts `value` to an empty array if it's not an array like object.
               *
               * @private
               * @param {*} value The value to inspect.
               * @returns {Array|Object} Returns the cast array-like object.
               */
              function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
              }

              /**
               * Casts `value` to `identity` if it's not a function.
               *
               * @private
               * @param {*} value The value to inspect.
               * @returns {Function} Returns cast function.
               */
              function castFunction(value) {
                return typeof value == 'function' ? value : identity;
              }

              /**
               * Casts `value` to a path array if it's not one.
               *
               * @private
               * @param {*} value The value to inspect.
               * @param {Object} [object] The object to query keys on.
               * @returns {Array} Returns the cast property path array.
               */
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
              }

              /**
               * A `baseRest` alias which can be replaced with `identity` by module
               * replacement plugins.
               *
               * @private
               * @type {Function}
               * @param {Function} func The function to apply a rest parameter to.
               * @returns {Function} Returns the new function.
               */
              var castRest = baseRest;

              /**
               * Casts `array` to a slice if it's needed.
               *
               * @private
               * @param {Array} array The array to inspect.
               * @param {number} start The start position.
               * @param {number} [end=array.length] The end position.
               * @returns {Array} Returns the cast slice.
               */
              function castSlice(array, start, end) {
                var length = array.length;
                end = end === undefined ? length : end;
                return !start && end >= length ? array : baseSlice(array, start, end);
              }

              /**
               * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
               *
               * @private
               * @param {number|Object} id The timer id or timeout object of the timer to clear.
               */
              var clearTimeout = ctxClearTimeout || function (id) {
                return root.clearTimeout(id);
              };

              /**
               * Creates a clone of  `buffer`.
               *
               * @private
               * @param {Buffer} buffer The buffer to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Buffer} Returns the cloned buffer.
               */
              function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length,
                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

                buffer.copy(result);
                return result;
              }

              /**
               * Creates a clone of `arrayBuffer`.
               *
               * @private
               * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
               * @returns {ArrayBuffer} Returns the cloned array buffer.
               */
              function cloneArrayBuffer(arrayBuffer) {
                var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                return result;
              }

              /**
               * Creates a clone of `dataView`.
               *
               * @private
               * @param {Object} dataView The data view to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned data view.
               */
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }

              /**
               * Creates a clone of `regexp`.
               *
               * @private
               * @param {Object} regexp The regexp to clone.
               * @returns {Object} Returns the cloned regexp.
               */
              function cloneRegExp(regexp) {
                var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result.lastIndex = regexp.lastIndex;
                return result;
              }

              /**
               * Creates a clone of the `symbol` object.
               *
               * @private
               * @param {Object} symbol The symbol object to clone.
               * @returns {Object} Returns the cloned symbol object.
               */
              function cloneSymbol(symbol) {
                return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }

              /**
               * Creates a clone of `typedArray`.
               *
               * @private
               * @param {Object} typedArray The typed array to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the cloned typed array.
               */
              function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }

              /**
               * Compares values to sort them in ascending order.
               *
               * @private
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {number} Returns the sort order indicator for `value`.
               */
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined,
                  valIsNull = value === null,
                  valIsReflexive = value === value,
                  valIsSymbol = isSymbol(value);

                  var othIsDefined = other !== undefined,
                  othIsNull = other === null,
                  othIsReflexive = other === other,
                  othIsSymbol = isSymbol(other);

                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other ||
                  valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol ||
                  valIsNull && othIsDefined && othIsReflexive ||
                  !valIsDefined && othIsReflexive ||
                  !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other ||
                  othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol ||
                  othIsNull && valIsDefined && valIsReflexive ||
                  !othIsDefined && valIsReflexive ||
                  !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }

              /**
               * Used by `_.orderBy` to compare multiple properties of a value to another
               * and stable sort them.
               *
               * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
               * specify an order of "desc" for descending or "asc" for ascending sort order
               * of corresponding values.
               *
               * @private
               * @param {Object} object The object to compare.
               * @param {Object} other The other object to compare.
               * @param {boolean[]|string[]} orders The order to sort by for each property.
               * @returns {number} Returns the sort order indicator for `object`.
               */
              function compareMultiple(object, other, orders) {
                var index = -1,
                objCriteria = object.criteria,
                othCriteria = other.criteria,
                length = objCriteria.length,
                ordersLength = orders.length;

                while (++index < length) {
                  var result = compareAscending(objCriteria[index], othCriteria[index]);
                  if (result) {
                    if (index >= ordersLength) {
                      return result;
                    }
                    var order = orders[index];
                    return result * (order == 'desc' ? -1 : 1);
                  }
                }
                // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                // that causes it, under certain circumstances, to provide the same value for
                // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                // for more details.
                //
                // This also ensures a stable sort in V8 and other engines.
                // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                return object.index - other.index;
              }

              /**
               * Creates an array that is the composition of partially applied arguments,
               * placeholders, and provided arguments into a single array of arguments.
               *
               * @private
               * @param {Array} args The provided arguments.
               * @param {Array} partials The arguments to prepend to those provided.
               * @param {Array} holders The `partials` placeholder indexes.
               * @params {boolean} [isCurried] Specify composing for a curried function.
               * @returns {Array} Returns the new array of composed arguments.
               */
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1,
                argsLength = args.length,
                holdersLength = holders.length,
                leftIndex = -1,
                leftLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(leftLength + rangeLength),
                isUncurried = !isCurried;

                while (++leftIndex < leftLength) {
                  result[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result[leftIndex++] = args[argsIndex++];
                }
                return result;
              }

              /**
               * This function is like `composeArgs` except that the arguments composition
               * is tailored for `_.partialRight`.
               *
               * @private
               * @param {Array} args The provided arguments.
               * @param {Array} partials The arguments to append to those provided.
               * @param {Array} holders The `partials` placeholder indexes.
               * @params {boolean} [isCurried] Specify composing for a curried function.
               * @returns {Array} Returns the new array of composed arguments.
               */
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1,
                argsLength = args.length,
                holdersIndex = -1,
                holdersLength = holders.length,
                rightIndex = -1,
                rightLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(rangeLength + rightLength),
                isUncurried = !isCurried;

                while (++argsIndex < rangeLength) {
                  result[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result;
              }

              /**
               * Copies the values of `source` to `array`.
               *
               * @private
               * @param {Array} source The array to copy values from.
               * @param {Array} [array=[]] The array to copy values to.
               * @returns {Array} Returns `array`.
               */
              function copyArray(source, array) {
                var index = -1,
                length = source.length;

                array || (array = Array(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }

              /**
               * Copies properties of `source` to `object`.
               *
               * @private
               * @param {Object} source The object to copy properties from.
               * @param {Array} props The property identifiers to copy.
               * @param {Object} [object={}] The object to copy properties to.
               * @param {Function} [customizer] The function to customize copied values.
               * @returns {Object} Returns `object`.
               */
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});

                var index = -1,
                length = props.length;

                while (++index < length) {
                  var key = props[index];

                  var newValue = customizer ?
                  customizer(object[key], source[key], key, object, source) :
                  undefined;

                  if (newValue === undefined) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }

              /**
               * Copies own symbols of `source` to `object`.
               *
               * @private
               * @param {Object} source The object to copy symbols from.
               * @param {Object} [object={}] The object to copy symbols to.
               * @returns {Object} Returns `object`.
               */
              function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
              }

              /**
               * Copies own and inherited symbols of `source` to `object`.
               *
               * @private
               * @param {Object} source The object to copy symbols from.
               * @param {Object} [object={}] The object to copy symbols to.
               * @returns {Object} Returns `object`.
               */
              function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
              }

              /**
               * Creates a function like `_.groupBy`.
               *
               * @private
               * @param {Function} setter The function to set accumulator values.
               * @param {Function} [initializer] The accumulator object initializer.
               * @returns {Function} Returns the new aggregator function.
               */
              function createAggregator(setter, initializer) {
                return function (collection, iteratee) {
                  var func = isArray(collection) ? arrayAggregator : baseAggregator,
                  accumulator = initializer ? initializer() : {};

                  return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                };
              }

              /**
               * Creates a function like `_.assign`.
               *
               * @private
               * @param {Function} assigner The function to assign values.
               * @returns {Function} Returns the new assigner function.
               */
              function createAssigner(assigner) {
                return baseRest(function (object, sources) {
                  var index = -1,
                  length = sources.length,
                  customizer = length > 1 ? sources[length - 1] : undefined,
                  guard = length > 2 ? sources[2] : undefined;

                  customizer = assigner.length > 3 && typeof customizer == 'function' ? (
                  length--, customizer) :
                  undefined;

                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                  }
                  object = Object(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }

              /**
               * Creates a `baseEach` or `baseEachRight` function.
               *
               * @private
               * @param {Function} eachFunc The function to iterate over a collection.
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Function} Returns the new base function.
               */
              function createBaseEach(eachFunc, fromRight) {
                return function (collection, iteratee) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                  }
                  var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);

                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }

              /**
               * Creates a base function for methods like `_.forIn` and `_.forOwn`.
               *
               * @private
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Function} Returns the new base function.
               */
              function createBaseFor(fromRight) {
                return function (object, iteratee, keysFunc) {
                  var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;

                  while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }

              /**
               * Creates a function that wraps `func` to invoke it with the optional `this`
               * binding of `thisArg`.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @param {*} [thisArg] The `this` binding of `func`.
               * @returns {Function} Returns the new wrapped function.
               */
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

                function wrapper() {
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }

              /**
               * Creates a function like `_.lowerFirst`.
               *
               * @private
               * @param {string} methodName The name of the `String` case method to use.
               * @returns {Function} Returns the new case function.
               */
              function createCaseFirst(methodName) {
                return function (string) {
                  string = toString(string);

                  var strSymbols = hasUnicode(string) ?
                  stringToArray(string) :
                  undefined;

                  var chr = strSymbols ?
                  strSymbols[0] :
                  string.charAt(0);

                  var trailing = strSymbols ?
                  castSlice(strSymbols, 1).join('') :
                  string.slice(1);

                  return chr[methodName]() + trailing;
                };
              }

              /**
               * Creates a function like `_.camelCase`.
               *
               * @private
               * @param {Function} callback The function to combine each word.
               * @returns {Function} Returns the new compounder function.
               */
              function createCompounder(callback) {
                return function (string) {
                  return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                };
              }

              /**
               * Creates a function that produces an instance of `Ctor` regardless of
               * whether it was invoked as part of a `new` expression or by `call` or `apply`.
               *
               * @private
               * @param {Function} Ctor The constructor to wrap.
               * @returns {Function} Returns the new wrapped function.
               */
              function createCtor(Ctor) {
                return function () {
                  // Use a `switch` statement to work with class constructors. See
                  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                  // for more details.
                  var args = arguments;
                  switch (args.length) {
                    case 0:return new Ctor();
                    case 1:return new Ctor(args[0]);
                    case 2:return new Ctor(args[0], args[1]);
                    case 3:return new Ctor(args[0], args[1], args[2]);
                    case 4:return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);}

                  var thisBinding = baseCreate(Ctor.prototype),
                  result = Ctor.apply(thisBinding, args);

                  // Mimic the constructor's `return` behavior.
                  // See https://es5.github.io/#x13.2.2 for more details.
                  return isObject(result) ? result : thisBinding;
                };
              }

              /**
               * Creates a function that wraps `func` to enable currying.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @param {number} arity The arity of `func`.
               * @returns {Function} Returns the new wrapped function.
               */
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);

                function wrapper() {
                  var length = arguments.length,
                  args = Array(length),
                  index = length,
                  placeholder = getHolder(wrapper);

                  while (index--) {
                    args[index] = arguments[index];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ?
                  [] :
                  replaceHolders(args, placeholder);

                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(
                    func, bitmask, createHybrid, wrapper.placeholder, undefined,
                    args, holders, undefined, undefined, arity - length);
                  }
                  var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                  return apply(fn, this, args);
                }
                return wrapper;
              }

              /**
               * Creates a `_.find` or `_.findLast` function.
               *
               * @private
               * @param {Function} findIndexFunc The function to find the collection index.
               * @returns {Function} Returns the new find function.
               */
              function createFind(findIndexFunc) {
                return function (collection, predicate, fromIndex) {
                  var iterable = Object(collection);
                  if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection);
                    predicate = function (key) {return iteratee(iterable[key], key, iterable);};
                  }
                  var index = findIndexFunc(collection, predicate, fromIndex);
                  return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                };
              }

              /**
               * Creates a `_.flow` or `_.flowRight` function.
               *
               * @private
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Function} Returns the new flow function.
               */
              function createFlow(fromRight) {
                return flatRest(function (funcs) {
                  var length = funcs.length,
                  index = length,
                  prereq = LodashWrapper.prototype.thru;

                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index--) {
                    var func = funcs[index];
                    if (typeof func != 'function') {
                      throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index = wrapper ? index : length;
                  while (++index < length) {
                    func = funcs[index];

                    var funcName = getFuncName(func),
                    data = funcName == 'wrapper' ? getData(func) : undefined;

                    if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1)
                    {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ?
                      wrapper[funcName]() :
                      wrapper.thru(func);
                    }
                  }
                  return function () {
                    var args = arguments,
                    value = args[0];

                    if (wrapper && args.length == 1 && isArray(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index = 0,
                    result = length ? funcs[index].apply(this, args) : value;

                    while (++index < length) {
                      result = funcs[index].call(this, result);
                    }
                    return result;
                  };
                });
              }

              /**
               * Creates a function that wraps `func` to invoke it with optional `this`
               * binding of `thisArg`, partial application, and currying.
               *
               * @private
               * @param {Function|string} func The function or method name to wrap.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @param {*} [thisArg] The `this` binding of `func`.
               * @param {Array} [partials] The arguments to prepend to those provided to
               *  the new function.
               * @param {Array} [holders] The `partials` placeholder indexes.
               * @param {Array} [partialsRight] The arguments to append to those provided
               *  to the new function.
               * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
               * @param {Array} [argPos] The argument positions of the new function.
               * @param {number} [ary] The arity cap of `func`.
               * @param {number} [arity] The arity of `func`.
               * @returns {Function} Returns the new wrapped function.
               */
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG,
                isBind = bitmask & WRAP_BIND_FLAG,
                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                isFlip = bitmask & WRAP_FLIP_FLAG,
                Ctor = isBindKey ? undefined : createCtor(func);

                function wrapper() {
                  var length = arguments.length,
                  args = Array(length),
                  index = length;

                  while (index--) {
                    args[index] = arguments[index];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper),
                    holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(
                    func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                    args, newHolders, argPos, ary, arity - length);

                  }
                  var thisBinding = isBind ? thisArg : this,
                  fn = isBindKey ? thisBinding[func] : func;

                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary < length) {
                    args.length = ary;
                  }
                  if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }

              /**
               * Creates a function like `_.invertBy`.
               *
               * @private
               * @param {Function} setter The function to set accumulator values.
               * @param {Function} toIteratee The function to resolve iteratees.
               * @returns {Function} Returns the new inverter function.
               */
              function createInverter(setter, toIteratee) {
                return function (object, iteratee) {
                  return baseInverter(object, setter, toIteratee(iteratee), {});
                };
              }

              /**
               * Creates a function that performs a mathematical operation on two values.
               *
               * @private
               * @param {Function} operator The function to perform the operation.
               * @param {number} [defaultValue] The value used for `undefined` arguments.
               * @returns {Function} Returns the new mathematical operation function.
               */
              function createMathOperation(operator, defaultValue) {
                return function (value, other) {
                  var result;
                  if (value === undefined && other === undefined) {
                    return defaultValue;
                  }
                  if (value !== undefined) {
                    result = value;
                  }
                  if (other !== undefined) {
                    if (result === undefined) {
                      return other;
                    }
                    if (typeof value == 'string' || typeof other == 'string') {
                      value = baseToString(value);
                      other = baseToString(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result = operator(value, other);
                  }
                  return result;
                };
              }

              /**
               * Creates a function like `_.over`.
               *
               * @private
               * @param {Function} arrayFunc The function to iterate over iteratees.
               * @returns {Function} Returns the new over function.
               */
              function createOver(arrayFunc) {
                return flatRest(function (iteratees) {
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  return baseRest(function (args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function (iteratee) {
                      return apply(iteratee, thisArg, args);
                    });
                  });
                });
              }

              /**
               * Creates the padding for `string` based on `length`. The `chars` string
               * is truncated if the number of characters exceeds `length`.
               *
               * @private
               * @param {number} length The padding length.
               * @param {string} [chars=' '] The string used as padding.
               * @returns {string} Returns the padding for `string`.
               */
              function createPadding(length, chars) {
                chars = chars === undefined ? ' ' : baseToString(chars);

                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ?
                castSlice(stringToArray(result), 0, length).join('') :
                result.slice(0, length);
              }

              /**
               * Creates a function that wraps `func` to invoke it with the `this` binding
               * of `thisArg` and `partials` prepended to the arguments it receives.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @param {*} thisArg The `this` binding of `func`.
               * @param {Array} partials The arguments to prepend to those provided to
               *  the new function.
               * @returns {Function} Returns the new wrapped function.
               */
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

                function wrapper() {
                  var argsIndex = -1,
                  argsLength = arguments.length,
                  leftIndex = -1,
                  leftLength = partials.length,
                  args = Array(leftLength + argsLength),
                  fn = this && this !== root && this instanceof wrapper ? Ctor : func;

                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }

              /**
               * Creates a `_.range` or `_.rangeRight` function.
               *
               * @private
               * @param {boolean} [fromRight] Specify iterating from right to left.
               * @returns {Function} Returns the new range function.
               */
              function createRange(fromRight) {
                return function (start, end, step) {
                  if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                    end = step = undefined;
                  }
                  // Ensure the sign of `-0` is preserved.
                  start = toFinite(start);
                  if (end === undefined) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }

              /**
               * Creates a function that performs a relational operation on two values.
               *
               * @private
               * @param {Function} operator The function to perform the operation.
               * @returns {Function} Returns the new relational operation function.
               */
              function createRelationalOperation(operator) {
                return function (value, other) {
                  if (!(typeof value == 'string' && typeof other == 'string')) {
                    value = toNumber(value);
                    other = toNumber(other);
                  }
                  return operator(value, other);
                };
              }

              /**
               * Creates a function that wraps `func` to continue currying.
               *
               * @private
               * @param {Function} func The function to wrap.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @param {Function} wrapFunc The function to create the `func` wrapper.
               * @param {*} placeholder The placeholder value.
               * @param {*} [thisArg] The `this` binding of `func`.
               * @param {Array} [partials] The arguments to prepend to those provided to
               *  the new function.
               * @param {Array} [holders] The `partials` placeholder indexes.
               * @param {Array} [argPos] The argument positions of the new function.
               * @param {number} [ary] The arity cap of `func`.
               * @param {number} [arity] The arity of `func`.
               * @returns {Function} Returns the new wrapped function.
               */
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG,
                newHolders = isCurry ? holders : undefined,
                newHoldersRight = isCurry ? undefined : holders,
                newPartials = isCurry ? partials : undefined,
                newPartialsRight = isCurry ? undefined : partials;

                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                }
                var newData = [
                func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
                newHoldersRight, argPos, ary, arity];


                var result = wrapFunc.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return setWrapToString(result, func, bitmask);
              }

              /**
               * Creates a function like `_.round`.
               *
               * @private
               * @param {string} methodName The name of the `Math` method to use when rounding.
               * @returns {Function} Returns the new round function.
               */
              function createRound(methodName) {
                var func = Math[methodName];
                return function (number, precision) {
                  number = toNumber(number);
                  precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                  if (precision && nativeIsFinite(number)) {
                    // Shift with exponential notation to avoid floating-point issues.
                    // See [MDN](https://mdn.io/round#Examples) for more details.
                    var pair = (toString(number) + 'e').split('e'),
                    value = func(pair[0] + 'e' + (+pair[1] + precision));

                    pair = (toString(value) + 'e').split('e');
                    return +(pair[0] + 'e' + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }

              /**
               * Creates a set object of `values`.
               *
               * @private
               * @param {Array} values The values to add to the set.
               * @returns {Object} Returns the new set.
               */
              var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
                return new Set(values);
              };

              /**
               * Creates a `_.toPairs` or `_.toPairsIn` function.
               *
               * @private
               * @param {Function} keysFunc The function to get the keys of a given object.
               * @returns {Function} Returns the new pairs function.
               */
              function createToPairs(keysFunc) {
                return function (object) {
                  var tag = getTag(object);
                  if (tag == mapTag) {
                    return mapToArray(object);
                  }
                  if (tag == setTag) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }

              /**
               * Creates a function that either curries or invokes `func` with optional
               * `this` binding and partially applied arguments.
               *
               * @private
               * @param {Function|string} func The function or method name to wrap.
               * @param {number} bitmask The bitmask flags.
               *    1 - `_.bind`
               *    2 - `_.bindKey`
               *    4 - `_.curry` or `_.curryRight` of a bound function
               *    8 - `_.curry`
               *   16 - `_.curryRight`
               *   32 - `_.partial`
               *   64 - `_.partialRight`
               *  128 - `_.rearg`
               *  256 - `_.ary`
               *  512 - `_.flip`
               * @param {*} [thisArg] The `this` binding of `func`.
               * @param {Array} [partials] The arguments to be partially applied.
               * @param {Array} [holders] The `partials` placeholder indexes.
               * @param {Array} [argPos] The argument positions of the new function.
               * @param {number} [ary] The arity cap of `func`.
               * @param {number} [arity] The arity of `func`.
               * @returns {Function} Returns the new wrapped function.
               */
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                  partials = holders = undefined;
                }
                ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                arity = arity === undefined ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;

                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials,
                  holdersRight = holders;

                  partials = holders = undefined;
                }
                var data = isBindKey ? undefined : getData(func);

                var newData = [
                func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
                argPos, ary, arity];


                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined ?
                isBindKey ? 0 : func.length :
                nativeMax(newData[9] - length, 0);

                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                  bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                  result = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                  result = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result = createHybrid.apply(undefined, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result, newData), func, bitmask);
              }

              /**
               * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
               * of source objects to the destination object for all destination properties
               * that resolve to `undefined`.
               *
               * @private
               * @param {*} objValue The destination value.
               * @param {*} srcValue The source value.
               * @param {string} key The key of the property to assign.
               * @param {Object} object The parent object of `objValue`.
               * @returns {*} Returns the value to assign.
               */
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined ||
                eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }

              /**
               * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
               * objects into destination objects that are passed thru.
               *
               * @private
               * @param {*} objValue The destination value.
               * @param {*} srcValue The source value.
               * @param {string} key The key of the property to merge.
               * @param {Object} object The parent object of `objValue`.
               * @param {Object} source The parent object of `srcValue`.
               * @param {Object} [stack] Tracks traversed source values and their merged
               *  counterparts.
               * @returns {*} Returns the value to assign.
               */
              function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                if (isObject(objValue) && isObject(srcValue)) {
                  // Recursively merge objects and arrays (susceptible to call stack limits).
                  stack.set(srcValue, objValue);
                  baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                  stack['delete'](srcValue);
                }
                return objValue;
              }

              /**
               * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
               * objects.
               *
               * @private
               * @param {*} value The value to inspect.
               * @param {string} key The key of the property to inspect.
               * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
               */
              function customOmitClone(value) {
                return isPlainObject(value) ? undefined : value;
              }

              /**
               * A specialized version of `baseIsEqualDeep` for arrays with support for
               * partial deep comparisons.
               *
               * @private
               * @param {Array} array The array to compare.
               * @param {Array} other The other array to compare.
               * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
               * @param {Function} customizer The function to customize comparisons.
               * @param {Function} equalFunc The function to determine equivalents of values.
               * @param {Object} stack Tracks traversed `array` and `other` objects.
               * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
               */
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                arrLength = array.length,
                othLength = other.length;

                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                // Check that cyclic values are equal.
                var arrStacked = stack.get(array);
                var othStacked = stack.get(other);
                if (arrStacked && othStacked) {
                  return arrStacked == other && othStacked == array;
                }
                var index = -1,
                result = true,
                seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

                stack.set(array, other);
                stack.set(other, array);

                // Ignore non-index properties.
                while (++index < arrLength) {
                  var arrValue = array[index],
                  othValue = other[index];

                  if (customizer) {
                    var compared = isPartial ?
                    customizer(othValue, arrValue, index, other, array, stack) :
                    customizer(arrValue, othValue, index, array, other, stack);
                  }
                  if (compared !== undefined) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  // Recursively compare arrays (susceptible to call stack limits).
                  if (seen) {
                    if (!arraySome(other, function (othValue, othIndex) {
                      if (!cacheHas(seen, othIndex) && (
                      arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                      }
                    })) {
                      result = false;
                      break;
                    }
                  } else if (!(
                  arrValue === othValue ||
                  equalFunc(arrValue, othValue, bitmask, customizer, stack)))
                  {
                    result = false;
                    break;
                  }
                }
                stack['delete'](array);
                stack['delete'](other);
                return result;
              }

              /**
               * A specialized version of `baseIsEqualDeep` for comparing objects of
               * the same `toStringTag`.
               *
               * **Note:** This function only supports comparing values with tags of
               * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
               *
               * @private
               * @param {Object} object The object to compare.
               * @param {Object} other The other object to compare.
               * @param {string} tag The `toStringTag` of the objects to compare.
               * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
               * @param {Function} customizer The function to customize comparisons.
               * @param {Function} equalFunc The function to determine equivalents of values.
               * @param {Object} stack Tracks traversed `object` and `other` objects.
               * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
               */
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;

                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                      return false;
                    }
                    return true;

                  case boolTag:
                  case dateTag:
                  case numberTag:
                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                    // Invalid dates are coerced to `NaN`.
                    return eq(+object, +other);

                  case errorTag:
                    return object.name == other.name && object.message == other.message;

                  case regexpTag:
                  case stringTag:
                    // Coerce regexes to strings and treat strings, primitives and objects,
                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                    // for more details.
                    return object == other + '';

                  case mapTag:
                    var convert = mapToArray;

                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);

                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;

                    // Recursively compare objects (susceptible to call stack limits).
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack['delete'](object);
                    return result;

                  case symbolTag:
                    if (symbolValueOf) {
                      return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }}

                return false;
              }

              /**
               * A specialized version of `baseIsEqualDeep` for objects with support for
               * partial deep comparisons.
               *
               * @private
               * @param {Object} object The object to compare.
               * @param {Object} other The other object to compare.
               * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
               * @param {Function} customizer The function to customize comparisons.
               * @param {Function} equalFunc The function to determine equivalents of values.
               * @param {Object} stack Tracks traversed `object` and `other` objects.
               * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
               */
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                objProps = getAllKeys(object),
                objLength = objProps.length,
                othProps = getAllKeys(other),
                othLength = othProps.length;

                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                // Check that cyclic values are equal.
                var objStacked = stack.get(object);
                var othStacked = stack.get(other);
                if (objStacked && othStacked) {
                  return objStacked == other && othStacked == object;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);

                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key],
                  othValue = other[key];

                  if (customizer) {
                    var compared = isPartial ?
                    customizer(othValue, objValue, key, other, object, stack) :
                    customizer(objValue, othValue, key, object, other, stack);
                  }
                  // Recursively compare objects (susceptible to call stack limits).
                  if (!(compared === undefined ?
                  objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) :
                  compared))
                  {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == 'constructor');
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor,
                  othCtor = other.constructor;

                  // Non `Object` object instances with different constructors are not equal.
                  if (objCtor != othCtor &&
                  'constructor' in object && 'constructor' in other &&
                  !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    result = false;
                  }
                }
                stack['delete'](object);
                stack['delete'](other);
                return result;
              }

              /**
               * A specialized version of `baseRest` which flattens the rest array.
               *
               * @private
               * @param {Function} func The function to apply a rest parameter to.
               * @returns {Function} Returns the new function.
               */
              function flatRest(func) {
                return setToString(overRest(func, undefined, flatten), func + '');
              }

              /**
               * Creates an array of own enumerable property names and symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names and symbols.
               */
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }

              /**
               * Creates an array of own and inherited enumerable property names and
               * symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names and symbols.
               */
              function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
              }

              /**
               * Gets metadata for `func`.
               *
               * @private
               * @param {Function} func The function to query.
               * @returns {*} Returns the metadata for `func`.
               */
              var getData = !metaMap ? noop : function (func) {
                return metaMap.get(func);
              };

              /**
               * Gets the name of `func`.
               *
               * @private
               * @param {Function} func The function to query.
               * @returns {string} Returns the function name.
               */
              function getFuncName(func) {
                var result = func.name + '',
                array = realNames[result],
                length = hasOwnProperty.call(realNames, result) ? array.length : 0;

                while (length--) {
                  var data = array[length],
                  otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result;
              }

              /**
               * Gets the argument placeholder value for `func`.
               *
               * @private
               * @param {Function} func The function to inspect.
               * @returns {*} Returns the placeholder value.
               */
              function getHolder(func) {
                var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                return object.placeholder;
              }

              /**
               * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
               * this function returns the custom method, otherwise it returns `baseIteratee`.
               * If arguments are provided, the chosen function is invoked with them and
               * its result is returned.
               *
               * @private
               * @param {*} [value] The value to convert to an iteratee.
               * @param {number} [arity] The arity of the created iteratee.
               * @returns {Function} Returns the chosen function or its result.
               */
              function getIteratee() {
                var result = lodash.iteratee || iteratee;
                result = result === iteratee ? baseIteratee : result;
                return arguments.length ? result(arguments[0], arguments[1]) : result;
              }

              /**
               * Gets the data for `map`.
               *
               * @private
               * @param {Object} map The map to query.
               * @param {string} key The reference key.
               * @returns {*} Returns the map data.
               */
              function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ?
                data[typeof key == 'string' ? 'string' : 'hash'] :
                data.map;
              }

              /**
               * Gets the property names, values, and compare flags of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the match data of `object`.
               */
              function getMatchData(object) {
                var result = keys(object),
                length = result.length;

                while (length--) {
                  var key = result[length],
                  value = object[key];

                  result[length] = [key, value, isStrictComparable(value)];
                }
                return result;
              }

              /**
               * Gets the native function at `key` of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {string} key The key of the method to get.
               * @returns {*} Returns the function if it's native, else `undefined`.
               */
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined;
              }

              /**
               * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
               *
               * @private
               * @param {*} value The value to query.
               * @returns {string} Returns the raw `toStringTag`.
               */
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag];

                try {
                  value[symToStringTag] = undefined;
                  var unmasked = true;
                } catch (e) {}

                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }

              /**
               * Creates an array of the own enumerable symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of symbols.
               */
              var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                if (object == null) {
                  return [];
                }
                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), function (symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };

              /**
               * Creates an array of the own and inherited enumerable symbols of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of symbols.
               */
              var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                var result = [];
                while (object) {
                  arrayPush(result, getSymbols(object));
                  object = getPrototype(object);
                }
                return result;
              };

              /**
               * Gets the `toStringTag` of `value`.
               *
               * @private
               * @param {*} value The value to query.
               * @returns {string} Returns the `toStringTag`.
               */
              var getTag = baseGetTag;

              // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
              if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag ||
              Map && getTag(new Map()) != mapTag ||
              Promise && getTag(Promise.resolve()) != promiseTag ||
              Set && getTag(new Set()) != setTag ||
              WeakMap && getTag(new WeakMap()) != weakMapTag) {
                getTag = function (value) {
                  var result = baseGetTag(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : '';

                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:return dataViewTag;
                      case mapCtorString:return mapTag;
                      case promiseCtorString:return promiseTag;
                      case setCtorString:return setTag;
                      case weakMapCtorString:return weakMapTag;}

                  }
                  return result;
                };
              }

              /**
               * Gets the view, applying any `transforms` to the `start` and `end` positions.
               *
               * @private
               * @param {number} start The start of the view.
               * @param {number} end The end of the view.
               * @param {Array} transforms The transformations to apply to the view.
               * @returns {Object} Returns an object containing the `start` and `end`
               *  positions of the view.
               */
              function getView(start, end, transforms) {
                var index = -1,
                length = transforms.length;

                while (++index < length) {
                  var data = transforms[index],
                  size = data.size;

                  switch (data.type) {
                    case 'drop':start += size;break;
                    case 'dropRight':end -= size;break;
                    case 'take':end = nativeMin(end, start + size);break;
                    case 'takeRight':start = nativeMax(start, end - size);break;}

                }
                return { 'start': start, 'end': end };
              }

              /**
               * Extracts wrapper details from the `source` body comment.
               *
               * @private
               * @param {string} source The source to inspect.
               * @returns {Array} Returns the wrapper details.
               */
              function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
              }

              /**
               * Checks if `path` exists on `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array|string} path The path to check.
               * @param {Function} hasFunc The function to check properties.
               * @returns {boolean} Returns `true` if `path` exists, else `false`.
               */
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);

                var index = -1,
                length = path.length,
                result = false;

                while (++index < length) {
                  var key = toKey(path[index]);
                  if (!(result = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result || ++index != length) {
                  return result;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (
                isArray(object) || isArguments(object));
              }

              /**
               * Initializes an array clone.
               *
               * @private
               * @param {Array} array The array to clone.
               * @returns {Array} Returns the initialized clone.
               */
              function initCloneArray(array) {
                var length = array.length,
                result = new array.constructor(length);

                // Add properties assigned by `RegExp#exec`.
                if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                  result.index = array.index;
                  result.input = array.input;
                }
                return result;
              }

              /**
               * Initializes an object clone.
               *
               * @private
               * @param {Object} object The object to clone.
               * @returns {Object} Returns the initialized clone.
               */
              function initCloneObject(object) {
                return typeof object.constructor == 'function' && !isPrototype(object) ?
                baseCreate(getPrototype(object)) :
                {};
              }

              /**
               * Initializes an object clone based on its `toStringTag`.
               *
               * **Note:** This function only supports cloning values with tags of
               * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
               *
               * @private
               * @param {Object} object The object to clone.
               * @param {string} tag The `toStringTag` of the object to clone.
               * @param {boolean} [isDeep] Specify a deep clone.
               * @returns {Object} Returns the initialized clone.
               */
              function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag:
                    return cloneArrayBuffer(object);

                  case boolTag:
                  case dateTag:
                    return new Ctor(+object);

                  case dataViewTag:
                    return cloneDataView(object, isDeep);

                  case float32Tag:case float64Tag:
                  case int8Tag:case int16Tag:case int32Tag:
                  case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
                    return cloneTypedArray(object, isDeep);

                  case mapTag:
                    return new Ctor();

                  case numberTag:
                  case stringTag:
                    return new Ctor(object);

                  case regexpTag:
                    return cloneRegExp(object);

                  case setTag:
                    return new Ctor();

                  case symbolTag:
                    return cloneSymbol(object);}

              }

              /**
               * Inserts wrapper `details` in a comment at the top of the `source` body.
               *
               * @private
               * @param {string} source The source to modify.
               * @returns {Array} details The details to insert.
               * @returns {string} Returns the modified source.
               */
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                details = details.join(length > 2 ? ', ' : ' ');
                return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
              }

              /**
               * Checks if `value` is a flattenable `arguments` object or array.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
               */
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) ||
                !!(spreadableSymbol && value && value[spreadableSymbol]);
              }

              /**
               * Checks if `value` is a valid array-like index.
               *
               * @private
               * @param {*} value The value to check.
               * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
               * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
               */
              function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;

                return !!length && (
                type == 'number' ||
                type != 'symbol' && reIsUint.test(value)) &&
                value > -1 && value % 1 == 0 && value < length;
              }

              /**
               * Checks if the given arguments are from an iteratee call.
               *
               * @private
               * @param {*} value The potential iteratee value argument.
               * @param {*} index The potential iteratee index or key argument.
               * @param {*} object The potential iteratee object argument.
               * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
               *  else `false`.
               */
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == 'number' ?
                isArrayLike(object) && isIndex(index, object.length) :
                type == 'string' && index in object)
                {
                  return eq(object[index], value);
                }
                return false;
              }

              /**
               * Checks if `value` is a property name and not a property path.
               *
               * @private
               * @param {*} value The value to check.
               * @param {Object} [object] The object to query keys on.
               * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
               */
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                object != null && value in Object(object);
              }

              /**
               * Checks if `value` is suitable for use as unique object key.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
               */
              function isKeyable(value) {
                var type = typeof value;
                return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ?
                value !== '__proto__' :
                value === null;
              }

              /**
               * Checks if `func` has a lazy counterpart.
               *
               * @private
               * @param {Function} func The function to check.
               * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
               *  else `false`.
               */
              function isLaziable(func) {
                var funcName = getFuncName(func),
                other = lodash[funcName];

                if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }

              /**
               * Checks if `func` has its source masked.
               *
               * @private
               * @param {Function} func The function to check.
               * @returns {boolean} Returns `true` if `func` is masked, else `false`.
               */
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }

              /**
               * Checks if `func` is capable of being masked.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
               */
              var isMaskable = coreJsData ? isFunction : stubFalse;

              /**
               * Checks if `value` is likely a prototype object.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
               */
              function isPrototype(value) {
                var Ctor = value && value.constructor,
                proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

                return value === proto;
              }

              /**
               * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
               *
               * @private
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` if suitable for strict
               *  equality comparisons, else `false`.
               */
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }

              /**
               * A specialized version of `matchesProperty` for source values suitable
               * for strict equality comparisons, i.e. `===`.
               *
               * @private
               * @param {string} key The key of the property to get.
               * @param {*} srcValue The value to match.
               * @returns {Function} Returns the new spec function.
               */
              function matchesStrictComparable(key, srcValue) {
                return function (object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (
                  srcValue !== undefined || key in Object(object));
                };
              }

              /**
               * A specialized version of `_.memoize` which clears the memoized function's
               * cache when it exceeds `MAX_MEMOIZE_SIZE`.
               *
               * @private
               * @param {Function} func The function to have its output memoized.
               * @returns {Function} Returns the new memoized function.
               */
              function memoizeCapped(func) {
                var result = memoize(func, function (key) {
                  if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                  }
                  return key;
                });

                var cache = result.cache;
                return result;
              }

              /**
               * Merges the function metadata of `source` into `data`.
               *
               * Merging metadata reduces the number of wrappers used to invoke a function.
               * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
               * may be applied regardless of execution order. Methods like `_.ary` and
               * `_.rearg` modify function arguments, making the order in which they are
               * executed important, preventing the merging of metadata. However, we make
               * an exception for a safe combined case where curried functions have `_.ary`
               * and or `_.rearg` applied.
               *
               * @private
               * @param {Array} data The destination metadata.
               * @param {Array} source The source metadata.
               * @returns {Array} Returns `data`.
               */
              function mergeData(data, source) {
                var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

                var isCombo =
                srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG ||
                srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] ||
                srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;

                // Exit early if metadata can't be merged.
                if (!(isCommon || isCombo)) {
                  return data;
                }
                // Use source `thisArg` if available.
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  // Set when currying a bound function.
                  newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                // Compose partial arguments.
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                // Compose partial right arguments.
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                // Use source `argPos` if available.
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                // Use source `ary` if it's smaller.
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                // Use source `arity` if one is not provided.
                if (data[9] == null) {
                  data[9] = source[9];
                }
                // Use source `func` and merge bitmasks.
                data[0] = source[0];
                data[1] = newBitmask;

                return data;
              }

              /**
               * This function is like
               * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
               * except that it includes inherited enumerable properties.
               *
               * @private
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               */
              function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                  for (var key in Object(object)) {
                    result.push(key);
                  }
                }
                return result;
              }

              /**
               * Converts `value` to a string using `Object.prototype.toString`.
               *
               * @private
               * @param {*} value The value to convert.
               * @returns {string} Returns the converted string.
               */
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }

              /**
               * A specialized version of `baseRest` which transforms the rest array.
               *
               * @private
               * @param {Function} func The function to apply a rest parameter to.
               * @param {number} [start=func.length-1] The start position of the rest parameter.
               * @param {Function} transform The rest array transform.
               * @returns {Function} Returns the new function.
               */
              function overRest(func, start, transform) {
                start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                return function () {
                  var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);

                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }

              /**
               * Gets the parent value at `path` of `object`.
               *
               * @private
               * @param {Object} object The object to query.
               * @param {Array} path The path to get the parent value of.
               * @returns {*} Returns the parent value.
               */
              function parent(object, path) {
                return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
              }

              /**
               * Reorder `array` according to the specified indexes where the element at
               * the first index is assigned as the first element, the element at
               * the second index is assigned as the second element, and so on.
               *
               * @private
               * @param {Array} array The array to reorder.
               * @param {Array} indexes The arranged array indexes.
               * @returns {Array} Returns `array`.
               */
              function reorder(array, indexes) {
                var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = copyArray(array);

                while (length--) {
                  var index = indexes[length];
                  array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                }
                return array;
              }

              /**
               * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
               *
               * @private
               * @param {Object} object The object to query.
               * @param {string} key The key of the property to get.
               * @returns {*} Returns the property value.
               */
              function safeGet(object, key) {
                if (key === 'constructor' && typeof object[key] === 'function') {
                  return;
                }

                if (key == '__proto__') {
                  return;
                }

                return object[key];
              }

              /**
               * Sets metadata for `func`.
               *
               * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
               * period of time, it will trip its breaker and transition to an identity
               * function to avoid garbage collection pauses in V8. See
               * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
               * for more details.
               *
               * @private
               * @param {Function} func The function to associate metadata with.
               * @param {*} data The metadata.
               * @returns {Function} Returns `func`.
               */
              var setData = shortOut(baseSetData);

              /**
               * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
               *
               * @private
               * @param {Function} func The function to delay.
               * @param {number} wait The number of milliseconds to delay invocation.
               * @returns {number|Object} Returns the timer id or timeout object.
               */
              var setTimeout = ctxSetTimeout || function (func, wait) {
                return root.setTimeout(func, wait);
              };

              /**
               * Sets the `toString` method of `func` to return `string`.
               *
               * @private
               * @param {Function} func The function to modify.
               * @param {Function} string The `toString` result.
               * @returns {Function} Returns `func`.
               */
              var setToString = shortOut(baseSetToString);

              /**
               * Sets the `toString` method of `wrapper` to mimic the source of `reference`
               * with wrapper details in a comment at the top of the source body.
               *
               * @private
               * @param {Function} wrapper The function to modify.
               * @param {Function} reference The reference function.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @returns {Function} Returns `wrapper`.
               */
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + '';
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }

              /**
               * Creates a function that'll short out and invoke `identity` instead
               * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
               * milliseconds.
               *
               * @private
               * @param {Function} func The function to restrict.
               * @returns {Function} Returns the new shortable function.
               */
              function shortOut(func) {
                var count = 0,
                lastCalled = 0;

                return function () {
                  var stamp = nativeNow(),
                  remaining = HOT_SPAN - (stamp - lastCalled);

                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined, arguments);
                };
              }

              /**
               * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
               *
               * @private
               * @param {Array} array The array to shuffle.
               * @param {number} [size=array.length] The size of `array`.
               * @returns {Array} Returns `array`.
               */
              function shuffleSelf(array, size) {
                var index = -1,
                length = array.length,
                lastIndex = length - 1;

                size = size === undefined ? length : size;
                while (++index < size) {
                  var rand = baseRandom(index, lastIndex),
                  value = array[rand];

                  array[rand] = array[index];
                  array[index] = value;
                }
                array.length = size;
                return array;
              }

              /**
               * Converts `string` to a property path array.
               *
               * @private
               * @param {string} string The string to convert.
               * @returns {Array} Returns the property path array.
               */
              var stringToPath = memoizeCapped(function (string) {
                var result = [];
                if (string.charCodeAt(0) === 46 /* . */) {
                    result.push('');
                  }
                string.replace(rePropName, function (match, number, quote, subString) {
                  result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
                });
                return result;
              });

              /**
               * Converts `value` to a string key if it's not a string or symbol.
               *
               * @private
               * @param {*} value The value to inspect.
               * @returns {string|symbol} Returns the key.
               */
              function toKey(value) {
                if (typeof value == 'string' || isSymbol(value)) {
                  return value;
                }
                var result = value + '';
                return result == '0' && 1 / value == -INFINITY ? '-0' : result;
              }

              /**
               * Converts `func` to its source code.
               *
               * @private
               * @param {Function} func The function to convert.
               * @returns {string} Returns the source code.
               */
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {}
                  try {
                    return func + '';
                  } catch (e) {}
                }
                return '';
              }

              /**
               * Updates wrapper `details` based on `bitmask` flags.
               *
               * @private
               * @returns {Array} details The details to modify.
               * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
               * @returns {Array} Returns `details`.
               */
              function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function (pair) {
                  var value = '_.' + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }

              /**
               * Creates a clone of `wrapper`.
               *
               * @private
               * @param {Object} wrapper The wrapper to clone.
               * @returns {Object} Returns the cloned wrapper.
               */
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result.__actions__ = copyArray(wrapper.__actions__);
                result.__index__ = wrapper.__index__;
                result.__values__ = wrapper.__values__;
                return result;
              }

              /*------------------------------------------------------------------------*/

              /**
               * Creates an array of elements split into groups the length of `size`.
               * If `array` can't be split evenly, the final chunk will be the remaining
               * elements.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to process.
               * @param {number} [size=1] The length of each chunk
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the new array of chunks.
               * @example
               *
               * _.chunk(['a', 'b', 'c', 'd'], 2);
               * // => [['a', 'b'], ['c', 'd']]
               *
               * _.chunk(['a', 'b', 'c', 'd'], 3);
               * // => [['a', 'b', 'c'], ['d']]
               */
              function chunk(array, size, guard) {
                if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                  size = 1;
                } else {
                  size = nativeMax(toInteger(size), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size < 1) {
                  return [];
                }
                var index = 0,
                resIndex = 0,
                result = Array(nativeCeil(length / size));

                while (index < length) {
                  result[resIndex++] = baseSlice(array, index, index += size);
                }
                return result;
              }

              /**
               * Creates an array with all falsey values removed. The values `false`, `null`,
               * `0`, `""`, `undefined`, and `NaN` are falsey.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to compact.
               * @returns {Array} Returns the new array of filtered values.
               * @example
               *
               * _.compact([0, 1, false, 2, '', 3]);
               * // => [1, 2, 3]
               */
              function compact(array) {
                var index = -1,
                length = array == null ? 0 : array.length,
                resIndex = 0,
                result = [];

                while (++index < length) {
                  var value = array[index];
                  if (value) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }

              /**
               * Creates a new array concatenating `array` with any additional arrays
               * and/or values.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to concatenate.
               * @param {...*} [values] The values to concatenate.
               * @returns {Array} Returns the new concatenated array.
               * @example
               *
               * var array = [1];
               * var other = _.concat(array, 2, [3], [[4]]);
               *
               * console.log(other);
               * // => [1, 2, 3, [4]]
               *
               * console.log(array);
               * // => [1]
               */
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array(length - 1),
                array = arguments[0],
                index = length;

                while (index--) {
                  args[index - 1] = arguments[index];
                }
                return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
              }

              /**
               * Creates an array of `array` values not included in the other given arrays
               * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons. The order and references of result values are
               * determined by the first array.
               *
               * **Note:** Unlike `_.pullAll`, this method returns a new array.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {...Array} [values] The values to exclude.
               * @returns {Array} Returns the new array of filtered values.
               * @see _.without, _.xor
               * @example
               *
               * _.difference([2, 1], [2, 3]);
               * // => [1]
               */
              var difference = baseRest(function (array, values) {
                return isArrayLikeObject(array) ?
                baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) :
                [];
              });

              /**
               * This method is like `_.difference` except that it accepts `iteratee` which
               * is invoked for each element of `array` and `values` to generate the criterion
               * by which they're compared. The order and references of result values are
               * determined by the first array. The iteratee is invoked with one argument:
               * (value).
               *
               * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {...Array} [values] The values to exclude.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns the new array of filtered values.
               * @example
               *
               * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
               * // => [1.2]
               *
               * // The `_.property` iteratee shorthand.
               * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
               * // => [{ 'x': 2 }]
               */
              var differenceBy = baseRest(function (array, values) {
                var iteratee = last(values);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return isArrayLikeObject(array) ?
                baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) :
                [];
              });

              /**
               * This method is like `_.difference` except that it accepts `comparator`
               * which is invoked to compare elements of `array` to `values`. The order and
               * references of result values are determined by the first array. The comparator
               * is invoked with two arguments: (arrVal, othVal).
               *
               * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {...Array} [values] The values to exclude.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of filtered values.
               * @example
               *
               * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
               *
               * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
               * // => [{ 'x': 2, 'y': 1 }]
               */
              var differenceWith = baseRest(function (array, values) {
                var comparator = last(values);
                if (isArrayLikeObject(comparator)) {
                  comparator = undefined;
                }
                return isArrayLikeObject(array) ?
                baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) :
                [];
              });

              /**
               * Creates a slice of `array` with `n` elements dropped from the beginning.
               *
               * @static
               * @memberOf _
               * @since 0.5.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {number} [n=1] The number of elements to drop.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.drop([1, 2, 3]);
               * // => [2, 3]
               *
               * _.drop([1, 2, 3], 2);
               * // => [3]
               *
               * _.drop([1, 2, 3], 5);
               * // => []
               *
               * _.drop([1, 2, 3], 0);
               * // => [1, 2, 3]
               */
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, n < 0 ? 0 : n, length);
              }

              /**
               * Creates a slice of `array` with `n` elements dropped from the end.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {number} [n=1] The number of elements to drop.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.dropRight([1, 2, 3]);
               * // => [1, 2]
               *
               * _.dropRight([1, 2, 3], 2);
               * // => [1]
               *
               * _.dropRight([1, 2, 3], 5);
               * // => []
               *
               * _.dropRight([1, 2, 3], 0);
               * // => [1, 2, 3]
               */
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }

              /**
               * Creates a slice of `array` excluding elements dropped from the end.
               * Elements are dropped until `predicate` returns falsey. The predicate is
               * invoked with three arguments: (value, index, array).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': true },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': false }
               * ];
               *
               * _.dropRightWhile(users, function(o) { return !o.active; });
               * // => objects for ['barney']
               *
               * // The `_.matches` iteratee shorthand.
               * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
               * // => objects for ['barney', 'fred']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.dropRightWhile(users, ['active', false]);
               * // => objects for ['barney']
               *
               * // The `_.property` iteratee shorthand.
               * _.dropRightWhile(users, 'active');
               * // => objects for ['barney', 'fred', 'pebbles']
               */
              function dropRightWhile(array, predicate) {
                return array && array.length ?
                baseWhile(array, getIteratee(predicate, 3), true, true) :
                [];
              }

              /**
               * Creates a slice of `array` excluding elements dropped from the beginning.
               * Elements are dropped until `predicate` returns falsey. The predicate is
               * invoked with three arguments: (value, index, array).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': false },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': true }
               * ];
               *
               * _.dropWhile(users, function(o) { return !o.active; });
               * // => objects for ['pebbles']
               *
               * // The `_.matches` iteratee shorthand.
               * _.dropWhile(users, { 'user': 'barney', 'active': false });
               * // => objects for ['fred', 'pebbles']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.dropWhile(users, ['active', false]);
               * // => objects for ['pebbles']
               *
               * // The `_.property` iteratee shorthand.
               * _.dropWhile(users, 'active');
               * // => objects for ['barney', 'fred', 'pebbles']
               */
              function dropWhile(array, predicate) {
                return array && array.length ?
                baseWhile(array, getIteratee(predicate, 3), true) :
                [];
              }

              /**
               * Fills elements of `array` with `value` from `start` up to, but not
               * including, `end`.
               *
               * **Note:** This method mutates `array`.
               *
               * @static
               * @memberOf _
               * @since 3.2.0
               * @category Array
               * @param {Array} array The array to fill.
               * @param {*} value The value to fill `array` with.
               * @param {number} [start=0] The start position.
               * @param {number} [end=array.length] The end position.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = [1, 2, 3];
               *
               * _.fill(array, 'a');
               * console.log(array);
               * // => ['a', 'a', 'a']
               *
               * _.fill(Array(3), 2);
               * // => [2, 2, 2]
               *
               * _.fill([4, 6, 8, 10], '*', 1, 3);
               * // => [4, '*', '*', 10]
               */
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }

              /**
               * This method is like `_.find` except that it returns the index of the first
               * element `predicate` returns truthy for instead of the element itself.
               *
               * @static
               * @memberOf _
               * @since 1.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param {number} [fromIndex=0] The index to search from.
               * @returns {number} Returns the index of the found element, else `-1`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': false },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': true }
               * ];
               *
               * _.findIndex(users, function(o) { return o.user == 'barney'; });
               * // => 0
               *
               * // The `_.matches` iteratee shorthand.
               * _.findIndex(users, { 'user': 'fred', 'active': false });
               * // => 1
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.findIndex(users, ['active', false]);
               * // => 0
               *
               * // The `_.property` iteratee shorthand.
               * _.findIndex(users, 'active');
               * // => 2
               */
              function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index);
              }

              /**
               * This method is like `_.findIndex` except that it iterates over elements
               * of `collection` from right to left.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param {number} [fromIndex=array.length-1] The index to search from.
               * @returns {number} Returns the index of the found element, else `-1`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': true },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': false }
               * ];
               *
               * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
               * // => 2
               *
               * // The `_.matches` iteratee shorthand.
               * _.findLastIndex(users, { 'user': 'barney', 'active': true });
               * // => 0
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.findLastIndex(users, ['active', false]);
               * // => 2
               *
               * // The `_.property` iteratee shorthand.
               * _.findLastIndex(users, 'active');
               * // => 0
               */
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length - 1;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = fromIndex < 0 ?
                  nativeMax(length + index, 0) :
                  nativeMin(index, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index, true);
              }

              /**
               * Flattens `array` a single level deep.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to flatten.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * _.flatten([1, [2, [3, [4]], 5]]);
               * // => [1, 2, [3, [4]], 5]
               */
              function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }

              /**
               * Recursively flattens `array`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to flatten.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * _.flattenDeep([1, [2, [3, [4]], 5]]);
               * // => [1, 2, 3, 4, 5]
               */
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }

              /**
               * Recursively flatten `array` up to `depth` times.
               *
               * @static
               * @memberOf _
               * @since 4.4.0
               * @category Array
               * @param {Array} array The array to flatten.
               * @param {number} [depth=1] The maximum recursion depth.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * var array = [1, [2, [3, [4]], 5]];
               *
               * _.flattenDepth(array, 1);
               * // => [1, 2, [3, [4]], 5]
               *
               * _.flattenDepth(array, 2);
               * // => [1, 2, 3, [4], 5]
               */
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }

              /**
               * The inverse of `_.toPairs`; this method returns an object composed
               * from key-value `pairs`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} pairs The key-value pairs.
               * @returns {Object} Returns the new object.
               * @example
               *
               * _.fromPairs([['a', 1], ['b', 2]]);
               * // => { 'a': 1, 'b': 2 }
               */
              function fromPairs(pairs) {
                var index = -1,
                length = pairs == null ? 0 : pairs.length,
                result = {};

                while (++index < length) {
                  var pair = pairs[index];
                  result[pair[0]] = pair[1];
                }
                return result;
              }

              /**
               * Gets the first element of `array`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @alias first
               * @category Array
               * @param {Array} array The array to query.
               * @returns {*} Returns the first element of `array`.
               * @example
               *
               * _.head([1, 2, 3]);
               * // => 1
               *
               * _.head([]);
               * // => undefined
               */
              function head(array) {
                return array && array.length ? array[0] : undefined;
              }

              /**
               * Gets the index at which the first occurrence of `value` is found in `array`
               * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons. If `fromIndex` is negative, it's used as the
               * offset from the end of `array`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} [fromIndex=0] The index to search from.
               * @returns {number} Returns the index of the matched value, else `-1`.
               * @example
               *
               * _.indexOf([1, 2, 1, 2], 2);
               * // => 1
               *
               * // Search from the `fromIndex`.
               * _.indexOf([1, 2, 1, 2], 2, 2);
               * // => 3
               */
              function indexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax(length + index, 0);
                }
                return baseIndexOf(array, value, index);
              }

              /**
               * Gets all but the last element of `array`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to query.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.initial([1, 2, 3]);
               * // => [1, 2]
               */
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
              }

              /**
               * Creates an array of unique values that are included in all given arrays
               * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons. The order and references of result values are
               * determined by the first array.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @returns {Array} Returns the new array of intersecting values.
               * @example
               *
               * _.intersection([2, 1], [2, 3]);
               * // => [2]
               */
              var intersection = baseRest(function (arrays) {
                var mapped = arrayMap(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0] ?
                baseIntersection(mapped) :
                [];
              });

              /**
               * This method is like `_.intersection` except that it accepts `iteratee`
               * which is invoked for each element of each `arrays` to generate the criterion
               * by which they're compared. The order and references of result values are
               * determined by the first array. The iteratee is invoked with one argument:
               * (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns the new array of intersecting values.
               * @example
               *
               * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
               * // => [2.1]
               *
               * // The `_.property` iteratee shorthand.
               * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
               * // => [{ 'x': 1 }]
               */
              var intersectionBy = baseRest(function (arrays) {
                var iteratee = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);

                if (iteratee === last(mapped)) {
                  iteratee = undefined;
                } else {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ?
                baseIntersection(mapped, getIteratee(iteratee, 2)) :
                [];
              });

              /**
               * This method is like `_.intersection` except that it accepts `comparator`
               * which is invoked to compare elements of `arrays`. The order and references
               * of result values are determined by the first array. The comparator is
               * invoked with two arguments: (arrVal, othVal).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of intersecting values.
               * @example
               *
               * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
               * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
               *
               * _.intersectionWith(objects, others, _.isEqual);
               * // => [{ 'x': 1, 'y': 2 }]
               */
              var intersectionWith = baseRest(function (arrays) {
                var comparator = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);

                comparator = typeof comparator == 'function' ? comparator : undefined;
                if (comparator) {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ?
                baseIntersection(mapped, undefined, comparator) :
                [];
              });

              /**
               * Converts all elements in `array` into a string separated by `separator`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to convert.
               * @param {string} [separator=','] The element separator.
               * @returns {string} Returns the joined string.
               * @example
               *
               * _.join(['a', 'b', 'c'], '~');
               * // => 'a~b~c'
               */
              function join(array, separator) {
                return array == null ? '' : nativeJoin.call(array, separator);
              }

              /**
               * Gets the last element of `array`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to query.
               * @returns {*} Returns the last element of `array`.
               * @example
               *
               * _.last([1, 2, 3]);
               * // => 3
               */
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined;
              }

              /**
               * This method is like `_.indexOf` except that it iterates over elements of
               * `array` from right to left.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @param {number} [fromIndex=array.length-1] The index to search from.
               * @returns {number} Returns the index of the matched value, else `-1`.
               * @example
               *
               * _.lastIndexOf([1, 2, 1, 2], 2);
               * // => 3
               *
               * // Search from the `fromIndex`.
               * _.lastIndexOf([1, 2, 1, 2], 2, 2);
               * // => 1
               */
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length;
                if (fromIndex !== undefined) {
                  index = toInteger(fromIndex);
                  index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                }
                return value === value ?
                strictLastIndexOf(array, value, index) :
                baseFindIndex(array, baseIsNaN, index, true);
              }

              /**
               * Gets the element at index `n` of `array`. If `n` is negative, the nth
               * element from the end is returned.
               *
               * @static
               * @memberOf _
               * @since 4.11.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {number} [n=0] The index of the element to return.
               * @returns {*} Returns the nth element of `array`.
               * @example
               *
               * var array = ['a', 'b', 'c', 'd'];
               *
               * _.nth(array, 1);
               * // => 'b'
               *
               * _.nth(array, -2);
               * // => 'c';
               */
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined;
              }

              /**
               * Removes all given values from `array` using
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons.
               *
               * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
               * to remove elements from an array by predicate.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {...*} [values] The values to remove.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
               *
               * _.pull(array, 'a', 'c');
               * console.log(array);
               * // => ['b', 'b']
               */
              var pull = baseRest(pullAll);

              /**
               * This method is like `_.pull` except that it accepts an array of values to remove.
               *
               * **Note:** Unlike `_.difference`, this method mutates `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {Array} values The values to remove.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
               *
               * _.pullAll(array, ['a', 'c']);
               * console.log(array);
               * // => ['b', 'b']
               */
              function pullAll(array, values) {
                return array && array.length && values && values.length ?
                basePullAll(array, values) :
                array;
              }

              /**
               * This method is like `_.pullAll` except that it accepts `iteratee` which is
               * invoked for each element of `array` and `values` to generate the criterion
               * by which they're compared. The iteratee is invoked with one argument: (value).
               *
               * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {Array} values The values to remove.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
               *
               * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
               * console.log(array);
               * // => [{ 'x': 2 }]
               */
              function pullAllBy(array, values, iteratee) {
                return array && array.length && values && values.length ?
                basePullAll(array, values, getIteratee(iteratee, 2)) :
                array;
              }

              /**
               * This method is like `_.pullAll` except that it accepts `comparator` which
               * is invoked to compare elements of `array` to `values`. The comparator is
               * invoked with two arguments: (arrVal, othVal).
               *
               * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
               *
               * @static
               * @memberOf _
               * @since 4.6.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {Array} values The values to remove.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
               *
               * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
               * console.log(array);
               * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
               */
              function pullAllWith(array, values, comparator) {
                return array && array.length && values && values.length ?
                basePullAll(array, values, undefined, comparator) :
                array;
              }

              /**
               * Removes elements from `array` corresponding to `indexes` and returns an
               * array of removed elements.
               *
               * **Note:** Unlike `_.at`, this method mutates `array`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {...(number|number[])} [indexes] The indexes of elements to remove.
               * @returns {Array} Returns the new array of removed elements.
               * @example
               *
               * var array = ['a', 'b', 'c', 'd'];
               * var pulled = _.pullAt(array, [1, 3]);
               *
               * console.log(array);
               * // => ['a', 'c']
               *
               * console.log(pulled);
               * // => ['b', 'd']
               */
              var pullAt = flatRest(function (array, indexes) {
                var length = array == null ? 0 : array.length,
                result = baseAt(array, indexes);

                basePullAt(array, arrayMap(indexes, function (index) {
                  return isIndex(index, length) ? +index : index;
                }).sort(compareAscending));

                return result;
              });

              /**
               * Removes all elements from `array` that `predicate` returns truthy for
               * and returns an array of the removed elements. The predicate is invoked
               * with three arguments: (value, index, array).
               *
               * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
               * to pull elements from an array by value.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new array of removed elements.
               * @example
               *
               * var array = [1, 2, 3, 4];
               * var evens = _.remove(array, function(n) {
               *   return n % 2 == 0;
               * });
               *
               * console.log(array);
               * // => [1, 3]
               *
               * console.log(evens);
               * // => [2, 4]
               */
              function remove(array, predicate) {
                var result = [];
                if (!(array && array.length)) {
                  return result;
                }
                var index = -1,
                indexes = [],
                length = array.length;

                predicate = getIteratee(predicate, 3);
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                  }
                }
                basePullAt(array, indexes);
                return result;
              }

              /**
               * Reverses `array` so that the first element becomes the last, the second
               * element becomes the second to last, and so on.
               *
               * **Note:** This method mutates `array` and is based on
               * [`Array#reverse`](https://mdn.io/Array/reverse).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to modify.
               * @returns {Array} Returns `array`.
               * @example
               *
               * var array = [1, 2, 3];
               *
               * _.reverse(array);
               * // => [3, 2, 1]
               *
               * console.log(array);
               * // => [3, 2, 1]
               */
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }

              /**
               * Creates a slice of `array` from `start` up to, but not including, `end`.
               *
               * **Note:** This method is used instead of
               * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
               * returned.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to slice.
               * @param {number} [start=0] The start position.
               * @param {number} [end=array.length] The end position.
               * @returns {Array} Returns the slice of `array`.
               */
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                  start = 0;
                  end = length;
                } else
                {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined ? length : toInteger(end);
                }
                return baseSlice(array, start, end);
              }

              /**
               * Uses a binary search to determine the lowest index at which `value`
               * should be inserted into `array` in order to maintain its sort order.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               * @example
               *
               * _.sortedIndex([30, 50], 40);
               * // => 1
               */
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }

              /**
               * This method is like `_.sortedIndex` except that it accepts `iteratee`
               * which is invoked for `value` and each element of `array` to compute their
               * sort ranking. The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               * @example
               *
               * var objects = [{ 'x': 4 }, { 'x': 5 }];
               *
               * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
               * // => 0
               *
               * // The `_.property` iteratee shorthand.
               * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
               * // => 0
               */
              function sortedIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
              }

              /**
               * This method is like `_.indexOf` except that it performs a binary
               * search on a sorted `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @returns {number} Returns the index of the matched value, else `-1`.
               * @example
               *
               * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
               * // => 1
               */
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value);
                  if (index < length && eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }

              /**
               * This method is like `_.sortedIndex` except that it returns the highest
               * index at which `value` should be inserted into `array` in order to
               * maintain its sort order.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               * @example
               *
               * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
               * // => 4
               */
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }

              /**
               * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
               * which is invoked for `value` and each element of `array` to compute their
               * sort ranking. The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The sorted array to inspect.
               * @param {*} value The value to evaluate.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {number} Returns the index at which `value` should be inserted
               *  into `array`.
               * @example
               *
               * var objects = [{ 'x': 4 }, { 'x': 5 }];
               *
               * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
               * // => 1
               *
               * // The `_.property` iteratee shorthand.
               * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
               * // => 1
               */
              function sortedLastIndexBy(array, value, iteratee) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
              }

              /**
               * This method is like `_.lastIndexOf` except that it performs a binary
               * search on a sorted `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {*} value The value to search for.
               * @returns {number} Returns the index of the matched value, else `-1`.
               * @example
               *
               * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
               * // => 3
               */
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value, true) - 1;
                  if (eq(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }

              /**
               * This method is like `_.uniq` except that it's designed and optimized
               * for sorted arrays.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @returns {Array} Returns the new duplicate free array.
               * @example
               *
               * _.sortedUniq([1, 1, 2]);
               * // => [1, 2]
               */
              function sortedUniq(array) {
                return array && array.length ?
                baseSortedUniq(array) :
                [];
              }

              /**
               * This method is like `_.uniqBy` except that it's designed and optimized
               * for sorted arrays.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {Function} [iteratee] The iteratee invoked per element.
               * @returns {Array} Returns the new duplicate free array.
               * @example
               *
               * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
               * // => [1.1, 2.3]
               */
              function sortedUniqBy(array, iteratee) {
                return array && array.length ?
                baseSortedUniq(array, getIteratee(iteratee, 2)) :
                [];
              }

              /**
               * Gets all but the first element of `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.tail([1, 2, 3]);
               * // => [2, 3]
               */
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
              }

              /**
               * Creates a slice of `array` with `n` elements taken from the beginning.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {number} [n=1] The number of elements to take.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.take([1, 2, 3]);
               * // => [1]
               *
               * _.take([1, 2, 3], 2);
               * // => [1, 2]
               *
               * _.take([1, 2, 3], 5);
               * // => [1, 2, 3]
               *
               * _.take([1, 2, 3], 0);
               * // => []
               */
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                return baseSlice(array, 0, n < 0 ? 0 : n);
              }

              /**
               * Creates a slice of `array` with `n` elements taken from the end.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {number} [n=1] The number of elements to take.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * _.takeRight([1, 2, 3]);
               * // => [3]
               *
               * _.takeRight([1, 2, 3], 2);
               * // => [2, 3]
               *
               * _.takeRight([1, 2, 3], 5);
               * // => [1, 2, 3]
               *
               * _.takeRight([1, 2, 3], 0);
               * // => []
               */
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined ? 1 : toInteger(n);
                n = length - n;
                return baseSlice(array, n < 0 ? 0 : n, length);
              }

              /**
               * Creates a slice of `array` with elements taken from the end. Elements are
               * taken until `predicate` returns falsey. The predicate is invoked with
               * three arguments: (value, index, array).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': true },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': false }
               * ];
               *
               * _.takeRightWhile(users, function(o) { return !o.active; });
               * // => objects for ['fred', 'pebbles']
               *
               * // The `_.matches` iteratee shorthand.
               * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
               * // => objects for ['pebbles']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.takeRightWhile(users, ['active', false]);
               * // => objects for ['fred', 'pebbles']
               *
               * // The `_.property` iteratee shorthand.
               * _.takeRightWhile(users, 'active');
               * // => []
               */
              function takeRightWhile(array, predicate) {
                return array && array.length ?
                baseWhile(array, getIteratee(predicate, 3), false, true) :
                [];
              }

              /**
               * Creates a slice of `array` with elements taken from the beginning. Elements
               * are taken until `predicate` returns falsey. The predicate is invoked with
               * three arguments: (value, index, array).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Array
               * @param {Array} array The array to query.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the slice of `array`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'active': false },
               *   { 'user': 'fred',    'active': false },
               *   { 'user': 'pebbles', 'active': true }
               * ];
               *
               * _.takeWhile(users, function(o) { return !o.active; });
               * // => objects for ['barney', 'fred']
               *
               * // The `_.matches` iteratee shorthand.
               * _.takeWhile(users, { 'user': 'barney', 'active': false });
               * // => objects for ['barney']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.takeWhile(users, ['active', false]);
               * // => objects for ['barney', 'fred']
               *
               * // The `_.property` iteratee shorthand.
               * _.takeWhile(users, 'active');
               * // => []
               */
              function takeWhile(array, predicate) {
                return array && array.length ?
                baseWhile(array, getIteratee(predicate, 3)) :
                [];
              }

              /**
               * Creates an array of unique values, in order, from all given arrays using
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @returns {Array} Returns the new array of combined values.
               * @example
               *
               * _.union([2], [1, 2]);
               * // => [2, 1]
               */
              var union = baseRest(function (arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
              });

              /**
               * This method is like `_.union` except that it accepts `iteratee` which is
               * invoked for each element of each `arrays` to generate the criterion by
               * which uniqueness is computed. Result values are chosen from the first
               * array in which the value occurs. The iteratee is invoked with one argument:
               * (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns the new array of combined values.
               * @example
               *
               * _.unionBy([2.1], [1.2, 2.3], Math.floor);
               * // => [2.1, 1.2]
               *
               * // The `_.property` iteratee shorthand.
               * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
               * // => [{ 'x': 1 }, { 'x': 2 }]
               */
              var unionBy = baseRest(function (arrays) {
                var iteratee = last(arrays);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
              });

              /**
               * This method is like `_.union` except that it accepts `comparator` which
               * is invoked to compare elements of `arrays`. Result values are chosen from
               * the first array in which the value occurs. The comparator is invoked
               * with two arguments: (arrVal, othVal).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of combined values.
               * @example
               *
               * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
               * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
               *
               * _.unionWith(objects, others, _.isEqual);
               * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
               */
              var unionWith = baseRest(function (arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == 'function' ? comparator : undefined;
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
              });

              /**
               * Creates a duplicate-free version of an array, using
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons, in which only the first occurrence of each element
               * is kept. The order of result values is determined by the order they occur
               * in the array.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @returns {Array} Returns the new duplicate free array.
               * @example
               *
               * _.uniq([2, 1, 2]);
               * // => [2, 1]
               */
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }

              /**
               * This method is like `_.uniq` except that it accepts `iteratee` which is
               * invoked for each element in `array` to generate the criterion by which
               * uniqueness is computed. The order of result values is determined by the
               * order they occur in the array. The iteratee is invoked with one argument:
               * (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns the new duplicate free array.
               * @example
               *
               * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
               * // => [2.1, 1.2]
               *
               * // The `_.property` iteratee shorthand.
               * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
               * // => [{ 'x': 1 }, { 'x': 2 }]
               */
              function uniqBy(array, iteratee) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
              }

              /**
               * This method is like `_.uniq` except that it accepts `comparator` which
               * is invoked to compare elements of `array`. The order of result values is
               * determined by the order they occur in the array.The comparator is invoked
               * with two arguments: (arrVal, othVal).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new duplicate free array.
               * @example
               *
               * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
               *
               * _.uniqWith(objects, _.isEqual);
               * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
               */
              function uniqWith(array, comparator) {
                comparator = typeof comparator == 'function' ? comparator : undefined;
                return array && array.length ? baseUniq(array, undefined, comparator) : [];
              }

              /**
               * This method is like `_.zip` except that it accepts an array of grouped
               * elements and creates an array regrouping the elements to their pre-zip
               * configuration.
               *
               * @static
               * @memberOf _
               * @since 1.2.0
               * @category Array
               * @param {Array} array The array of grouped elements to process.
               * @returns {Array} Returns the new array of regrouped elements.
               * @example
               *
               * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
               * // => [['a', 1, true], ['b', 2, false]]
               *
               * _.unzip(zipped);
               * // => [['a', 'b'], [1, 2], [true, false]]
               */
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter(array, function (group) {
                  if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                  }
                });
                return baseTimes(length, function (index) {
                  return arrayMap(array, baseProperty(index));
                });
              }

              /**
               * This method is like `_.unzip` except that it accepts `iteratee` to specify
               * how regrouped values should be combined. The iteratee is invoked with the
               * elements of each group: (...group).
               *
               * @static
               * @memberOf _
               * @since 3.8.0
               * @category Array
               * @param {Array} array The array of grouped elements to process.
               * @param {Function} [iteratee=_.identity] The function to combine
               *  regrouped values.
               * @returns {Array} Returns the new array of regrouped elements.
               * @example
               *
               * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
               * // => [[1, 10, 100], [2, 20, 200]]
               *
               * _.unzipWith(zipped, _.add);
               * // => [3, 30, 300]
               */
              function unzipWith(array, iteratee) {
                if (!(array && array.length)) {
                  return [];
                }
                var result = unzip(array);
                if (iteratee == null) {
                  return result;
                }
                return arrayMap(result, function (group) {
                  return apply(iteratee, undefined, group);
                });
              }

              /**
               * Creates an array excluding all given values using
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * for equality comparisons.
               *
               * **Note:** Unlike `_.pull`, this method returns a new array.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {Array} array The array to inspect.
               * @param {...*} [values] The values to exclude.
               * @returns {Array} Returns the new array of filtered values.
               * @see _.difference, _.xor
               * @example
               *
               * _.without([2, 1, 2, 3], 1, 2);
               * // => [3]
               */
              var without = baseRest(function (array, values) {
                return isArrayLikeObject(array) ?
                baseDifference(array, values) :
                [];
              });

              /**
               * Creates an array of unique values that is the
               * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
               * of the given arrays. The order of result values is determined by the order
               * they occur in the arrays.
               *
               * @static
               * @memberOf _
               * @since 2.4.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @returns {Array} Returns the new array of filtered values.
               * @see _.difference, _.without
               * @example
               *
               * _.xor([2, 1], [2, 3]);
               * // => [1, 3]
               */
              var xor = baseRest(function (arrays) {
                return baseXor(arrayFilter(arrays, isArrayLikeObject));
              });

              /**
               * This method is like `_.xor` except that it accepts `iteratee` which is
               * invoked for each element of each `arrays` to generate the criterion by
               * which by which they're compared. The order of result values is determined
               * by the order they occur in the arrays. The iteratee is invoked with one
               * argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Array} Returns the new array of filtered values.
               * @example
               *
               * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
               * // => [1.2, 3.4]
               *
               * // The `_.property` iteratee shorthand.
               * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
               * // => [{ 'x': 2 }]
               */
              var xorBy = baseRest(function (arrays) {
                var iteratee = last(arrays);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = undefined;
                }
                return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
              });

              /**
               * This method is like `_.xor` except that it accepts `comparator` which is
               * invoked to compare elements of `arrays`. The order of result values is
               * determined by the order they occur in the arrays. The comparator is invoked
               * with two arguments: (arrVal, othVal).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Array
               * @param {...Array} [arrays] The arrays to inspect.
               * @param {Function} [comparator] The comparator invoked per element.
               * @returns {Array} Returns the new array of filtered values.
               * @example
               *
               * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
               * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
               *
               * _.xorWith(objects, others, _.isEqual);
               * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
               */
              var xorWith = baseRest(function (arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == 'function' ? comparator : undefined;
                return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
              });

              /**
               * Creates an array of grouped elements, the first of which contains the
               * first elements of the given arrays, the second of which contains the
               * second elements of the given arrays, and so on.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Array
               * @param {...Array} [arrays] The arrays to process.
               * @returns {Array} Returns the new array of grouped elements.
               * @example
               *
               * _.zip(['a', 'b'], [1, 2], [true, false]);
               * // => [['a', 1, true], ['b', 2, false]]
               */
              var zip = baseRest(unzip);

              /**
               * This method is like `_.fromPairs` except that it accepts two arrays,
               * one of property identifiers and one of corresponding values.
               *
               * @static
               * @memberOf _
               * @since 0.4.0
               * @category Array
               * @param {Array} [props=[]] The property identifiers.
               * @param {Array} [values=[]] The property values.
               * @returns {Object} Returns the new object.
               * @example
               *
               * _.zipObject(['a', 'b'], [1, 2]);
               * // => { 'a': 1, 'b': 2 }
               */
              function zipObject(props, values) {
                return baseZipObject(props || [], values || [], assignValue);
              }

              /**
               * This method is like `_.zipObject` except that it supports property paths.
               *
               * @static
               * @memberOf _
               * @since 4.1.0
               * @category Array
               * @param {Array} [props=[]] The property identifiers.
               * @param {Array} [values=[]] The property values.
               * @returns {Object} Returns the new object.
               * @example
               *
               * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
               * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
               */
              function zipObjectDeep(props, values) {
                return baseZipObject(props || [], values || [], baseSet);
              }

              /**
               * This method is like `_.zip` except that it accepts `iteratee` to specify
               * how grouped values should be combined. The iteratee is invoked with the
               * elements of each group: (...group).
               *
               * @static
               * @memberOf _
               * @since 3.8.0
               * @category Array
               * @param {...Array} [arrays] The arrays to process.
               * @param {Function} [iteratee=_.identity] The function to combine
               *  grouped values.
               * @returns {Array} Returns the new array of grouped elements.
               * @example
               *
               * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
               *   return a + b + c;
               * });
               * // => [111, 222]
               */
              var zipWith = baseRest(function (arrays) {
                var length = arrays.length,
                iteratee = length > 1 ? arrays[length - 1] : undefined;

                iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                return unzipWith(arrays, iteratee);
              });

              /*------------------------------------------------------------------------*/

              /**
               * Creates a `lodash` wrapper instance that wraps `value` with explicit method
               * chain sequences enabled. The result of such sequences must be unwrapped
               * with `_#value`.
               *
               * @static
               * @memberOf _
               * @since 1.3.0
               * @category Seq
               * @param {*} value The value to wrap.
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'age': 36 },
               *   { 'user': 'fred',    'age': 40 },
               *   { 'user': 'pebbles', 'age': 1 }
               * ];
               *
               * var youngest = _
               *   .chain(users)
               *   .sortBy('age')
               *   .map(function(o) {
               *     return o.user + ' is ' + o.age;
               *   })
               *   .head()
               *   .value();
               * // => 'pebbles is 1'
               */
              function chain(value) {
                var result = lodash(value);
                result.__chain__ = true;
                return result;
              }

              /**
               * This method invokes `interceptor` and returns `value`. The interceptor
               * is invoked with one argument; (value). The purpose of this method is to
               * "tap into" a method chain sequence in order to modify intermediate results.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Seq
               * @param {*} value The value to provide to `interceptor`.
               * @param {Function} interceptor The function to invoke.
               * @returns {*} Returns `value`.
               * @example
               *
               * _([1, 2, 3])
               *  .tap(function(array) {
               *    // Mutate input array.
               *    array.pop();
               *  })
               *  .reverse()
               *  .value();
               * // => [2, 1]
               */
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }

              /**
               * This method is like `_.tap` except that it returns the result of `interceptor`.
               * The purpose of this method is to "pass thru" values replacing intermediate
               * results in a method chain sequence.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Seq
               * @param {*} value The value to provide to `interceptor`.
               * @param {Function} interceptor The function to invoke.
               * @returns {*} Returns the result of `interceptor`.
               * @example
               *
               * _('  abc  ')
               *  .chain()
               *  .trim()
               *  .thru(function(value) {
               *    return [value];
               *  })
               *  .value();
               * // => ['abc']
               */
              function thru(value, interceptor) {
                return interceptor(value);
              }

              /**
               * This method is the wrapper version of `_.at`.
               *
               * @name at
               * @memberOf _
               * @since 1.0.0
               * @category Seq
               * @param {...(string|string[])} [paths] The property paths to pick.
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
               *
               * _(object).at(['a[0].b.c', 'a[1]']).value();
               * // => [3, 4]
               */
              var wrapperAt = flatRest(function (paths) {
                var length = paths.length,
                start = length ? paths[0] : 0,
                value = this.__wrapped__,
                interceptor = function (object) {return baseAt(object, paths);};

                if (length > 1 || this.__actions__.length ||
                !(value instanceof LazyWrapper) || !isIndex(start)) {
                  return this.thru(interceptor);
                }
                value = value.slice(start, +start + (length ? 1 : 0));
                value.__actions__.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': undefined });

                return new LodashWrapper(value, this.__chain__).thru(function (array) {
                  if (length && !array.length) {
                    array.push(undefined);
                  }
                  return array;
                });
              });

              /**
               * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
               *
               * @name chain
               * @memberOf _
               * @since 0.1.0
               * @category Seq
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * var users = [
               *   { 'user': 'barney', 'age': 36 },
               *   { 'user': 'fred',   'age': 40 }
               * ];
               *
               * // A sequence without explicit chaining.
               * _(users).head();
               * // => { 'user': 'barney', 'age': 36 }
               *
               * // A sequence with explicit chaining.
               * _(users)
               *   .chain()
               *   .head()
               *   .pick('user')
               *   .value();
               * // => { 'user': 'barney' }
               */
              function wrapperChain() {
                return chain(this);
              }

              /**
               * Executes the chain sequence and returns the wrapped result.
               *
               * @name commit
               * @memberOf _
               * @since 3.2.0
               * @category Seq
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * var array = [1, 2];
               * var wrapped = _(array).push(3);
               *
               * console.log(array);
               * // => [1, 2]
               *
               * wrapped = wrapped.commit();
               * console.log(array);
               * // => [1, 2, 3]
               *
               * wrapped.last();
               * // => 3
               *
               * console.log(array);
               * // => [1, 2, 3]
               */
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }

              /**
               * Gets the next value on a wrapped object following the
               * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
               *
               * @name next
               * @memberOf _
               * @since 4.0.0
               * @category Seq
               * @returns {Object} Returns the next iterator value.
               * @example
               *
               * var wrapped = _([1, 2]);
               *
               * wrapped.next();
               * // => { 'done': false, 'value': 1 }
               *
               * wrapped.next();
               * // => { 'done': false, 'value': 2 }
               *
               * wrapped.next();
               * // => { 'done': true, 'value': undefined }
               */
              function wrapperNext() {
                if (this.__values__ === undefined) {
                  this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length,
                value = done ? undefined : this.__values__[this.__index__++];

                return { 'done': done, 'value': value };
              }

              /**
               * Enables the wrapper to be iterable.
               *
               * @name Symbol.iterator
               * @memberOf _
               * @since 4.0.0
               * @category Seq
               * @returns {Object} Returns the wrapper object.
               * @example
               *
               * var wrapped = _([1, 2]);
               *
               * wrapped[Symbol.iterator]() === wrapped;
               * // => true
               *
               * Array.from(wrapped);
               * // => [1, 2]
               */
              function wrapperToIterator() {
                return this;
              }

              /**
               * Creates a clone of the chain sequence planting `value` as the wrapped value.
               *
               * @name plant
               * @memberOf _
               * @since 3.2.0
               * @category Seq
               * @param {*} value The value to plant.
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * var wrapped = _([1, 2]).map(square);
               * var other = wrapped.plant([3, 4]);
               *
               * other.value();
               * // => [9, 16]
               *
               * wrapped.value();
               * // => [1, 4]
               */
              function wrapperPlant(value) {
                var result,
                parent = this;

                while (parent instanceof baseLodash) {
                  var clone = wrapperClone(parent);
                  clone.__index__ = 0;
                  clone.__values__ = undefined;
                  if (result) {
                    previous.__wrapped__ = clone;
                  } else {
                    result = clone;
                  }
                  var previous = clone;
                  parent = parent.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result;
              }

              /**
               * This method is the wrapper version of `_.reverse`.
               *
               * **Note:** This method mutates the wrapped array.
               *
               * @name reverse
               * @memberOf _
               * @since 0.1.0
               * @category Seq
               * @returns {Object} Returns the new `lodash` wrapper instance.
               * @example
               *
               * var array = [1, 2, 3];
               *
               * _(array).reverse().value()
               * // => [3, 2, 1]
               *
               * console.log(array);
               * // => [3, 2, 1]
               */
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    'func': thru,
                    'args': [reverse],
                    'thisArg': undefined });

                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }

              /**
               * Executes the chain sequence to resolve the unwrapped value.
               *
               * @name value
               * @memberOf _
               * @since 0.1.0
               * @alias toJSON, valueOf
               * @category Seq
               * @returns {*} Returns the resolved unwrapped value.
               * @example
               *
               * _([1, 2, 3]).value();
               * // => [1, 2, 3]
               */
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }

              /*------------------------------------------------------------------------*/

              /**
               * Creates an object composed of keys generated from the results of running
               * each element of `collection` thru `iteratee`. The corresponding value of
               * each key is the number of times the key was returned by `iteratee`. The
               * iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 0.5.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
               * @returns {Object} Returns the composed aggregate object.
               * @example
               *
               * _.countBy([6.1, 4.2, 6.3], Math.floor);
               * // => { '4': 1, '6': 2 }
               *
               * // The `_.property` iteratee shorthand.
               * _.countBy(['one', 'two', 'three'], 'length');
               * // => { '3': 2, '5': 1 }
               */
              var countBy = createAggregator(function (result, value, key) {
                if (hasOwnProperty.call(result, key)) {
                  ++result[key];
                } else {
                  baseAssignValue(result, key, 1);
                }
              });

              /**
               * Checks if `predicate` returns truthy for **all** elements of `collection`.
               * Iteration is stopped once `predicate` returns falsey. The predicate is
               * invoked with three arguments: (value, index|key, collection).
               *
               * **Note:** This method returns `true` for
               * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
               * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
               * elements of empty collections.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {boolean} Returns `true` if all elements pass the predicate check,
               *  else `false`.
               * @example
               *
               * _.every([true, 1, null, 'yes'], Boolean);
               * // => false
               *
               * var users = [
               *   { 'user': 'barney', 'age': 36, 'active': false },
               *   { 'user': 'fred',   'age': 40, 'active': false }
               * ];
               *
               * // The `_.matches` iteratee shorthand.
               * _.every(users, { 'user': 'barney', 'active': false });
               * // => false
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.every(users, ['active', false]);
               * // => true
               *
               * // The `_.property` iteratee shorthand.
               * _.every(users, 'active');
               * // => false
               */
              function every(collection, predicate, guard) {
                var func = isArray(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }

              /**
               * Iterates over elements of `collection`, returning an array of all elements
               * `predicate` returns truthy for. The predicate is invoked with three
               * arguments: (value, index|key, collection).
               *
               * **Note:** Unlike `_.remove`, this method returns a new array.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new filtered array.
               * @see _.reject
               * @example
               *
               * var users = [
               *   { 'user': 'barney', 'age': 36, 'active': true },
               *   { 'user': 'fred',   'age': 40, 'active': false }
               * ];
               *
               * _.filter(users, function(o) { return !o.active; });
               * // => objects for ['fred']
               *
               * // The `_.matches` iteratee shorthand.
               * _.filter(users, { 'age': 36, 'active': true });
               * // => objects for ['barney']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.filter(users, ['active', false]);
               * // => objects for ['fred']
               *
               * // The `_.property` iteratee shorthand.
               * _.filter(users, 'active');
               * // => objects for ['barney']
               *
               * // Combining several predicates using `_.overEvery` or `_.overSome`.
               * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
               * // => objects for ['fred', 'barney']
               */
              function filter(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }

              /**
               * Iterates over elements of `collection`, returning the first element
               * `predicate` returns truthy for. The predicate is invoked with three
               * arguments: (value, index|key, collection).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param {number} [fromIndex=0] The index to search from.
               * @returns {*} Returns the matched element, else `undefined`.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'age': 36, 'active': true },
               *   { 'user': 'fred',    'age': 40, 'active': false },
               *   { 'user': 'pebbles', 'age': 1,  'active': true }
               * ];
               *
               * _.find(users, function(o) { return o.age < 40; });
               * // => object for 'barney'
               *
               * // The `_.matches` iteratee shorthand.
               * _.find(users, { 'age': 1, 'active': true });
               * // => object for 'pebbles'
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.find(users, ['active', false]);
               * // => object for 'fred'
               *
               * // The `_.property` iteratee shorthand.
               * _.find(users, 'active');
               * // => object for 'barney'
               */
              var find = createFind(findIndex);

              /**
               * This method is like `_.find` except that it iterates over elements of
               * `collection` from right to left.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param {number} [fromIndex=collection.length-1] The index to search from.
               * @returns {*} Returns the matched element, else `undefined`.
               * @example
               *
               * _.findLast([1, 2, 3, 4], function(n) {
               *   return n % 2 == 1;
               * });
               * // => 3
               */
              var findLast = createFind(findLastIndex);

              /**
               * Creates a flattened array of values by running each element in `collection`
               * thru `iteratee` and flattening the mapped results. The iteratee is invoked
               * with three arguments: (value, index|key, collection).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * function duplicate(n) {
               *   return [n, n];
               * }
               *
               * _.flatMap([1, 2], duplicate);
               * // => [1, 1, 2, 2]
               */
              function flatMap(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), 1);
              }

              /**
               * This method is like `_.flatMap` except that it recursively flattens the
               * mapped results.
               *
               * @static
               * @memberOf _
               * @since 4.7.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * function duplicate(n) {
               *   return [[[n, n]]];
               * }
               *
               * _.flatMapDeep([1, 2], duplicate);
               * // => [1, 1, 2, 2]
               */
              function flatMapDeep(collection, iteratee) {
                return baseFlatten(map(collection, iteratee), INFINITY);
              }

              /**
               * This method is like `_.flatMap` except that it recursively flattens the
               * mapped results up to `depth` times.
               *
               * @static
               * @memberOf _
               * @since 4.7.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @param {number} [depth=1] The maximum recursion depth.
               * @returns {Array} Returns the new flattened array.
               * @example
               *
               * function duplicate(n) {
               *   return [[[n, n]]];
               * }
               *
               * _.flatMapDepth([1, 2], duplicate, 2);
               * // => [[1, 1], [2, 2]]
               */
              function flatMapDepth(collection, iteratee, depth) {
                depth = depth === undefined ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee), depth);
              }

              /**
               * Iterates over elements of `collection` and invokes `iteratee` for each element.
               * The iteratee is invoked with three arguments: (value, index|key, collection).
               * Iteratee functions may exit iteration early by explicitly returning `false`.
               *
               * **Note:** As with other "Collections" methods, objects with a "length"
               * property are iterated like arrays. To avoid this behavior use `_.forIn`
               * or `_.forOwn` for object iteration.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @alias each
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array|Object} Returns `collection`.
               * @see _.forEachRight
               * @example
               *
               * _.forEach([1, 2], function(value) {
               *   console.log(value);
               * });
               * // => Logs `1` then `2`.
               *
               * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
               *   console.log(key);
               * });
               * // => Logs 'a' then 'b' (iteration order is not guaranteed).
               */
              function forEach(collection, iteratee) {
                var func = isArray(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee, 3));
              }

              /**
               * This method is like `_.forEach` except that it iterates over elements of
               * `collection` from right to left.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @alias eachRight
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array|Object} Returns `collection`.
               * @see _.forEach
               * @example
               *
               * _.forEachRight([1, 2], function(value) {
               *   console.log(value);
               * });
               * // => Logs `2` then `1`.
               */
              function forEachRight(collection, iteratee) {
                var func = isArray(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee, 3));
              }

              /**
               * Creates an object composed of keys generated from the results of running
               * each element of `collection` thru `iteratee`. The order of grouped values
               * is determined by the order they occur in `collection`. The corresponding
               * value of each key is an array of elements responsible for generating the
               * key. The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
               * @returns {Object} Returns the composed aggregate object.
               * @example
               *
               * _.groupBy([6.1, 4.2, 6.3], Math.floor);
               * // => { '4': [4.2], '6': [6.1, 6.3] }
               *
               * // The `_.property` iteratee shorthand.
               * _.groupBy(['one', 'two', 'three'], 'length');
               * // => { '3': ['one', 'two'], '5': ['three'] }
               */
              var groupBy = createAggregator(function (result, value, key) {
                if (hasOwnProperty.call(result, key)) {
                  result[key].push(value);
                } else {
                  baseAssignValue(result, key, [value]);
                }
              });

              /**
               * Checks if `value` is in `collection`. If `collection` is a string, it's
               * checked for a substring of `value`, otherwise
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * is used for equality comparisons. If `fromIndex` is negative, it's used as
               * the offset from the end of `collection`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object|string} collection The collection to inspect.
               * @param {*} value The value to search for.
               * @param {number} [fromIndex=0] The index to search from.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
               * @returns {boolean} Returns `true` if `value` is found, else `false`.
               * @example
               *
               * _.includes([1, 2, 3], 1);
               * // => true
               *
               * _.includes([1, 2, 3], 1, 2);
               * // => false
               *
               * _.includes({ 'a': 1, 'b': 2 }, 1);
               * // => true
               *
               * _.includes('abcd', 'bc');
               * // => true
               */
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;

                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString(collection) ?
                fromIndex <= length && collection.indexOf(value, fromIndex) > -1 :
                !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }

              /**
               * Invokes the method at `path` of each element in `collection`, returning
               * an array of the results of each invoked method. Any additional arguments
               * are provided to each invoked method. If `path` is a function, it's invoked
               * for, and `this` bound to, each element in `collection`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Array|Function|string} path The path of the method to invoke or
               *  the function invoked per iteration.
               * @param {...*} [args] The arguments to invoke each method with.
               * @returns {Array} Returns the array of results.
               * @example
               *
               * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
               * // => [[1, 5, 7], [1, 2, 3]]
               *
               * _.invokeMap([123, 456], String.prototype.split, '');
               * // => [['1', '2', '3'], ['4', '5', '6']]
               */
              var invokeMap = baseRest(function (collection, path, args) {
                var index = -1,
                isFunc = typeof path == 'function',
                result = isArrayLike(collection) ? Array(collection.length) : [];

                baseEach(collection, function (value) {
                  result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                });
                return result;
              });

              /**
               * Creates an object composed of keys generated from the results of running
               * each element of `collection` thru `iteratee`. The corresponding value of
               * each key is the last element responsible for generating the key. The
               * iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
               * @returns {Object} Returns the composed aggregate object.
               * @example
               *
               * var array = [
               *   { 'dir': 'left', 'code': 97 },
               *   { 'dir': 'right', 'code': 100 }
               * ];
               *
               * _.keyBy(array, function(o) {
               *   return String.fromCharCode(o.code);
               * });
               * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
               *
               * _.keyBy(array, 'dir');
               * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
               */
              var keyBy = createAggregator(function (result, value, key) {
                baseAssignValue(result, key, value);
              });

              /**
               * Creates an array of values by running each element in `collection` thru
               * `iteratee`. The iteratee is invoked with three arguments:
               * (value, index|key, collection).
               *
               * Many lodash methods are guarded to work as iteratees for methods like
               * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
               *
               * The guarded methods are:
               * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
               * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
               * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
               * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new mapped array.
               * @example
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * _.map([4, 8], square);
               * // => [16, 64]
               *
               * _.map({ 'a': 4, 'b': 8 }, square);
               * // => [16, 64] (iteration order is not guaranteed)
               *
               * var users = [
               *   { 'user': 'barney' },
               *   { 'user': 'fred' }
               * ];
               *
               * // The `_.property` iteratee shorthand.
               * _.map(users, 'user');
               * // => ['barney', 'fred']
               */
              function map(collection, iteratee) {
                var func = isArray(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee, 3));
              }

              /**
               * This method is like `_.sortBy` except that it allows specifying the sort
               * orders of the iteratees to sort by. If `orders` is unspecified, all values
               * are sorted in ascending order. Otherwise, specify an order of "desc" for
               * descending or "asc" for ascending sort order of corresponding values.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
               *  The iteratees to sort by.
               * @param {string[]} [orders] The sort orders of `iteratees`.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
               * @returns {Array} Returns the new sorted array.
               * @example
               *
               * var users = [
               *   { 'user': 'fred',   'age': 48 },
               *   { 'user': 'barney', 'age': 34 },
               *   { 'user': 'fred',   'age': 40 },
               *   { 'user': 'barney', 'age': 36 }
               * ];
               *
               * // Sort by `user` in ascending order and by `age` in descending order.
               * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
               * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
               */
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined : orders;
                if (!isArray(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }

              /**
               * Creates an array of elements split into two groups, the first of which
               * contains elements `predicate` returns truthy for, the second of which
               * contains elements `predicate` returns falsey for. The predicate is
               * invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the array of grouped elements.
               * @example
               *
               * var users = [
               *   { 'user': 'barney',  'age': 36, 'active': false },
               *   { 'user': 'fred',    'age': 40, 'active': true },
               *   { 'user': 'pebbles', 'age': 1,  'active': false }
               * ];
               *
               * _.partition(users, function(o) { return o.active; });
               * // => objects for [['fred'], ['barney', 'pebbles']]
               *
               * // The `_.matches` iteratee shorthand.
               * _.partition(users, { 'age': 1, 'active': false });
               * // => objects for [['pebbles'], ['barney', 'fred']]
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.partition(users, ['active', false]);
               * // => objects for [['barney', 'pebbles'], ['fred']]
               *
               * // The `_.property` iteratee shorthand.
               * _.partition(users, 'active');
               * // => objects for [['fred'], ['barney', 'pebbles']]
               */
              var partition = createAggregator(function (result, value, key) {
                result[key ? 0 : 1].push(value);
              }, function () {return [[], []];});

              /**
               * Reduces `collection` to a value which is the accumulated result of running
               * each element in `collection` thru `iteratee`, where each successive
               * invocation is supplied the return value of the previous. If `accumulator`
               * is not given, the first element of `collection` is used as the initial
               * value. The iteratee is invoked with four arguments:
               * (accumulator, value, index|key, collection).
               *
               * Many lodash methods are guarded to work as iteratees for methods like
               * `_.reduce`, `_.reduceRight`, and `_.transform`.
               *
               * The guarded methods are:
               * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
               * and `sortBy`
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @param {*} [accumulator] The initial value.
               * @returns {*} Returns the accumulated value.
               * @see _.reduceRight
               * @example
               *
               * _.reduce([1, 2], function(sum, n) {
               *   return sum + n;
               * }, 0);
               * // => 3
               *
               * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
               *   (result[value] || (result[value] = [])).push(key);
               *   return result;
               * }, {});
               * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
               */
              function reduce(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduce : baseReduce,
                initAccum = arguments.length < 3;

                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
              }

              /**
               * This method is like `_.reduce` except that it iterates over elements of
               * `collection` from right to left.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @param {*} [accumulator] The initial value.
               * @returns {*} Returns the accumulated value.
               * @see _.reduce
               * @example
               *
               * var array = [[0, 1], [2, 3], [4, 5]];
               *
               * _.reduceRight(array, function(flattened, other) {
               *   return flattened.concat(other);
               * }, []);
               * // => [4, 5, 2, 3, 0, 1]
               */
              function reduceRight(collection, iteratee, accumulator) {
                var func = isArray(collection) ? arrayReduceRight : baseReduce,
                initAccum = arguments.length < 3;

                return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
              }

              /**
               * The opposite of `_.filter`; this method returns the elements of `collection`
               * that `predicate` does **not** return truthy for.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the new filtered array.
               * @see _.filter
               * @example
               *
               * var users = [
               *   { 'user': 'barney', 'age': 36, 'active': false },
               *   { 'user': 'fred',   'age': 40, 'active': true }
               * ];
               *
               * _.reject(users, function(o) { return !o.active; });
               * // => objects for ['fred']
               *
               * // The `_.matches` iteratee shorthand.
               * _.reject(users, { 'age': 40, 'active': true });
               * // => objects for ['barney']
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.reject(users, ['active', false]);
               * // => objects for ['fred']
               *
               * // The `_.property` iteratee shorthand.
               * _.reject(users, 'active');
               * // => objects for ['barney']
               */
              function reject(collection, predicate) {
                var func = isArray(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }

              /**
               * Gets a random element from `collection`.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to sample.
               * @returns {*} Returns the random element.
               * @example
               *
               * _.sample([1, 2, 3, 4]);
               * // => 2
               */
              function sample(collection) {
                var func = isArray(collection) ? arraySample : baseSample;
                return func(collection);
              }

              /**
               * Gets `n` random elements at unique keys from `collection` up to the
               * size of `collection`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Collection
               * @param {Array|Object} collection The collection to sample.
               * @param {number} [n=1] The number of elements to sample.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the random elements.
               * @example
               *
               * _.sampleSize([1, 2, 3], 2);
               * // => [3, 1]
               *
               * _.sampleSize([1, 2, 3], 4);
               * // => [2, 3, 1]
               */
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n);
              }

              /**
               * Creates an array of shuffled values, using a version of the
               * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to shuffle.
               * @returns {Array} Returns the new shuffled array.
               * @example
               *
               * _.shuffle([1, 2, 3, 4]);
               * // => [4, 1, 3, 2]
               */
              function shuffle(collection) {
                var func = isArray(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }

              /**
               * Gets the size of `collection` by returning its length for array-like
               * values or the number of own enumerable string keyed properties for objects.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object|string} collection The collection to inspect.
               * @returns {number} Returns the collection size.
               * @example
               *
               * _.size([1, 2, 3]);
               * // => 3
               *
               * _.size({ 'a': 1, 'b': 2 });
               * // => 2
               *
               * _.size('pebbles');
               * // => 7
               */
              function size(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                  return collection.size;
                }
                return baseKeys(collection).length;
              }

              /**
               * Checks if `predicate` returns truthy for **any** element of `collection`.
               * Iteration is stopped once `predicate` returns truthy. The predicate is
               * invoked with three arguments: (value, index|key, collection).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {boolean} Returns `true` if any element passes the predicate check,
               *  else `false`.
               * @example
               *
               * _.some([null, 0, 'yes', false], Boolean);
               * // => true
               *
               * var users = [
               *   { 'user': 'barney', 'active': true },
               *   { 'user': 'fred',   'active': false }
               * ];
               *
               * // The `_.matches` iteratee shorthand.
               * _.some(users, { 'user': 'barney', 'active': false });
               * // => false
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.some(users, ['active', false]);
               * // => true
               *
               * // The `_.property` iteratee shorthand.
               * _.some(users, 'active');
               * // => true
               */
              function some(collection, predicate, guard) {
                var func = isArray(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                  predicate = undefined;
                }
                return func(collection, getIteratee(predicate, 3));
              }

              /**
               * Creates an array of elements, sorted in ascending order by the results of
               * running each element in a collection thru each iteratee. This method
               * performs a stable sort, that is, it preserves the original sort order of
               * equal elements. The iteratees are invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Collection
               * @param {Array|Object} collection The collection to iterate over.
               * @param {...(Function|Function[])} [iteratees=[_.identity]]
               *  The iteratees to sort by.
               * @returns {Array} Returns the new sorted array.
               * @example
               *
               * var users = [
               *   { 'user': 'fred',   'age': 48 },
               *   { 'user': 'barney', 'age': 36 },
               *   { 'user': 'fred',   'age': 30 },
               *   { 'user': 'barney', 'age': 34 }
               * ];
               *
               * _.sortBy(users, [function(o) { return o.user; }]);
               * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
               *
               * _.sortBy(users, ['user', 'age']);
               * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
               */
              var sortBy = baseRest(function (collection, iteratees) {
                if (collection == null) {
                  return [];
                }
                var length = iteratees.length;
                if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                  iteratees = [];
                } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                  iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
              });

              /*------------------------------------------------------------------------*/

              /**
               * Gets the timestamp of the number of milliseconds that have elapsed since
               * the Unix epoch (1 January 1970 00:00:00 UTC).
               *
               * @static
               * @memberOf _
               * @since 2.4.0
               * @category Date
               * @returns {number} Returns the timestamp.
               * @example
               *
               * _.defer(function(stamp) {
               *   console.log(_.now() - stamp);
               * }, _.now());
               * // => Logs the number of milliseconds it took for the deferred invocation.
               */
              var now = ctxNow || function () {
                return root.Date.now();
              };

              /*------------------------------------------------------------------------*/

              /**
               * The opposite of `_.before`; this method creates a function that invokes
               * `func` once it's called `n` or more times.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {number} n The number of calls before `func` is invoked.
               * @param {Function} func The function to restrict.
               * @returns {Function} Returns the new restricted function.
               * @example
               *
               * var saves = ['profile', 'settings'];
               *
               * var done = _.after(saves.length, function() {
               *   console.log('done saving!');
               * });
               *
               * _.forEach(saves, function(type) {
               *   asyncSave({ 'type': type, 'complete': done });
               * });
               * // => Logs 'done saving!' after the two async saves have completed.
               */
              function after(n, func) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }

              /**
               * Creates a function that invokes `func`, with up to `n` arguments,
               * ignoring any additional arguments.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Function
               * @param {Function} func The function to cap arguments for.
               * @param {number} [n=func.length] The arity cap.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Function} Returns the new capped function.
               * @example
               *
               * _.map(['6', '8', '10'], _.ary(parseInt, 1));
               * // => [6, 8, 10]
               */
              function ary(func, n, guard) {
                n = guard ? undefined : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
              }

              /**
               * Creates a function that invokes `func`, with the `this` binding and arguments
               * of the created function, while it's called less than `n` times. Subsequent
               * calls to the created function return the result of the last `func` invocation.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Function
               * @param {number} n The number of calls at which `func` is no longer invoked.
               * @param {Function} func The function to restrict.
               * @returns {Function} Returns the new restricted function.
               * @example
               *
               * jQuery(element).on('click', _.before(5, addContactToList));
               * // => Allows adding up to 4 contacts to the list.
               */
              function before(n, func) {
                var result;
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                n = toInteger(n);
                return function () {
                  if (--n > 0) {
                    result = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined;
                  }
                  return result;
                };
              }

              /**
               * Creates a function that invokes `func` with the `this` binding of `thisArg`
               * and `partials` prepended to the arguments it receives.
               *
               * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
               * may be used as a placeholder for partially applied arguments.
               *
               * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
               * property of bound functions.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to bind.
               * @param {*} thisArg The `this` binding of `func`.
               * @param {...*} [partials] The arguments to be partially applied.
               * @returns {Function} Returns the new bound function.
               * @example
               *
               * function greet(greeting, punctuation) {
               *   return greeting + ' ' + this.user + punctuation;
               * }
               *
               * var object = { 'user': 'fred' };
               *
               * var bound = _.bind(greet, object, 'hi');
               * bound('!');
               * // => 'hi fred!'
               *
               * // Bound with placeholders.
               * var bound = _.bind(greet, object, _, '!');
               * bound('hi');
               * // => 'hi fred!'
               */
              var bind = baseRest(function (func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bind));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
              });

              /**
               * Creates a function that invokes the method at `object[key]` with `partials`
               * prepended to the arguments it receives.
               *
               * This method differs from `_.bind` by allowing bound functions to reference
               * methods that may be redefined or don't yet exist. See
               * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
               * for more details.
               *
               * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
               * builds, may be used as a placeholder for partially applied arguments.
               *
               * @static
               * @memberOf _
               * @since 0.10.0
               * @category Function
               * @param {Object} object The object to invoke the method on.
               * @param {string} key The key of the method.
               * @param {...*} [partials] The arguments to be partially applied.
               * @returns {Function} Returns the new bound function.
               * @example
               *
               * var object = {
               *   'user': 'fred',
               *   'greet': function(greeting, punctuation) {
               *     return greeting + ' ' + this.user + punctuation;
               *   }
               * };
               *
               * var bound = _.bindKey(object, 'greet', 'hi');
               * bound('!');
               * // => 'hi fred!'
               *
               * object.greet = function(greeting, punctuation) {
               *   return greeting + 'ya ' + this.user + punctuation;
               * };
               *
               * bound('!');
               * // => 'hiya fred!'
               *
               * // Bound with placeholders.
               * var bound = _.bindKey(object, 'greet', _, '!');
               * bound('hi');
               * // => 'hiya fred!'
               */
              var bindKey = baseRest(function (object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bindKey));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
              });

              /**
               * Creates a function that accepts arguments of `func` and either invokes
               * `func` returning its result, if at least `arity` number of arguments have
               * been provided, or returns a function that accepts the remaining `func`
               * arguments, and so on. The arity of `func` may be specified if `func.length`
               * is not sufficient.
               *
               * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
               * may be used as a placeholder for provided arguments.
               *
               * **Note:** This method doesn't set the "length" property of curried functions.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Function
               * @param {Function} func The function to curry.
               * @param {number} [arity=func.length] The arity of `func`.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Function} Returns the new curried function.
               * @example
               *
               * var abc = function(a, b, c) {
               *   return [a, b, c];
               * };
               *
               * var curried = _.curry(abc);
               *
               * curried(1)(2)(3);
               * // => [1, 2, 3]
               *
               * curried(1, 2)(3);
               * // => [1, 2, 3]
               *
               * curried(1, 2, 3);
               * // => [1, 2, 3]
               *
               * // Curried with placeholders.
               * curried(1)(_, 3)(2);
               * // => [1, 2, 3]
               */
              function curry(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curry.placeholder;
                return result;
              }

              /**
               * This method is like `_.curry` except that arguments are applied to `func`
               * in the manner of `_.partialRight` instead of `_.partial`.
               *
               * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
               * builds, may be used as a placeholder for provided arguments.
               *
               * **Note:** This method doesn't set the "length" property of curried functions.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Function
               * @param {Function} func The function to curry.
               * @param {number} [arity=func.length] The arity of `func`.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Function} Returns the new curried function.
               * @example
               *
               * var abc = function(a, b, c) {
               *   return [a, b, c];
               * };
               *
               * var curried = _.curryRight(abc);
               *
               * curried(3)(2)(1);
               * // => [1, 2, 3]
               *
               * curried(2, 3)(1);
               * // => [1, 2, 3]
               *
               * curried(1, 2, 3);
               * // => [1, 2, 3]
               *
               * // Curried with placeholders.
               * curried(3)(1, _)(2);
               * // => [1, 2, 3]
               */
              function curryRight(func, arity, guard) {
                arity = guard ? undefined : arity;
                var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                result.placeholder = curryRight.placeholder;
                return result;
              }

              /**
               * Creates a debounced function that delays invoking `func` until after `wait`
               * milliseconds have elapsed since the last time the debounced function was
               * invoked. The debounced function comes with a `cancel` method to cancel
               * delayed `func` invocations and a `flush` method to immediately invoke them.
               * Provide `options` to indicate whether `func` should be invoked on the
               * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
               * with the last arguments provided to the debounced function. Subsequent
               * calls to the debounced function return the result of the last `func`
               * invocation.
               *
               * **Note:** If `leading` and `trailing` options are `true`, `func` is
               * invoked on the trailing edge of the timeout only if the debounced function
               * is invoked more than once during the `wait` timeout.
               *
               * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
               * until to the next tick, similar to `setTimeout` with a timeout of `0`.
               *
               * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
               * for details over the differences between `_.debounce` and `_.throttle`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to debounce.
               * @param {number} [wait=0] The number of milliseconds to delay.
               * @param {Object} [options={}] The options object.
               * @param {boolean} [options.leading=false]
               *  Specify invoking on the leading edge of the timeout.
               * @param {number} [options.maxWait]
               *  The maximum time `func` is allowed to be delayed before it's invoked.
               * @param {boolean} [options.trailing=true]
               *  Specify invoking on the trailing edge of the timeout.
               * @returns {Function} Returns the new debounced function.
               * @example
               *
               * // Avoid costly calculations while the window size is in flux.
               * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
               *
               * // Invoke `sendMail` when clicked, debouncing subsequent calls.
               * jQuery(element).on('click', _.debounce(sendMail, 300, {
               *   'leading': true,
               *   'trailing': false
               * }));
               *
               * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
               * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
               * var source = new EventSource('/stream');
               * jQuery(source).on('message', debounced);
               *
               * // Cancel the trailing debounced invocation.
               * jQuery(window).on('popstate', debounced.cancel);
               */
              function debounce(func, wait, options) {
                var lastArgs,
                lastThis,
                maxWait,
                result,
                timerId,
                lastCallTime,
                lastInvokeTime = 0,
                leading = false,
                maxing = false,
                trailing = true;

                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = 'maxWait' in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }

                function invokeFunc(time) {
                  var args = lastArgs,
                  thisArg = lastThis;

                  lastArgs = lastThis = undefined;
                  lastInvokeTime = time;
                  result = func.apply(thisArg, args);
                  return result;
                }

                function leadingEdge(time) {
                  // Reset any `maxWait` timer.
                  lastInvokeTime = time;
                  // Start the timer for the trailing edge.
                  timerId = setTimeout(timerExpired, wait);
                  // Invoke the leading edge.
                  return leading ? invokeFunc(time) : result;
                }

                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime,
                  timeWaiting = wait - timeSinceLastCall;

                  return maxing ?
                  nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) :
                  timeWaiting;
                }

                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime;

                  // Either this is the first call, activity has stopped and we're at the
                  // trailing edge, the system time has gone backwards and we're treating
                  // it as the trailing edge, or we've hit the `maxWait` limit.
                  return lastCallTime === undefined || timeSinceLastCall >= wait ||
                  timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }

                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  // Restart the timer.
                  timerId = setTimeout(timerExpired, remainingWait(time));
                }

                function trailingEdge(time) {
                  timerId = undefined;

                  // Only invoke if we have `lastArgs` which means `func` has been
                  // debounced at least once.
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = undefined;
                  return result;
                }

                function cancel() {
                  if (timerId !== undefined) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined;
                }

                function flush() {
                  return timerId === undefined ? result : trailingEdge(now());
                }

                function debounced() {
                  var time = now(),
                  isInvoking = shouldInvoke(time);

                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;

                  if (isInvoking) {
                    if (timerId === undefined) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      // Handle invocations in a tight loop.
                      clearTimeout(timerId);
                      timerId = setTimeout(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                  }
                  return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }

              /**
               * Defers invoking the `func` until the current call stack has cleared. Any
               * additional arguments are provided to `func` when it's invoked.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to defer.
               * @param {...*} [args] The arguments to invoke `func` with.
               * @returns {number} Returns the timer id.
               * @example
               *
               * _.defer(function(text) {
               *   console.log(text);
               * }, 'deferred');
               * // => Logs 'deferred' after one millisecond.
               */
              var defer = baseRest(function (func, args) {
                return baseDelay(func, 1, args);
              });

              /**
               * Invokes `func` after `wait` milliseconds. Any additional arguments are
               * provided to `func` when it's invoked.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to delay.
               * @param {number} wait The number of milliseconds to delay invocation.
               * @param {...*} [args] The arguments to invoke `func` with.
               * @returns {number} Returns the timer id.
               * @example
               *
               * _.delay(function(text) {
               *   console.log(text);
               * }, 1000, 'later');
               * // => Logs 'later' after one second.
               */
              var delay = baseRest(function (func, wait, args) {
                return baseDelay(func, toNumber(wait) || 0, args);
              });

              /**
               * Creates a function that invokes `func` with arguments reversed.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Function
               * @param {Function} func The function to flip arguments for.
               * @returns {Function} Returns the new flipped function.
               * @example
               *
               * var flipped = _.flip(function() {
               *   return _.toArray(arguments);
               * });
               *
               * flipped('a', 'b', 'c', 'd');
               * // => ['d', 'c', 'b', 'a']
               */
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }

              /**
               * Creates a function that memoizes the result of `func`. If `resolver` is
               * provided, it determines the cache key for storing the result based on the
               * arguments provided to the memoized function. By default, the first argument
               * provided to the memoized function is used as the map cache key. The `func`
               * is invoked with the `this` binding of the memoized function.
               *
               * **Note:** The cache is exposed as the `cache` property on the memoized
               * function. Its creation may be customized by replacing the `_.memoize.Cache`
               * constructor with one whose instances implement the
               * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
               * method interface of `clear`, `delete`, `get`, `has`, and `set`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to have its output memoized.
               * @param {Function} [resolver] The function to resolve the cache key.
               * @returns {Function} Returns the new memoized function.
               * @example
               *
               * var object = { 'a': 1, 'b': 2 };
               * var other = { 'c': 3, 'd': 4 };
               *
               * var values = _.memoize(_.values);
               * values(object);
               * // => [1, 2]
               *
               * values(other);
               * // => [3, 4]
               *
               * object.a = 2;
               * values(object);
               * // => [1, 2]
               *
               * // Modify the result cache.
               * values.cache.set(object, ['a', 'b']);
               * values(object);
               * // => ['a', 'b']
               *
               * // Replace `_.memoize.Cache`.
               * _.memoize.Cache = WeakMap;
               */
              function memoize(func, resolver) {
                if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function () {
                  var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;

                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result = func.apply(this, args);
                  memoized.cache = cache.set(key, result) || cache;
                  return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }

              // Expose `MapCache`.
              memoize.Cache = MapCache;

              /**
               * Creates a function that negates the result of the predicate `func`. The
               * `func` predicate is invoked with the `this` binding and arguments of the
               * created function.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Function
               * @param {Function} predicate The predicate to negate.
               * @returns {Function} Returns the new negated function.
               * @example
               *
               * function isEven(n) {
               *   return n % 2 == 0;
               * }
               *
               * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
               * // => [1, 3, 5]
               */
              function negate(predicate) {
                if (typeof predicate != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return function () {
                  var args = arguments;
                  switch (args.length) {
                    case 0:return !predicate.call(this);
                    case 1:return !predicate.call(this, args[0]);
                    case 2:return !predicate.call(this, args[0], args[1]);
                    case 3:return !predicate.call(this, args[0], args[1], args[2]);}

                  return !predicate.apply(this, args);
                };
              }

              /**
               * Creates a function that is restricted to invoking `func` once. Repeat calls
               * to the function return the value of the first invocation. The `func` is
               * invoked with the `this` binding and arguments of the created function.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to restrict.
               * @returns {Function} Returns the new restricted function.
               * @example
               *
               * var initialize = _.once(createApplication);
               * initialize();
               * initialize();
               * // => `createApplication` is invoked once
               */
              function once(func) {
                return before(2, func);
              }

              /**
               * Creates a function that invokes `func` with its arguments transformed.
               *
               * @static
               * @since 4.0.0
               * @memberOf _
               * @category Function
               * @param {Function} func The function to wrap.
               * @param {...(Function|Function[])} [transforms=[_.identity]]
               *  The argument transforms.
               * @returns {Function} Returns the new function.
               * @example
               *
               * function doubled(n) {
               *   return n * 2;
               * }
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * var func = _.overArgs(function(x, y) {
               *   return [x, y];
               * }, [square, doubled]);
               *
               * func(9, 3);
               * // => [81, 6]
               *
               * func(10, 5);
               * // => [100, 10]
               */
              var overArgs = castRest(function (func, transforms) {
                transforms = transforms.length == 1 && isArray(transforms[0]) ?
                arrayMap(transforms[0], baseUnary(getIteratee())) :
                arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

                var funcsLength = transforms.length;
                return baseRest(function (args) {
                  var index = -1,
                  length = nativeMin(args.length, funcsLength);

                  while (++index < length) {
                    args[index] = transforms[index].call(this, args[index]);
                  }
                  return apply(func, this, args);
                });
              });

              /**
               * Creates a function that invokes `func` with `partials` prepended to the
               * arguments it receives. This method is like `_.bind` except it does **not**
               * alter the `this` binding.
               *
               * The `_.partial.placeholder` value, which defaults to `_` in monolithic
               * builds, may be used as a placeholder for partially applied arguments.
               *
               * **Note:** This method doesn't set the "length" property of partially
               * applied functions.
               *
               * @static
               * @memberOf _
               * @since 0.2.0
               * @category Function
               * @param {Function} func The function to partially apply arguments to.
               * @param {...*} [partials] The arguments to be partially applied.
               * @returns {Function} Returns the new partially applied function.
               * @example
               *
               * function greet(greeting, name) {
               *   return greeting + ' ' + name;
               * }
               *
               * var sayHelloTo = _.partial(greet, 'hello');
               * sayHelloTo('fred');
               * // => 'hello fred'
               *
               * // Partially applied with placeholders.
               * var greetFred = _.partial(greet, _, 'fred');
               * greetFred('hi');
               * // => 'hi fred'
               */
              var partial = baseRest(function (func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
              });

              /**
               * This method is like `_.partial` except that partially applied arguments
               * are appended to the arguments it receives.
               *
               * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
               * builds, may be used as a placeholder for partially applied arguments.
               *
               * **Note:** This method doesn't set the "length" property of partially
               * applied functions.
               *
               * @static
               * @memberOf _
               * @since 1.0.0
               * @category Function
               * @param {Function} func The function to partially apply arguments to.
               * @param {...*} [partials] The arguments to be partially applied.
               * @returns {Function} Returns the new partially applied function.
               * @example
               *
               * function greet(greeting, name) {
               *   return greeting + ' ' + name;
               * }
               *
               * var greetFred = _.partialRight(greet, 'fred');
               * greetFred('hi');
               * // => 'hi fred'
               *
               * // Partially applied with placeholders.
               * var sayHelloTo = _.partialRight(greet, 'hello', _);
               * sayHelloTo('fred');
               * // => 'hello fred'
               */
              var partialRight = baseRest(function (func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
              });

              /**
               * Creates a function that invokes `func` with arguments arranged according
               * to the specified `indexes` where the argument value at the first index is
               * provided as the first argument, the argument value at the second index is
               * provided as the second argument, and so on.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Function
               * @param {Function} func The function to rearrange arguments for.
               * @param {...(number|number[])} indexes The arranged argument indexes.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var rearged = _.rearg(function(a, b, c) {
               *   return [a, b, c];
               * }, [2, 0, 1]);
               *
               * rearged('b', 'c', 'a')
               * // => ['a', 'b', 'c']
               */
              var rearg = flatRest(function (func, indexes) {
                return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
              });

              /**
               * Creates a function that invokes `func` with the `this` binding of the
               * created function and arguments from `start` and beyond provided as
               * an array.
               *
               * **Note:** This method is based on the
               * [rest parameter](https://mdn.io/rest_parameters).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Function
               * @param {Function} func The function to apply a rest parameter to.
               * @param {number} [start=func.length-1] The start position of the rest parameter.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var say = _.rest(function(what, names) {
               *   return what + ' ' + _.initial(names).join(', ') +
               *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
               * });
               *
               * say('hello', 'fred', 'barney', 'pebbles');
               * // => 'hello fred, barney, & pebbles'
               */
              function rest(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start === undefined ? start : toInteger(start);
                return baseRest(func, start);
              }

              /**
               * Creates a function that invokes `func` with the `this` binding of the
               * create function and an array of arguments much like
               * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
               *
               * **Note:** This method is based on the
               * [spread operator](https://mdn.io/spread_operator).
               *
               * @static
               * @memberOf _
               * @since 3.2.0
               * @category Function
               * @param {Function} func The function to spread arguments over.
               * @param {number} [start=0] The start position of the spread.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var say = _.spread(function(who, what) {
               *   return who + ' says ' + what;
               * });
               *
               * say(['fred', 'hello']);
               * // => 'fred says hello'
               *
               * var numbers = Promise.all([
               *   Promise.resolve(40),
               *   Promise.resolve(36)
               * ]);
               *
               * numbers.then(_.spread(function(x, y) {
               *   return x + y;
               * }));
               * // => a Promise of 76
               */
              function spread(func, start) {
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                start = start == null ? 0 : nativeMax(toInteger(start), 0);
                return baseRest(function (args) {
                  var array = args[start],
                  otherArgs = castSlice(args, 0, start);

                  if (array) {
                    arrayPush(otherArgs, array);
                  }
                  return apply(func, this, otherArgs);
                });
              }

              /**
               * Creates a throttled function that only invokes `func` at most once per
               * every `wait` milliseconds. The throttled function comes with a `cancel`
               * method to cancel delayed `func` invocations and a `flush` method to
               * immediately invoke them. Provide `options` to indicate whether `func`
               * should be invoked on the leading and/or trailing edge of the `wait`
               * timeout. The `func` is invoked with the last arguments provided to the
               * throttled function. Subsequent calls to the throttled function return the
               * result of the last `func` invocation.
               *
               * **Note:** If `leading` and `trailing` options are `true`, `func` is
               * invoked on the trailing edge of the timeout only if the throttled function
               * is invoked more than once during the `wait` timeout.
               *
               * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
               * until to the next tick, similar to `setTimeout` with a timeout of `0`.
               *
               * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
               * for details over the differences between `_.throttle` and `_.debounce`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {Function} func The function to throttle.
               * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
               * @param {Object} [options={}] The options object.
               * @param {boolean} [options.leading=true]
               *  Specify invoking on the leading edge of the timeout.
               * @param {boolean} [options.trailing=true]
               *  Specify invoking on the trailing edge of the timeout.
               * @returns {Function} Returns the new throttled function.
               * @example
               *
               * // Avoid excessively updating the position while scrolling.
               * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
               *
               * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
               * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
               * jQuery(element).on('click', throttled);
               *
               * // Cancel the trailing throttled invocation.
               * jQuery(window).on('popstate', throttled.cancel);
               */
              function throttle(func, wait, options) {
                var leading = true,
                trailing = true;

                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (isObject(options)) {
                  leading = 'leading' in options ? !!options.leading : leading;
                  trailing = 'trailing' in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                  'leading': leading,
                  'maxWait': wait,
                  'trailing': trailing });

              }

              /**
               * Creates a function that accepts up to one argument, ignoring any
               * additional arguments.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Function
               * @param {Function} func The function to cap arguments for.
               * @returns {Function} Returns the new capped function.
               * @example
               *
               * _.map(['6', '8', '10'], _.unary(parseInt));
               * // => [6, 8, 10]
               */
              function unary(func) {
                return ary(func, 1);
              }

              /**
               * Creates a function that provides `value` to `wrapper` as its first
               * argument. Any additional arguments provided to the function are appended
               * to those provided to the `wrapper`. The wrapper is invoked with the `this`
               * binding of the created function.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Function
               * @param {*} value The value to wrap.
               * @param {Function} [wrapper=identity] The wrapper function.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var p = _.wrap(_.escape, function(func, text) {
               *   return '<p>' + func(text) + '</p>';
               * });
               *
               * p('fred, barney, & pebbles');
               * // => '<p>fred, barney, &amp; pebbles</p>'
               */
              function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
              }

              /*------------------------------------------------------------------------*/

              /**
               * Casts `value` as an array if it's not one.
               *
               * @static
               * @memberOf _
               * @since 4.4.0
               * @category Lang
               * @param {*} value The value to inspect.
               * @returns {Array} Returns the cast array.
               * @example
               *
               * _.castArray(1);
               * // => [1]
               *
               * _.castArray({ 'a': 1 });
               * // => [{ 'a': 1 }]
               *
               * _.castArray('abc');
               * // => ['abc']
               *
               * _.castArray(null);
               * // => [null]
               *
               * _.castArray(undefined);
               * // => [undefined]
               *
               * _.castArray();
               * // => []
               *
               * var array = [1, 2, 3];
               * console.log(_.castArray(array) === array);
               * // => true
               */
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray(value) ? value : [value];
              }

              /**
               * Creates a shallow clone of `value`.
               *
               * **Note:** This method is loosely based on the
               * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
               * and supports cloning arrays, array buffers, booleans, date objects, maps,
               * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
               * arrays. The own enumerable properties of `arguments` objects are cloned
               * as plain objects. An empty object is returned for uncloneable values such
               * as error objects, functions, DOM nodes, and WeakMaps.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to clone.
               * @returns {*} Returns the cloned value.
               * @see _.cloneDeep
               * @example
               *
               * var objects = [{ 'a': 1 }, { 'b': 2 }];
               *
               * var shallow = _.clone(objects);
               * console.log(shallow[0] === objects[0]);
               * // => true
               */
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }

              /**
               * This method is like `_.clone` except that it accepts `customizer` which
               * is invoked to produce the cloned value. If `customizer` returns `undefined`,
               * cloning is handled by the method instead. The `customizer` is invoked with
               * up to four arguments; (value [, index|key, object, stack]).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to clone.
               * @param {Function} [customizer] The function to customize cloning.
               * @returns {*} Returns the cloned value.
               * @see _.cloneDeepWith
               * @example
               *
               * function customizer(value) {
               *   if (_.isElement(value)) {
               *     return value.cloneNode(false);
               *   }
               * }
               *
               * var el = _.cloneWith(document.body, customizer);
               *
               * console.log(el === document.body);
               * // => false
               * console.log(el.nodeName);
               * // => 'BODY'
               * console.log(el.childNodes.length);
               * // => 0
               */
              function cloneWith(value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }

              /**
               * This method is like `_.clone` except that it recursively clones `value`.
               *
               * @static
               * @memberOf _
               * @since 1.0.0
               * @category Lang
               * @param {*} value The value to recursively clone.
               * @returns {*} Returns the deep cloned value.
               * @see _.clone
               * @example
               *
               * var objects = [{ 'a': 1 }, { 'b': 2 }];
               *
               * var deep = _.cloneDeep(objects);
               * console.log(deep[0] === objects[0]);
               * // => false
               */
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }

              /**
               * This method is like `_.cloneWith` except that it recursively clones `value`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to recursively clone.
               * @param {Function} [customizer] The function to customize cloning.
               * @returns {*} Returns the deep cloned value.
               * @see _.cloneWith
               * @example
               *
               * function customizer(value) {
               *   if (_.isElement(value)) {
               *     return value.cloneNode(true);
               *   }
               * }
               *
               * var el = _.cloneDeepWith(document.body, customizer);
               *
               * console.log(el === document.body);
               * // => false
               * console.log(el.nodeName);
               * // => 'BODY'
               * console.log(el.childNodes.length);
               * // => 20
               */
              function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
              }

              /**
               * Checks if `object` conforms to `source` by invoking the predicate
               * properties of `source` with the corresponding property values of `object`.
               *
               * **Note:** This method is equivalent to `_.conforms` when `source` is
               * partially applied.
               *
               * @static
               * @memberOf _
               * @since 4.14.0
               * @category Lang
               * @param {Object} object The object to inspect.
               * @param {Object} source The object of property predicates to conform to.
               * @returns {boolean} Returns `true` if `object` conforms, else `false`.
               * @example
               *
               * var object = { 'a': 1, 'b': 2 };
               *
               * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
               * // => true
               *
               * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
               * // => false
               */
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
              }

              /**
               * Performs a
               * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
               * comparison between two values to determine if they are equivalent.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
               * @example
               *
               * var object = { 'a': 1 };
               * var other = { 'a': 1 };
               *
               * _.eq(object, object);
               * // => true
               *
               * _.eq(object, other);
               * // => false
               *
               * _.eq('a', 'a');
               * // => true
               *
               * _.eq('a', Object('a'));
               * // => false
               *
               * _.eq(NaN, NaN);
               * // => true
               */
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }

              /**
               * Checks if `value` is greater than `other`.
               *
               * @static
               * @memberOf _
               * @since 3.9.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is greater than `other`,
               *  else `false`.
               * @see _.lt
               * @example
               *
               * _.gt(3, 1);
               * // => true
               *
               * _.gt(3, 3);
               * // => false
               *
               * _.gt(1, 3);
               * // => false
               */
              var gt = createRelationalOperation(baseGt);

              /**
               * Checks if `value` is greater than or equal to `other`.
               *
               * @static
               * @memberOf _
               * @since 3.9.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is greater than or equal to
               *  `other`, else `false`.
               * @see _.lte
               * @example
               *
               * _.gte(3, 1);
               * // => true
               *
               * _.gte(3, 3);
               * // => true
               *
               * _.gte(1, 3);
               * // => false
               */
              var gte = createRelationalOperation(function (value, other) {
                return value >= other;
              });

              /**
               * Checks if `value` is likely an `arguments` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an `arguments` object,
               *  else `false`.
               * @example
               *
               * _.isArguments(function() { return arguments; }());
               * // => true
               *
               * _.isArguments([1, 2, 3]);
               * // => false
               */
              var isArguments = baseIsArguments(function () {return arguments;}()) ? baseIsArguments : function (value) {
                return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
                !propertyIsEnumerable.call(value, 'callee');
              };

              /**
               * Checks if `value` is classified as an `Array` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array, else `false`.
               * @example
               *
               * _.isArray([1, 2, 3]);
               * // => true
               *
               * _.isArray(document.body.children);
               * // => false
               *
               * _.isArray('abc');
               * // => false
               *
               * _.isArray(_.noop);
               * // => false
               */
              var isArray = Array.isArray;

              /**
               * Checks if `value` is classified as an `ArrayBuffer` object.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
               * @example
               *
               * _.isArrayBuffer(new ArrayBuffer(2));
               * // => true
               *
               * _.isArrayBuffer(new Array(2));
               * // => false
               */
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

              /**
               * Checks if `value` is array-like. A value is considered array-like if it's
               * not a function and has a `value.length` that's an integer greater than or
               * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
               * @example
               *
               * _.isArrayLike([1, 2, 3]);
               * // => true
               *
               * _.isArrayLike(document.body.children);
               * // => true
               *
               * _.isArrayLike('abc');
               * // => true
               *
               * _.isArrayLike(_.noop);
               * // => false
               */
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }

              /**
               * This method is like `_.isArrayLike` except that it also checks if `value`
               * is an object.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an array-like object,
               *  else `false`.
               * @example
               *
               * _.isArrayLikeObject([1, 2, 3]);
               * // => true
               *
               * _.isArrayLikeObject(document.body.children);
               * // => true
               *
               * _.isArrayLikeObject('abc');
               * // => false
               *
               * _.isArrayLikeObject(_.noop);
               * // => false
               */
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }

              /**
               * Checks if `value` is classified as a boolean primitive or object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
               * @example
               *
               * _.isBoolean(false);
               * // => true
               *
               * _.isBoolean(null);
               * // => false
               */
              function isBoolean(value) {
                return value === true || value === false ||
                isObjectLike(value) && baseGetTag(value) == boolTag;
              }

              /**
               * Checks if `value` is a buffer.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
               * @example
               *
               * _.isBuffer(new Buffer(2));
               * // => true
               *
               * _.isBuffer(new Uint8Array(2));
               * // => false
               */
              var isBuffer = nativeIsBuffer || stubFalse;

              /**
               * Checks if `value` is classified as a `Date` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
               * @example
               *
               * _.isDate(new Date);
               * // => true
               *
               * _.isDate('Mon April 23 2012');
               * // => false
               */
              var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

              /**
               * Checks if `value` is likely a DOM element.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
               * @example
               *
               * _.isElement(document.body);
               * // => true
               *
               * _.isElement('<body>');
               * // => false
               */
              function isElement(value) {
                return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
              }

              /**
               * Checks if `value` is an empty object, collection, map, or set.
               *
               * Objects are considered empty if they have no own enumerable string keyed
               * properties.
               *
               * Array-like values such as `arguments` objects, arrays, buffers, strings, or
               * jQuery-like collections are considered empty if they have a `length` of `0`.
               * Similarly, maps and sets are considered empty if they have a `size` of `0`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is empty, else `false`.
               * @example
               *
               * _.isEmpty(null);
               * // => true
               *
               * _.isEmpty(true);
               * // => true
               *
               * _.isEmpty(1);
               * // => true
               *
               * _.isEmpty([1, 2, 3]);
               * // => false
               *
               * _.isEmpty({ 'a': 1 });
               * // => false
               */
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (isArrayLike(value) && (
                isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                  return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                  return !value.size;
                }
                if (isPrototype(value)) {
                  return !baseKeys(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }

              /**
               * Performs a deep comparison between two values to determine if they are
               * equivalent.
               *
               * **Note:** This method supports comparing arrays, array buffers, booleans,
               * date objects, error objects, maps, numbers, `Object` objects, regexes,
               * sets, strings, symbols, and typed arrays. `Object` objects are compared
               * by their own, not inherited, enumerable properties. Functions and DOM
               * nodes are compared by strict equality, i.e. `===`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
               * @example
               *
               * var object = { 'a': 1 };
               * var other = { 'a': 1 };
               *
               * _.isEqual(object, other);
               * // => true
               *
               * object === other;
               * // => false
               */
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }

              /**
               * This method is like `_.isEqual` except that it accepts `customizer` which
               * is invoked to compare values. If `customizer` returns `undefined`, comparisons
               * are handled by the method instead. The `customizer` is invoked with up to
               * six arguments: (objValue, othValue [, index|key, object, other, stack]).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @param {Function} [customizer] The function to customize comparisons.
               * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
               * @example
               *
               * function isGreeting(value) {
               *   return /^h(?:i|ello)$/.test(value);
               * }
               *
               * function customizer(objValue, othValue) {
               *   if (isGreeting(objValue) && isGreeting(othValue)) {
               *     return true;
               *   }
               * }
               *
               * var array = ['hello', 'goodbye'];
               * var other = ['hi', 'goodbye'];
               *
               * _.isEqualWith(array, other, customizer);
               * // => true
               */
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                var result = customizer ? customizer(value, other) : undefined;
                return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
              }

              /**
               * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
               * `SyntaxError`, `TypeError`, or `URIError` object.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
               * @example
               *
               * _.isError(new Error);
               * // => true
               *
               * _.isError(Error);
               * // => false
               */
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag ||
                typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
              }

              /**
               * Checks if `value` is a finite primitive number.
               *
               * **Note:** This method is based on
               * [`Number.isFinite`](https://mdn.io/Number/isFinite).
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
               * @example
               *
               * _.isFinite(3);
               * // => true
               *
               * _.isFinite(Number.MIN_VALUE);
               * // => true
               *
               * _.isFinite(Infinity);
               * // => false
               *
               * _.isFinite('3');
               * // => false
               */
              function isFinite(value) {
                return typeof value == 'number' && nativeIsFinite(value);
              }

              /**
               * Checks if `value` is classified as a `Function` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a function, else `false`.
               * @example
               *
               * _.isFunction(_);
               * // => true
               *
               * _.isFunction(/abc/);
               * // => false
               */
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }

              /**
               * Checks if `value` is an integer.
               *
               * **Note:** This method is based on
               * [`Number.isInteger`](https://mdn.io/Number/isInteger).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
               * @example
               *
               * _.isInteger(3);
               * // => true
               *
               * _.isInteger(Number.MIN_VALUE);
               * // => false
               *
               * _.isInteger(Infinity);
               * // => false
               *
               * _.isInteger('3');
               * // => false
               */
              function isInteger(value) {
                return typeof value == 'number' && value == toInteger(value);
              }

              /**
               * Checks if `value` is a valid array-like length.
               *
               * **Note:** This method is loosely based on
               * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
               * @example
               *
               * _.isLength(3);
               * // => true
               *
               * _.isLength(Number.MIN_VALUE);
               * // => false
               *
               * _.isLength(Infinity);
               * // => false
               *
               * _.isLength('3');
               * // => false
               */
              function isLength(value) {
                return typeof value == 'number' &&
                value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }

              /**
               * Checks if `value` is the
               * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
               * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is an object, else `false`.
               * @example
               *
               * _.isObject({});
               * // => true
               *
               * _.isObject([1, 2, 3]);
               * // => true
               *
               * _.isObject(_.noop);
               * // => true
               *
               * _.isObject(null);
               * // => false
               */
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == 'object' || type == 'function');
              }

              /**
               * Checks if `value` is object-like. A value is object-like if it's not `null`
               * and has a `typeof` result of "object".
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
               * @example
               *
               * _.isObjectLike({});
               * // => true
               *
               * _.isObjectLike([1, 2, 3]);
               * // => true
               *
               * _.isObjectLike(_.noop);
               * // => false
               *
               * _.isObjectLike(null);
               * // => false
               */
              function isObjectLike(value) {
                return value != null && typeof value == 'object';
              }

              /**
               * Checks if `value` is classified as a `Map` object.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a map, else `false`.
               * @example
               *
               * _.isMap(new Map);
               * // => true
               *
               * _.isMap(new WeakMap);
               * // => false
               */
              var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

              /**
               * Performs a partial deep comparison between `object` and `source` to
               * determine if `object` contains equivalent property values.
               *
               * **Note:** This method is equivalent to `_.matches` when `source` is
               * partially applied.
               *
               * Partial comparisons will match empty array and empty object `source`
               * values against any array or object value, respectively. See `_.isEqual`
               * for a list of supported value comparisons.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Lang
               * @param {Object} object The object to inspect.
               * @param {Object} source The object of property values to match.
               * @returns {boolean} Returns `true` if `object` is a match, else `false`.
               * @example
               *
               * var object = { 'a': 1, 'b': 2 };
               *
               * _.isMatch(object, { 'b': 2 });
               * // => true
               *
               * _.isMatch(object, { 'b': 1 });
               * // => false
               */
              function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
              }

              /**
               * This method is like `_.isMatch` except that it accepts `customizer` which
               * is invoked to compare values. If `customizer` returns `undefined`, comparisons
               * are handled by the method instead. The `customizer` is invoked with five
               * arguments: (objValue, srcValue, index|key, object, source).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {Object} object The object to inspect.
               * @param {Object} source The object of property values to match.
               * @param {Function} [customizer] The function to customize comparisons.
               * @returns {boolean} Returns `true` if `object` is a match, else `false`.
               * @example
               *
               * function isGreeting(value) {
               *   return /^h(?:i|ello)$/.test(value);
               * }
               *
               * function customizer(objValue, srcValue) {
               *   if (isGreeting(objValue) && isGreeting(srcValue)) {
               *     return true;
               *   }
               * }
               *
               * var object = { 'greeting': 'hello' };
               * var source = { 'greeting': 'hi' };
               *
               * _.isMatchWith(object, source, customizer);
               * // => true
               */
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return baseIsMatch(object, source, getMatchData(source), customizer);
              }

              /**
               * Checks if `value` is `NaN`.
               *
               * **Note:** This method is based on
               * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
               * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
               * `undefined` and other non-number values.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
               * @example
               *
               * _.isNaN(NaN);
               * // => true
               *
               * _.isNaN(new Number(NaN));
               * // => true
               *
               * isNaN(undefined);
               * // => true
               *
               * _.isNaN(undefined);
               * // => false
               */
              function isNaN(value) {
                // An `NaN` primitive is the only value that is not equal to itself.
                // Perform the `toStringTag` check first to avoid errors with some
                // ActiveX objects in IE.
                return isNumber(value) && value != +value;
              }

              /**
               * Checks if `value` is a pristine native function.
               *
               * **Note:** This method can't reliably detect native functions in the presence
               * of the core-js package because core-js circumvents this kind of detection.
               * Despite multiple requests, the core-js maintainer has made it clear: any
               * attempt to fix the detection will be obstructed. As a result, we're left
               * with little choice but to throw an error. Unfortunately, this also affects
               * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
               * which rely on core-js.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a native function,
               *  else `false`.
               * @example
               *
               * _.isNative(Array.prototype.push);
               * // => true
               *
               * _.isNative(_);
               * // => false
               */
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
              }

              /**
               * Checks if `value` is `null`.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
               * @example
               *
               * _.isNull(null);
               * // => true
               *
               * _.isNull(void 0);
               * // => false
               */
              function isNull(value) {
                return value === null;
              }

              /**
               * Checks if `value` is `null` or `undefined`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
               * @example
               *
               * _.isNil(null);
               * // => true
               *
               * _.isNil(void 0);
               * // => true
               *
               * _.isNil(NaN);
               * // => false
               */
              function isNil(value) {
                return value == null;
              }

              /**
               * Checks if `value` is classified as a `Number` primitive or object.
               *
               * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
               * classified as numbers, use the `_.isFinite` method.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a number, else `false`.
               * @example
               *
               * _.isNumber(3);
               * // => true
               *
               * _.isNumber(Number.MIN_VALUE);
               * // => true
               *
               * _.isNumber(Infinity);
               * // => true
               *
               * _.isNumber('3');
               * // => false
               */
              function isNumber(value) {
                return typeof value == 'number' ||
                isObjectLike(value) && baseGetTag(value) == numberTag;
              }

              /**
               * Checks if `value` is a plain object, that is, an object created by the
               * `Object` constructor or one with a `[[Prototype]]` of `null`.
               *
               * @static
               * @memberOf _
               * @since 0.8.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               * }
               *
               * _.isPlainObject(new Foo);
               * // => false
               *
               * _.isPlainObject([1, 2, 3]);
               * // => false
               *
               * _.isPlainObject({ 'x': 0, 'y': 0 });
               * // => true
               *
               * _.isPlainObject(Object.create(null));
               * // => true
               */
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                return typeof Ctor == 'function' && Ctor instanceof Ctor &&
                funcToString.call(Ctor) == objectCtorString;
              }

              /**
               * Checks if `value` is classified as a `RegExp` object.
               *
               * @static
               * @memberOf _
               * @since 0.1.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
               * @example
               *
               * _.isRegExp(/abc/);
               * // => true
               *
               * _.isRegExp('/abc/');
               * // => false
               */
              var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

              /**
               * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
               * double precision number which isn't the result of a rounded unsafe integer.
               *
               * **Note:** This method is based on
               * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
               * @example
               *
               * _.isSafeInteger(3);
               * // => true
               *
               * _.isSafeInteger(Number.MIN_VALUE);
               * // => false
               *
               * _.isSafeInteger(Infinity);
               * // => false
               *
               * _.isSafeInteger('3');
               * // => false
               */
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
              }

              /**
               * Checks if `value` is classified as a `Set` object.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a set, else `false`.
               * @example
               *
               * _.isSet(new Set);
               * // => true
               *
               * _.isSet(new WeakSet);
               * // => false
               */
              var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

              /**
               * Checks if `value` is classified as a `String` primitive or object.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a string, else `false`.
               * @example
               *
               * _.isString('abc');
               * // => true
               *
               * _.isString(1);
               * // => false
               */
              function isString(value) {
                return typeof value == 'string' ||
                !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
              }

              /**
               * Checks if `value` is classified as a `Symbol` primitive or object.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
               * @example
               *
               * _.isSymbol(Symbol.iterator);
               * // => true
               *
               * _.isSymbol('abc');
               * // => false
               */
              function isSymbol(value) {
                return typeof value == 'symbol' ||
                isObjectLike(value) && baseGetTag(value) == symbolTag;
              }

              /**
               * Checks if `value` is classified as a typed array.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
               * @example
               *
               * _.isTypedArray(new Uint8Array);
               * // => true
               *
               * _.isTypedArray([]);
               * // => false
               */
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

              /**
               * Checks if `value` is `undefined`.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
               * @example
               *
               * _.isUndefined(void 0);
               * // => true
               *
               * _.isUndefined(null);
               * // => false
               */
              function isUndefined(value) {
                return value === undefined;
              }

              /**
               * Checks if `value` is classified as a `WeakMap` object.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
               * @example
               *
               * _.isWeakMap(new WeakMap);
               * // => true
               *
               * _.isWeakMap(new Map);
               * // => false
               */
              function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
              }

              /**
               * Checks if `value` is classified as a `WeakSet` object.
               *
               * @static
               * @memberOf _
               * @since 4.3.0
               * @category Lang
               * @param {*} value The value to check.
               * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
               * @example
               *
               * _.isWeakSet(new WeakSet);
               * // => true
               *
               * _.isWeakSet(new Set);
               * // => false
               */
              function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
              }

              /**
               * Checks if `value` is less than `other`.
               *
               * @static
               * @memberOf _
               * @since 3.9.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is less than `other`,
               *  else `false`.
               * @see _.gt
               * @example
               *
               * _.lt(1, 3);
               * // => true
               *
               * _.lt(3, 3);
               * // => false
               *
               * _.lt(3, 1);
               * // => false
               */
              var lt = createRelationalOperation(baseLt);

              /**
               * Checks if `value` is less than or equal to `other`.
               *
               * @static
               * @memberOf _
               * @since 3.9.0
               * @category Lang
               * @param {*} value The value to compare.
               * @param {*} other The other value to compare.
               * @returns {boolean} Returns `true` if `value` is less than or equal to
               *  `other`, else `false`.
               * @see _.gte
               * @example
               *
               * _.lte(1, 3);
               * // => true
               *
               * _.lte(3, 3);
               * // => true
               *
               * _.lte(3, 1);
               * // => false
               */
              var lte = createRelationalOperation(function (value, other) {
                return value <= other;
              });

              /**
               * Converts `value` to an array.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {Array} Returns the converted array.
               * @example
               *
               * _.toArray({ 'a': 1, 'b': 2 });
               * // => [1, 2]
               *
               * _.toArray('abc');
               * // => ['a', 'b', 'c']
               *
               * _.toArray(1);
               * // => []
               *
               * _.toArray(null);
               * // => []
               */
              function toArray(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike(value)) {
                  return isString(value) ? stringToArray(value) : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value),
                func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;

                return func(value);
              }

              /**
               * Converts `value` to a finite number.
               *
               * @static
               * @memberOf _
               * @since 4.12.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {number} Returns the converted number.
               * @example
               *
               * _.toFinite(3.2);
               * // => 3.2
               *
               * _.toFinite(Number.MIN_VALUE);
               * // => 5e-324
               *
               * _.toFinite(Infinity);
               * // => 1.7976931348623157e+308
               *
               * _.toFinite('3.2');
               * // => 3.2
               */
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }

              /**
               * Converts `value` to an integer.
               *
               * **Note:** This method is loosely based on
               * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {number} Returns the converted integer.
               * @example
               *
               * _.toInteger(3.2);
               * // => 3
               *
               * _.toInteger(Number.MIN_VALUE);
               * // => 0
               *
               * _.toInteger(Infinity);
               * // => 1.7976931348623157e+308
               *
               * _.toInteger('3.2');
               * // => 3
               */
              function toInteger(value) {
                var result = toFinite(value),
                remainder = result % 1;

                return result === result ? remainder ? result - remainder : result : 0;
              }

              /**
               * Converts `value` to an integer suitable for use as the length of an
               * array-like object.
               *
               * **Note:** This method is based on
               * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {number} Returns the converted integer.
               * @example
               *
               * _.toLength(3.2);
               * // => 3
               *
               * _.toLength(Number.MIN_VALUE);
               * // => 0
               *
               * _.toLength(Infinity);
               * // => 4294967295
               *
               * _.toLength('3.2');
               * // => 3
               */
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }

              /**
               * Converts `value` to a number.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to process.
               * @returns {number} Returns the number.
               * @example
               *
               * _.toNumber(3.2);
               * // => 3.2
               *
               * _.toNumber(Number.MIN_VALUE);
               * // => 5e-324
               *
               * _.toNumber(Infinity);
               * // => Infinity
               *
               * _.toNumber('3.2');
               * // => 3.2
               */
              function toNumber(value) {
                if (typeof value == 'number') {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                  value = isObject(other) ? other + '' : other;
                }
                if (typeof value != 'string') {
                  return value === 0 ? value : +value;
                }
                value = value.replace(reTrim, '');
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ?
                freeParseInt(value.slice(2), isBinary ? 2 : 8) :
                reIsBadHex.test(value) ? NAN : +value;
              }

              /**
               * Converts `value` to a plain object flattening inherited enumerable string
               * keyed properties of `value` to own properties of the plain object.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {Object} Returns the converted plain object.
               * @example
               *
               * function Foo() {
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.assign({ 'a': 1 }, new Foo);
               * // => { 'a': 1, 'b': 2 }
               *
               * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
               * // => { 'a': 1, 'b': 2, 'c': 3 }
               */
              function toPlainObject(value) {
                return copyObject(value, keysIn(value));
              }

              /**
               * Converts `value` to a safe integer. A safe integer can be compared and
               * represented correctly.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {number} Returns the converted integer.
               * @example
               *
               * _.toSafeInteger(3.2);
               * // => 3
               *
               * _.toSafeInteger(Number.MIN_VALUE);
               * // => 0
               *
               * _.toSafeInteger(Infinity);
               * // => 9007199254740991
               *
               * _.toSafeInteger('3.2');
               * // => 3
               */
              function toSafeInteger(value) {
                return value ?
                baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) :
                value === 0 ? value : 0;
              }

              /**
               * Converts `value` to a string. An empty string is returned for `null`
               * and `undefined` values. The sign of `-0` is preserved.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Lang
               * @param {*} value The value to convert.
               * @returns {string} Returns the converted string.
               * @example
               *
               * _.toString(null);
               * // => ''
               *
               * _.toString(-0);
               * // => '-0'
               *
               * _.toString([1, 2, 3]);
               * // => '1,2,3'
               */
              function toString(value) {
                return value == null ? '' : baseToString(value);
              }

              /*------------------------------------------------------------------------*/

              /**
               * Assigns own enumerable string keyed properties of source objects to the
               * destination object. Source objects are applied from left to right.
               * Subsequent sources overwrite property assignments of previous sources.
               *
               * **Note:** This method mutates `object` and is loosely based on
               * [`Object.assign`](https://mdn.io/Object/assign).
               *
               * @static
               * @memberOf _
               * @since 0.10.0
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} [sources] The source objects.
               * @returns {Object} Returns `object`.
               * @see _.assignIn
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               * }
               *
               * function Bar() {
               *   this.c = 3;
               * }
               *
               * Foo.prototype.b = 2;
               * Bar.prototype.d = 4;
               *
               * _.assign({ 'a': 0 }, new Foo, new Bar);
               * // => { 'a': 1, 'c': 3 }
               */
              var assign = createAssigner(function (object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                  copyObject(source, keys(source), object);
                  return;
                }
                for (var key in source) {
                  if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                  }
                }
              });

              /**
               * This method is like `_.assign` except that it iterates over own and
               * inherited source properties.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @alias extend
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} [sources] The source objects.
               * @returns {Object} Returns `object`.
               * @see _.assign
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               * }
               *
               * function Bar() {
               *   this.c = 3;
               * }
               *
               * Foo.prototype.b = 2;
               * Bar.prototype.d = 4;
               *
               * _.assignIn({ 'a': 0 }, new Foo, new Bar);
               * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
               */
              var assignIn = createAssigner(function (object, source) {
                copyObject(source, keysIn(source), object);
              });

              /**
               * This method is like `_.assignIn` except that it accepts `customizer`
               * which is invoked to produce the assigned values. If `customizer` returns
               * `undefined`, assignment is handled by the method instead. The `customizer`
               * is invoked with five arguments: (objValue, srcValue, key, object, source).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @alias extendWith
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} sources The source objects.
               * @param {Function} [customizer] The function to customize assigned values.
               * @returns {Object} Returns `object`.
               * @see _.assignWith
               * @example
               *
               * function customizer(objValue, srcValue) {
               *   return _.isUndefined(objValue) ? srcValue : objValue;
               * }
               *
               * var defaults = _.partialRight(_.assignInWith, customizer);
               *
               * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
               * // => { 'a': 1, 'b': 2 }
               */
              var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                copyObject(source, keysIn(source), object, customizer);
              });

              /**
               * This method is like `_.assign` except that it accepts `customizer`
               * which is invoked to produce the assigned values. If `customizer` returns
               * `undefined`, assignment is handled by the method instead. The `customizer`
               * is invoked with five arguments: (objValue, srcValue, key, object, source).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} sources The source objects.
               * @param {Function} [customizer] The function to customize assigned values.
               * @returns {Object} Returns `object`.
               * @see _.assignInWith
               * @example
               *
               * function customizer(objValue, srcValue) {
               *   return _.isUndefined(objValue) ? srcValue : objValue;
               * }
               *
               * var defaults = _.partialRight(_.assignWith, customizer);
               *
               * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
               * // => { 'a': 1, 'b': 2 }
               */
              var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                copyObject(source, keys(source), object, customizer);
              });

              /**
               * Creates an array of values corresponding to `paths` of `object`.
               *
               * @static
               * @memberOf _
               * @since 1.0.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {...(string|string[])} [paths] The property paths to pick.
               * @returns {Array} Returns the picked values.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
               *
               * _.at(object, ['a[0].b.c', 'a[1]']);
               * // => [3, 4]
               */
              var at = flatRest(baseAt);

              /**
               * Creates an object that inherits from the `prototype` object. If a
               * `properties` object is given, its own enumerable string keyed properties
               * are assigned to the created object.
               *
               * @static
               * @memberOf _
               * @since 2.3.0
               * @category Object
               * @param {Object} prototype The object to inherit from.
               * @param {Object} [properties] The properties to assign to the object.
               * @returns {Object} Returns the new object.
               * @example
               *
               * function Shape() {
               *   this.x = 0;
               *   this.y = 0;
               * }
               *
               * function Circle() {
               *   Shape.call(this);
               * }
               *
               * Circle.prototype = _.create(Shape.prototype, {
               *   'constructor': Circle
               * });
               *
               * var circle = new Circle;
               * circle instanceof Circle;
               * // => true
               *
               * circle instanceof Shape;
               * // => true
               */
              function create(prototype, properties) {
                var result = baseCreate(prototype);
                return properties == null ? result : baseAssign(result, properties);
              }

              /**
               * Assigns own and inherited enumerable string keyed properties of source
               * objects to the destination object for all destination properties that
               * resolve to `undefined`. Source objects are applied from left to right.
               * Once a property is set, additional values of the same property are ignored.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} [sources] The source objects.
               * @returns {Object} Returns `object`.
               * @see _.defaultsDeep
               * @example
               *
               * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
               * // => { 'a': 1, 'b': 2 }
               */
              var defaults = baseRest(function (object, sources) {
                object = Object(object);

                var index = -1;
                var length = sources.length;
                var guard = length > 2 ? sources[2] : undefined;

                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                  length = 1;
                }

                while (++index < length) {
                  var source = sources[index];
                  var props = keysIn(source);
                  var propsIndex = -1;
                  var propsLength = props.length;

                  while (++propsIndex < propsLength) {
                    var key = props[propsIndex];
                    var value = object[key];

                    if (value === undefined ||
                    eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                      object[key] = source[key];
                    }
                  }
                }

                return object;
              });

              /**
               * This method is like `_.defaults` except that it recursively assigns
               * default properties.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 3.10.0
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} [sources] The source objects.
               * @returns {Object} Returns `object`.
               * @see _.defaults
               * @example
               *
               * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
               * // => { 'a': { 'b': 2, 'c': 3 } }
               */
              var defaultsDeep = baseRest(function (args) {
                args.push(undefined, customDefaultsMerge);
                return apply(mergeWith, undefined, args);
              });

              /**
               * This method is like `_.find` except that it returns the key of the first
               * element `predicate` returns truthy for instead of the element itself.
               *
               * @static
               * @memberOf _
               * @since 1.1.0
               * @category Object
               * @param {Object} object The object to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {string|undefined} Returns the key of the matched element,
               *  else `undefined`.
               * @example
               *
               * var users = {
               *   'barney':  { 'age': 36, 'active': true },
               *   'fred':    { 'age': 40, 'active': false },
               *   'pebbles': { 'age': 1,  'active': true }
               * };
               *
               * _.findKey(users, function(o) { return o.age < 40; });
               * // => 'barney' (iteration order is not guaranteed)
               *
               * // The `_.matches` iteratee shorthand.
               * _.findKey(users, { 'age': 1, 'active': true });
               * // => 'pebbles'
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.findKey(users, ['active', false]);
               * // => 'fred'
               *
               * // The `_.property` iteratee shorthand.
               * _.findKey(users, 'active');
               * // => 'barney'
               */
              function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
              }

              /**
               * This method is like `_.findKey` except that it iterates over elements of
               * a collection in the opposite order.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Object
               * @param {Object} object The object to inspect.
               * @param {Function} [predicate=_.identity] The function invoked per iteration.
               * @returns {string|undefined} Returns the key of the matched element,
               *  else `undefined`.
               * @example
               *
               * var users = {
               *   'barney':  { 'age': 36, 'active': true },
               *   'fred':    { 'age': 40, 'active': false },
               *   'pebbles': { 'age': 1,  'active': true }
               * };
               *
               * _.findLastKey(users, function(o) { return o.age < 40; });
               * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
               *
               * // The `_.matches` iteratee shorthand.
               * _.findLastKey(users, { 'age': 36, 'active': true });
               * // => 'barney'
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.findLastKey(users, ['active', false]);
               * // => 'fred'
               *
               * // The `_.property` iteratee shorthand.
               * _.findLastKey(users, 'active');
               * // => 'pebbles'
               */
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }

              /**
               * Iterates over own and inherited enumerable string keyed properties of an
               * object and invokes `iteratee` for each property. The iteratee is invoked
               * with three arguments: (value, key, object). Iteratee functions may exit
               * iteration early by explicitly returning `false`.
               *
               * @static
               * @memberOf _
               * @since 0.3.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns `object`.
               * @see _.forInRight
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.forIn(new Foo, function(value, key) {
               *   console.log(key);
               * });
               * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
               */
              function forIn(object, iteratee) {
                return object == null ?
                object :
                baseFor(object, getIteratee(iteratee, 3), keysIn);
              }

              /**
               * This method is like `_.forIn` except that it iterates over properties of
               * `object` in the opposite order.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns `object`.
               * @see _.forIn
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.forInRight(new Foo, function(value, key) {
               *   console.log(key);
               * });
               * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
               */
              function forInRight(object, iteratee) {
                return object == null ?
                object :
                baseForRight(object, getIteratee(iteratee, 3), keysIn);
              }

              /**
               * Iterates over own enumerable string keyed properties of an object and
               * invokes `iteratee` for each property. The iteratee is invoked with three
               * arguments: (value, key, object). Iteratee functions may exit iteration
               * early by explicitly returning `false`.
               *
               * @static
               * @memberOf _
               * @since 0.3.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns `object`.
               * @see _.forOwnRight
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.forOwn(new Foo, function(value, key) {
               *   console.log(key);
               * });
               * // => Logs 'a' then 'b' (iteration order is not guaranteed).
               */
              function forOwn(object, iteratee) {
                return object && baseForOwn(object, getIteratee(iteratee, 3));
              }

              /**
               * This method is like `_.forOwn` except that it iterates over properties of
               * `object` in the opposite order.
               *
               * @static
               * @memberOf _
               * @since 2.0.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns `object`.
               * @see _.forOwn
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.forOwnRight(new Foo, function(value, key) {
               *   console.log(key);
               * });
               * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
               */
              function forOwnRight(object, iteratee) {
                return object && baseForOwnRight(object, getIteratee(iteratee, 3));
              }

              /**
               * Creates an array of function property names from own enumerable properties
               * of `object`.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to inspect.
               * @returns {Array} Returns the function names.
               * @see _.functionsIn
               * @example
               *
               * function Foo() {
               *   this.a = _.constant('a');
               *   this.b = _.constant('b');
               * }
               *
               * Foo.prototype.c = _.constant('c');
               *
               * _.functions(new Foo);
               * // => ['a', 'b']
               */
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
              }

              /**
               * Creates an array of function property names from own and inherited
               * enumerable properties of `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The object to inspect.
               * @returns {Array} Returns the function names.
               * @see _.functions
               * @example
               *
               * function Foo() {
               *   this.a = _.constant('a');
               *   this.b = _.constant('b');
               * }
               *
               * Foo.prototype.c = _.constant('c');
               *
               * _.functionsIn(new Foo);
               * // => ['a', 'b', 'c']
               */
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
              }

              /**
               * Gets the value at `path` of `object`. If the resolved value is
               * `undefined`, the `defaultValue` is returned in its place.
               *
               * @static
               * @memberOf _
               * @since 3.7.0
               * @category Object
               * @param {Object} object The object to query.
               * @param {Array|string} path The path of the property to get.
               * @param {*} [defaultValue] The value returned for `undefined` resolved values.
               * @returns {*} Returns the resolved value.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 3 } }] };
               *
               * _.get(object, 'a[0].b.c');
               * // => 3
               *
               * _.get(object, ['a', '0', 'b', 'c']);
               * // => 3
               *
               * _.get(object, 'a.b.c', 'default');
               * // => 'default'
               */
              function get(object, path, defaultValue) {
                var result = object == null ? undefined : baseGet(object, path);
                return result === undefined ? defaultValue : result;
              }

              /**
               * Checks if `path` is a direct property of `object`.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to query.
               * @param {Array|string} path The path to check.
               * @returns {boolean} Returns `true` if `path` exists, else `false`.
               * @example
               *
               * var object = { 'a': { 'b': 2 } };
               * var other = _.create({ 'a': _.create({ 'b': 2 }) });
               *
               * _.has(object, 'a');
               * // => true
               *
               * _.has(object, 'a.b');
               * // => true
               *
               * _.has(object, ['a', 'b']);
               * // => true
               *
               * _.has(other, 'a');
               * // => false
               */
              function has(object, path) {
                return object != null && hasPath(object, path, baseHas);
              }

              /**
               * Checks if `path` is a direct or inherited property of `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The object to query.
               * @param {Array|string} path The path to check.
               * @returns {boolean} Returns `true` if `path` exists, else `false`.
               * @example
               *
               * var object = _.create({ 'a': _.create({ 'b': 2 }) });
               *
               * _.hasIn(object, 'a');
               * // => true
               *
               * _.hasIn(object, 'a.b');
               * // => true
               *
               * _.hasIn(object, ['a', 'b']);
               * // => true
               *
               * _.hasIn(object, 'b');
               * // => false
               */
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }

              /**
               * Creates an object composed of the inverted keys and values of `object`.
               * If `object` contains duplicate values, subsequent values overwrite
               * property assignments of previous values.
               *
               * @static
               * @memberOf _
               * @since 0.7.0
               * @category Object
               * @param {Object} object The object to invert.
               * @returns {Object} Returns the new inverted object.
               * @example
               *
               * var object = { 'a': 1, 'b': 2, 'c': 1 };
               *
               * _.invert(object);
               * // => { '1': 'c', '2': 'b' }
               */
              var invert = createInverter(function (result, value, key) {
                if (value != null &&
                typeof value.toString != 'function') {
                  value = nativeObjectToString.call(value);
                }

                result[value] = key;
              }, constant(identity));

              /**
               * This method is like `_.invert` except that the inverted object is generated
               * from the results of running each element of `object` thru `iteratee`. The
               * corresponding inverted value of each inverted key is an array of keys
               * responsible for generating the inverted value. The iteratee is invoked
               * with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.1.0
               * @category Object
               * @param {Object} object The object to invert.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {Object} Returns the new inverted object.
               * @example
               *
               * var object = { 'a': 1, 'b': 2, 'c': 1 };
               *
               * _.invertBy(object);
               * // => { '1': ['a', 'c'], '2': ['b'] }
               *
               * _.invertBy(object, function(value) {
               *   return 'group' + value;
               * });
               * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
               */
              var invertBy = createInverter(function (result, value, key) {
                if (value != null &&
                typeof value.toString != 'function') {
                  value = nativeObjectToString.call(value);
                }

                if (hasOwnProperty.call(result, value)) {
                  result[value].push(key);
                } else {
                  result[value] = [key];
                }
              }, getIteratee);

              /**
               * Invokes the method at `path` of `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The object to query.
               * @param {Array|string} path The path of the method to invoke.
               * @param {...*} [args] The arguments to invoke the method with.
               * @returns {*} Returns the result of the invoked method.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
               *
               * _.invoke(object, 'a[0].b.c.slice', 1, 3);
               * // => [2, 3]
               */
              var invoke = baseRest(baseInvoke);

              /**
               * Creates an array of the own enumerable property names of `object`.
               *
               * **Note:** Non-object values are coerced to objects. See the
               * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
               * for more details.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.keys(new Foo);
               * // => ['a', 'b'] (iteration order is not guaranteed)
               *
               * _.keys('hi');
               * // => ['0', '1']
               */
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }

              /**
               * Creates an array of the own and inherited enumerable property names of `object`.
               *
               * **Note:** Non-object values are coerced to objects.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property names.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.keysIn(new Foo);
               * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
               */
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }

              /**
               * The opposite of `_.mapValues`; this method creates an object with the
               * same values as `object` and keys generated by running each own enumerable
               * string keyed property of `object` thru `iteratee`. The iteratee is invoked
               * with three arguments: (value, key, object).
               *
               * @static
               * @memberOf _
               * @since 3.8.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns the new mapped object.
               * @see _.mapValues
               * @example
               *
               * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
               *   return key + value;
               * });
               * // => { 'a1': 1, 'b2': 2 }
               */
              function mapKeys(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);

                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, iteratee(value, key, object), value);
                });
                return result;
              }

              /**
               * Creates an object with the same keys as `object` and values generated
               * by running each own enumerable string keyed property of `object` thru
               * `iteratee`. The iteratee is invoked with three arguments:
               * (value, key, object).
               *
               * @static
               * @memberOf _
               * @since 2.4.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Object} Returns the new mapped object.
               * @see _.mapKeys
               * @example
               *
               * var users = {
               *   'fred':    { 'user': 'fred',    'age': 40 },
               *   'pebbles': { 'user': 'pebbles', 'age': 1 }
               * };
               *
               * _.mapValues(users, function(o) { return o.age; });
               * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
               *
               * // The `_.property` iteratee shorthand.
               * _.mapValues(users, 'age');
               * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
               */
              function mapValues(object, iteratee) {
                var result = {};
                iteratee = getIteratee(iteratee, 3);

                baseForOwn(object, function (value, key, object) {
                  baseAssignValue(result, key, iteratee(value, key, object));
                });
                return result;
              }

              /**
               * This method is like `_.assign` except that it recursively merges own and
               * inherited enumerable string keyed properties of source objects into the
               * destination object. Source properties that resolve to `undefined` are
               * skipped if a destination value exists. Array and plain object properties
               * are merged recursively. Other objects and value types are overridden by
               * assignment. Source objects are applied from left to right. Subsequent
               * sources overwrite property assignments of previous sources.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 0.5.0
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} [sources] The source objects.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var object = {
               *   'a': [{ 'b': 2 }, { 'd': 4 }]
               * };
               *
               * var other = {
               *   'a': [{ 'c': 3 }, { 'e': 5 }]
               * };
               *
               * _.merge(object, other);
               * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
               */
              var merge = createAssigner(function (object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
              });

              /**
               * This method is like `_.merge` except that it accepts `customizer` which
               * is invoked to produce the merged values of the destination and source
               * properties. If `customizer` returns `undefined`, merging is handled by the
               * method instead. The `customizer` is invoked with six arguments:
               * (objValue, srcValue, key, object, source, stack).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The destination object.
               * @param {...Object} sources The source objects.
               * @param {Function} customizer The function to customize assigned values.
               * @returns {Object} Returns `object`.
               * @example
               *
               * function customizer(objValue, srcValue) {
               *   if (_.isArray(objValue)) {
               *     return objValue.concat(srcValue);
               *   }
               * }
               *
               * var object = { 'a': [1], 'b': [2] };
               * var other = { 'a': [3], 'b': [4] };
               *
               * _.mergeWith(object, other, customizer);
               * // => { 'a': [1, 3], 'b': [2, 4] }
               */
              var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                baseMerge(object, source, srcIndex, customizer);
              });

              /**
               * The opposite of `_.pick`; this method creates an object composed of the
               * own and inherited enumerable property paths of `object` that are not omitted.
               *
               * **Note:** This method is considerably slower than `_.pick`.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The source object.
               * @param {...(string|string[])} [paths] The property paths to omit.
               * @returns {Object} Returns the new object.
               * @example
               *
               * var object = { 'a': 1, 'b': '2', 'c': 3 };
               *
               * _.omit(object, ['a', 'c']);
               * // => { 'b': '2' }
               */
              var omit = flatRest(function (object, paths) {
                var result = {};
                if (object == null) {
                  return result;
                }
                var isDeep = false;
                paths = arrayMap(paths, function (path) {
                  path = castPath(path, object);
                  isDeep || (isDeep = path.length > 1);
                  return path;
                });
                copyObject(object, getAllKeysIn(object), result);
                if (isDeep) {
                  result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                }
                var length = paths.length;
                while (length--) {
                  baseUnset(result, paths[length]);
                }
                return result;
              });

              /**
               * The opposite of `_.pickBy`; this method creates an object composed of
               * the own and inherited enumerable string keyed properties of `object` that
               * `predicate` doesn't return truthy for. The predicate is invoked with two
               * arguments: (value, key).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The source object.
               * @param {Function} [predicate=_.identity] The function invoked per property.
               * @returns {Object} Returns the new object.
               * @example
               *
               * var object = { 'a': 1, 'b': '2', 'c': 3 };
               *
               * _.omitBy(object, _.isNumber);
               * // => { 'b': '2' }
               */
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }

              /**
               * Creates an object composed of the picked `object` properties.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The source object.
               * @param {...(string|string[])} [paths] The property paths to pick.
               * @returns {Object} Returns the new object.
               * @example
               *
               * var object = { 'a': 1, 'b': '2', 'c': 3 };
               *
               * _.pick(object, ['a', 'c']);
               * // => { 'a': 1, 'c': 3 }
               */
              var pick = flatRest(function (object, paths) {
                return object == null ? {} : basePick(object, paths);
              });

              /**
               * Creates an object composed of the `object` properties `predicate` returns
               * truthy for. The predicate is invoked with two arguments: (value, key).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The source object.
               * @param {Function} [predicate=_.identity] The function invoked per property.
               * @returns {Object} Returns the new object.
               * @example
               *
               * var object = { 'a': 1, 'b': '2', 'c': 3 };
               *
               * _.pickBy(object, _.isNumber);
               * // => { 'a': 1, 'c': 3 }
               */
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap(getAllKeysIn(object), function (prop) {
                  return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function (value, path) {
                  return predicate(value, path[0]);
                });
              }

              /**
               * This method is like `_.get` except that if the resolved value is a
               * function it's invoked with the `this` binding of its parent object and
               * its result is returned.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to query.
               * @param {Array|string} path The path of the property to resolve.
               * @param {*} [defaultValue] The value returned for `undefined` resolved values.
               * @returns {*} Returns the resolved value.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
               *
               * _.result(object, 'a[0].b.c1');
               * // => 3
               *
               * _.result(object, 'a[0].b.c2');
               * // => 4
               *
               * _.result(object, 'a[0].b.c3', 'default');
               * // => 'default'
               *
               * _.result(object, 'a[0].b.c3', _.constant('default'));
               * // => 'default'
               */
              function result(object, path, defaultValue) {
                path = castPath(path, object);

                var index = -1,
                length = path.length;

                // Ensure the loop is entered when path is empty.
                if (!length) {
                  length = 1;
                  object = undefined;
                }
                while (++index < length) {
                  var value = object == null ? undefined : object[toKey(path[index])];
                  if (value === undefined) {
                    index = length;
                    value = defaultValue;
                  }
                  object = isFunction(value) ? value.call(object) : value;
                }
                return object;
              }

              /**
               * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
               * it's created. Arrays are created for missing index properties while objects
               * are created for all other missing properties. Use `_.setWith` to customize
               * `path` creation.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 3.7.0
               * @category Object
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to set.
               * @param {*} value The value to set.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 3 } }] };
               *
               * _.set(object, 'a[0].b.c', 4);
               * console.log(object.a[0].b.c);
               * // => 4
               *
               * _.set(object, ['x', '0', 'y', 'z'], 5);
               * console.log(object.x[0].y.z);
               * // => 5
               */
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }

              /**
               * This method is like `_.set` except that it accepts `customizer` which is
               * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
               * path creation is handled by the method instead. The `customizer` is invoked
               * with three arguments: (nsValue, key, nsObject).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to set.
               * @param {*} value The value to set.
               * @param {Function} [customizer] The function to customize assigned values.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var object = {};
               *
               * _.setWith(object, '[0][1]', 'a', Object);
               * // => { '0': { '1': 'a' } }
               */
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseSet(object, path, value, customizer);
              }

              /**
               * Creates an array of own enumerable string keyed-value pairs for `object`
               * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
               * entries are returned.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @alias entries
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the key-value pairs.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.toPairs(new Foo);
               * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
               */
              var toPairs = createToPairs(keys);

              /**
               * Creates an array of own and inherited enumerable string keyed-value pairs
               * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
               * or set, its entries are returned.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @alias entriesIn
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the key-value pairs.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.toPairsIn(new Foo);
               * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
               */
              var toPairsIn = createToPairs(keysIn);

              /**
               * An alternative to `_.reduce`; this method transforms `object` to a new
               * `accumulator` object which is the result of running each of its own
               * enumerable string keyed properties thru `iteratee`, with each invocation
               * potentially mutating the `accumulator` object. If `accumulator` is not
               * provided, a new object with the same `[[Prototype]]` will be used. The
               * iteratee is invoked with four arguments: (accumulator, value, key, object).
               * Iteratee functions may exit iteration early by explicitly returning `false`.
               *
               * @static
               * @memberOf _
               * @since 1.3.0
               * @category Object
               * @param {Object} object The object to iterate over.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @param {*} [accumulator] The custom accumulator value.
               * @returns {*} Returns the accumulated value.
               * @example
               *
               * _.transform([2, 3, 4], function(result, n) {
               *   result.push(n *= n);
               *   return n % 2 == 0;
               * }, []);
               * // => [4, 9]
               *
               * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
               *   (result[value] || (result[value] = [])).push(key);
               * }, {});
               * // => { '1': ['a', 'c'], '2': ['b'] }
               */
              function transform(object, iteratee, accumulator) {
                var isArr = isArray(object),
                isArrLike = isArr || isBuffer(object) || isTypedArray(object);

                iteratee = getIteratee(iteratee, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else
                  if (isObject(object)) {
                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                  } else
                  {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
                  return iteratee(accumulator, value, index, object);
                });
                return accumulator;
              }

              /**
               * Removes the property at `path` of `object`.
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Object
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to unset.
               * @returns {boolean} Returns `true` if the property is deleted, else `false`.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 7 } }] };
               * _.unset(object, 'a[0].b.c');
               * // => true
               *
               * console.log(object);
               * // => { 'a': [{ 'b': {} }] };
               *
               * _.unset(object, ['a', '0', 'b', 'c']);
               * // => true
               *
               * console.log(object);
               * // => { 'a': [{ 'b': {} }] };
               */
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }

              /**
               * This method is like `_.set` except that accepts `updater` to produce the
               * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
               * is invoked with one argument: (value).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.6.0
               * @category Object
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to set.
               * @param {Function} updater The function to produce the updated value.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var object = { 'a': [{ 'b': { 'c': 3 } }] };
               *
               * _.update(object, 'a[0].b.c', function(n) { return n * n; });
               * console.log(object.a[0].b.c);
               * // => 9
               *
               * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
               * console.log(object.x[0].y.z);
               * // => 0
               */
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
              }

              /**
               * This method is like `_.update` except that it accepts `customizer` which is
               * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
               * path creation is handled by the method instead. The `customizer` is invoked
               * with three arguments: (nsValue, key, nsObject).
               *
               * **Note:** This method mutates `object`.
               *
               * @static
               * @memberOf _
               * @since 4.6.0
               * @category Object
               * @param {Object} object The object to modify.
               * @param {Array|string} path The path of the property to set.
               * @param {Function} updater The function to produce the updated value.
               * @param {Function} [customizer] The function to customize assigned values.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var object = {};
               *
               * _.updateWith(object, '[0][1]', _.constant('a'), Object);
               * // => { '0': { '1': 'a' } }
               */
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == 'function' ? customizer : undefined;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
              }

              /**
               * Creates an array of the own enumerable string keyed property values of `object`.
               *
               * **Note:** Non-object values are coerced to objects.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property values.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.values(new Foo);
               * // => [1, 2] (iteration order is not guaranteed)
               *
               * _.values('hi');
               * // => ['h', 'i']
               */
              function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
              }

              /**
               * Creates an array of the own and inherited enumerable string keyed property
               * values of `object`.
               *
               * **Note:** Non-object values are coerced to objects.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Object
               * @param {Object} object The object to query.
               * @returns {Array} Returns the array of property values.
               * @example
               *
               * function Foo() {
               *   this.a = 1;
               *   this.b = 2;
               * }
               *
               * Foo.prototype.c = 3;
               *
               * _.valuesIn(new Foo);
               * // => [1, 2, 3] (iteration order is not guaranteed)
               */
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
              }

              /*------------------------------------------------------------------------*/

              /**
               * Clamps `number` within the inclusive `lower` and `upper` bounds.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Number
               * @param {number} number The number to clamp.
               * @param {number} [lower] The lower bound.
               * @param {number} upper The upper bound.
               * @returns {number} Returns the clamped number.
               * @example
               *
               * _.clamp(-10, -5, 5);
               * // => -5
               *
               * _.clamp(10, -5, 5);
               * // => 5
               */
              function clamp(number, lower, upper) {
                if (upper === undefined) {
                  upper = lower;
                  lower = undefined;
                }
                if (upper !== undefined) {
                  upper = toNumber(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined) {
                  lower = toNumber(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number), lower, upper);
              }

              /**
               * Checks if `n` is between `start` and up to, but not including, `end`. If
               * `end` is not specified, it's set to `start` with `start` then set to `0`.
               * If `start` is greater than `end` the params are swapped to support
               * negative ranges.
               *
               * @static
               * @memberOf _
               * @since 3.3.0
               * @category Number
               * @param {number} number The number to check.
               * @param {number} [start=0] The start of the range.
               * @param {number} end The end of the range.
               * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
               * @see _.range, _.rangeRight
               * @example
               *
               * _.inRange(3, 2, 4);
               * // => true
               *
               * _.inRange(4, 8);
               * // => true
               *
               * _.inRange(4, 2);
               * // => false
               *
               * _.inRange(2, 2);
               * // => false
               *
               * _.inRange(1.2, 2);
               * // => true
               *
               * _.inRange(5.2, 4);
               * // => false
               *
               * _.inRange(-3, -2, -6);
               * // => true
               */
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber(number);
                return baseInRange(number, start, end);
              }

              /**
               * Produces a random number between the inclusive `lower` and `upper` bounds.
               * If only one argument is provided a number between `0` and the given number
               * is returned. If `floating` is `true`, or either `lower` or `upper` are
               * floats, a floating-point number is returned instead of an integer.
               *
               * **Note:** JavaScript follows the IEEE-754 standard for resolving
               * floating-point values which can produce unexpected results.
               *
               * @static
               * @memberOf _
               * @since 0.7.0
               * @category Number
               * @param {number} [lower=0] The lower bound.
               * @param {number} [upper=1] The upper bound.
               * @param {boolean} [floating] Specify returning a floating-point number.
               * @returns {number} Returns the random number.
               * @example
               *
               * _.random(0, 5);
               * // => an integer between 0 and 5
               *
               * _.random(5);
               * // => also an integer between 0 and 5
               *
               * _.random(5, true);
               * // => a floating-point number between 0 and 5
               *
               * _.random(1.2, 5.2);
               * // => a floating-point number between 1.2 and 5.2
               */
              function random(lower, upper, floating) {
                if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                  upper = floating = undefined;
                }
                if (floating === undefined) {
                  if (typeof upper == 'boolean') {
                    floating = upper;
                    upper = undefined;
                  } else
                  if (typeof lower == 'boolean') {
                    floating = lower;
                    lower = undefined;
                  }
                }
                if (lower === undefined && upper === undefined) {
                  lower = 0;
                  upper = 1;
                } else
                {
                  lower = toFinite(lower);
                  if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }

              /*------------------------------------------------------------------------*/

              /**
               * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the camel cased string.
               * @example
               *
               * _.camelCase('Foo Bar');
               * // => 'fooBar'
               *
               * _.camelCase('--foo-bar--');
               * // => 'fooBar'
               *
               * _.camelCase('__FOO_BAR__');
               * // => 'fooBar'
               */
              var camelCase = createCompounder(function (result, word, index) {
                word = word.toLowerCase();
                return result + (index ? capitalize(word) : word);
              });

              /**
               * Converts the first character of `string` to upper case and the remaining
               * to lower case.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to capitalize.
               * @returns {string} Returns the capitalized string.
               * @example
               *
               * _.capitalize('FRED');
               * // => 'Fred'
               */
              function capitalize(string) {
                return upperFirst(toString(string).toLowerCase());
              }

              /**
               * Deburrs `string` by converting
               * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
               * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
               * letters to basic Latin letters and removing
               * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to deburr.
               * @returns {string} Returns the deburred string.
               * @example
               *
               * _.deburr('dj vu');
               * // => 'deja vu'
               */
              function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
              }

              /**
               * Checks if `string` ends with the given target string.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to inspect.
               * @param {string} [target] The string to search for.
               * @param {number} [position=string.length] The position to search up to.
               * @returns {boolean} Returns `true` if `string` ends with `target`,
               *  else `false`.
               * @example
               *
               * _.endsWith('abc', 'c');
               * // => true
               *
               * _.endsWith('abc', 'b');
               * // => false
               *
               * _.endsWith('abc', 'b', 2);
               * // => true
               */
              function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);

                var length = string.length;
                position = position === undefined ?
                length :
                baseClamp(toInteger(position), 0, length);

                var end = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end) == target;
              }

              /**
               * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
               * corresponding HTML entities.
               *
               * **Note:** No other characters are escaped. To escape additional
               * characters use a third-party library like [_he_](https://mths.be/he).
               *
               * Though the ">" character is escaped for symmetry, characters like
               * ">" and "/" don't need escaping in HTML and have no special meaning
               * unless they're part of a tag or unquoted attribute value. See
               * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
               * (under "semi-related fun fact") for more details.
               *
               * When working with HTML you should always
               * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
               * XSS vectors.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category String
               * @param {string} [string=''] The string to escape.
               * @returns {string} Returns the escaped string.
               * @example
               *
               * _.escape('fred, barney, & pebbles');
               * // => 'fred, barney, &amp; pebbles'
               */
              function escape(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ?
                string.replace(reUnescapedHtml, escapeHtmlChar) :
                string;
              }

              /**
               * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
               * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to escape.
               * @returns {string} Returns the escaped string.
               * @example
               *
               * _.escapeRegExp('[lodash](https://lodash.com/)');
               * // => '\[lodash\]\(https://lodash\.com/\)'
               */
              function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ?
                string.replace(reRegExpChar, '\\$&') :
                string;
              }

              /**
               * Converts `string` to
               * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the kebab cased string.
               * @example
               *
               * _.kebabCase('Foo Bar');
               * // => 'foo-bar'
               *
               * _.kebabCase('fooBar');
               * // => 'foo-bar'
               *
               * _.kebabCase('__FOO_BAR__');
               * // => 'foo-bar'
               */
              var kebabCase = createCompounder(function (result, word, index) {
                return result + (index ? '-' : '') + word.toLowerCase();
              });

              /**
               * Converts `string`, as space separated words, to lower case.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the lower cased string.
               * @example
               *
               * _.lowerCase('--Foo-Bar--');
               * // => 'foo bar'
               *
               * _.lowerCase('fooBar');
               * // => 'foo bar'
               *
               * _.lowerCase('__FOO_BAR__');
               * // => 'foo bar'
               */
              var lowerCase = createCompounder(function (result, word, index) {
                return result + (index ? ' ' : '') + word.toLowerCase();
              });

              /**
               * Converts the first character of `string` to lower case.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the converted string.
               * @example
               *
               * _.lowerFirst('Fred');
               * // => 'fred'
               *
               * _.lowerFirst('FRED');
               * // => 'fRED'
               */
              var lowerFirst = createCaseFirst('toLowerCase');

              /**
               * Pads `string` on the left and right sides if it's shorter than `length`.
               * Padding characters are truncated if they can't be evenly divided by `length`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to pad.
               * @param {number} [length=0] The padding length.
               * @param {string} [chars=' '] The string used as padding.
               * @returns {string} Returns the padded string.
               * @example
               *
               * _.pad('abc', 8);
               * // => '  abc   '
               *
               * _.pad('abc', 8, '_-');
               * // => '_-abc_-_'
               *
               * _.pad('abc', 3);
               * // => 'abc'
               */
              function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);

                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                  return string;
                }
                var mid = (length - strLength) / 2;
                return (
                  createPadding(nativeFloor(mid), chars) +
                  string +
                  createPadding(nativeCeil(mid), chars));

              }

              /**
               * Pads `string` on the right side if it's shorter than `length`. Padding
               * characters are truncated if they exceed `length`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to pad.
               * @param {number} [length=0] The padding length.
               * @param {string} [chars=' '] The string used as padding.
               * @returns {string} Returns the padded string.
               * @example
               *
               * _.padEnd('abc', 6);
               * // => 'abc   '
               *
               * _.padEnd('abc', 6, '_-');
               * // => 'abc_-_'
               *
               * _.padEnd('abc', 3);
               * // => 'abc'
               */
              function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);

                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ?
                string + createPadding(length - strLength, chars) :
                string;
              }

              /**
               * Pads `string` on the left side if it's shorter than `length`. Padding
               * characters are truncated if they exceed `length`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to pad.
               * @param {number} [length=0] The padding length.
               * @param {string} [chars=' '] The string used as padding.
               * @returns {string} Returns the padded string.
               * @example
               *
               * _.padStart('abc', 6);
               * // => '   abc'
               *
               * _.padStart('abc', 6, '_-');
               * // => '_-_abc'
               *
               * _.padStart('abc', 3);
               * // => 'abc'
               */
              function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);

                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ?
                createPadding(length - strLength, chars) + string :
                string;
              }

              /**
               * Converts `string` to an integer of the specified radix. If `radix` is
               * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
               * hexadecimal, in which case a `radix` of `16` is used.
               *
               * **Note:** This method aligns with the
               * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
               *
               * @static
               * @memberOf _
               * @since 1.1.0
               * @category String
               * @param {string} string The string to convert.
               * @param {number} [radix=10] The radix to interpret `value` by.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {number} Returns the converted integer.
               * @example
               *
               * _.parseInt('08');
               * // => 8
               *
               * _.map(['6', '08', '10'], _.parseInt);
               * // => [6, 8, 10]
               */
              function parseInt(string, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
              }

              /**
               * Repeats the given string `n` times.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to repeat.
               * @param {number} [n=1] The number of times to repeat the string.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {string} Returns the repeated string.
               * @example
               *
               * _.repeat('*', 3);
               * // => '***'
               *
               * _.repeat('abc', 2);
               * // => 'abcabc'
               *
               * _.repeat('abc', 0);
               * // => ''
               */
              function repeat(string, n, guard) {
                if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString(string), n);
              }

              /**
               * Replaces matches for `pattern` in `string` with `replacement`.
               *
               * **Note:** This method is based on
               * [`String#replace`](https://mdn.io/String/replace).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to modify.
               * @param {RegExp|string} pattern The pattern to replace.
               * @param {Function|string} replacement The match replacement.
               * @returns {string} Returns the modified string.
               * @example
               *
               * _.replace('Hi Fred', 'Fred', 'Barney');
               * // => 'Hi Barney'
               */
              function replace() {
                var args = arguments,
                string = toString(args[0]);

                return args.length < 3 ? string : string.replace(args[1], args[2]);
              }

              /**
               * Converts `string` to
               * [snake case](https://en.wikipedia.org/wiki/Snake_case).
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the snake cased string.
               * @example
               *
               * _.snakeCase('Foo Bar');
               * // => 'foo_bar'
               *
               * _.snakeCase('fooBar');
               * // => 'foo_bar'
               *
               * _.snakeCase('--FOO-BAR--');
               * // => 'foo_bar'
               */
              var snakeCase = createCompounder(function (result, word, index) {
                return result + (index ? '_' : '') + word.toLowerCase();
              });

              /**
               * Splits `string` by `separator`.
               *
               * **Note:** This method is based on
               * [`String#split`](https://mdn.io/String/split).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to split.
               * @param {RegExp|string} separator The separator pattern to split by.
               * @param {number} [limit] The length to truncate results to.
               * @returns {Array} Returns the string segments.
               * @example
               *
               * _.split('a-b-c', '-', 2);
               * // => ['a', 'b']
               */
              function split(string, separator, limit) {
                if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                  separator = limit = undefined;
                }
                limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string = toString(string);
                if (string && (
                typeof separator == 'string' ||
                separator != null && !isRegExp(separator)))
                {
                  separator = baseToString(separator);
                  if (!separator && hasUnicode(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                  }
                }
                return string.split(separator, limit);
              }

              /**
               * Converts `string` to
               * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
               *
               * @static
               * @memberOf _
               * @since 3.1.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the start cased string.
               * @example
               *
               * _.startCase('--foo-bar--');
               * // => 'Foo Bar'
               *
               * _.startCase('fooBar');
               * // => 'Foo Bar'
               *
               * _.startCase('__FOO_BAR__');
               * // => 'FOO BAR'
               */
              var startCase = createCompounder(function (result, word, index) {
                return result + (index ? ' ' : '') + upperFirst(word);
              });

              /**
               * Checks if `string` starts with the given target string.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to inspect.
               * @param {string} [target] The string to search for.
               * @param {number} [position=0] The position to search from.
               * @returns {boolean} Returns `true` if `string` starts with `target`,
               *  else `false`.
               * @example
               *
               * _.startsWith('abc', 'a');
               * // => true
               *
               * _.startsWith('abc', 'b');
               * // => false
               *
               * _.startsWith('abc', 'b', 1);
               * // => true
               */
              function startsWith(string, target, position) {
                string = toString(string);
                position = position == null ?
                0 :
                baseClamp(toInteger(position), 0, string.length);

                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
              }

              /**
               * Creates a compiled template function that can interpolate data properties
               * in "interpolate" delimiters, HTML-escape interpolated data properties in
               * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
               * properties may be accessed as free variables in the template. If a setting
               * object is given, it takes precedence over `_.templateSettings` values.
               *
               * **Note:** In the development build `_.template` utilizes
               * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
               * for easier debugging.
               *
               * For more information on precompiling templates see
               * [lodash's custom builds documentation](https://lodash.com/custom-builds).
               *
               * For more information on Chrome extension sandboxes see
               * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category String
               * @param {string} [string=''] The template string.
               * @param {Object} [options={}] The options object.
               * @param {RegExp} [options.escape=_.templateSettings.escape]
               *  The HTML "escape" delimiter.
               * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
               *  The "evaluate" delimiter.
               * @param {Object} [options.imports=_.templateSettings.imports]
               *  An object to import into the template as free variables.
               * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
               *  The "interpolate" delimiter.
               * @param {string} [options.sourceURL='lodash.templateSources[n]']
               *  The sourceURL of the compiled template.
               * @param {string} [options.variable='obj']
               *  The data object variable name.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Function} Returns the compiled template function.
               * @example
               *
               * // Use the "interpolate" delimiter to create a compiled template.
               * var compiled = _.template('hello <%= user %>!');
               * compiled({ 'user': 'fred' });
               * // => 'hello fred!'
               *
               * // Use the HTML "escape" delimiter to escape data property values.
               * var compiled = _.template('<b><%- value %></b>');
               * compiled({ 'value': '<script>' });
               * // => '<b>&lt;script&gt;</b>'
               *
               * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
               * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
               * compiled({ 'users': ['fred', 'barney'] });
               * // => '<li>fred</li><li>barney</li>'
               *
               * // Use the internal `print` function in "evaluate" delimiters.
               * var compiled = _.template('<% print("hello " + user); %>!');
               * compiled({ 'user': 'barney' });
               * // => 'hello barney!'
               *
               * // Use the ES template literal delimiter as an "interpolate" delimiter.
               * // Disable support by replacing the "interpolate" delimiter.
               * var compiled = _.template('hello ${ user }!');
               * compiled({ 'user': 'pebbles' });
               * // => 'hello pebbles!'
               *
               * // Use backslashes to treat delimiters as plain text.
               * var compiled = _.template('<%= "\\<%- value %\\>" %>');
               * compiled({ 'value': 'ignored' });
               * // => '<%- value %>'
               *
               * // Use the `imports` option to import `jQuery` as `jq`.
               * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
               * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
               * compiled({ 'users': ['fred', 'barney'] });
               * // => '<li>fred</li><li>barney</li>'
               *
               * // Use the `sourceURL` option to specify a custom sourceURL for the template.
               * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
               * compiled(data);
               * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
               *
               * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
               * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
               * compiled.source;
               * // => function(data) {
               * //   var __t, __p = '';
               * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
               * //   return __p;
               * // }
               *
               * // Use custom template delimiters.
               * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
               * var compiled = _.template('hello {{ user }}!');
               * compiled({ 'user': 'mustache' });
               * // => 'hello mustache!'
               *
               * // Use the `source` property to inline compiled templates for meaningful
               * // line numbers in error messages and stack traces.
               * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
               *   var JST = {\
               *     "main": ' + _.template(mainText).source + '\
               *   };\
               * ');
               */
              function template(string, options, guard) {
                // Based on John Resig's `tmpl` implementation
                // (http://ejohn.org/blog/javascript-micro-templating/)
                // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                var settings = lodash.templateSettings;

                if (guard && isIterateeCall(string, options, guard)) {
                  options = undefined;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);

                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                importsKeys = keys(imports),
                importsValues = baseValues(imports, importsKeys);

                var isEscaping,
                isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '";

                // Compile the regexp to match each delimiter.
                var reDelimiters = RegExp(
                (options.escape || reNoMatch).source + '|' +
                interpolate.source + '|' +
                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                (options.evaluate || reNoMatch).source + '|$',
                'g');

                // Use a sourceURL for easier debugging.
                // The sourceURL gets injected into the source that's eval-ed, so be careful
                // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
                // and escape the comment, thus injecting code that gets evaled.
                var sourceURL = '//# sourceURL=' + (
                hasOwnProperty.call(options, 'sourceURL') ?
                (options.sourceURL + '').replace(/\s/g, ' ') :
                'lodash.templateSources[' + ++templateCounter + ']') +
                '\n';

                string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);

                  // Escape characters that can't be included in string literals.
                  source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                  // Replace delimiters with snippets.
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                  }
                  index = offset + match.length;

                  // The JS engine embedded in Adobe products needs `match` returned in
                  // order to produce the correct `offset` value.
                  return match;
                });

                source += "';\n";

                // If `variable` is not specified wrap a with-statement around the generated
                // code to add the data object to the top of the scope chain.
                var variable = hasOwnProperty.call(options, 'variable') && options.variable;
                if (!variable) {
                  source = 'with (obj) {\n' + source + '\n}\n';
                }
                // Cleanup code by stripping empty strings.
                source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).
                replace(reEmptyStringMiddle, '$1').
                replace(reEmptyStringTrailing, '$1;');

                // Frame code as the function body.
                source = 'function(' + (variable || 'obj') + ') {\n' + (
                variable ?
                '' :
                'obj || (obj = {});\n') +

                "var __t, __p = ''" + (
                isEscaping ?
                ', __e = _.escape' :
                '') + (

                isEvaluating ?
                ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n" :
                ';\n') +

                source +
                'return __p\n}';

                var result = attempt(function () {
                  return Function(importsKeys, sourceURL + 'return ' + source).
                  apply(undefined, importsValues);
                });

                // Provide the compiled function's source by its `toString` method or
                // the `source` property as a convenience for inlining compiled templates.
                result.source = source;
                if (isError(result)) {
                  throw result;
                }
                return result;
              }

              /**
               * Converts `string`, as a whole, to lower case just like
               * [String#toLowerCase](https://mdn.io/toLowerCase).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the lower cased string.
               * @example
               *
               * _.toLower('--Foo-Bar--');
               * // => '--foo-bar--'
               *
               * _.toLower('fooBar');
               * // => 'foobar'
               *
               * _.toLower('__FOO_BAR__');
               * // => '__foo_bar__'
               */
              function toLower(value) {
                return toString(value).toLowerCase();
              }

              /**
               * Converts `string`, as a whole, to upper case just like
               * [String#toUpperCase](https://mdn.io/toUpperCase).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the upper cased string.
               * @example
               *
               * _.toUpper('--foo-bar--');
               * // => '--FOO-BAR--'
               *
               * _.toUpper('fooBar');
               * // => 'FOOBAR'
               *
               * _.toUpper('__foo_bar__');
               * // => '__FOO_BAR__'
               */
              function toUpper(value) {
                return toString(value).toUpperCase();
              }

              /**
               * Removes leading and trailing whitespace or specified characters from `string`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to trim.
               * @param {string} [chars=whitespace] The characters to trim.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {string} Returns the trimmed string.
               * @example
               *
               * _.trim('  abc  ');
               * // => 'abc'
               *
               * _.trim('-_-abc-_-', '_-');
               * // => 'abc'
               *
               * _.map(['  foo  ', '  bar  '], _.trim);
               * // => ['foo', 'bar']
               */
              function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrim, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                chrSymbols = stringToArray(chars),
                start = charsStartIndex(strSymbols, chrSymbols),
                end = charsEndIndex(strSymbols, chrSymbols) + 1;

                return castSlice(strSymbols, start, end).join('');
              }

              /**
               * Removes trailing whitespace or specified characters from `string`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to trim.
               * @param {string} [chars=whitespace] The characters to trim.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {string} Returns the trimmed string.
               * @example
               *
               * _.trimEnd('  abc  ');
               * // => '  abc'
               *
               * _.trimEnd('-_-abc-_-', '_-');
               * // => '-_-abc'
               */
              function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimEnd, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

                return castSlice(strSymbols, 0, end).join('');
              }

              /**
               * Removes leading whitespace or specified characters from `string`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to trim.
               * @param {string} [chars=whitespace] The characters to trim.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {string} Returns the trimmed string.
               * @example
               *
               * _.trimStart('  abc  ');
               * // => 'abc  '
               *
               * _.trimStart('-_-abc-_-', '_-');
               * // => 'abc-_-'
               */
              function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined)) {
                  return string.replace(reTrimStart, '');
                }
                if (!string || !(chars = baseToString(chars))) {
                  return string;
                }
                var strSymbols = stringToArray(string),
                start = charsStartIndex(strSymbols, stringToArray(chars));

                return castSlice(strSymbols, start).join('');
              }

              /**
               * Truncates `string` if it's longer than the given maximum string length.
               * The last characters of the truncated string are replaced with the omission
               * string which defaults to "...".
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to truncate.
               * @param {Object} [options={}] The options object.
               * @param {number} [options.length=30] The maximum string length.
               * @param {string} [options.omission='...'] The string to indicate text is omitted.
               * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
               * @returns {string} Returns the truncated string.
               * @example
               *
               * _.truncate('hi-diddly-ho there, neighborino');
               * // => 'hi-diddly-ho there, neighbo...'
               *
               * _.truncate('hi-diddly-ho there, neighborino', {
               *   'length': 24,
               *   'separator': ' '
               * });
               * // => 'hi-diddly-ho there,...'
               *
               * _.truncate('hi-diddly-ho there, neighborino', {
               *   'length': 24,
               *   'separator': /,? +/
               * });
               * // => 'hi-diddly-ho there...'
               *
               * _.truncate('hi-diddly-ho there, neighborino', {
               *   'omission': ' [...]'
               * });
               * // => 'hi-diddly-ho there, neig [...]'
               */
              function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH,
                omission = DEFAULT_TRUNC_OMISSION;

                if (isObject(options)) {
                  var separator = 'separator' in options ? options.separator : separator;
                  length = 'length' in options ? toInteger(options.length) : length;
                  omission = 'omission' in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);

                var strLength = string.length;
                if (hasUnicode(string)) {
                  var strSymbols = stringToArray(string);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result = strSymbols ?
                castSlice(strSymbols, 0, end).join('') :
                string.slice(0, end);

                if (separator === undefined) {
                  return result + omission;
                }
                if (strSymbols) {
                  end += result.length - end;
                }
                if (isRegExp(separator)) {
                  if (string.slice(end).search(separator)) {
                    var match,
                    substring = result;

                    if (!separator.global) {
                      separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                      var newEnd = match.index;
                    }
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                  }
                } else if (string.indexOf(baseToString(separator), end) != end) {
                  var index = result.lastIndexOf(separator);
                  if (index > -1) {
                    result = result.slice(0, index);
                  }
                }
                return result + omission;
              }

              /**
               * The inverse of `_.escape`; this method converts the HTML entities
               * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
               * their corresponding characters.
               *
               * **Note:** No other HTML entities are unescaped. To unescape additional
               * HTML entities use a third-party library like [_he_](https://mths.be/he).
               *
               * @static
               * @memberOf _
               * @since 0.6.0
               * @category String
               * @param {string} [string=''] The string to unescape.
               * @returns {string} Returns the unescaped string.
               * @example
               *
               * _.unescape('fred, barney, &amp; pebbles');
               * // => 'fred, barney, & pebbles'
               */
              function unescape(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ?
                string.replace(reEscapedHtml, unescapeHtmlChar) :
                string;
              }

              /**
               * Converts `string`, as space separated words, to upper case.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the upper cased string.
               * @example
               *
               * _.upperCase('--foo-bar');
               * // => 'FOO BAR'
               *
               * _.upperCase('fooBar');
               * // => 'FOO BAR'
               *
               * _.upperCase('__foo_bar__');
               * // => 'FOO BAR'
               */
              var upperCase = createCompounder(function (result, word, index) {
                return result + (index ? ' ' : '') + word.toUpperCase();
              });

              /**
               * Converts the first character of `string` to upper case.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category String
               * @param {string} [string=''] The string to convert.
               * @returns {string} Returns the converted string.
               * @example
               *
               * _.upperFirst('fred');
               * // => 'Fred'
               *
               * _.upperFirst('FRED');
               * // => 'FRED'
               */
              var upperFirst = createCaseFirst('toUpperCase');

              /**
               * Splits `string` into an array of its words.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category String
               * @param {string} [string=''] The string to inspect.
               * @param {RegExp|string} [pattern] The pattern to match words.
               * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
               * @returns {Array} Returns the words of `string`.
               * @example
               *
               * _.words('fred, barney, & pebbles');
               * // => ['fred', 'barney', 'pebbles']
               *
               * _.words('fred, barney, & pebbles', /[^, ]+/g);
               * // => ['fred', 'barney', '&', 'pebbles']
               */
              function words(string, pattern, guard) {
                string = toString(string);
                pattern = guard ? undefined : pattern;

                if (pattern === undefined) {
                  return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern) || [];
              }

              /*------------------------------------------------------------------------*/

              /**
               * Attempts to invoke `func`, returning either the result or the caught error
               * object. Any additional arguments are provided to `func` when it's invoked.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Util
               * @param {Function} func The function to attempt.
               * @param {...*} [args] The arguments to invoke `func` with.
               * @returns {*} Returns the `func` result or error object.
               * @example
               *
               * // Avoid throwing errors for invalid selectors.
               * var elements = _.attempt(function(selector) {
               *   return document.querySelectorAll(selector);
               * }, '>_>');
               *
               * if (_.isError(elements)) {
               *   elements = [];
               * }
               */
              var attempt = baseRest(function (func, args) {
                try {
                  return apply(func, undefined, args);
                } catch (e) {
                  return isError(e) ? e : new Error(e);
                }
              });

              /**
               * Binds methods of an object to the object itself, overwriting the existing
               * method.
               *
               * **Note:** This method doesn't set the "length" property of bound functions.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {Object} object The object to bind and assign the bound methods to.
               * @param {...(string|string[])} methodNames The object method names to bind.
               * @returns {Object} Returns `object`.
               * @example
               *
               * var view = {
               *   'label': 'docs',
               *   'click': function() {
               *     console.log('clicked ' + this.label);
               *   }
               * };
               *
               * _.bindAll(view, ['click']);
               * jQuery(element).on('click', view.click);
               * // => Logs 'clicked docs' when clicked.
               */
              var bindAll = flatRest(function (object, methodNames) {
                arrayEach(methodNames, function (key) {
                  key = toKey(key);
                  baseAssignValue(object, key, bind(object[key], object));
                });
                return object;
              });

              /**
               * Creates a function that iterates over `pairs` and invokes the corresponding
               * function of the first predicate to return truthy. The predicate-function
               * pairs are invoked with the `this` binding and arguments of the created
               * function.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {Array} pairs The predicate-function pairs.
               * @returns {Function} Returns the new composite function.
               * @example
               *
               * var func = _.cond([
               *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
               *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
               *   [_.stubTrue,                      _.constant('no match')]
               * ]);
               *
               * func({ 'a': 1, 'b': 2 });
               * // => 'matches A'
               *
               * func({ 'a': 0, 'b': 1 });
               * // => 'matches B'
               *
               * func({ 'a': '1', 'b': '2' });
               * // => 'no match'
               */
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length,
                toIteratee = getIteratee();

                pairs = !length ? [] : arrayMap(pairs, function (pair) {
                  if (typeof pair[1] != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  return [toIteratee(pair[0]), pair[1]];
                });

                return baseRest(function (args) {
                  var index = -1;
                  while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                      return apply(pair[1], this, args);
                    }
                  }
                });
              }

              /**
               * Creates a function that invokes the predicate properties of `source` with
               * the corresponding property values of a given object, returning `true` if
               * all predicates return truthy, else `false`.
               *
               * **Note:** The created function is equivalent to `_.conformsTo` with
               * `source` partially applied.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {Object} source The object of property predicates to conform to.
               * @returns {Function} Returns the new spec function.
               * @example
               *
               * var objects = [
               *   { 'a': 2, 'b': 1 },
               *   { 'a': 1, 'b': 2 }
               * ];
               *
               * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
               * // => [{ 'a': 1, 'b': 2 }]
               */
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }

              /**
               * Creates a function that returns `value`.
               *
               * @static
               * @memberOf _
               * @since 2.4.0
               * @category Util
               * @param {*} value The value to return from the new function.
               * @returns {Function} Returns the new constant function.
               * @example
               *
               * var objects = _.times(2, _.constant({ 'a': 1 }));
               *
               * console.log(objects);
               * // => [{ 'a': 1 }, { 'a': 1 }]
               *
               * console.log(objects[0] === objects[1]);
               * // => true
               */
              function constant(value) {
                return function () {
                  return value;
                };
              }

              /**
               * Checks `value` to determine whether a default value should be returned in
               * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
               * or `undefined`.
               *
               * @static
               * @memberOf _
               * @since 4.14.0
               * @category Util
               * @param {*} value The value to check.
               * @param {*} defaultValue The default value.
               * @returns {*} Returns the resolved value.
               * @example
               *
               * _.defaultTo(1, 10);
               * // => 1
               *
               * _.defaultTo(undefined, 10);
               * // => 10
               */
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }

              /**
               * Creates a function that returns the result of invoking the given functions
               * with the `this` binding of the created function, where each successive
               * invocation is supplied the return value of the previous.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Util
               * @param {...(Function|Function[])} [funcs] The functions to invoke.
               * @returns {Function} Returns the new composite function.
               * @see _.flowRight
               * @example
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * var addSquare = _.flow([_.add, square]);
               * addSquare(1, 2);
               * // => 9
               */
              var flow = createFlow();

              /**
               * This method is like `_.flow` except that it creates a function that
               * invokes the given functions from right to left.
               *
               * @static
               * @since 3.0.0
               * @memberOf _
               * @category Util
               * @param {...(Function|Function[])} [funcs] The functions to invoke.
               * @returns {Function} Returns the new composite function.
               * @see _.flow
               * @example
               *
               * function square(n) {
               *   return n * n;
               * }
               *
               * var addSquare = _.flowRight([square, _.add]);
               * addSquare(1, 2);
               * // => 9
               */
              var flowRight = createFlow(true);

              /**
               * This method returns the first argument it receives.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {*} value Any value.
               * @returns {*} Returns `value`.
               * @example
               *
               * var object = { 'a': 1 };
               *
               * console.log(_.identity(object) === object);
               * // => true
               */
              function identity(value) {
                return value;
              }

              /**
               * Creates a function that invokes `func` with the arguments of the created
               * function. If `func` is a property name, the created function returns the
               * property value for a given element. If `func` is an array or object, the
               * created function returns `true` for elements that contain the equivalent
               * source properties, otherwise it returns `false`.
               *
               * @static
               * @since 4.0.0
               * @memberOf _
               * @category Util
               * @param {*} [func=_.identity] The value to convert to a callback.
               * @returns {Function} Returns the callback.
               * @example
               *
               * var users = [
               *   { 'user': 'barney', 'age': 36, 'active': true },
               *   { 'user': 'fred',   'age': 40, 'active': false }
               * ];
               *
               * // The `_.matches` iteratee shorthand.
               * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
               * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
               *
               * // The `_.matchesProperty` iteratee shorthand.
               * _.filter(users, _.iteratee(['user', 'fred']));
               * // => [{ 'user': 'fred', 'age': 40 }]
               *
               * // The `_.property` iteratee shorthand.
               * _.map(users, _.iteratee('user'));
               * // => ['barney', 'fred']
               *
               * // Create custom iteratee shorthands.
               * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
               *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
               *     return func.test(string);
               *   };
               * });
               *
               * _.filter(['abc', 'def'], /ef/);
               * // => ['def']
               */
              function iteratee(func) {
                return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
              }

              /**
               * Creates a function that performs a partial deep comparison between a given
               * object and `source`, returning `true` if the given object has equivalent
               * property values, else `false`.
               *
               * **Note:** The created function is equivalent to `_.isMatch` with `source`
               * partially applied.
               *
               * Partial comparisons will match empty array and empty object `source`
               * values against any array or object value, respectively. See `_.isEqual`
               * for a list of supported value comparisons.
               *
               * **Note:** Multiple values can be checked by combining several matchers
               * using `_.overSome`
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Util
               * @param {Object} source The object of property values to match.
               * @returns {Function} Returns the new spec function.
               * @example
               *
               * var objects = [
               *   { 'a': 1, 'b': 2, 'c': 3 },
               *   { 'a': 4, 'b': 5, 'c': 6 }
               * ];
               *
               * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
               * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
               *
               * // Checking for several possible values
               * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
               * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
               */
              function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
              }

              /**
               * Creates a function that performs a partial deep comparison between the
               * value at `path` of a given object to `srcValue`, returning `true` if the
               * object value is equivalent, else `false`.
               *
               * **Note:** Partial comparisons will match empty array and empty object
               * `srcValue` values against any array or object value, respectively. See
               * `_.isEqual` for a list of supported value comparisons.
               *
               * **Note:** Multiple values can be checked by combining several matchers
               * using `_.overSome`
               *
               * @static
               * @memberOf _
               * @since 3.2.0
               * @category Util
               * @param {Array|string} path The path of the property to get.
               * @param {*} srcValue The value to match.
               * @returns {Function} Returns the new spec function.
               * @example
               *
               * var objects = [
               *   { 'a': 1, 'b': 2, 'c': 3 },
               *   { 'a': 4, 'b': 5, 'c': 6 }
               * ];
               *
               * _.find(objects, _.matchesProperty('a', 4));
               * // => { 'a': 4, 'b': 5, 'c': 6 }
               *
               * // Checking for several possible values
               * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
               * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
               */
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
              }

              /**
               * Creates a function that invokes the method at `path` of a given object.
               * Any additional arguments are provided to the invoked method.
               *
               * @static
               * @memberOf _
               * @since 3.7.0
               * @category Util
               * @param {Array|string} path The path of the method to invoke.
               * @param {...*} [args] The arguments to invoke the method with.
               * @returns {Function} Returns the new invoker function.
               * @example
               *
               * var objects = [
               *   { 'a': { 'b': _.constant(2) } },
               *   { 'a': { 'b': _.constant(1) } }
               * ];
               *
               * _.map(objects, _.method('a.b'));
               * // => [2, 1]
               *
               * _.map(objects, _.method(['a', 'b']));
               * // => [2, 1]
               */
              var method = baseRest(function (path, args) {
                return function (object) {
                  return baseInvoke(object, path, args);
                };
              });

              /**
               * The opposite of `_.method`; this method creates a function that invokes
               * the method at a given path of `object`. Any additional arguments are
               * provided to the invoked method.
               *
               * @static
               * @memberOf _
               * @since 3.7.0
               * @category Util
               * @param {Object} object The object to query.
               * @param {...*} [args] The arguments to invoke the method with.
               * @returns {Function} Returns the new invoker function.
               * @example
               *
               * var array = _.times(3, _.constant),
               *     object = { 'a': array, 'b': array, 'c': array };
               *
               * _.map(['a[2]', 'c[0]'], _.methodOf(object));
               * // => [2, 0]
               *
               * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
               * // => [2, 0]
               */
              var methodOf = baseRest(function (object, args) {
                return function (path) {
                  return baseInvoke(object, path, args);
                };
              });

              /**
               * Adds all own enumerable string keyed function properties of a source
               * object to the destination object. If `object` is a function, then methods
               * are added to its prototype as well.
               *
               * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
               * avoid conflicts caused by modifying the original.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {Function|Object} [object=lodash] The destination object.
               * @param {Object} source The object of functions to add.
               * @param {Object} [options={}] The options object.
               * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
               * @returns {Function|Object} Returns `object`.
               * @example
               *
               * function vowels(string) {
               *   return _.filter(string, function(v) {
               *     return /[aeiou]/i.test(v);
               *   });
               * }
               *
               * _.mixin({ 'vowels': vowels });
               * _.vowels('fred');
               * // => ['e']
               *
               * _('fred').vowels().value();
               * // => ['e']
               *
               * _.mixin({ 'vowels': vowels }, { 'chain': false });
               * _('fred').vowels();
               * // => ['e']
               */
              function mixin(object, source, options) {
                var props = keys(source),
                methodNames = baseFunctions(source, props);

                if (options == null &&
                !(isObject(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys(source));
                }
                var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                isFunc = isFunction(object);

                arrayEach(methodNames, function (methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function () {
                      var chainAll = this.__chain__;
                      if (chain || chainAll) {
                        var result = object(this.__wrapped__),
                        actions = result.__actions__ = copyArray(this.__actions__);

                        actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                        result.__chain__ = chainAll;
                        return result;
                      }
                      return func.apply(object, arrayPush([this.value()], arguments));
                    };
                  }
                });

                return object;
              }

              /**
               * Reverts the `_` variable to its previous value and returns a reference to
               * the `lodash` function.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @returns {Function} Returns the `lodash` function.
               * @example
               *
               * var lodash = _.noConflict();
               */
              function noConflict() {
                if (root._ === this) {
                  root._ = oldDash;
                }
                return this;
              }

              /**
               * This method returns `undefined`.
               *
               * @static
               * @memberOf _
               * @since 2.3.0
               * @category Util
               * @example
               *
               * _.times(2, _.noop);
               * // => [undefined, undefined]
               */
              function noop() {
                // No operation performed.
              }

              /**
               * Creates a function that gets the argument at index `n`. If `n` is negative,
               * the nth argument from the end is returned.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {number} [n=0] The index of the argument to return.
               * @returns {Function} Returns the new pass-thru function.
               * @example
               *
               * var func = _.nthArg(1);
               * func('a', 'b', 'c', 'd');
               * // => 'b'
               *
               * var func = _.nthArg(-2);
               * func('a', 'b', 'c', 'd');
               * // => 'c'
               */
              function nthArg(n) {
                n = toInteger(n);
                return baseRest(function (args) {
                  return baseNth(args, n);
                });
              }

              /**
               * Creates a function that invokes `iteratees` with the arguments it receives
               * and returns their results.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {...(Function|Function[])} [iteratees=[_.identity]]
               *  The iteratees to invoke.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var func = _.over([Math.max, Math.min]);
               *
               * func(1, 2, 3, 4);
               * // => [4, 1]
               */
              var over = createOver(arrayMap);

              /**
               * Creates a function that checks if **all** of the `predicates` return
               * truthy when invoked with the arguments it receives.
               *
               * Following shorthands are possible for providing predicates.
               * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
               * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {...(Function|Function[])} [predicates=[_.identity]]
               *  The predicates to check.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var func = _.overEvery([Boolean, isFinite]);
               *
               * func('1');
               * // => true
               *
               * func(null);
               * // => false
               *
               * func(NaN);
               * // => false
               */
              var overEvery = createOver(arrayEvery);

              /**
               * Creates a function that checks if **any** of the `predicates` return
               * truthy when invoked with the arguments it receives.
               *
               * Following shorthands are possible for providing predicates.
               * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
               * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {...(Function|Function[])} [predicates=[_.identity]]
               *  The predicates to check.
               * @returns {Function} Returns the new function.
               * @example
               *
               * var func = _.overSome([Boolean, isFinite]);
               *
               * func('1');
               * // => true
               *
               * func(null);
               * // => true
               *
               * func(NaN);
               * // => false
               *
               * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
               * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
               */
              var overSome = createOver(arraySome);

              /**
               * Creates a function that returns the value at `path` of a given object.
               *
               * @static
               * @memberOf _
               * @since 2.4.0
               * @category Util
               * @param {Array|string} path The path of the property to get.
               * @returns {Function} Returns the new accessor function.
               * @example
               *
               * var objects = [
               *   { 'a': { 'b': 2 } },
               *   { 'a': { 'b': 1 } }
               * ];
               *
               * _.map(objects, _.property('a.b'));
               * // => [2, 1]
               *
               * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
               * // => [1, 2]
               */
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }

              /**
               * The opposite of `_.property`; this method creates a function that returns
               * the value at a given path of `object`.
               *
               * @static
               * @memberOf _
               * @since 3.0.0
               * @category Util
               * @param {Object} object The object to query.
               * @returns {Function} Returns the new accessor function.
               * @example
               *
               * var array = [0, 1, 2],
               *     object = { 'a': array, 'b': array, 'c': array };
               *
               * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
               * // => [2, 0]
               *
               * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
               * // => [2, 0]
               */
              function propertyOf(object) {
                return function (path) {
                  return object == null ? undefined : baseGet(object, path);
                };
              }

              /**
               * Creates an array of numbers (positive and/or negative) progressing from
               * `start` up to, but not including, `end`. A step of `-1` is used if a negative
               * `start` is specified without an `end` or `step`. If `end` is not specified,
               * it's set to `start` with `start` then set to `0`.
               *
               * **Note:** JavaScript follows the IEEE-754 standard for resolving
               * floating-point values which can produce unexpected results.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {number} [start=0] The start of the range.
               * @param {number} end The end of the range.
               * @param {number} [step=1] The value to increment or decrement by.
               * @returns {Array} Returns the range of numbers.
               * @see _.inRange, _.rangeRight
               * @example
               *
               * _.range(4);
               * // => [0, 1, 2, 3]
               *
               * _.range(-4);
               * // => [0, -1, -2, -3]
               *
               * _.range(1, 5);
               * // => [1, 2, 3, 4]
               *
               * _.range(0, 20, 5);
               * // => [0, 5, 10, 15]
               *
               * _.range(0, -4, -1);
               * // => [0, -1, -2, -3]
               *
               * _.range(1, 4, 0);
               * // => [1, 1, 1]
               *
               * _.range(0);
               * // => []
               */
              var range = createRange();

              /**
               * This method is like `_.range` except that it populates values in
               * descending order.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {number} [start=0] The start of the range.
               * @param {number} end The end of the range.
               * @param {number} [step=1] The value to increment or decrement by.
               * @returns {Array} Returns the range of numbers.
               * @see _.inRange, _.range
               * @example
               *
               * _.rangeRight(4);
               * // => [3, 2, 1, 0]
               *
               * _.rangeRight(-4);
               * // => [-3, -2, -1, 0]
               *
               * _.rangeRight(1, 5);
               * // => [4, 3, 2, 1]
               *
               * _.rangeRight(0, 20, 5);
               * // => [15, 10, 5, 0]
               *
               * _.rangeRight(0, -4, -1);
               * // => [-3, -2, -1, 0]
               *
               * _.rangeRight(1, 4, 0);
               * // => [1, 1, 1]
               *
               * _.rangeRight(0);
               * // => []
               */
              var rangeRight = createRange(true);

              /**
               * This method returns a new empty array.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {Array} Returns the new empty array.
               * @example
               *
               * var arrays = _.times(2, _.stubArray);
               *
               * console.log(arrays);
               * // => [[], []]
               *
               * console.log(arrays[0] === arrays[1]);
               * // => false
               */
              function stubArray() {
                return [];
              }

              /**
               * This method returns `false`.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {boolean} Returns `false`.
               * @example
               *
               * _.times(2, _.stubFalse);
               * // => [false, false]
               */
              function stubFalse() {
                return false;
              }

              /**
               * This method returns a new empty object.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {Object} Returns the new empty object.
               * @example
               *
               * var objects = _.times(2, _.stubObject);
               *
               * console.log(objects);
               * // => [{}, {}]
               *
               * console.log(objects[0] === objects[1]);
               * // => false
               */
              function stubObject() {
                return {};
              }

              /**
               * This method returns an empty string.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {string} Returns the empty string.
               * @example
               *
               * _.times(2, _.stubString);
               * // => ['', '']
               */
              function stubString() {
                return '';
              }

              /**
               * This method returns `true`.
               *
               * @static
               * @memberOf _
               * @since 4.13.0
               * @category Util
               * @returns {boolean} Returns `true`.
               * @example
               *
               * _.times(2, _.stubTrue);
               * // => [true, true]
               */
              function stubTrue() {
                return true;
              }

              /**
               * Invokes the iteratee `n` times, returning an array of the results of
               * each invocation. The iteratee is invoked with one argument; (index).
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {number} n The number of times to invoke `iteratee`.
               * @param {Function} [iteratee=_.identity] The function invoked per iteration.
               * @returns {Array} Returns the array of results.
               * @example
               *
               * _.times(3, String);
               * // => ['0', '1', '2']
               *
               *  _.times(4, _.constant(0));
               * // => [0, 0, 0, 0]
               */
              function times(n, iteratee) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER) {
                  return [];
                }
                var index = MAX_ARRAY_LENGTH,
                length = nativeMin(n, MAX_ARRAY_LENGTH);

                iteratee = getIteratee(iteratee);
                n -= MAX_ARRAY_LENGTH;

                var result = baseTimes(length, iteratee);
                while (++index < n) {
                  iteratee(index);
                }
                return result;
              }

              /**
               * Converts `value` to a property path array.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Util
               * @param {*} value The value to convert.
               * @returns {Array} Returns the new property path array.
               * @example
               *
               * _.toPath('a.b.c');
               * // => ['a', 'b', 'c']
               *
               * _.toPath('a[0].b.c');
               * // => ['a', '0', 'b', 'c']
               */
              function toPath(value) {
                if (isArray(value)) {
                  return arrayMap(value, toKey);
                }
                return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
              }

              /**
               * Generates a unique ID. If `prefix` is given, the ID is appended to it.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Util
               * @param {string} [prefix=''] The value to prefix the ID with.
               * @returns {string} Returns the unique ID.
               * @example
               *
               * _.uniqueId('contact_');
               * // => 'contact_104'
               *
               * _.uniqueId();
               * // => '105'
               */
              function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
              }

              /*------------------------------------------------------------------------*/

              /**
               * Adds two numbers.
               *
               * @static
               * @memberOf _
               * @since 3.4.0
               * @category Math
               * @param {number} augend The first number in an addition.
               * @param {number} addend The second number in an addition.
               * @returns {number} Returns the total.
               * @example
               *
               * _.add(6, 4);
               * // => 10
               */
              var add = createMathOperation(function (augend, addend) {
                return augend + addend;
              }, 0);

              /**
               * Computes `number` rounded up to `precision`.
               *
               * @static
               * @memberOf _
               * @since 3.10.0
               * @category Math
               * @param {number} number The number to round up.
               * @param {number} [precision=0] The precision to round up to.
               * @returns {number} Returns the rounded up number.
               * @example
               *
               * _.ceil(4.006);
               * // => 5
               *
               * _.ceil(6.004, 2);
               * // => 6.01
               *
               * _.ceil(6040, -2);
               * // => 6100
               */
              var ceil = createRound('ceil');

              /**
               * Divide two numbers.
               *
               * @static
               * @memberOf _
               * @since 4.7.0
               * @category Math
               * @param {number} dividend The first number in a division.
               * @param {number} divisor The second number in a division.
               * @returns {number} Returns the quotient.
               * @example
               *
               * _.divide(6, 4);
               * // => 1.5
               */
              var divide = createMathOperation(function (dividend, divisor) {
                return dividend / divisor;
              }, 1);

              /**
               * Computes `number` rounded down to `precision`.
               *
               * @static
               * @memberOf _
               * @since 3.10.0
               * @category Math
               * @param {number} number The number to round down.
               * @param {number} [precision=0] The precision to round down to.
               * @returns {number} Returns the rounded down number.
               * @example
               *
               * _.floor(4.006);
               * // => 4
               *
               * _.floor(0.046, 2);
               * // => 0.04
               *
               * _.floor(4060, -2);
               * // => 4000
               */
              var floor = createRound('floor');

              /**
               * Computes the maximum value of `array`. If `array` is empty or falsey,
               * `undefined` is returned.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Math
               * @param {Array} array The array to iterate over.
               * @returns {*} Returns the maximum value.
               * @example
               *
               * _.max([4, 2, 8, 6]);
               * // => 8
               *
               * _.max([]);
               * // => undefined
               */
              function max(array) {
                return array && array.length ?
                baseExtremum(array, identity, baseGt) :
                undefined;
              }

              /**
               * This method is like `_.max` except that it accepts `iteratee` which is
               * invoked for each element in `array` to generate the criterion by which
               * the value is ranked. The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {*} Returns the maximum value.
               * @example
               *
               * var objects = [{ 'n': 1 }, { 'n': 2 }];
               *
               * _.maxBy(objects, function(o) { return o.n; });
               * // => { 'n': 2 }
               *
               * // The `_.property` iteratee shorthand.
               * _.maxBy(objects, 'n');
               * // => { 'n': 2 }
               */
              function maxBy(array, iteratee) {
                return array && array.length ?
                baseExtremum(array, getIteratee(iteratee, 2), baseGt) :
                undefined;
              }

              /**
               * Computes the mean of the values in `array`.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @returns {number} Returns the mean.
               * @example
               *
               * _.mean([4, 2, 8, 6]);
               * // => 5
               */
              function mean(array) {
                return baseMean(array, identity);
              }

              /**
               * This method is like `_.mean` except that it accepts `iteratee` which is
               * invoked for each element in `array` to generate the value to be averaged.
               * The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.7.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {number} Returns the mean.
               * @example
               *
               * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
               *
               * _.meanBy(objects, function(o) { return o.n; });
               * // => 5
               *
               * // The `_.property` iteratee shorthand.
               * _.meanBy(objects, 'n');
               * // => 5
               */
              function meanBy(array, iteratee) {
                return baseMean(array, getIteratee(iteratee, 2));
              }

              /**
               * Computes the minimum value of `array`. If `array` is empty or falsey,
               * `undefined` is returned.
               *
               * @static
               * @since 0.1.0
               * @memberOf _
               * @category Math
               * @param {Array} array The array to iterate over.
               * @returns {*} Returns the minimum value.
               * @example
               *
               * _.min([4, 2, 8, 6]);
               * // => 2
               *
               * _.min([]);
               * // => undefined
               */
              function min(array) {
                return array && array.length ?
                baseExtremum(array, identity, baseLt) :
                undefined;
              }

              /**
               * This method is like `_.min` except that it accepts `iteratee` which is
               * invoked for each element in `array` to generate the criterion by which
               * the value is ranked. The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {*} Returns the minimum value.
               * @example
               *
               * var objects = [{ 'n': 1 }, { 'n': 2 }];
               *
               * _.minBy(objects, function(o) { return o.n; });
               * // => { 'n': 1 }
               *
               * // The `_.property` iteratee shorthand.
               * _.minBy(objects, 'n');
               * // => { 'n': 1 }
               */
              function minBy(array, iteratee) {
                return array && array.length ?
                baseExtremum(array, getIteratee(iteratee, 2), baseLt) :
                undefined;
              }

              /**
               * Multiply two numbers.
               *
               * @static
               * @memberOf _
               * @since 4.7.0
               * @category Math
               * @param {number} multiplier The first number in a multiplication.
               * @param {number} multiplicand The second number in a multiplication.
               * @returns {number} Returns the product.
               * @example
               *
               * _.multiply(6, 4);
               * // => 24
               */
              var multiply = createMathOperation(function (multiplier, multiplicand) {
                return multiplier * multiplicand;
              }, 1);

              /**
               * Computes `number` rounded to `precision`.
               *
               * @static
               * @memberOf _
               * @since 3.10.0
               * @category Math
               * @param {number} number The number to round.
               * @param {number} [precision=0] The precision to round to.
               * @returns {number} Returns the rounded number.
               * @example
               *
               * _.round(4.006);
               * // => 4
               *
               * _.round(4.006, 2);
               * // => 4.01
               *
               * _.round(4060, -2);
               * // => 4100
               */
              var round = createRound('round');

              /**
               * Subtract two numbers.
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Math
               * @param {number} minuend The first number in a subtraction.
               * @param {number} subtrahend The second number in a subtraction.
               * @returns {number} Returns the difference.
               * @example
               *
               * _.subtract(6, 4);
               * // => 2
               */
              var subtract = createMathOperation(function (minuend, subtrahend) {
                return minuend - subtrahend;
              }, 0);

              /**
               * Computes the sum of the values in `array`.
               *
               * @static
               * @memberOf _
               * @since 3.4.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @returns {number} Returns the sum.
               * @example
               *
               * _.sum([4, 2, 8, 6]);
               * // => 20
               */
              function sum(array) {
                return array && array.length ?
                baseSum(array, identity) :
                0;
              }

              /**
               * This method is like `_.sum` except that it accepts `iteratee` which is
               * invoked for each element in `array` to generate the value to be summed.
               * The iteratee is invoked with one argument: (value).
               *
               * @static
               * @memberOf _
               * @since 4.0.0
               * @category Math
               * @param {Array} array The array to iterate over.
               * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
               * @returns {number} Returns the sum.
               * @example
               *
               * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
               *
               * _.sumBy(objects, function(o) { return o.n; });
               * // => 20
               *
               * // The `_.property` iteratee shorthand.
               * _.sumBy(objects, 'n');
               * // => 20
               */
              function sumBy(array, iteratee) {
                return array && array.length ?
                baseSum(array, getIteratee(iteratee, 2)) :
                0;
              }

              /*------------------------------------------------------------------------*/

              // Add methods that return wrapped values in chain sequences.
              lodash.after = after;
              lodash.ary = ary;
              lodash.assign = assign;
              lodash.assignIn = assignIn;
              lodash.assignInWith = assignInWith;
              lodash.assignWith = assignWith;
              lodash.at = at;
              lodash.before = before;
              lodash.bind = bind;
              lodash.bindAll = bindAll;
              lodash.bindKey = bindKey;
              lodash.castArray = castArray;
              lodash.chain = chain;
              lodash.chunk = chunk;
              lodash.compact = compact;
              lodash.concat = concat;
              lodash.cond = cond;
              lodash.conforms = conforms;
              lodash.constant = constant;
              lodash.countBy = countBy;
              lodash.create = create;
              lodash.curry = curry;
              lodash.curryRight = curryRight;
              lodash.debounce = debounce;
              lodash.defaults = defaults;
              lodash.defaultsDeep = defaultsDeep;
              lodash.defer = defer;
              lodash.delay = delay;
              lodash.difference = difference;
              lodash.differenceBy = differenceBy;
              lodash.differenceWith = differenceWith;
              lodash.drop = drop;
              lodash.dropRight = dropRight;
              lodash.dropRightWhile = dropRightWhile;
              lodash.dropWhile = dropWhile;
              lodash.fill = fill;
              lodash.filter = filter;
              lodash.flatMap = flatMap;
              lodash.flatMapDeep = flatMapDeep;
              lodash.flatMapDepth = flatMapDepth;
              lodash.flatten = flatten;
              lodash.flattenDeep = flattenDeep;
              lodash.flattenDepth = flattenDepth;
              lodash.flip = flip;
              lodash.flow = flow;
              lodash.flowRight = flowRight;
              lodash.fromPairs = fromPairs;
              lodash.functions = functions;
              lodash.functionsIn = functionsIn;
              lodash.groupBy = groupBy;
              lodash.initial = initial;
              lodash.intersection = intersection;
              lodash.intersectionBy = intersectionBy;
              lodash.intersectionWith = intersectionWith;
              lodash.invert = invert;
              lodash.invertBy = invertBy;
              lodash.invokeMap = invokeMap;
              lodash.iteratee = iteratee;
              lodash.keyBy = keyBy;
              lodash.keys = keys;
              lodash.keysIn = keysIn;
              lodash.map = map;
              lodash.mapKeys = mapKeys;
              lodash.mapValues = mapValues;
              lodash.matches = matches;
              lodash.matchesProperty = matchesProperty;
              lodash.memoize = memoize;
              lodash.merge = merge;
              lodash.mergeWith = mergeWith;
              lodash.method = method;
              lodash.methodOf = methodOf;
              lodash.mixin = mixin;
              lodash.negate = negate;
              lodash.nthArg = nthArg;
              lodash.omit = omit;
              lodash.omitBy = omitBy;
              lodash.once = once;
              lodash.orderBy = orderBy;
              lodash.over = over;
              lodash.overArgs = overArgs;
              lodash.overEvery = overEvery;
              lodash.overSome = overSome;
              lodash.partial = partial;
              lodash.partialRight = partialRight;
              lodash.partition = partition;
              lodash.pick = pick;
              lodash.pickBy = pickBy;
              lodash.property = property;
              lodash.propertyOf = propertyOf;
              lodash.pull = pull;
              lodash.pullAll = pullAll;
              lodash.pullAllBy = pullAllBy;
              lodash.pullAllWith = pullAllWith;
              lodash.pullAt = pullAt;
              lodash.range = range;
              lodash.rangeRight = rangeRight;
              lodash.rearg = rearg;
              lodash.reject = reject;
              lodash.remove = remove;
              lodash.rest = rest;
              lodash.reverse = reverse;
              lodash.sampleSize = sampleSize;
              lodash.set = set;
              lodash.setWith = setWith;
              lodash.shuffle = shuffle;
              lodash.slice = slice;
              lodash.sortBy = sortBy;
              lodash.sortedUniq = sortedUniq;
              lodash.sortedUniqBy = sortedUniqBy;
              lodash.split = split;
              lodash.spread = spread;
              lodash.tail = tail;
              lodash.take = take;
              lodash.takeRight = takeRight;
              lodash.takeRightWhile = takeRightWhile;
              lodash.takeWhile = takeWhile;
              lodash.tap = tap;
              lodash.throttle = throttle;
              lodash.thru = thru;
              lodash.toArray = toArray;
              lodash.toPairs = toPairs;
              lodash.toPairsIn = toPairsIn;
              lodash.toPath = toPath;
              lodash.toPlainObject = toPlainObject;
              lodash.transform = transform;
              lodash.unary = unary;
              lodash.union = union;
              lodash.unionBy = unionBy;
              lodash.unionWith = unionWith;
              lodash.uniq = uniq;
              lodash.uniqBy = uniqBy;
              lodash.uniqWith = uniqWith;
              lodash.unset = unset;
              lodash.unzip = unzip;
              lodash.unzipWith = unzipWith;
              lodash.update = update;
              lodash.updateWith = updateWith;
              lodash.values = values;
              lodash.valuesIn = valuesIn;
              lodash.without = without;
              lodash.words = words;
              lodash.wrap = wrap;
              lodash.xor = xor;
              lodash.xorBy = xorBy;
              lodash.xorWith = xorWith;
              lodash.zip = zip;
              lodash.zipObject = zipObject;
              lodash.zipObjectDeep = zipObjectDeep;
              lodash.zipWith = zipWith;

              // Add aliases.
              lodash.entries = toPairs;
              lodash.entriesIn = toPairsIn;
              lodash.extend = assignIn;
              lodash.extendWith = assignInWith;

              // Add methods to `lodash.prototype`.
              mixin(lodash, lodash);

              /*------------------------------------------------------------------------*/

              // Add methods that return unwrapped values in chain sequences.
              lodash.add = add;
              lodash.attempt = attempt;
              lodash.camelCase = camelCase;
              lodash.capitalize = capitalize;
              lodash.ceil = ceil;
              lodash.clamp = clamp;
              lodash.clone = clone;
              lodash.cloneDeep = cloneDeep;
              lodash.cloneDeepWith = cloneDeepWith;
              lodash.cloneWith = cloneWith;
              lodash.conformsTo = conformsTo;
              lodash.deburr = deburr;
              lodash.defaultTo = defaultTo;
              lodash.divide = divide;
              lodash.endsWith = endsWith;
              lodash.eq = eq;
              lodash.escape = escape;
              lodash.escapeRegExp = escapeRegExp;
              lodash.every = every;
              lodash.find = find;
              lodash.findIndex = findIndex;
              lodash.findKey = findKey;
              lodash.findLast = findLast;
              lodash.findLastIndex = findLastIndex;
              lodash.findLastKey = findLastKey;
              lodash.floor = floor;
              lodash.forEach = forEach;
              lodash.forEachRight = forEachRight;
              lodash.forIn = forIn;
              lodash.forInRight = forInRight;
              lodash.forOwn = forOwn;
              lodash.forOwnRight = forOwnRight;
              lodash.get = get;
              lodash.gt = gt;
              lodash.gte = gte;
              lodash.has = has;
              lodash.hasIn = hasIn;
              lodash.head = head;
              lodash.identity = identity;
              lodash.includes = includes;
              lodash.indexOf = indexOf;
              lodash.inRange = inRange;
              lodash.invoke = invoke;
              lodash.isArguments = isArguments;
              lodash.isArray = isArray;
              lodash.isArrayBuffer = isArrayBuffer;
              lodash.isArrayLike = isArrayLike;
              lodash.isArrayLikeObject = isArrayLikeObject;
              lodash.isBoolean = isBoolean;
              lodash.isBuffer = isBuffer;
              lodash.isDate = isDate;
              lodash.isElement = isElement;
              lodash.isEmpty = isEmpty;
              lodash.isEqual = isEqual;
              lodash.isEqualWith = isEqualWith;
              lodash.isError = isError;
              lodash.isFinite = isFinite;
              lodash.isFunction = isFunction;
              lodash.isInteger = isInteger;
              lodash.isLength = isLength;
              lodash.isMap = isMap;
              lodash.isMatch = isMatch;
              lodash.isMatchWith = isMatchWith;
              lodash.isNaN = isNaN;
              lodash.isNative = isNative;
              lodash.isNil = isNil;
              lodash.isNull = isNull;
              lodash.isNumber = isNumber;
              lodash.isObject = isObject;
              lodash.isObjectLike = isObjectLike;
              lodash.isPlainObject = isPlainObject;
              lodash.isRegExp = isRegExp;
              lodash.isSafeInteger = isSafeInteger;
              lodash.isSet = isSet;
              lodash.isString = isString;
              lodash.isSymbol = isSymbol;
              lodash.isTypedArray = isTypedArray;
              lodash.isUndefined = isUndefined;
              lodash.isWeakMap = isWeakMap;
              lodash.isWeakSet = isWeakSet;
              lodash.join = join;
              lodash.kebabCase = kebabCase;
              lodash.last = last;
              lodash.lastIndexOf = lastIndexOf;
              lodash.lowerCase = lowerCase;
              lodash.lowerFirst = lowerFirst;
              lodash.lt = lt;
              lodash.lte = lte;
              lodash.max = max;
              lodash.maxBy = maxBy;
              lodash.mean = mean;
              lodash.meanBy = meanBy;
              lodash.min = min;
              lodash.minBy = minBy;
              lodash.stubArray = stubArray;
              lodash.stubFalse = stubFalse;
              lodash.stubObject = stubObject;
              lodash.stubString = stubString;
              lodash.stubTrue = stubTrue;
              lodash.multiply = multiply;
              lodash.nth = nth;
              lodash.noConflict = noConflict;
              lodash.noop = noop;
              lodash.now = now;
              lodash.pad = pad;
              lodash.padEnd = padEnd;
              lodash.padStart = padStart;
              lodash.parseInt = parseInt;
              lodash.random = random;
              lodash.reduce = reduce;
              lodash.reduceRight = reduceRight;
              lodash.repeat = repeat;
              lodash.replace = replace;
              lodash.result = result;
              lodash.round = round;
              lodash.runInContext = runInContext;
              lodash.sample = sample;
              lodash.size = size;
              lodash.snakeCase = snakeCase;
              lodash.some = some;
              lodash.sortedIndex = sortedIndex;
              lodash.sortedIndexBy = sortedIndexBy;
              lodash.sortedIndexOf = sortedIndexOf;
              lodash.sortedLastIndex = sortedLastIndex;
              lodash.sortedLastIndexBy = sortedLastIndexBy;
              lodash.sortedLastIndexOf = sortedLastIndexOf;
              lodash.startCase = startCase;
              lodash.startsWith = startsWith;
              lodash.subtract = subtract;
              lodash.sum = sum;
              lodash.sumBy = sumBy;
              lodash.template = template;
              lodash.times = times;
              lodash.toFinite = toFinite;
              lodash.toInteger = toInteger;
              lodash.toLength = toLength;
              lodash.toLower = toLower;
              lodash.toNumber = toNumber;
              lodash.toSafeInteger = toSafeInteger;
              lodash.toString = toString;
              lodash.toUpper = toUpper;
              lodash.trim = trim;
              lodash.trimEnd = trimEnd;
              lodash.trimStart = trimStart;
              lodash.truncate = truncate;
              lodash.unescape = unescape;
              lodash.uniqueId = uniqueId;
              lodash.upperCase = upperCase;
              lodash.upperFirst = upperFirst;

              // Add aliases.
              lodash.each = forEach;
              lodash.eachRight = forEachRight;
              lodash.first = head;

              mixin(lodash, function () {
                var source = {};
                baseForOwn(lodash, function (func, methodName) {
                  if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              }(), { 'chain': false });

              /*------------------------------------------------------------------------*/

              /**
               * The semantic version number.
               *
               * @static
               * @memberOf _
               * @type {string}
               */
              lodash.VERSION = VERSION;

              // Assign default placeholders.
              arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
                lodash[methodName].placeholder = lodash;
              });

              // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
              arrayEach(['drop', 'take'], function (methodName, index) {
                LazyWrapper.prototype[methodName] = function (n) {
                  n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

                  var result = this.__filtered__ && !index ?
                  new LazyWrapper(this) :
                  this.clone();

                  if (result.__filtered__) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                  } else {
                    result.__views__.push({
                      'size': nativeMin(n, MAX_ARRAY_LENGTH),
                      'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });

                  }
                  return result;
                };

                LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });

              // Add `LazyWrapper` methods that accept an `iteratee` value.
              arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
                var type = index + 1,
                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

                LazyWrapper.prototype[methodName] = function (iteratee) {
                  var result = this.clone();
                  result.__iteratees__.push({
                    'iteratee': getIteratee(iteratee, 3),
                    'type': type });

                  result.__filtered__ = result.__filtered__ || isFilter;
                  return result;
                };
              });

              // Add `LazyWrapper` methods for `_.head` and `_.last`.
              arrayEach(['head', 'last'], function (methodName, index) {
                var takeName = 'take' + (index ? 'Right' : '');

                LazyWrapper.prototype[methodName] = function () {
                  return this[takeName](1).value()[0];
                };
              });

              // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
              arrayEach(['initial', 'tail'], function (methodName, index) {
                var dropName = 'drop' + (index ? '' : 'Right');

                LazyWrapper.prototype[methodName] = function () {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });

              LazyWrapper.prototype.compact = function () {
                return this.filter(identity);
              };

              LazyWrapper.prototype.find = function (predicate) {
                return this.filter(predicate).head();
              };

              LazyWrapper.prototype.findLast = function (predicate) {
                return this.reverse().find(predicate);
              };

              LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                if (typeof path == 'function') {
                  return new LazyWrapper(this);
                }
                return this.map(function (value) {
                  return baseInvoke(value, path, args);
                });
              });

              LazyWrapper.prototype.reject = function (predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };

              LazyWrapper.prototype.slice = function (start, end) {
                start = toInteger(start);

                var result = this;
                if (result.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result);
                }
                if (start < 0) {
                  result = result.takeRight(-start);
                } else if (start) {
                  result = result.drop(start);
                }
                if (end !== undefined) {
                  end = toInteger(end);
                  result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                }
                return result;
              };

              LazyWrapper.prototype.takeRightWhile = function (predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };

              LazyWrapper.prototype.toArray = function () {
                return this.take(MAX_ARRAY_LENGTH);
              };

              // Add `LazyWrapper` methods to `lodash.prototype`.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                isTaker = /^(?:head|last)$/.test(methodName),
                lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
                retUnwrapped = isTaker || /^find/.test(methodName);

                if (!lodashFunc) {
                  return;
                }
                lodash.prototype[methodName] = function () {
                  var value = this.__wrapped__,
                  args = isTaker ? [1] : arguments,
                  isLazy = value instanceof LazyWrapper,
                  iteratee = args[0],
                  useLazy = isLazy || isArray(value);

                  var interceptor = function (value) {
                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                    return isTaker && chainAll ? result[0] : result;
                  };

                  if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__,
                  isHybrid = !!this.__actions__.length,
                  isUnwrapped = retUnwrapped && !chainAll,
                  onlyLazy = isLazy && !isHybrid;

                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
                    return new LodashWrapper(result, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
                };
              });

              // Add `Array` methods to `lodash.prototype`.
              arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
                var func = arrayProto[methodName],
                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                retUnwrapped = /^(?:pop|shift)$/.test(methodName);

                lodash.prototype[methodName] = function () {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                  }
                  return this[chainName](function (value) {
                    return func.apply(isArray(value) ? value : [], args);
                  });
                };
              });

              // Map minified method names to their real names.
              baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                var lodashFunc = lodash[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + '';
                  if (!hasOwnProperty.call(realNames, key)) {
                    realNames[key] = [];
                  }
                  realNames[key].push({ 'name': methodName, 'func': lodashFunc });
                }
              });

              realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                'name': 'wrapper',
                'func': undefined }];


              // Add methods to `LazyWrapper`.
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;

              // Add chain sequence methods to the `lodash` wrapper.
              lodash.prototype.at = wrapperAt;
              lodash.prototype.chain = wrapperChain;
              lodash.prototype.commit = wrapperCommit;
              lodash.prototype.next = wrapperNext;
              lodash.prototype.plant = wrapperPlant;
              lodash.prototype.reverse = wrapperReverse;
              lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

              // Add lazy aliases.
              lodash.prototype.first = lodash.prototype.head;

              if (symIterator) {
                lodash.prototype[symIterator] = wrapperToIterator;
              }
              return lodash;
            };

            /*--------------------------------------------------------------------------*/

            // Export lodash.
            var _ = runInContext();

            // Some AMD build optimizers, like r.js, check for condition patterns like:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
              // Expose Lodash on the global object to prevent errors when Lodash is
              // loaded by a script tag in the presence of an AMD loader.
              // See http://requirejs.org/docs/errors.html#mismatch for more details.
              // Use `_.noConflict` to remove Lodash from the global object.
              root._ = _;

              // Define as an anonymous module so, through path mapping, it can be
              // referenced as the "underscore" module.
              define(function () {
                return _;
              });
            }
            // Check for `exports` after `define` in case a build optimizer adds it.
            else if (freeModule) {
                // Export for Node.js.
                (freeModule.exports = _)._ = _;
                // Export for CommonJS support.
                freeExports._ = _;
              } else
              {
                // Export to the global object.
                root._ = _;
              }
          }).call(this);

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 69: [function (require, module, exports) {
      var MapCache = require('./_MapCache');

      /** Error message constants. */
      var FUNC_ERROR_TEXT = 'Expected a function';

      /**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */
      function memoize(func, resolver) {
        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function () {
          var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }

      // Expose `MapCache`.
      memoize.Cache = MapCache;

      module.exports = memoize;

    }, { "./_MapCache": 21 }], 70: [function (require, module, exports) {
      var baseToString = require('./_baseToString');

      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */
      function toString(value) {
        return value == null ? '' : baseToString(value);
      }

      module.exports = toString;

    }, { "./_baseToString": 28 }], 71: [function (require, module, exports) {
      module.exports = [
      "abs",
      "and",
      "annotation",
      "annotation-xml",
      "apply",
      "approx",
      "arccos",
      "arccosh",
      "arccot",
      "arccoth",
      "arccsc",
      "arccsch",
      "arcsec",
      "arcsech",
      "arcsin",
      "arcsinh",
      "arctan",
      "arctanh",
      "arg",
      "bind",
      "bvar",
      "card",
      "cartesianproduct",
      "cbytes",
      "ceiling",
      "cerror",
      "ci",
      "cn",
      "codomain",
      "complexes",
      "compose",
      "condition",
      "conjugate",
      "cos",
      "cosh",
      "cot",
      "coth",
      "cs",
      "csc",
      "csch",
      "csymbol",
      "curl",
      "declare",
      "degree",
      "determinant",
      "diff",
      "divergence",
      "divide",
      "domain",
      "domainofapplication",
      "emptyset",
      "encoding",
      "eq",
      "equivalent",
      "eulergamma",
      "exists",
      "exp",
      "exponentiale",
      "factorial",
      "factorof",
      "false",
      "floor",
      "fn",
      "forall",
      "function",
      "gcd",
      "geq",
      "grad",
      "gt",
      "ident",
      "image",
      "imaginary",
      "imaginaryi",
      "implies",
      "in",
      "infinity",
      "int",
      "integers",
      "intersect",
      "interval",
      "inverse",
      "lambda",
      "laplacian",
      "lcm",
      "leq",
      "limit",
      "list",
      "ln",
      "log",
      "logbase",
      "lowlimit",
      "lt",
      "maction",
      "malign",
      "maligngroup",
      "malignmark",
      "malignscope",
      "math",
      "matrix",
      "matrixrow",
      "max",
      "mean",
      "median",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mfraction",
      "mglyph",
      "mi",
      "min",
      "minus",
      "mlabeledtr",
      "mlongdiv",
      "mmultiscripts",
      "mn",
      "mo",
      "mode",
      "moment",
      "momentabout",
      "mover",
      "mpadded",
      "mphantom",
      "mprescripts",
      "mroot",
      "mrow",
      "ms",
      "mscarries",
      "mscarry",
      "msgroup",
      "msline",
      "mspace",
      "msqrt",
      "msrow",
      "mstack",
      "mstyle",
      "msub",
      "msubsup",
      "msup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover",
      "naturalnumbers",
      "neq",
      "none",
      "not",
      "notanumber",
      "notin",
      "notprsubset",
      "notsubset",
      "or",
      "otherwise",
      "outerproduct",
      "partialdiff",
      "pi",
      "piece",
      "piecewice",
      "piecewise",
      "plus",
      "power",
      "primes",
      "product",
      "prsubset",
      "quotient",
      "rationals",
      "real",
      "reals",
      "reln",
      "rem",
      "root",
      "scalarproduct",
      "sdev",
      "sec",
      "sech",
      "select",
      "selector",
      "semantics",
      "sep",
      "set",
      "setdiff",
      "share",
      "sin",
      "sinh",
      "span",
      "subset",
      "sum",
      "tan",
      "tanh",
      "tendsto",
      "times",
      "transpose",
      "true",
      "union",
      "uplimit",
      "var",
      "variance",
      "vector",
      "vectorproduct",
      "xor"];


    }, {}], 72: [function (require, module, exports) {
      /* normalize-selector v0.1.0 (c) 2014 Kyle Simpson */

      (function UMD(name, context, definition) {
        if (typeof module !== "undefined" && module.exports) {module.exports = definition();} else
        if (typeof define === "function" && define.amd) {define(definition);} else
        {context[name] = definition(name, context);}
      })("normalizeSelector", this, function DEF(name, context) {
        "use strict";

        function normalizeSelector(sel) {

          // save unmatched text, if any
          function saveUnmatched() {
            if (unmatched) {
              // whitespace needed after combinator?
              if (tokens.length > 0 &&
              /^[~+>]$/.test(tokens[tokens.length - 1]))
              {
                tokens.push(" ");
              }

              // save unmatched text
              tokens.push(unmatched);
            }
          }

          var tokens = [],match,unmatched,regex,state = [0],
          next_match_idx = 0,prev_match_idx,
          not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/,
          whitespace_pattern = /^\s+$/,
          attribute_nonspecial_pattern = /[^\s=~!^|$*\[\]\(\)]{2}/,
          state_patterns = [
          /\s+|\/\*|["'>~+\[\(]/g, // general
          /\s+|\/\*|["'\[\]\(\)]/g, // [..] set
          /\s+|\/\*|["'\[\]\(\)]/g, // (..) set
          null, // string literal (placeholder)
          /\*\//g // comment
          ];


          sel = sel.trim();

          while (true) {
            unmatched = "";

            regex = state_patterns[state[state.length - 1]];

            regex.lastIndex = next_match_idx;
            match = regex.exec(sel);

            // matched text to process?
            if (match) {
              prev_match_idx = next_match_idx;
              next_match_idx = regex.lastIndex;

              // collect the previous string chunk not matched before this token
              if (prev_match_idx < next_match_idx - match[0].length) {
                unmatched = sel.substring(prev_match_idx, next_match_idx - match[0].length);
              }

              // need to force a space (possibly skipped
              // previously by the parser)?
              if (
              state[state.length - 1] === 1 &&
              attribute_nonspecial_pattern.test(
              tokens[tokens.length - 1].substr(-1) +
              unmatched.charAt(0)))

              {
                tokens.push(" ");
              }

              // general, [ ] pair, ( ) pair?
              if (state[state.length - 1] < 3) {
                saveUnmatched();

                // starting a [ ] pair?
                if (match[0] === "[") {
                  state.push(1);
                }
                // starting a ( ) pair?
                else if (match[0] === "(") {
                    state.push(2);
                  }
                  // starting a string literal?
                  else if (/^["']$/.test(match[0])) {
                      state.push(3);
                      state_patterns[3] = new RegExp(match[0], "g");
                    }
                    // starting a comment?
                    else if (match[0] === "/*") {
                        state.push(4);
                      }
                      // ending a [ ] or ( ) pair?
                      else if (/^[\]\)]$/.test(match[0]) && state.length > 0) {
                          state.pop();
                        }
                        // handling whitespace or a combinator?
                        else if (/^(?:\s+|[~+>])$/.test(match[0])) {
                            // need to insert whitespace before?
                            if (tokens.length > 0 &&
                            !whitespace_pattern.test(tokens[tokens.length - 1]) &&
                            state[state.length - 1] === 0)
                            {
                              // add normalized whitespace
                              tokens.push(" ");
                            }

                            // whitespace token we can skip?
                            if (whitespace_pattern.test(match[0])) {
                              continue;
                            }
                          }

                // save matched text
                tokens.push(match[0]);
              }
              // otherwise, string literal or comment
              else {
                  // save unmatched text
                  tokens[tokens.length - 1] += unmatched;

                  // unescaped terminator to string literal or comment?
                  if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
                    // comment terminator?
                    if (state[state.length - 1] === 4) {
                      // ok to drop comment?
                      if (tokens.length < 2 ||
                      whitespace_pattern.test(tokens[tokens.length - 2]))
                      {
                        tokens.pop();
                      }
                      // otherwise, turn comment into whitespace
                      else {
                          tokens[tokens.length - 1] = " ";
                        }

                      // handled already
                      match[0] = "";
                    }

                    state.pop();
                  }

                  // append matched text to existing token
                  tokens[tokens.length - 1] += match[0];
                }
            }
            // otherwise, end of processing (no more matches)
            else {
                unmatched = sel.substr(next_match_idx);
                saveUnmatched();

                break;
              }
          }

          return tokens.join("").trim();
        }

        return normalizeSelector;
      });


    }, {}], 73: [function (require, module, exports) {
      exports.endianness = function () {return 'LE';};

      exports.hostname = function () {
        if (typeof location !== 'undefined') {
          return location.hostname;
        } else
        return '';
      };

      exports.loadavg = function () {return [];};

      exports.uptime = function () {return 0;};

      exports.freemem = function () {
        return Number.MAX_VALUE;
      };

      exports.totalmem = function () {
        return Number.MAX_VALUE;
      };

      exports.cpus = function () {return [];};

      exports.type = function () {return 'Browser';};

      exports.release = function () {
        if (typeof navigator !== 'undefined') {
          return navigator.appVersion;
        }
        return '';
      };

      exports.networkInterfaces =
      exports.getNetworkInterfaces =
      function () {return {};};

      exports.arch = function () {return 'javascript';};

      exports.platform = function () {return 'browser';};

      exports.tmpdir = exports.tmpDir = function () {
        return '/tmp';
      };

      exports.EOL = '\n';

      exports.homedir = function () {
        return '/';
      };

    }, {}], 74: [function (require, module, exports) {
      (function (process) {(function () {
          // 'path' module extracted from Node.js v8.11.1 (only the posix part)
          // transplited with Babel

          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict';

          function assertPath(path) {
            if (typeof path !== 'string') {
              throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
            }
          }

          // Resolves . and .. elements in a path with directory names
          function normalizeStringPosix(path, allowAboveRoot) {
            var res = '';
            var lastSegmentLength = 0;
            var lastSlash = -1;
            var dots = 0;
            var code;
            for (var i = 0; i <= path.length; ++i) {
              if (i < path.length)
              code = path.charCodeAt(i);else
              if (code === 47 /*/*/)
                break;else

              code = 47 /*/*/;
              if (code === 47 /*/*/) {
                  if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                  } else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                        if (res.length > 2) {
                          var lastSlashIndex = res.lastIndexOf('/');
                          if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                              res = '';
                              lastSegmentLength = 0;
                            } else {
                              res = res.slice(0, lastSlashIndex);
                              lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                          }
                        } else if (res.length === 2 || res.length === 1) {
                          res = '';
                          lastSegmentLength = 0;
                          lastSlash = i;
                          dots = 0;
                          continue;
                        }
                      }
                    if (allowAboveRoot) {
                      if (res.length > 0)
                      res += '/..';else

                      res = '..';
                      lastSegmentLength = 2;
                    }
                  } else {
                    if (res.length > 0)
                    res += '/' + path.slice(lastSlash + 1, i);else

                    res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                  }
                  lastSlash = i;
                  dots = 0;
                } else if (code === 46 /*.*/ && dots !== -1) {
                ++dots;
              } else {
                dots = -1;
              }
            }
            return res;
          }

          function _format(sep, pathObject) {
            var dir = pathObject.dir || pathObject.root;
            var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
            if (!dir) {
              return base;
            }
            if (dir === pathObject.root) {
              return dir + base;
            }
            return dir + sep + base;
          }

          var posix = {
            // path.resolve([from ...], to)
            resolve: function resolve() {
              var resolvedPath = '';
              var resolvedAbsolute = false;
              var cwd;

              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0)
                path = arguments[i];else
                {
                  if (cwd === undefined)
                  cwd = process.cwd();
                  path = cwd;
                }

                assertPath(path);

                // Skip empty entries
                if (path.length === 0) {
                  continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

              if (resolvedAbsolute) {
                if (resolvedPath.length > 0)
                return '/' + resolvedPath;else

                return '/';
              } else if (resolvedPath.length > 0) {
                return resolvedPath;
              } else {
                return '.';
              }
            },

            normalize: function normalize(path) {
              assertPath(path);

              if (path.length === 0) return '.';

              var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
              var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

              // Normalize the path
              path = normalizeStringPosix(path, !isAbsolute);

              if (path.length === 0 && !isAbsolute) path = '.';
              if (path.length > 0 && trailingSeparator) path += '/';

              if (isAbsolute) return '/' + path;
              return path;
            },

            isAbsolute: function isAbsolute(path) {
              assertPath(path);
              return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
            },

            join: function join() {
              if (arguments.length === 0)
              return '.';
              var joined;
              for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg);
                if (arg.length > 0) {
                  if (joined === undefined)
                  joined = arg;else

                  joined += '/' + arg;
                }
              }
              if (joined === undefined)
              return '.';
              return posix.normalize(joined);
            },

            relative: function relative(from, to) {
              assertPath(from);
              assertPath(to);

              if (from === to) return '';

              from = posix.resolve(from);
              to = posix.resolve(to);

              if (from === to) return '';

              // Trim any leading backslashes
              var fromStart = 1;
              for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== 47 /*/*/)
                  break;
              }
              var fromEnd = from.length;
              var fromLen = fromEnd - fromStart;

              // Trim any leading backslashes
              var toStart = 1;
              for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== 47 /*/*/)
                  break;
              }
              var toEnd = to.length;
              var toLen = toEnd - toStart;

              // Compare paths to find the longest common path from root
              var length = fromLen < toLen ? fromLen : toLen;
              var lastCommonSep = -1;
              var i = 0;
              for (; i <= length; ++i) {
                if (i === length) {
                  if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                      } else if (i === 0) {
                      // We get here if `from` is the root
                      // For example: from='/'; to='/foo'
                      return to.slice(toStart + i);
                    }
                  } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                      } else if (i === 0) {
                      // We get here if `to` is the root.
                      // For example: from='/foo'; to='/'
                      lastCommonSep = 0;
                    }
                  }
                  break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode)
                break;else
                if (fromCode === 47 /*/*/)
                  lastCommonSep = i;
              }

              var out = '';
              // Generate the relative path based on the path difference between `to`
              // and `from`
              for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                    if (out.length === 0)
                    out += '..';else

                    out += '/..';
                  }
              }

              // Lastly, append the rest of the destination (`to`) path that comes after
              // the common path parts
              if (out.length > 0)
              return out + to.slice(toStart + lastCommonSep);else
              {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === 47 /*/*/)
                  ++toStart;
                return to.slice(toStart);
              }
            },

            _makeLong: function _makeLong(path) {
              return path;
            },

            dirname: function dirname(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var code = path.charCodeAt(0);
              var hasRoot = code === 47 /*/*/;
              var end = -1;
              var matchedSlash = true;
              for (var i = path.length - 1; i >= 1; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    if (!matchedSlash) {
                      end = i;
                      break;
                    }
                  } else {
                  // We saw the first non-path separator
                  matchedSlash = false;
                }
              }

              if (end === -1) return hasRoot ? '/' : '.';
              if (hasRoot && end === 1) return '//';
              return path.slice(0, end);
            },

            basename: function basename(path, ext) {
              if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
              assertPath(path);

              var start = 0;
              var end = -1;
              var matchedSlash = true;
              var i;

              if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else {
                    if (firstNonSlashEnd === -1) {
                      // We saw the first non-path separator, remember this index in case
                      // we need it if the extension ends up not matching
                      matchedSlash = false;
                      firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                      // Try to match the explicit extension
                      if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                          // We matched the extension, so mark this as the end of our path
                          // component
                          end = i;
                        }
                      } else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                      }
                    }
                  }
                }

                if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
                return path.slice(start, end);
              } else {
                for (i = path.length - 1; i >= 0; --i) {
                  if (path.charCodeAt(i) === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                  }
                }

                if (end === -1) return '';
                return path.slice(start, end);
              }
            },

            extname: function extname(path) {
              assertPath(path);
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;
              for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                    startDot = i;else
                    if (preDotState !== 1)
                    preDotState = 1;
                  } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }

              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                return '';
              }
              return path.slice(startDot, end);
            },

            format: function format(pathObject) {
              if (pathObject === null || typeof pathObject !== 'object') {
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
              }
              return _format('/', pathObject);
            },

            parse: function parse(path) {
              assertPath(path);

              var ret = { root: '', dir: '', base: '', ext: '', name: '' };
              if (path.length === 0) return ret;
              var code = path.charCodeAt(0);
              var isAbsolute = code === 47 /*/*/;
              var start;
              if (isAbsolute) {
                ret.root = '/';
                start = 1;
              } else {
                start = 0;
              }
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              var i = path.length - 1;

              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;

              // Get non-dir info
              for (; i >= start; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                  } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }

              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                if (end !== -1) {
                  if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
                }
              } else {
                if (startPart === 0 && isAbsolute) {
                  ret.name = path.slice(1, startDot);
                  ret.base = path.slice(1, end);
                } else {
                  ret.name = path.slice(startPart, startDot);
                  ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
              }

              if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

              return ret;
            },

            sep: '/',
            delimiter: ':',
            win32: null,
            posix: null };


          posix.posix = posix;

          module.exports = posix;

        }).call(this);}).call(this, require('_process'));
    }, { "_process": 160 }], 75: [function (require, module, exports) {
      /* eslint no-param-reassign: off */

      const Comment = require('postcss/lib/comment');
      const Parser = require('postcss/lib/parser');

      const { isInlineComment } = require('./nodes/inline-comment');
      const { interpolation } = require('./nodes/interpolation');
      const { isMixinToken } = require('./nodes/mixin');
      const importNode = require('./nodes/import');
      const variableNode = require('./nodes/variable');

      const importantPattern = /(!\s*important)$/i;

      module.exports = class LessParser extends Parser {
        constructor(...args) {
          super(...args);

          this.lastNode = null;
        }

        atrule(token) {
          if (interpolation.bind(this)(token)) {
            return;
          }

          super.atrule(token);
          importNode(this.lastNode);
          variableNode(this.lastNode);
        }

        decl(...args) {
          super.decl(...args);

          // #123: add `extend` decorator to nodes
          const extendPattern = /extend\(.+\)/i;

          if (extendPattern.test(this.lastNode.value)) {
            this.lastNode.extend = true;
          }
        }

        each(tokens) {
          // prepend a space so the `name` will be parsed correctly
          tokens[0][1] = ` ${tokens[0][1]}`;

          const firstParenIndex = tokens.findIndex(t => t[0] === '(');
          const lastParen = tokens.reverse().find(t => t[0] === ')');
          const lastParenIndex = tokens.reverse().indexOf(lastParen);
          const paramTokens = tokens.splice(firstParenIndex, lastParenIndex);
          const params = paramTokens.map(t => t[1]).join('');

          for (const token of tokens.reverse()) {
            this.tokenizer.back(token);
          }

          this.atrule(this.tokenizer.nextToken());
          this.lastNode.function = true;
          this.lastNode.params = params;
        }

        init(node, line, column) {
          super.init(node, line, column);
          this.lastNode = node;
        }

        inlineComment(token) {
          const node = new Comment();
          const text = token[1].slice(2);

          this.init(node, token[2], token[3]);

          node.source.end = { line: token[4], column: token[5] };
          node.inline = true;
          node.raws.begin = '//';

          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            const match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            [, node.raws.left, node.text, node.raws.right] = match;
          }
        }

        mixin(tokens) {
          const [first] = tokens;
          const identifier = first[1].slice(0, 1);
          const bracketsIndex = tokens.findIndex(t => t[0] === 'brackets');
          const firstParenIndex = tokens.findIndex(t => t[0] === '(');
          let important = '';

          // fix for #86. if rulesets are mixin params, they need to be converted to a brackets token
          if ((bracketsIndex < 0 || bracketsIndex > 3) && firstParenIndex > 0) {
            const lastParenIndex = tokens.reduce((last, t, i) => t[0] === ')' ? i : last);

            const contents = tokens.slice(firstParenIndex, lastParenIndex + firstParenIndex);
            const brackets = contents.map(t => t[1]).join('');
            const [paren] = tokens.slice(firstParenIndex);
            const start = [paren[2], paren[3]];
            const [last] = tokens.slice(lastParenIndex, lastParenIndex + 1);
            const end = [last[2], last[3]];
            const newToken = ['brackets', brackets].concat(start, end);

            const tokensBefore = tokens.slice(0, firstParenIndex);
            const tokensAfter = tokens.slice(lastParenIndex + 1);
            tokens = tokensBefore;
            tokens.push(newToken);
            tokens = tokens.concat(tokensAfter);
          }

          const importantTokens = [];

          for (const token of tokens) {
            if (token[1] === '!' || importantTokens.length) {
              importantTokens.push(token);
            }

            if (token[1] === 'important') {
              break;
            }
          }

          if (importantTokens.length) {
            const [bangToken] = importantTokens;
            const bangIndex = tokens.indexOf(bangToken);
            const last = importantTokens[importantTokens.length - 1];
            const start = [bangToken[2], bangToken[3]];
            const end = [last[4], last[5]];
            const combined = importantTokens.map(t => t[1]).join('');
            const newToken = ['word', combined].concat(start, end);
            tokens.splice(bangIndex, importantTokens.length, newToken);
          }

          const importantIndex = tokens.findIndex(t => importantPattern.test(t[1]));

          if (importantIndex > 0) {
            [, important] = tokens[importantIndex];
            tokens.splice(importantIndex, 1);
          }

          for (const token of tokens.reverse()) {
            this.tokenizer.back(token);
          }

          this.atrule(this.tokenizer.nextToken());
          this.lastNode.mixin = true;
          this.lastNode.raws.identifier = identifier;

          if (important) {
            this.lastNode.important = true;
            this.lastNode.raws.important = important;
          }
        }

        other(token) {
          if (!isInlineComment.bind(this)(token)) {
            super.other(token);
          }
        }

        rule(tokens) {
          const last = tokens[tokens.length - 1];
          const prev = tokens[tokens.length - 2];

          if (prev[0] === 'at-word' && last[0] === '{') {
            this.tokenizer.back(last);
            if (interpolation.bind(this)(prev)) {
              const newToken = this.tokenizer.nextToken();

              tokens = tokens.slice(0, tokens.length - 2).concat([newToken]);

              for (const tokn of tokens.reverse()) {
                this.tokenizer.back(tokn);
              }

              return;
            }
          }

          super.rule(tokens);

          // #123: add `extend` decorator to nodes
          const extendPattern = /:extend\(.+\)/i;

          if (extendPattern.test(this.lastNode.selector)) {
            this.lastNode.extend = true;
          }
        }

        unknownWord(tokens) {
          // NOTE: keep commented for examining unknown structures
          // console.log('unknown', tokens);

          const [first] = tokens;

          // #121 support `each` - http://lesscss.org/functions/#list-functions-each
          if (tokens[0][1] === 'each' && tokens[1][0] === '(') {
            this.each(tokens);
            return;
          }

          // TODO: move this into a util function/file
          if (isMixinToken(first)) {
            this.mixin(tokens);
            return;
          }

          super.unknownWord(tokens);
        }};


    }, { "./nodes/import": 78, "./nodes/inline-comment": 79, "./nodes/interpolation": 80, "./nodes/mixin": 81, "./nodes/variable": 82, "postcss/lib/comment": 126, "postcss/lib/parser": 136 }], 76: [function (require, module, exports) {
      const Stringifier = require('postcss/lib/stringifier');

      module.exports = class LessStringifier extends Stringifier {
        atrule(node, semicolon) {
          if (!node.mixin && !node.variable && !node.function) {
            super.atrule(node, semicolon);
            return;
          }

          const identifier = node.function ? '' : node.raws.identifier || '@';
          let name = `${identifier}${node.name}`;
          let params = node.params ? this.rawValue(node, 'params') : '';
          const important = node.raws.important || '';

          if (node.variable) {
            params = node.value;
          }

          if (typeof node.raws.afterName !== 'undefined') {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          if (node.nodes) {
            this.block(node, name + params + important);
          } else {
            const end = (node.raws.between || '') + important + (semicolon ? ';' : '');
            this.builder(name + params + end, node);
          }
        }

        comment(node) {
          if (node.inline) {
            const left = this.raw(node, 'left', 'commentLeft');
            const right = this.raw(node, 'right', 'commentRight');
            this.builder(`//${left}${node.text}${right}`, node);
          } else {
            super.comment(node);
          }
        }};


    }, { "postcss/lib/stringifier": 143 }], 77: [function (require, module, exports) {
      const Input = require('postcss/lib/input');

      const LessParser = require('./LessParser');
      const LessStringifier = require('./LessStringifier');

      module.exports = {
        parse(less, options) {
          const input = new Input(less, options);
          const parser = new LessParser(input);

          parser.parse();

          return parser.root;
        },

        stringify(node, builder) {
          const stringifier = new LessStringifier(builder);
          stringifier.stringify(node);
        },

        nodeToString(node) {
          let result = '';

          module.exports.stringify(node, bit => {
            result += bit;
          });

          return result;
        } };


    }, { "./LessParser": 75, "./LessStringifier": 76, "postcss/lib/input": 130 }], 78: [function (require, module, exports) {
      /* eslint no-param-reassign: off */

      const tokenize = require('postcss/lib/tokenize');

      const urlPattern = /^url\((.+)\)/;

      module.exports = node => {
        const { name, params = '' } = node;

        if (name === 'import' && params.length) {
          node.import = true;

          const tokenizer = tokenize({ css: params });

          node.filename = params.replace(urlPattern, '$1');

          while (!tokenizer.endOfFile()) {
            const [type, content] = tokenizer.nextToken();

            if (type === 'word' && content === 'url') {
              return;
            } else if (type === 'brackets') {
              node.options = content;
              node.filename = params.replace(content, '').trim();
              break;
            }
          }
        }
      };

    }, { "postcss/lib/tokenize": 145 }], 79: [function (require, module, exports) {
      /* eslint-disable no-param-reassign */

      const tokenizer = require('postcss/lib/tokenize');
      const Input = require('postcss/lib/input');

      module.exports = {
        isInlineComment(token) {
          if (token[0] === 'word' && token[1].slice(0, 2) === '//') {
            const first = token;
            const bits = [];
            let last;

            while (token) {
              if (/\r?\n/.test(token[1])) {
                // If there are quotes, fix tokenizer creating one token from start quote to end quote
                if (/['"].*\r?\n/.test(token[1])) {
                  // Add string before newline to inline comment token
                  bits.push(token[1].substring(0, token[1].indexOf('\n')));

                  // Get remaining input and retokenize
                  let remainingInput = token[1].substring(token[1].indexOf('\n'));
                  remainingInput += this.input.css.valueOf().substring(this.tokenizer.position());

                  // Replace tokenizer to retokenize the rest of the string
                  this.input = new Input(remainingInput);
                  this.tokenizer = tokenizer(this.input);
                } else {
                  // If the tokenizer went to the next line go back
                  this.tokenizer.back(token);
                }
                break;
              }

              bits.push(token[1]);
              last = token;
              token = this.tokenizer.nextToken({ ignoreUnclosed: true });
            }

            const newToken = ['comment', bits.join(''), first[2], first[3], last[2], last[3]];

            this.inlineComment(newToken);
            return true;
          } else if (token[1] === '/') {
            // issue #135
            const next = this.tokenizer.nextToken({ ignoreUnclosed: true });

            if (next[0] === 'comment' && /^\/\*/.test(next[1])) {
              next[0] = 'word';
              next[1] = next[1].slice(1);
              token[1] = '//';
              this.tokenizer.back(next);
              return module.exports.isInlineComment.bind(this)(token);
            }
          }

          return false;
        } };


    }, { "postcss/lib/input": 130, "postcss/lib/tokenize": 145 }], 80: [function (require, module, exports) {
      /* eslint no-param-reassign: off */

      module.exports = {
        interpolation(token) {
          let first = token;
          const tokens = [token];
          const validTypes = ['word', '{', '}'];

          token = this.tokenizer.nextToken();

          // look for @{ but not @[word]{
          if (first[1].length > 1 || token[0] !== '{') {
            this.tokenizer.back(token);
            return false;
          }

          while (token && validTypes.includes(token[0])) {
            tokens.push(token);
            token = this.tokenizer.nextToken();
          }

          const words = tokens.map(tokn => tokn[1]);
          [first] = tokens;
          const last = tokens.pop();
          const start = [first[2], first[3]];
          const end = [last[4] || last[2], last[5] || last[3]];
          const newToken = ['word', words.join('')].concat(start, end);

          this.tokenizer.back(token);
          this.tokenizer.back(newToken);

          return true;
        } };


    }, {}], 81: [function (require, module, exports) {
      const hashColorPattern = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/;
      const unpaddedFractionalNumbersPattern = /\.[0-9]/;

      const isMixinToken = token => {
        const [, symbol] = token;
        const [char] = symbol;

        return (
          (char === '.' || char === '#') &&
          // ignore hashes used for colors
          hashColorPattern.test(symbol) === false &&
          // ignore dots used for unpadded fractional numbers
          unpaddedFractionalNumbersPattern.test(symbol) === false);

      };

      module.exports = { isMixinToken };

    }, {}], 82: [function (require, module, exports) {
      /* eslint no-param-reassign: off */

      const afterPattern = /:$/;
      const beforePattern = /^:(\s+)?/;
      // const bracketsPattern = /\{/;

      module.exports = node => {
        const { name, params = '' } = node;

        // situations like @page :last { color: red } should default to the built-in AtRule
        // LESS variables are @name : value; < note that for them to be valid LESS vars, they must end in
        // a semicolon.

        if (node.name.slice(-1) !== ':') {
          return;
        }

        if (afterPattern.test(name)) {
          const [match] = name.match(afterPattern);

          node.name = name.replace(match, '');
          node.raws.afterName = match + (node.raws.afterName || '');
          node.variable = true;
          node.value = node.params;
        }

        if (beforePattern.test(params)) {
          const [match] = params.match(beforePattern);

          node.value = params.replace(match, '');
          node.raws.afterName = (node.raws.afterName || '') + match;
          node.variable = true;
        }
      };

    }, {}], 83: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.default = parseMedia;

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      var _parsers = require('./parsers');

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media query list into an array of nodes. A typical node signature:
       *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',
       *    'media-feature-expression', 'media-feature', 'colon', 'value'
       *  {string} node.value -- the contents of a particular element, trimmed
       *    e.g.: `screen`, `max-width`, `1024px`
       *  {string} node.after -- whitespaces that follow the element
       *  {string} node.before -- whitespaces that precede the element
       *  {string} node.sourceIndex -- the index of the element in a source media
       *    query list, 0-based
       *  {object} node.parent -- a link to the parent node (a container)
       *
       * Some nodes (media queries, media feature expressions) contain other nodes.
       * They additionally have:
       *  {array} node.nodes -- an array of nodes of the type described here
       *  {funciton} node.each -- traverses direct children of the node, calling
       *    a callback for each one
       *  {funciton} node.walk -- traverses ALL descendants of the node, calling
       *    a callback for each one
       */

      function parseMedia(value) {
        return new _Container2.default({
          nodes: (0, _parsers.parseMediaList)(value),
          type: 'media-query-list',
          value: value.trim() });

      }
    }, { "./nodes/Container": 84, "./parsers": 86 }], 84: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });


      var _Node = require('./Node');

      var _Node2 = _interopRequireDefault(_Node);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function Container(opts) {
        var _this = this;

        this.constructor(opts);

        this.nodes = opts.nodes;

        if (this.after === undefined) {
          this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : '';
        }

        if (this.before === undefined) {
          this.before = this.nodes.length > 0 ? this.nodes[0].before : '';
        }

        if (this.sourceIndex === undefined) {
          this.sourceIndex = this.before.length;
        }

        this.nodes.forEach(function (node) {
          node.parent = _this; // eslint-disable-line no-param-reassign
        });
      } /**
       * A node that contains other nodes and support traversing over them
       */

      Container.prototype = Object.create(_Node2.default.prototype);
      Container.constructor = _Node2.default;

      /**
       * Iterate over descendant nodes of the node
       *
       * @param {RegExp|string} filter - Optional. Only nodes with node.type that
       *    satisfies the filter will be traversed over
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.walk = function walk(filter, cb) {
        var hasFilter = typeof filter === 'string' || filter instanceof RegExp;
        var callback = hasFilter ? cb : filter;
        var filterReg = typeof filter === 'string' ? new RegExp(filter) : filter;

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          var filtered = hasFilter ? filterReg.test(node.type) : true;
          if (filtered && callback && callback(node, i, this.nodes) === false) {
            return false;
          }
          if (node.nodes && node.walk(filter, cb) === false) {
            return false;
          }
        }
        return true;
      };

      /**
       * Iterate over immediate children of the node
       *
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.each = function each() {
        var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (cb(node, i, this.nodes) === false) {
            return false;
          }
        }
        return true;
      };

      exports.default = Container;
    }, { "./Node": 85 }], 85: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true });

      /**
       * A very generic node. Pretty much any element of a media query
       */

      function Node(opts) {
        this.after = opts.after;
        this.before = opts.before;
        this.type = opts.type;
        this.value = opts.value;
        this.sourceIndex = opts.sourceIndex;
      }

      exports.default = Node;
    }, {}], 86: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.parseMediaFeature = parseMediaFeature;
      exports.parseMediaQuery = parseMediaQuery;
      exports.parseMediaList = parseMediaList;

      var _Node = require('./nodes/Node');

      var _Node2 = _interopRequireDefault(_Node);

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`
       *
       * @param {string} string - the source expression string, can be inside parens
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes, the first element being a media feature,
       *    the secont - its value (may be missing)
       */

      function parseMediaFeature(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var modesEntered = [{
          mode: 'normal',
          character: null }];

        var result = [];
        var lastModeIndex = 0;
        var mediaFeature = '';
        var colon = null;
        var mediaFeatureValue = null;
        var indexLocal = index;

        var stringNormalized = string;
        // Strip trailing parens (if any), and correct the starting index
        if (string[0] === '(' && string[string.length - 1] === ')') {
          stringNormalized = string.substring(1, string.length - 1);
          indexLocal++;
        }

        for (var i = 0; i < stringNormalized.length; i++) {
          var character = stringNormalized[i];

          // If entering/exiting a string
          if (character === '\'' || character === '"') {
            if (modesEntered[lastModeIndex].isCalculationEnabled === true) {
              modesEntered.push({
                mode: 'string',
                isCalculationEnabled: false,
                character: character });

              lastModeIndex++;
            } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\') {
              modesEntered.pop();
              lastModeIndex--;
            }
          }

          // If entering/exiting interpolation
          if (character === '{') {
            modesEntered.push({
              mode: 'interpolation',
              isCalculationEnabled: true });

            lastModeIndex++;
          } else if (character === '}') {
            modesEntered.pop();
            lastModeIndex--;
          }

          // If a : is met outside of a string, function call or interpolation, than
          // this : separates a media feature and a value
          if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {
            var mediaFeatureValueStr = stringNormalized.substring(i + 1);
            mediaFeatureValue = {
              type: 'value',
              before: /^(\s*)/.exec(mediaFeatureValueStr)[1],
              after: /(\s*)$/.exec(mediaFeatureValueStr)[1],
              value: mediaFeatureValueStr.trim() };

            // +1 for the colon
            mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;
            colon = {
              type: 'colon',
              sourceIndex: i + indexLocal,
              after: mediaFeatureValue.before,
              value: ':' };
            break;
          }

          mediaFeature += character;
        }

        // Forming a media feature node
        mediaFeature = {
          type: 'media-feature',
          before: /^(\s*)/.exec(mediaFeature)[1],
          after: /(\s*)$/.exec(mediaFeature)[1],
          value: mediaFeature.trim() };

        mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;
        result.push(mediaFeature);

        if (colon !== null) {
          colon.before = mediaFeature.after;
          result.push(colon);
        }

        if (mediaFeatureValue !== null) {
          result.push(mediaFeatureValue);
        }

        return result;
      }

      /**
       * Parses a media query, e.g. `screen and (color)`, `only tv`
       *
       * @param {string} string - the source media query string
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes and Containers
       */

      function parseMediaQuery(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var result = [];

        // How many timies the parser entered parens/curly braces
        var localLevel = 0;
        // Has any keyword, media type, media feature expression or interpolation
        // ('element' hereafter) started
        var insideSomeValue = false;
        var node = void 0;

        function resetNode() {
          return {
            before: '',
            after: '',
            value: '' };

        }

        node = resetNode();

        for (var i = 0; i < string.length; i++) {
          var character = string[i];
          // If not yet entered any element
          if (!insideSomeValue) {
            if (character.search(/\s/) !== -1) {
              // A whitespace
              // Don't form 'after' yet; will do it later
              node.before += character;
            } else {
              // Not a whitespace - entering an element
              // Expression start
              if (character === '(') {
                node.type = 'media-feature-expression';
                localLevel++;
              }
              node.value = character;
              node.sourceIndex = index + i;
              insideSomeValue = true;
            }
          } else {
            // Already in the middle of some alement
            node.value += character;

            // Here parens just increase localLevel and don't trigger a start of
            // a media feature expression (since they can't be nested)
            // Interpolation start
            if (character === '{' || character === '(') {
              localLevel++;
            }
            // Interpolation/function call/media feature expression end
            if (character === ')' || character === '}') {
              localLevel--;
            }
          }

          // If exited all parens/curlies and the next symbol
          if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\s/) !== -1)) {
            if (['not', 'only', 'and'].indexOf(node.value) !== -1) {
              node.type = 'keyword';
            }
            // if it's an expression, parse its contents
            if (node.type === 'media-feature-expression') {
              node.nodes = parseMediaFeature(node.value, node.sourceIndex);
            }
            result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));
            node = resetNode();
            insideSomeValue = false;
          }
        }

        // Now process the result array - to specify undefined types of the nodes
        // and specify the `after` prop
        for (var _i = 0; _i < result.length; _i++) {
          node = result[_i];
          if (_i > 0) {
            result[_i - 1].after = node.before;
          }

          // Node types. Might not be set because contains interpolation/function
          // calls or fully consists of them
          if (node.type === undefined) {
            if (_i > 0) {
              // only `and` can follow an expression
              if (result[_i - 1].type === 'media-feature-expression') {
                node.type = 'keyword';
                continue;
              }
              // Anything after 'only|not' is a media type
              if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {
                node.type = 'media-type';
                continue;
              }
              // Anything after 'and' is an expression
              if (result[_i - 1].value === 'and') {
                node.type = 'media-feature-expression';
                continue;
              }

              if (result[_i - 1].type === 'media-type') {
                // if it is the last element - it might be an expression
                // or 'and' depending on what is after it
                if (!result[_i + 1]) {
                  node.type = 'media-feature-expression';
                } else {
                  node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';
                }
              }
            }

            if (_i === 0) {
              // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then
              // its type would have been set by now
              if (!result[_i + 1]) {
                node.type = 'media-type';
                continue;
              }

              // `screen and` or `#{...} (max-width: 10px)`
              if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {
                node.type = 'media-type';
                continue;
              }
              if (result[_i + 2]) {
                // `screen and (color) ...`
                if (result[_i + 2].type === 'media-feature-expression') {
                  node.type = 'media-type';
                  result[_i + 1].type = 'keyword';
                  continue;
                }
                // `only screen and ...`
                if (result[_i + 2].type === 'keyword') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  continue;
                }
              }
              if (result[_i + 3]) {
                // `screen and (color) ...`
                if (result[_i + 3].type === 'media-feature-expression') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  result[_i + 2].type = 'keyword';
                  continue;
                }
              }
            }
          }
        }
        return result;
      }

      /**
       * Parses a media query list. Takes a possible `url()` at the start into
       * account, and divides the list into media queries that are parsed separately
       *
       * @param {string} string - the source media query list string
       *
       * @return {Array} an array of Nodes/Containers
       */

      function parseMediaList(string) {
        var result = [];
        var interimIndex = 0;
        var levelLocal = 0;

        // Check for a `url(...)` part (if it is contents of an @import rule)
        var doesHaveUrl = /^(\s*)url\s*\(/.exec(string);
        if (doesHaveUrl !== null) {
          var i = doesHaveUrl[0].length;
          var parenthesesLv = 1;
          while (parenthesesLv > 0) {
            var character = string[i];
            if (character === '(') {
              parenthesesLv++;
            }
            if (character === ')') {
              parenthesesLv--;
            }
            i++;
          }
          result.unshift(new _Node2.default({
            type: 'url',
            value: string.substring(0, i).trim(),
            sourceIndex: doesHaveUrl[1].length,
            before: doesHaveUrl[1],
            after: /^(\s*)/.exec(string.substring(i))[1] }));

          interimIndex = i;
        }

        // Start processing the media query list
        for (var _i2 = interimIndex; _i2 < string.length; _i2++) {
          var _character = string[_i2];

          // Dividing the media query list into comma-separated media queries
          // Only count commas that are outside of any parens
          // (i.e., not part of function call params list, etc.)
          if (_character === '(') {
            levelLocal++;
          }
          if (_character === ')') {
            levelLocal--;
          }
          if (levelLocal === 0 && _character === ',') {
            var _mediaQueryString = string.substring(interimIndex, _i2);
            var _spaceBefore = /^(\s*)/.exec(_mediaQueryString)[1];
            result.push(new _Container2.default({
              type: 'media-query',
              value: _mediaQueryString.trim(),
              sourceIndex: interimIndex + _spaceBefore.length,
              nodes: parseMediaQuery(_mediaQueryString, interimIndex),
              before: _spaceBefore,
              after: /(\s*)$/.exec(_mediaQueryString)[1] }));

            interimIndex = _i2 + 1;
          }
        }

        var mediaQueryString = string.substring(interimIndex);
        var spaceBefore = /^(\s*)/.exec(mediaQueryString)[1];
        result.push(new _Container2.default({
          type: 'media-query',
          value: mediaQueryString.trim(),
          sourceIndex: interimIndex + spaceBefore.length,
          nodes: parseMediaQuery(mediaQueryString, interimIndex),
          before: spaceBefore,
          after: /(\s*)$/.exec(mediaQueryString)[1] }));


        return result;
      }
    }, { "./nodes/Container": 84, "./nodes/Node": 85 }], 87: [function (require, module, exports) {
      module.exports = function resolveNestedSelector(selector, node) {
        var parent = node.parent;
        var parentIsNestAtRule = parent.type === 'atrule' && parent.name === 'nest';

        if (parent.type === 'root') return [selector];
        if (parent.type !== 'rule' && !parentIsNestAtRule) return resolveNestedSelector(selector, parent);

        var parentSelectors = parentIsNestAtRule ?
        parent.params.split(',').map(function (s) {return s.trim();}) :
        parent.selectors;

        var resolvedSelectors = parentSelectors.reduce(function (result, parentSelector) {
          if (selector.indexOf('&') !== -1) {
            var newlyResolvedSelectors = resolveNestedSelector(parentSelector, parent).map(function (resolvedParentSelector) {
              return selector.replace(/&/g, resolvedParentSelector);
            });
            return result.concat(newlyResolvedSelectors);
          }

          var combinedSelector = [parentSelector, selector].join(' ');
          return result.concat(resolveNestedSelector(combinedSelector, parent));
        }, []);

        return resolvedSelectors;
      };

    }, {}], 88: [function (require, module, exports) {
      "use strict";

      var Input = require('postcss/lib/input');

      var SafeParser = require('./safe-parser');

      module.exports = function safeParse(css, opts) {
        var input = new Input(css, opts);
        var parser = new SafeParser(input);
        parser.parse();
        return parser.root;
      };


    }, { "./safe-parser": 89, "postcss/lib/input": 130 }], 89: [function (require, module, exports) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var tokenizer = require('postcss/lib/tokenize');

      var Comment = require('postcss/lib/comment');

      var Parser = require('postcss/lib/parser');

      var SafeParser =
      /*#__PURE__*/
      function (_Parser) {
        _inheritsLoose(SafeParser, _Parser);

        function SafeParser() {
          return _Parser.apply(this, arguments) || this;
        }

        var _proto = SafeParser.prototype;

        _proto.createTokenizer = function createTokenizer() {
          this.tokenizer = tokenizer(this.input, {
            ignoreErrors: true });

        };

        _proto.comment = function comment(token) {
          var node = new Comment();
          this.init(node, token[2], token[3]);
          node.source.end = {
            line: token[4],
            column: token[5] };

          var text = token[1].slice(2);
          if (text.slice(-2) === '*/') text = text.slice(0, -2);

          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            var match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        };

        _proto.decl = function decl(tokens) {
          if (tokens.length > 1 && tokens.some(function (i) {
            return i[0] === 'word';
          })) {
            _Parser.prototype.decl.call(this, tokens);
          }
        };

        _proto.unclosedBracket = function unclosedBracket() {};

        _proto.unknownWord = function unknownWord(tokens) {
          this.spaces += tokens.map(function (i) {
            return i[1];
          }).join('');
        };

        _proto.unexpectedClose = function unexpectedClose() {
          this.current.raws.after += '}';
        };

        _proto.doubleColon = function doubleColon() {};

        _proto.unnamedAtrule = function unnamedAtrule(node) {
          node.name = '';
        };

        _proto.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
          var colon = this.colon(tokens);
          if (colon === false) return;
          var split;

          for (split = colon - 1; split >= 0; split--) {
            if (tokens[split][0] === 'word') break;
          }

          for (split -= 1; split >= 0; split--) {
            if (tokens[split][0] !== 'space') {
              split += 1;
              break;
            }
          }

          var other = tokens.splice(split, tokens.length - split);
          this.decl(other);
        };

        _proto.checkMissedSemicolon = function checkMissedSemicolon() {};

        _proto.endFile = function endFile() {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }

          this.current.raws.after = (this.current.raws.after || '') + this.spaces;

          while (this.current.parent) {
            this.current = this.current.parent;
            this.current.raws.after = '';
          }
        };

        return SafeParser;
      }(Parser);

      module.exports = SafeParser;


    }, { "postcss/lib/comment": 126, "postcss/lib/parser": 136, "postcss/lib/tokenize": 145 }], 90: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _processor = _interopRequireDefault(require("./processor"));

      var selectors = _interopRequireWildcard(require("./selectors"));

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}}newObj.default = obj;return newObj;}}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      var parser = function parser(processor) {
        return new _processor.default(processor);
      };

      Object.assign(parser, selectors);
      delete parser.__esModule;
      var _default = parser;
      exports.default = _default;
      module.exports = exports.default;
    }, { "./processor": 92, "./selectors": 101 }], 91: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _indexesOf = _interopRequireDefault(require("indexes-of"));

      var _uniq = _interopRequireDefault(require("uniq"));

      var _root = _interopRequireDefault(require("./selectors/root"));

      var _selector = _interopRequireDefault(require("./selectors/selector"));

      var _className = _interopRequireDefault(require("./selectors/className"));

      var _comment = _interopRequireDefault(require("./selectors/comment"));

      var _id = _interopRequireDefault(require("./selectors/id"));

      var _tag = _interopRequireDefault(require("./selectors/tag"));

      var _string = _interopRequireDefault(require("./selectors/string"));

      var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));

      var _attribute = _interopRequireWildcard(require("./selectors/attribute"));

      var _universal = _interopRequireDefault(require("./selectors/universal"));

      var _combinator = _interopRequireDefault(require("./selectors/combinator"));

      var _nesting = _interopRequireDefault(require("./selectors/nesting"));

      var _sortAscending = _interopRequireDefault(require("./sortAscending"));

      var _tokenize = _interopRequireWildcard(require("./tokenize"));

      var tokens = _interopRequireWildcard(require("./tokenTypes"));

      var types = _interopRequireWildcard(require("./selectors/types"));

      var _util = require("./util");

      var _WHITESPACE_TOKENS, _Object$assign;

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}}newObj.default = obj;return newObj;}}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL] };

      }

      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL] };

      }

      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn },

          end: {
            line: endLine,
            column: endColumn } };


      }

      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }

      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return undefined;
        }

        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }

      function unescapeProp(node, prop) {
        var value = node[prop];

        if (typeof value !== "string") {
          return;
        }

        if (value.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, 'raws');
          node[prop] = (0, _util.unesc)(value);

          if (node.raws[prop] === undefined) {
            node.raws[prop] = value;
          }
        }

        return node;
      }

      var Parser =
      /*#__PURE__*/
      function () {
        function Parser(rule, options) {
          if (options === void 0) {
            options = {};
          }

          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false },
          options);
          this.position = 0;
          this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize.default)({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe });

          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root.default({
            source: rootSource });

          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector.default({
            source: {
              start: {
                line: 1,
                column: 1 } } });



          this.root.append(selector);
          this.current = selector;
          this.loop();
        }

        var _proto = Parser.prototype;

        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;

          return function (message, errorOptions) {
            if (typeof _this.rule === 'string') {
              return new Error(message);
            }

            return _this.rule.error(message, errorOptions);
          };
        };

        _proto.attribute = function attribute() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;

          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
          }

          var len = attr.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS] };


          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
          }

          var pos = 0;
          var spaceBefore = '';
          var commentBefore = '';
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;

          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];

            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                // if (
                //     len === 1 ||
                //     pos === 0 && this.content(next) === '|'
                // ) {
                //     return this.expected('attribute', token[TOKEN.START_POS], content);
                // }
                spaceAfterMeaningfulToken = true;

                if (this.options.lossy) {
                  break;
                }

                if (lastAdded) {
                  (0, _util.ensureObject)(node, 'spaces', lastAdded);
                  var prevContent = node.spaces[lastAdded].after || '';
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }

                break;

              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = '';
                  }

                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

                  if (rawValue) {
                    node.raws.namespace += content;
                  }

                  lastAdded = 'namespace';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
                  node.value += "$";

                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }

                  break;
                }

              // Falls through

              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.combinator:
                if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                if (content !== '|') {
                  spaceAfterMeaningfulToken = false;
                  break;
                }

                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.word:
                if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = 'namespace';
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = '';
                  }

                  node.attribute = (node.attribute || "") + content;

                  var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

                  if (_rawValue) {
                    node.raws.attribute += content;
                  }

                  lastAdded = 'attribute';
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                  var _unescaped = (0, _util.unesc)(content);

                  var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

                  var oldValue = node.value || '';
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;

                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }

                  lastAdded = 'value';
                } else {
                  var insensitive = content === 'i' || content === "I";

                  if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;

                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, 'raws');
                      node.raws.insensitiveFlag = content;
                    }

                    lastAdded = 'insensitive';

                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = '';
                    }

                    if (commentBefore) {
                      (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = '';
                    }
                  } else if (node.value || node.value === '') {
                    lastAdded = 'value';
                    node.value += content;

                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                var _unescapeValue = (0, _attribute.unescapeValue)(content),
                unescaped = _unescapeValue.unescaped,
                quoteMark = _unescapeValue.quoteMark;

                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = 'value';
                (0, _util.ensureObject)(node, 'raws');
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.equals:
                if (!node.attribute) {
                  return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
                }

                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                node.operator = node.operator ? node.operator + content : content;
                lastAdded = 'operator';
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
                    var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
                    var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
                    (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || '';
                    var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }

                break;

              default:
                return this.error("Unexpected \"" + content + "\" found.", {
                  index: token[_tokenize.FIELDS.START_POS] });}



            pos++;
          }

          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute.default(node));
          this.position++;
        }
        /**
         * return a node containing meaningless garbage up to (but not including) the specified token position.
         * if the token position is negative, all remaining tokens are consumed.
         *
         * This returns an array containing a single string node if all whitespace,
         * otherwise an array of comment nodes with space before and after.
         *
         * These tokens are not added to the current selector, the caller can add them or use them to amend
         * a previous node's space metadata.
         *
         * In lossy mode, this returns only comments.
         */;


        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }

          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = undefined;

          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};

              if (space) {
                spaces.before = space;
                space = "";
              }

              lastComment = new _comment.default({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces: spaces });

              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);

          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string.default({
                value: '',
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: '' } }));


            }
          }

          return nodes;
        }
        /**
         * 
         * @param {*} nodes 
         */;


        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;

          if (requiredSpace === void 0) {
            requiredSpace = false;
          }

          var space = "";
          var rawSpace = "";
          nodes.forEach(function (n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });

          if (rawSpace === space) {
            rawSpace = undefined;
          }

          var result = {
            space: space,
            rawSpace: rawSpace };

          return result;
        };

        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }

          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };

        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};

            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }

            var node = new _combinator.default({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws: raws });

            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };

        _proto.combinator = function combinator() {
          var _this3 = this;

          if (this.content() === '|') {
            return this.namespace();
          } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

            if (nodes.length > 0) {
              var last = this.current.last;

              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
                space = _this$convertWhitespa.space,
                rawSpace = _this$convertWhitespa.rawSpace;

                if (rawSpace !== undefined) {
                  last.rawSpaceAfter += rawSpace;
                }

                last.spaces.after += space;
              } else {
                nodes.forEach(function (n) {
                  return _this3.newNode(n);
                });
              }
            }

            return;
          }

          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = undefined;

          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }

          var node;

          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator.default({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS] });

            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }

          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
              _space = _this$convertWhitespa2.space,
              _rawSpace = _this$convertWhitespa2.rawSpace;

              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            // descendant combinator
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
            _space2 = _this$convertWhitespa3.space,
            _rawSpace2 = _this$convertWhitespa3.rawSpace;

            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }

            var spaces = {};
            var raws = {
              spaces: {} };


            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }

            node = new _combinator.default({
              value: ' ',
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: spaces,
              raws: raws });

          }

          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }

          return this.newNode(node);
        };

        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }

          this.current._inferEndPosition();

          var selector = new _selector.default({
            source: {
              start: tokenStart(this.tokens[this.position + 1]) } });


          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };

        _proto.comment = function comment() {
          var current = this.currToken;
          this.newNode(new _comment.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };

        _proto.missingBackslash = function missingBackslash() {
          return this.error('Expected a backslash preceding the semicolon.', {
            index: this.currToken[_tokenize.FIELDS.START_POS] });

        };

        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;

          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
        };

        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);

            if (nextContent === "|") {
              this.position++;
              return;
            }
          }

          var current = this.currToken;
          this.newNode(new _nesting.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;

          if (last && last.type === types.PSEUDO) {
            var selector = new _selector.default({
              source: {
                start: tokenStart(this.tokens[this.position - 1]) } });


            var cache = this.current;
            last.append(selector);
            this.current = selector;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }

            this.current = cache;
          } else {
            // I think this case should be an error. It's used to implement a basic parse of media queries
            // but I don't think it's a good idea.
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }

            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string.default({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS] }));

            }
          }

          if (unbalanced) {
            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.pseudo = function pseudo() {
          var _this4 = this;

          var pseudoStr = '';
          var startingToken = this.currToken;

          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }

          if (!this.currToken) {
            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function (first, length) {
              pseudoStr += first;

              _this4.newNode(new _pseudo.default({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS] }));


              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error('Misplaced parenthesis.', {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS] });

              }
            });
          } else {
            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.space = function space() {
          var content = this.content(); // Handle space before and after the selector

          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
            return node.type === 'comment';
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };

        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          var current = this.currToken;
          this.newNode(new _universal.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }),
          namespace);
          this.position++;
        };

        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;

          var nextToken = this.nextToken;
          var word = this.content();

          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;

            if (current.lastIndexOf('\\') === current.length - 1) {
              var next = this.nextToken;

              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next));
                this.position++;
              }
            }

            nextToken = this.nextToken;
          }

          var hasClass = (0, _indexesOf.default)(word, '.').filter(function (i) {
            return word[i - 1] !== '\\';
          });
          var hasId = (0, _indexesOf.default)(word, '#').filter(function (i) {
            return word[i - 1] !== '\\';
          }); // Eliminate Sass interpolations from the list of id indexes

          var interpolations = (0, _indexesOf.default)(word, '#{');

          if (interpolations.length) {
            hasId = hasId.filter(function (hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }

          var indices = (0, _sortAscending.default)((0, _uniq.default)([0].concat(hasClass, hasId)));
          indices.forEach(function (ind, i) {
            var index = indices[i + 1] || word.length;
            var value = word.slice(ind, index);

            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value, indices.length);
            }

            var node;
            var current = _this5.currToken;
            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _className.default(unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _id.default(unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value,
                source: source,
                sourceIndex: sourceIndex };

              unescapeProp(tagOpts, "value");
              node = new _tag.default(tagOpts);
            }

            _this5.newNode(node, namespace); // Ensure that the namespace is used only once


            namespace = null;
          });
          this.position++;
        };

        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          return this.splitWord(namespace);
        };

        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }

          this.current._inferEndPosition();

          return this.root;
        };

        _proto.parse = function parse(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;

            case tokens.comment:
              this.comment();
              break;

            case tokens.openParenthesis:
              this.parentheses();
              break;

            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }

              break;

            case tokens.openSquare:
              this.attribute();
              break;

            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;

            case tokens.colon:
              this.pseudo();
              break;

            case tokens.comma:
              this.comma();
              break;

            case tokens.asterisk:
              this.universal();
              break;

            case tokens.ampersand:
              this.nesting();
              break;

            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;

            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.

            case tokens.closeSquare:
              this.missingSquareBracket();

            case tokens.semicolon:
              this.missingBackslash();

            default:
              this.unexpected();}

        }
        /**
         * Helpers
         */;


        _proto.expected = function expected(description, index, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(', ') + " or " + last;
          }

          var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index });

          }

          return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
            index: index });

        };

        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? ' ' : space;
        };

        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? '' : space;
        };

        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? ' ' : '';
          } else {
            return space;
          }
        };

        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);

          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };

        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || '') + namespace;
              }

              namespace = true;
            }

            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }

          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = '';
          }

          return this.current.append(node);
        };

        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }

          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };

        /**
         * returns the index of the next non-whitespace, non-comment token.
         * returns -1 if no meaningful token is found.
         */
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }

          var searchPosition = startPosition;

          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }

          return -1;
        };

        _createClass(Parser, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          } },
        {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          } },
        {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          } }]);


        return Parser;
      }();

      exports.default = Parser;
      module.exports = exports.default;
    }, { "./selectors/attribute": 93, "./selectors/className": 94, "./selectors/combinator": 95, "./selectors/comment": 96, "./selectors/id": 100, "./selectors/nesting": 103, "./selectors/pseudo": 105, "./selectors/root": 106, "./selectors/selector": 107, "./selectors/string": 108, "./selectors/tag": 109, "./selectors/types": 110, "./selectors/universal": 111, "./sortAscending": 112, "./tokenTypes": 113, "./tokenize": 114, "./util": 117, "indexes-of": 14, "uniq": 516 }], 92: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _parser = _interopRequireDefault(require("./parser"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      var Processor =
      /*#__PURE__*/
      function () {
        function Processor(func, options) {
          this.func = func || function noop() {};

          this.funcRes = null;
          this.options = options;
        }

        var _proto = Processor.prototype;

        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };

        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };

        _proto._root = function _root(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var parser = new _parser.default(rule, this._parseOptions(options));
          return parser.root;
        };

        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options) };

        };

        _proto._run = function _run(rule, options) {
          var _this = this;

          if (options === void 0) {
            options = {};
          }

          return new Promise(function (resolve, reject) {
            try {
              var root = _this._root(rule, options);

              Promise.resolve(_this.func(root)).then(function (transform) {
                var string = undefined;

                if (_this._shouldUpdateSelector(rule, options)) {
                  string = root.toString();
                  rule.selector = string;
                }

                return {
                  transform: transform,
                  root: root,
                  string: string };

              }).then(resolve, reject);
            } catch (e) {
              reject(e);
              return;
            }
          });
        };

        _proto._runSync = function _runSync(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var root = this._root(rule, options);

          var transform = this.func(root);

          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }

          var string = undefined;

          if (options.updateSelector && typeof rule !== "string") {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string };

        }
        /**
         * Process rule into a selector AST.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<parser.Root>} The AST of the selector after processing it.
         */;


        _proto.ast = function ast(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.root;
          });
        }
        /**
         * Process rule into a selector AST synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {parser.Root} The AST of the selector after processing it.
         */;


        _proto.astSync = function astSync(rule, options) {
          return this._runSync(rule, options).root;
        }
        /**
         * Process a selector into a transformed value asynchronously
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<any>} The value returned by the processor.
         */;


        _proto.transform = function transform(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.transform;
          });
        }
        /**
         * Process a selector into a transformed value synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {any} The value returned by the processor.
         */;


        _proto.transformSync = function transformSync(rule, options) {
          return this._runSync(rule, options).transform;
        }
        /**
         * Process a selector into a new selector string asynchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.process = function process(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.string || result.root.toString();
          });
        }
        /**
         * Process a selector into a new selector string synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.processSync = function processSync(rule, options) {
          var result = this._runSync(rule, options);

          return result.string || result.root.toString();
        };

        return Processor;
      }();

      exports.default = Processor;
      module.exports = exports.default;
    }, { "./parser": 91 }], 93: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.unescapeValue = unescapeValue;
      exports.default = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _unesc = _interopRequireDefault(require("../util/unesc"));

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      var _CSSESC_QUOTE_OPTIONS;

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var deprecate = require("util-deprecate");

      var WRAPPED_IN_QUOTES = /^('|")(.*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m = unescaped.match(WRAPPED_IN_QUOTES);

        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }

        unescaped = (0, _unesc.default)(unescaped);

        if (unescaped !== value) {
          deprecatedUsage = true;
        }

        return {
          deprecatedUsage: deprecatedUsage,
          unescaped: unescaped,
          quoteMark: quoteMark };

      }

      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== undefined) {
          return opts;
        }

        if (opts.value === undefined) {
          return opts;
        }

        warnOfDeprecatedConstructor();

        var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

        if (!opts.raws) {
          opts.raws = {};
        }

        if (opts.raws.value === undefined) {
          opts.raws.value = opts.value;
        }

        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }

      var Attribute =
      /*#__PURE__*/
      function (_Namespace) {
        _inheritsLoose(Attribute, _Namespace);

        function Attribute(opts) {
          var _this;

          if (opts === void 0) {
            opts = {};
          }

          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, 'unquoted', {
            get: deprecate(function () {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function () {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") });

          _this._constructed = true;
          return _this;
        }
        /**
         * Returns the Attribute's value quoted such that it would be legal to use
         * in the value of a css file. The original value's quotation setting
         * used for stringification is left unchanged. See `setValue(value, options)`
         * if you want to control the quote settings of a new value for the attribute.
         *
         * You can also change the quotation used for the current value by setting quoteMark.
         *
         * Options:
         *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
         *     option is not set, the original value for quoteMark will be used. If
         *     indeterminate, a double quote is used. The legal values are:
         *     * `null` - the value will be unquoted and characters will be escaped as necessary.
         *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
         *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
         *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
         *     over the quoteMark option value.
         *   * smart {boolean} - if true, will select a quote mark based on the value
         *     and the other options specified here. See the `smartQuoteMark()`
         *     method.
         **/


        var _proto = Attribute.prototype;

        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }

          var quoteMark = this._determineQuoteMark(options);

          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc.default)(this._value, cssescopts);
          return escaped;
        };

        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        }
        /**
         * Set the unescaped value with the specified quotation options. The value
         * provided must not include any wrapping quote marks -- those quotes will
         * be interpreted as part of the value and escaped accordingly.
         */;


        _proto.setValue = function setValue(value, options) {
          if (options === void 0) {
            options = {};
          }

          this._value = value;
          this._quoteMark = this._determineQuoteMark(options);

          this._syncRawValue();
        }
        /**
         * Intelligently select a quoteMark value based on the value's contents. If
         * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
         * mark will be picked that minimizes the number of escapes.
         *
         * If there's no clear winner, the quote mark from these options is used,
         * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
         * true). If the quoteMark is unspecified, a double quote is used.
         *
         * @param options This takes the quoteMark and preferCurrentQuoteMark options
         * from the quoteValue method.
         */;


        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, '').length;
          var numDoubleQuotes = v.replace(/[^"]/g, '').length;

          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc.default)(v, {
              isIdentifier: true });


            if (escaped === v) {
              return Attribute.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);

              if (pref === Attribute.NO_QUOTE) {
                // pick a quote mark that isn't none and see if it's smaller
                var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc.default)(v, opts);

                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }

              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute.DOUBLE_QUOTE;
          } else {
            return Attribute.SINGLE_QUOTE;
          }
        }
        /**
         * Selects the preferred quote mark based on the options and the current quote mark value.
         * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
         * instead.
         */;


        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

          if (quoteMark === undefined) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }

          if (quoteMark === undefined) {
            quoteMark = Attribute.DOUBLE_QUOTE;
          }

          return quoteMark;
        };

        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };

        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped = (0, _cssesc.default)(value, {
              isIdentifier: true });


            if (escaped !== value) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };

        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: '',
            after: '' };

          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };

        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }

          if (concat === void 0) {
            concat = defaultAttrConcat;
          }

          var attrSpaces = this._spacesFor(spaceName);

          return concat(this.stringifyProperty(name), attrSpaces);
        }
        /**
         * returns the offset of the attribute part specified relative to the
         * start of the node of the output string.
         *
         * * "ns" - alias for "namespace"
         * * "namespace" - the namespace if it exists.
         * * "attribute" - the attribute name
         * * "attributeNS" - the start of the attribute or its namespace
         * * "operator" - the match operator of the attribute
         * * "value" - The value (string or identifier)
         * * "insensitive" - the case insensitivity flag;
         * @param part One of the possible values inside an attribute.
         * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
         */;


        _proto.offsetOf = function offsetOf(name) {
          var count = 1;

          var attributeSpaces = this._spacesFor("attribute");

          count += attributeSpaces.before.length;

          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }

          if (name === "attributeNS") {
            return count;
          }

          count += this.namespaceString.length;

          if (this.namespace) {
            count += 1;
          }

          if (name === "attribute") {
            return count;
          }

          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;

          var operatorSpaces = this._spacesFor("operator");

          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");

          if (name === "operator") {
            return operator ? count : -1;
          }

          count += operator.length;
          count += operatorSpaces.after.length;

          var valueSpaces = this._spacesFor("value");

          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");

          if (name === "value") {
            return value ? count : -1;
          }

          count += value.length;
          count += valueSpaces.after.length;

          var insensitiveSpaces = this._spacesFor("insensitive");

          count += insensitiveSpaces.before.length;

          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }

          return -1;
        };

        _proto.toString = function toString() {
          var _this2 = this;

          var selector = [this.rawSpaceBefore, '['];
          selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

          if (this.operator && (this.value || this.value === '')) {
            selector.push(this._stringFor('operator'));
            selector.push(this._stringFor('value'));
            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }

              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }

          selector.push(']');
          selector.push(this.rawSpaceAfter);
          return selector.join('');
        };

        _createClass(Attribute, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */ },

        {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          }
          /**
           * Set the quote mark to be used by this attribute's value.
           * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
           * value is updated accordingly.
           *
           * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
           */,

          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }

            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;

              this._syncRawValue();
            }
          } },
        {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          } },
        {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? 'i' : '';
          } },
        {
          key: "value",
          get: function get() {
            return this._value;
          }
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */,

          set: function set(v) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v),
              deprecatedUsage = _unescapeValue2.deprecatedUsage,
              unescaped = _unescapeValue2.unescaped,
              quoteMark = _unescapeValue2.quoteMark;

              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }

              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }

              this._value = unescaped;
              this._quoteMark = quoteMark;

              this._syncRawValue();
            } else {
              this._value = v;
            }
          } },
        {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set(name) {
            this._handleEscapes("attribute", name);

            this._attribute = name;
          } }]);


        return Attribute;
      }(_namespace.default);

      exports.default = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: 'single',
          wrap: true },

        '"': {
          quotes: 'double',
          wrap: true } },

      _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true },
      _CSSESC_QUOTE_OPTIONS);

      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }, { "../util/unesc": 119, "./namespace": 102, "./types": 110, "cssesc": 6, "util-deprecate": 519 }], 94: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var ClassName =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(ClassName, _Node);

        function ClassName(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }

        var _proto = ClassName.prototype;

        _proto.valueToString = function valueToString() {
          return '.' + _Node.prototype.valueToString.call(this);
        };

        _createClass(ClassName, [{
          key: "value",
          set: function set(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc.default)(v, {
                isIdentifier: true });


              if (escaped !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }

            this._value = v;
          },
          get: function get() {
            return this._value;
          } }]);


        return ClassName;
      }(_node.default);

      exports.default = ClassName;
      module.exports = exports.default;
    }, { "../util": 117, "./node": 104, "./types": 110, "cssesc": 6 }], 95: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Combinator =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(Combinator, _Node);

        function Combinator(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }

        return Combinator;
      }(_node.default);

      exports.default = Combinator;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 96: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Comment =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(Comment, _Node);

        function Comment(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }

        return Comment;
      }(_node.default);

      exports.default = Comment;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 97: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

      var _attribute = _interopRequireDefault(require("./attribute"));

      var _className = _interopRequireDefault(require("./className"));

      var _combinator = _interopRequireDefault(require("./combinator"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _id = _interopRequireDefault(require("./id"));

      var _nesting = _interopRequireDefault(require("./nesting"));

      var _pseudo = _interopRequireDefault(require("./pseudo"));

      var _root = _interopRequireDefault(require("./root"));

      var _selector = _interopRequireDefault(require("./selector"));

      var _string = _interopRequireDefault(require("./string"));

      var _tag = _interopRequireDefault(require("./tag"));

      var _universal = _interopRequireDefault(require("./universal"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      var attribute = function attribute(opts) {
        return new _attribute.default(opts);
      };

      exports.attribute = attribute;

      var className = function className(opts) {
        return new _className.default(opts);
      };

      exports.className = className;

      var combinator = function combinator(opts) {
        return new _combinator.default(opts);
      };

      exports.combinator = combinator;

      var comment = function comment(opts) {
        return new _comment.default(opts);
      };

      exports.comment = comment;

      var id = function id(opts) {
        return new _id.default(opts);
      };

      exports.id = id;

      var nesting = function nesting(opts) {
        return new _nesting.default(opts);
      };

      exports.nesting = nesting;

      var pseudo = function pseudo(opts) {
        return new _pseudo.default(opts);
      };

      exports.pseudo = pseudo;

      var root = function root(opts) {
        return new _root.default(opts);
      };

      exports.root = root;

      var selector = function selector(opts) {
        return new _selector.default(opts);
      };

      exports.selector = selector;

      var string = function string(opts) {
        return new _string.default(opts);
      };

      exports.string = string;

      var tag = function tag(opts) {
        return new _tag.default(opts);
      };

      exports.tag = tag;

      var universal = function universal(opts) {
        return new _universal.default(opts);
      };

      exports.universal = universal;
    }, { "./attribute": 93, "./className": 94, "./combinator": 95, "./comment": 96, "./id": 100, "./nesting": 103, "./pseudo": 105, "./root": 106, "./selector": 107, "./string": 108, "./tag": 109, "./universal": 111 }], 98: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var types = _interopRequireWildcard(require("./types"));

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}}newObj.default = obj;return newObj;}}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Container =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(Container, _Node);

        function Container(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;

          if (!_this.nodes) {
            _this.nodes = [];
          }

          return _this;
        }

        var _proto = Container.prototype;

        _proto.append = function append(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };

        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };

        _proto.at = function at(index) {
          return this.nodes[index];
        };

        _proto.index = function index(child) {
          if (typeof child === 'number') {
            return child;
          }

          return this.nodes.indexOf(child);
        };

        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = undefined;
          this.nodes.splice(child, 1);
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          return this;
        };

        _proto.removeAll = function removeAll() {
          for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var node = _ref;
            node.parent = undefined;
          }

          this.nodes = [];
          return this;
        };

        _proto.empty = function empty() {
          return this.removeAll();
        };

        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (oldIndex <= index) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index <= oldIndex) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = undefined;
          this.each(function (node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);

              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        }
        /**
         * Return the most specific node at the line and column number given.
         * The source location is based on the original parsed location, locations aren't
         * updated as selector nodes are mutated.
         * 
         * Note that this location is relative to the location of the first character
         * of the selector, and not the location of the selector in the overall document
         * when used in conjunction with postcss.
         *
         * If not found, returns undefined.
         * @param {number} line The line number of the node to find. (1-based index)
         * @param {number} col  The column number of the node to find. (1-based index)
         */;


        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return undefined;
          }
        };

        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };

        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }

          if (!this.indexes) {
            this.indexes = {};
          }

          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;

          if (!this.length) {
            return undefined;
          }

          var index, result;

          while (this.indexes[id] < this.length) {
            index = this.indexes[id];
            result = callback(this.at(index), index);

            if (result === false) {
              break;
            }

            this.indexes[id] += 1;
          }

          delete this.indexes[id];

          if (result === false) {
            return false;
          }
        };

        _proto.walk = function walk(callback) {
          return this.each(function (node, i) {
            var result = callback(node, i);

            if (result !== false && node.length) {
              result = node.walk(callback);
            }

            if (result === false) {
              return false;
            }
          });
        };

        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };

        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;

          return this.walk(function (selector) {
            if (selector.type === types.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };

        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };

        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };

        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ID) {
              return callback.call(_this6, selector);
            }
          });
        };

        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;

          return this.walk(function (selector) {
            if (selector.type === types.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };

        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;

          return this.walk(function (selector) {
            if (selector.type === types.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };

        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;

          return this.walk(function (selector) {
            if (selector.type === types.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };

        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;

          return this.walk(function (selector) {
            if (selector.type === types.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };

        _proto.split = function split(callback) {
          var _this11 = this;

          var current = [];
          return this.reduce(function (memo, node, index) {
            var split = callback.call(_this11, node);
            current.push(node);

            if (split) {
              memo.push(current);
              current = [];
            } else if (index === _this11.length - 1) {
              memo.push(current);
            }

            return memo;
          }, []);
        };

        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };

        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };

        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };

        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };

        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };

        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };

        _proto.toString = function toString() {
          return this.map(String).join('');
        };

        _createClass(Container, [{
          key: "first",
          get: function get() {
            return this.at(0);
          } },
        {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          } },
        {
          key: "length",
          get: function get() {
            return this.nodes.length;
          } }]);


        return Container;
      }(_node.default);

      exports.default = Container;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 99: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.isNode = isNode;
      exports.isPseudoElement = isPseudoElement;
      exports.isPseudoClass = isPseudoClass;
      exports.isContainer = isContainer;
      exports.isNamespace = isNamespace;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

      var _types = require("./types");

      var _IS_TYPE;

      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }

      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }

      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo;
      var isRoot = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      exports.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;

      function isPseudoElement(node) {
        return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after");
      }

      function isPseudoClass(node) {
        return isPseudo(node) && !isPseudoElement(node);
      }

      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }

      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }, { "./types": 110 }], 100: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var ID =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(ID, _Node);

        function ID(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }

        var _proto = ID.prototype;

        _proto.valueToString = function valueToString() {
          return '#' + _Node.prototype.valueToString.call(this);
        };

        return ID;
      }(_node.default);

      exports.default = ID;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 101: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;

      var _types = require("./types");

      Object.keys(_types).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        exports[key] = _types[key];
      });

      var _constructors = require("./constructors");

      Object.keys(_constructors).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        exports[key] = _constructors[key];
      });

      var _guards = require("./guards");

      Object.keys(_guards).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        exports[key] = _guards[key];
      });
    }, { "./constructors": 97, "./guards": 99, "./types": 110 }], 102: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Namespace =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(Namespace, _Node);

        function Namespace() {
          return _Node.apply(this, arguments) || this;
        }

        var _proto = Namespace.prototype;

        _proto.qualifiedName = function qualifiedName(value) {
          if (this.namespace) {
            return this.namespaceString + "|" + value;
          } else {
            return value;
          }
        };

        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };

        _createClass(Namespace, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;

              if (this.raws) {
                delete this.raws.namespace;
              }

              return;
            }

            var escaped = (0, _cssesc.default)(namespace, {
              isIdentifier: true });

            this._namespace = namespace;

            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          } },
        {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            this.namespace = namespace;
          } },
        {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");

              if (ns === true) {
                return '';
              } else {
                return ns;
              }
            } else {
              return '';
            }
          } }]);


        return Namespace;
      }(_node.default);

      exports.default = Namespace;
      ;
      module.exports = exports.default;
    }, { "../util": 117, "./node": 104, "cssesc": 6 }], 103: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Nesting =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(Nesting, _Node);

        function Nesting(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = '&';
          return _this;
        }

        return Nesting;
      }(_node.default);

      exports.default = Nesting;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 104: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _util = require("../util");

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var cloneNode = function cloneNode(obj, parent) {
        if (typeof obj !== 'object' || obj === null) {
          return obj;
        }

        var cloned = new obj.constructor();

        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }

          var value = obj[i];
          var type = typeof value;

          if (i === 'parent' && type === 'object') {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
              return cloneNode(j, cloned);
            });
          } else {
            cloned[i] = cloneNode(value, cloned);
          }
        }

        return cloned;
      };

      var Node =
      /*#__PURE__*/
      function () {
        function Node(opts) {
          if (opts === void 0) {
            opts = {};
          }

          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || '';
          this.spaces.after = this.spaces.after || '';
        }

        var _proto = Node.prototype;

        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }

          this.parent = undefined;
          return this;
        };

        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index in arguments) {
              this.parent.insertBefore(this, arguments[index]);
            }

            this.remove();
          }

          return this;
        };

        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };

        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };

        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }

          var cloned = cloneNode(this);

          for (var name in overrides) {
            cloned[name] = overrides[name];
          }

          return cloned;
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows non standard syntax to be appended to an existing property
         * by specifying the escaped value. By specifying the escaped value,
         * illegal characters are allowed to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped optional. the escaped value of the property.
         */;


        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

          if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name]; // delete any escaped value that was created by the setter.
          }
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows the escaped value to be specified directly, allowing illegal
         * characters to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped the escaped value of the property.
         */;


        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          this.raws[name] = valueEscaped;
        }
        /**
         * When you want a value to passed through to CSS directly. This method
         * deletes the corresponding raw value causing the stringifier to fallback
         * to the unescaped value.
         * @param {string} name the property to set.
         * @param {any} value The value that is both escaped and unescaped.
         */;


        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          if (this.raws) {
            delete this.raws[name];
          }
        }
        /**
         *
         * @param {number} line The number (starting with 1)
         * @param {number} column The column number (starting with 1)
         */;


        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }

            if (this.source.end.line < line) {
              return false;
            }

            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }

            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }

            return true;
          }

          return undefined;
        };

        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };

        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };

        _proto.toString = function toString() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
        };

        _createClass(Node, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

            if (rawSpace === undefined) {
              rawSpace = this.spaces && this.spaces.before;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          } },
        {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

            if (rawSpace === undefined) {
              rawSpace = this.spaces.after;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          } }]);


        return Node;
      }();

      exports.default = Node;
      module.exports = exports.default;
    }, { "../util": 117 }], 105: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Pseudo =
      /*#__PURE__*/
      function (_Container) {
        _inheritsLoose(Pseudo, _Container);

        function Pseudo(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }

        var _proto = Pseudo.prototype;

        _proto.toString = function toString() {
          var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
        };

        return Pseudo;
      }(_container.default);

      exports.default = Pseudo;
      module.exports = exports.default;
    }, { "./container": 98, "./types": 110 }], 106: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Root =
      /*#__PURE__*/
      function (_Container) {
        _inheritsLoose(Root, _Container);

        function Root(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }

        var _proto = Root.prototype;

        _proto.toString = function toString() {
          var str = this.reduce(function (memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(',');
          return this.trailingComma ? str + ',' : str;
        };

        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };

        _createClass(Root, [{
          key: "errorGenerator",
          set: function set(handler) {
            this._error = handler;
          } }]);


        return Root;
      }(_container.default);

      exports.default = Root;
      module.exports = exports.default;
    }, { "./container": 98, "./types": 110 }], 107: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Selector =
      /*#__PURE__*/
      function (_Container) {
        _inheritsLoose(Selector, _Container);

        function Selector(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }

        return Selector;
      }(_container.default);

      exports.default = Selector;
      module.exports = exports.default;
    }, { "./container": 98, "./types": 110 }], 108: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var String =
      /*#__PURE__*/
      function (_Node) {
        _inheritsLoose(String, _Node);

        function String(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }

        return String;
      }(_node.default);

      exports.default = String;
      module.exports = exports.default;
    }, { "./node": 104, "./types": 110 }], 109: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Tag =
      /*#__PURE__*/
      function (_Namespace) {
        _inheritsLoose(Tag, _Namespace);

        function Tag(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }

        return Tag;
      }(_namespace.default);

      exports.default = Tag;
      module.exports = exports.default;
    }, { "./namespace": 102, "./types": 110 }], 110: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
      var TAG = 'tag';
      exports.TAG = TAG;
      var STRING = 'string';
      exports.STRING = STRING;
      var SELECTOR = 'selector';
      exports.SELECTOR = SELECTOR;
      var ROOT = 'root';
      exports.ROOT = ROOT;
      var PSEUDO = 'pseudo';
      exports.PSEUDO = PSEUDO;
      var NESTING = 'nesting';
      exports.NESTING = NESTING;
      var ID = 'id';
      exports.ID = ID;
      var COMMENT = 'comment';
      exports.COMMENT = COMMENT;
      var COMBINATOR = 'combinator';
      exports.COMBINATOR = COMBINATOR;
      var CLASS = 'class';
      exports.CLASS = CLASS;
      var ATTRIBUTE = 'attribute';
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = 'universal';
      exports.UNIVERSAL = UNIVERSAL;
    }, {}], 111: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      var Universal =
      /*#__PURE__*/
      function (_Namespace) {
        _inheritsLoose(Universal, _Namespace);

        function Universal(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = '*';
          return _this;
        }

        return Universal;
      }(_namespace.default);

      exports.default = Universal;
      module.exports = exports.default;
    }, { "./namespace": 102, "./types": 110 }], 112: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = sortAscending;

      function sortAscending(list) {
        return list.sort(function (a, b) {
          return a - b;
        });
      }

      ;
      module.exports = exports.default;
    }, {}], 113: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38; // `&`.charCodeAt(0);

      exports.ampersand = ampersand;
      var asterisk = 42; // `*`.charCodeAt(0);

      exports.asterisk = asterisk;
      var at = 64; // `@`.charCodeAt(0);

      exports.at = at;
      var comma = 44; // `,`.charCodeAt(0);

      exports.comma = comma;
      var colon = 58; // `:`.charCodeAt(0);

      exports.colon = colon;
      var semicolon = 59; // `;`.charCodeAt(0);

      exports.semicolon = semicolon;
      var openParenthesis = 40; // `(`.charCodeAt(0);

      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41; // `)`.charCodeAt(0);

      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91; // `[`.charCodeAt(0);

      exports.openSquare = openSquare;
      var closeSquare = 93; // `]`.charCodeAt(0);

      exports.closeSquare = closeSquare;
      var dollar = 36; // `$`.charCodeAt(0);

      exports.dollar = dollar;
      var tilde = 126; // `~`.charCodeAt(0);

      exports.tilde = tilde;
      var caret = 94; // `^`.charCodeAt(0);

      exports.caret = caret;
      var plus = 43; // `+`.charCodeAt(0);

      exports.plus = plus;
      var equals = 61; // `=`.charCodeAt(0);

      exports.equals = equals;
      var pipe = 124; // `|`.charCodeAt(0);

      exports.pipe = pipe;
      var greaterThan = 62; // `>`.charCodeAt(0);

      exports.greaterThan = greaterThan;
      var space = 32; // ` `.charCodeAt(0);

      exports.space = space;
      var singleQuote = 39; // `'`.charCodeAt(0);

      exports.singleQuote = singleQuote;
      var doubleQuote = 34; // `"`.charCodeAt(0);

      exports.doubleQuote = doubleQuote;
      var slash = 47; // `/`.charCodeAt(0);

      exports.slash = slash;
      var bang = 33; // `!`.charCodeAt(0);

      exports.bang = bang;
      var backslash = 92; // '\\'.charCodeAt(0);

      exports.backslash = backslash;
      var cr = 13; // '\r'.charCodeAt(0);

      exports.cr = cr;
      var feed = 12; // '\f'.charCodeAt(0);

      exports.feed = feed;
      var newline = 10; // '\n'.charCodeAt(0);

      exports.newline = newline;
      var tab = 9; // '\t'.charCodeAt(0);
      // Expose aliases primarily for readability.

      exports.tab = tab;
      var str = singleQuote; // No good single character representation!

      exports.str = str;
      var comment = -1;
      exports.comment = comment;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }, {}], 114: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = tokenize;
      exports.FIELDS = void 0;

      var t = _interopRequireWildcard(require("./tokenTypes"));

      var _unescapable, _wordDelimiters;

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}}newObj.default = obj;return newObj;}}

      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";

      for (var i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      /**
       *  Returns the last index of the bar css word
       * @param {string} css The string in which the word begins
       * @param {number} start The index into the string where word's first letter occurs
       */


      function consumeWord(css, start) {
        var next = start;
        var code;

        do {
          code = css.charCodeAt(next);

          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            // All other characters are part of the word
            next++;
          }
        } while (next < css.length);

        return next - 1;
      }
      /**
       *  Returns the last index of the escape sequence
       * @param {string} css The string in which the sequence begins
       * @param {number} start The index into the string where escape character (`\`) occurs.
       */


      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);

        if (unescapable[code]) {// just consume the escape char
        } else if (hex[code]) {
          var hexDigits = 0; // consume up to 6 hex chars

          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          // the next char is part of the current word
          next++;
        }

        return next;
      }

      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6 };

      exports.FIELDS = FIELDS;

      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css,
        length = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

        function unclosed(what, fix) {
          if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
          }
        }

        while (start < length) {
          code = css.charCodeAt(start);

          if (code === t.newline) {
            offset = start;
            line += 1;
          }

          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);

                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

              tokenType = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            // Consume these characters as single tokens.

            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;

              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);

                if (next === -1) {
                  unclosed('quote', quote);
                }

                escapePos = next;

                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf('*/', start + 2) + 1;

                if (next === 0) {
                  unclosed('comment', '*/');
                }

                content = css.slice(start, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
              }

              end = next + 1;
              break;}
          // Ensure that the token structure remains consistent


          tokens.push([tokenType, // [0] Token type
          line, // [1] Starting line
          start - offset, // [2] Starting column
          endLine, // [3] Ending line
          endColumn, // [4] Ending column
          start, // [5] Start position / Source index
          end]); // Reset offset for the next token

          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }

          start = end;
        }

        return tokens;
      }
    }, { "./tokenTypes": 113 }], 115: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = ensureObject;

      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            obj[prop] = {};
          }

          obj = obj[prop];
        }
      }

      module.exports = exports.default;
    }, {}], 116: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = getProp;

      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            return undefined;
          }

          obj = obj[prop];
        }

        return obj;
      }

      module.exports = exports.default;
    }, {}], 117: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

      var _unesc = _interopRequireDefault(require("./unesc"));

      exports.unesc = _unesc.default;

      var _getProp = _interopRequireDefault(require("./getProp"));

      exports.getProp = _getProp.default;

      var _ensureObject = _interopRequireDefault(require("./ensureObject"));

      exports.ensureObject = _ensureObject.default;

      var _stripComments = _interopRequireDefault(require("./stripComments"));

      exports.stripComments = _stripComments.default;

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
    }, { "./ensureObject": 115, "./getProp": 116, "./stripComments": 118, "./unesc": 119 }], 118: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = stripComments;

      function stripComments(str) {
        var s = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;

        while (commentStart >= 0) {
          s = s + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);

          if (commentEnd < 0) {
            return s;
          }

          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }

        s = s + str.slice(lastEnd);
        return s;
      }

      module.exports = exports.default;
    }, {}], 119: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = unesc;
      var whitespace = '[\\x20\\t\\r\\n\\f]';
      var unescapeRegExp = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig');

      function unesc(str) {
        return str.replace(unescapeRegExp, function (_, escaped, escapedWhitespace) {
          var high = '0x' + escaped - 0x10000; // NaN means non-codepoint
          // Workaround erroneous numeric interpretation of +"0x"
          // eslint-disable-next-line no-self-compare

          return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
          String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
        });
      }

      module.exports = exports.default;
    }, {}], 120: [function (require, module, exports) {
      var parse = require("./parse");
      var walk = require("./walk");
      var stringify = require("./stringify");

      function ValueParser(value) {
        if (this instanceof ValueParser) {
          this.nodes = parse(value);
          return this;
        }
        return new ValueParser(value);
      }

      ValueParser.prototype.toString = function () {
        return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
      };

      ValueParser.prototype.walk = function (cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };

      ValueParser.unit = require("./unit");

      ValueParser.walk = walk;

      ValueParser.stringify = stringify;

      module.exports = ValueParser;

    }, { "./parse": 121, "./stringify": 122, "./unit": 123, "./walk": 124 }], 121: [function (require, module, exports) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;

      module.exports = function (input) {
        var tokens = [];
        var value = input;

        var next,
        quote,
        prev,
        token,
        escape,
        escapePos,
        whitespacePos,
        parenthesesOpenPos;
        var pos = 0;
        var code = value.charCodeAt(pos);
        var max = value.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;

        var name = "";
        var before = "";
        var after = "";

        while (pos < max) {
          // Whitespaces
          if (code <= 32) {
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            token = value.slice(pos, next);

            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
            } else if (
            code === comma ||
            code === colon ||
            code === slash &&
            value.charCodeAt(next + 1) !== star && (
            !parent ||
            parent && parent.type === "function" && parent.value !== "calc"))
            {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                value: token });

            }

            pos = next;

            // Quotes
          } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote: quote };

            do {
              escape = false;
              next = value.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += quote;
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape);
            token.value = value.slice(pos + 1, next);

            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);

            // Comments
          } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            token = {
              type: "comment",
              sourceIndex: pos };


            next = value.indexOf("*/", pos);
            if (next === -1) {
              token.unclosed = true;
              next = value.length;
            }

            token.value = value.slice(pos + 2, next);
            tokens.push(token);

            pos = next + 2;
            code = value.charCodeAt(pos);

            // Operation within calc
          } else if (
          (code === slash || code === star) &&
          parent &&
          parent.type === "function" &&
          parent.value === "calc")
          {
            token = value[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              value: token });

            pos += 1;
            code = value.charCodeAt(pos);

            // Dividers
          } else if (code === slash || code === comma || code === colon) {
            token = value[pos];

            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              value: token,
              before: before,
              after: "" });

            before = "";

            pos += 1;
            code = value.charCodeAt(pos);

            // Open parentheses
          } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value.slice(parenthesesOpenPos + 1, next) };

            pos = next;

            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next -= 1;
              do {
                escape = false;
                next = value.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape = !escape;
                  }
                } else {
                  value += ")";
                  next = value.length - 1;
                  token.unclosed = true;
                }
              } while (escape);
              // Whitespaces before closed
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code = value.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    value: value.slice(pos, whitespacePos + 1) }];


                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    value: value.slice(whitespacePos + 1, next) });

                } else {
                  token.after = value.slice(whitespacePos + 1, next);
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              code = value.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";

            // Close parentheses
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);

            parent.after = after;
            after = "";
            balanced -= 1;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;

            // Words
          } else {
            next = pos;
            do {
              if (code === backslash) {
                next += 1;
              }
              next += 1;
              code = value.charCodeAt(next);
            } while (
            next < max &&
            !(
            code <= 32 ||
            code === singleQuote ||
            code === doubleQuote ||
            code === comma ||
            code === colon ||
            code === slash ||
            code === openParentheses ||
            code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === slash &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === closeParentheses && balanced));


            token = value.slice(pos, next);

            if (openParentheses === code) {
              name = token;
            } else if (
            (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
            plus === token.charCodeAt(1) &&
            isUnicodeRange.test(token.slice(2)))
            {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                value: token });

            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                value: token });

            }

            pos = next;
          }
        }

        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
        }

        return stack[0].nodes;
      };

    }, {}], 122: [function (require, module, exports) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value = node.value;
        var buf;
        var customResult;

        if (custom && (customResult = custom(node)) !== undefined) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return (
            value +
            "(" + (
            node.before || "") +
            buf + (
            node.after || "") + (
            node.unclosed ? "" : ")"));

        }
        return value;
      }

      function stringify(nodes, custom) {
        var result, i;

        if (Array.isArray(nodes)) {
          result = "";
          for (i = nodes.length - 1; ~i; i -= 1) {
            result = stringifyNode(nodes[i], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }

      module.exports = stringify;

    }, {}], 123: [function (require, module, exports) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);

      // Check if three code points would start a number
      // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
      function likeNumber(value) {
        var code = value.charCodeAt(0);
        var nextCode;

        if (code === plus || code === minus) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          var nextNextCode = value.charCodeAt(2);

          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code === dot) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code >= 48 && code <= 57) {
          return true;
        }

        return false;
      }

      // Consume a number
      // https://www.w3.org/TR/css-syntax-3/#consume-number
      module.exports = function (value) {
        var pos = 0;
        var length = value.length;
        var code;
        var nextCode;
        var nextNextCode;

        if (length === 0 || !likeNumber(value)) {
          return false;
        }

        code = value.charCodeAt(pos);

        if (code === plus || code === minus) {
          pos++;
        }

        while (pos < length) {
          code = value.charCodeAt(pos);

          if (code < 48 || code > 57) {
            break;
          }

          pos += 1;
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);

        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        nextNextCode = value.charCodeAt(pos + 2);

        if (
        (code === exp || code === EXP) && (
        nextCode >= 48 && nextCode <= 57 ||
        (nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
        {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        return {
          number: value.slice(0, pos),
          unit: value.slice(pos) };

      };

    }, {}], 124: [function (require, module, exports) {
      module.exports = function walk(nodes, cb, bubble) {
        var i, max, node, result;

        for (i = 0, max = nodes.length; i < max; i += 1) {
          node = nodes[i];
          if (!bubble) {
            result = cb(node, i, nodes);
          }

          if (
          result !== false &&
          node.type === "function" &&
          Array.isArray(node.nodes))
          {
            walk(node.nodes, cb, bubble);
          }

          if (bubble) {
            cb(node, i, nodes);
          }
        }
      };

    }, {}], 125: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      /**
       * Represents an at-rule.
       *
       * If its followed in the CSS by a {} block, this node will have
       * a nodes property representing its children.
       *
       * @extends Container
       *
       * @example
       * const root = postcss.parse('@charset "UTF-8"; @media print {}')
       *
       * const charset = root.first
       * charset.type  //=> 'atrule'
       * charset.nodes //=> undefined
       *
       * const media = root.last
       * media.nodes   //=> []
       */
      var AtRule = /*#__PURE__*/function (_Container) {
        _inheritsLoose(AtRule, _Container);

        function AtRule(defaults) {
          var _this;

          _this = _Container.call(this, defaults) || this;
          _this.type = 'atrule';
          return _this;
        }

        var _proto = AtRule.prototype;

        _proto.append = function append() {
          var _Container$prototype$;

          if (!this.nodes) this.nodes = [];

          for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
            children[_key] = arguments[_key];
          }

          return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
        };

        _proto.prepend = function prepend() {
          var _Container$prototype$2;

          if (!this.nodes) this.nodes = [];

          for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            children[_key2] = arguments[_key2];
          }

          return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
        }
        /**
         * @memberof AtRule#
         * @member {string} name The at-rules name immediately follows the `@`.
         *
         * @example
         * const root  = postcss.parse('@media print {}')
         * media.name //=> 'media'
         * const media = root.first
         */

        /**
         * @memberof AtRule#
         * @member {string} params The at-rules parameters, the values
         *                         that follow the at-rules name but precede
         *                         any {} block.
         *
         * @example
         * const root  = postcss.parse('@media print, screen {}')
         * const media = root.first
         * media.params //=> 'print, screen'
         */

        /**
         * @memberof AtRule#
         * @member {object} raws Information to generate byte-to-byte equal
         *                        node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         *
         * PostCSS cleans at-rule parameters from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('  @media\nprint {\n}')
         * root.first.first.raws //=> { before: '  ',
         *                       //     between: ' ',
         *                       //     afterName: '\n',
         *                       //     after: '\n' }
         */;


        return AtRule;
      }(_container.default);

      var _default = AtRule;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./container": 127 }], 126: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      /**
       * Represents a comment between declarations or statements (rule and at-rules).
       *
       * Comments inside selectors, at-rule parameters, or declaration values
       * will be stored in the `raws` properties explained above.
       *
       * @extends Node
       */
      var Comment = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Comment, _Node);

        function Comment(defaults) {
          var _this;

          _this = _Node.call(this, defaults) || this;
          _this.type = 'comment';
          return _this;
        }
        /**
         * @memberof Comment#
         * @member {string} text The comments text.
         */

        /**
         * @memberof Comment#
         * @member {object} raws Information to generate byte-to-byte equal
         *                       node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text.
         */


        return Comment;
      }(_node.default);

      var _default = Comment;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./node": 134 }], 127: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _declaration = _interopRequireDefault(require("./declaration"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

      function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

      function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      function cleanSource(nodes) {
        return nodes.map(function (i) {
          if (i.nodes) i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }
      /**
       * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
       * inherit some common methods to help work with their children.
       *
       * Note that all containers can store any content. If you write a rule inside
       * a rule, PostCSS will parse it.
       *
       * @extends Node
       * @abstract
       */


      var Container = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Container, _Node);

        function Container() {
          return _Node.apply(this, arguments) || this;
        }

        var _proto = Container.prototype;

        _proto.push = function push(child) {
          child.parent = this;
          this.nodes.push(child);
          return this;
        }
        /**
         * Iterates through the containers immediate children,
         * calling `callback` for each child.
         *
         * Returning `false` in the callback will break iteration.
         *
         * This method only iterates through the containers immediate children.
         * If you need to recursively iterate through all the containers descendant
         * nodes, use {@link Container#walk}.
         *
         * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
         * if you are mutating the array of child nodes during iteration.
         * PostCSS will adjust the current index to match the mutations.
         *
         * @param {childIterator} callback Iterator receives each node and index.
         *
         * @return {false|undefined} Returns `false` if iteration was broke.
         *
         * @example
         * const root = postcss.parse('a { color: black; z-index: 1 }')
         * const rule = root.first
         *
         * for (const decl of rule.nodes) {
         *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
         *   // Cycle will be infinite, because cloneBefore moves the current node
         *   // to the next index
         * }
         *
         * rule.each(decl => {
         *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
         *   // Will be executed only for color and z-index
         * })
         */;


        _proto.each = function each(callback) {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};
          this.lastEach += 1;
          var id = this.lastEach;
          this.indexes[id] = 0;
          if (!this.nodes) return undefined;
          var index, result;

          while (this.indexes[id] < this.nodes.length) {
            index = this.indexes[id];
            result = callback(this.nodes[index], index);
            if (result === false) break;
            this.indexes[id] += 1;
          }

          delete this.indexes[id];
          return result;
        }
        /**
         * Traverses the containers descendant nodes, calling callback
         * for each node.
         *
         * Like container.each(), this method is safe to use
         * if you are mutating arrays during iteration.
         *
         * If you only need to iterate through the containers immediate children,
         * use {@link Container#each}.
         *
         * @param {childIterator} callback Iterator receives each node and index.
         *
         * @return {false|undefined} Returns `false` if iteration was broke.
         *
         * @example
         * root.walk(node => {
         *   // Traverses all descendant nodes.
         * })
         */;


        _proto.walk = function walk(callback) {
          return this.each(function (child, i) {
            var result;

            try {
              result = callback(child, i);
            } catch (e) {
              e.postcssNode = child;

              if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
                var s = child.source;
                e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
              }

              throw e;
            }

            if (result !== false && child.walk) {
              result = child.walk(callback);
            }

            return result;
          });
        }
        /**
         * Traverses the containers descendant nodes, calling callback
         * for each declaration node.
         *
         * If you pass a filter, iteration will only happen over declarations
         * with matching properties.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [prop]   String or regular expression
         *                                 to filter declarations by property name.
         * @param {childIterator} callback Iterator receives each node and index.
         *
         * @return {false|undefined} Returns `false` if iteration was broke.
         *
         * @example
         * root.walkDecls(decl => {
         *   checkPropertySupport(decl.prop)
         * })
         *
         * root.walkDecls('border-radius', decl => {
         *   decl.remove()
         * })
         *
         * root.walkDecls(/^background/, decl => {
         *   decl.value = takeFirstColorFromGradient(decl.value)
         * })
         */;


        _proto.walkDecls = function walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk(function (child, i) {
              if (child.type === 'decl') {
                return callback(child, i);
              }
            });
          }

          if (prop instanceof RegExp) {
            return this.walk(function (child, i) {
              if (child.type === 'decl' && prop.test(child.prop)) {
                return callback(child, i);
              }
            });
          }

          return this.walk(function (child, i) {
            if (child.type === 'decl' && child.prop === prop) {
              return callback(child, i);
            }
          });
        }
        /**
         * Traverses the containers descendant nodes, calling callback
         * for each rule node.
         *
         * If you pass a filter, iteration will only happen over rules
         * with matching selectors.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [selector] String or regular expression
         *                                   to filter rules by selector.
         * @param {childIterator} callback   Iterator receives each node and index.
         *
         * @return {false|undefined} returns `false` if iteration was broke.
         *
         * @example
         * const selectors = []
         * root.walkRules(rule => {
         *   selectors.push(rule.selector)
         * })
         * console.log(`Your CSS uses ${ selectors.length } selectors`)
         */;


        _proto.walkRules = function walkRules(selector, callback) {
          if (!callback) {
            callback = selector;
            return this.walk(function (child, i) {
              if (child.type === 'rule') {
                return callback(child, i);
              }
            });
          }

          if (selector instanceof RegExp) {
            return this.walk(function (child, i) {
              if (child.type === 'rule' && selector.test(child.selector)) {
                return callback(child, i);
              }
            });
          }

          return this.walk(function (child, i) {
            if (child.type === 'rule' && child.selector === selector) {
              return callback(child, i);
            }
          });
        }
        /**
         * Traverses the containers descendant nodes, calling callback
         * for each at-rule node.
         *
         * If you pass a filter, iteration will only happen over at-rules
         * that have matching names.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [name]   String or regular expression
         *                                 to filter at-rules by name.
         * @param {childIterator} callback Iterator receives each node and index.
         *
         * @return {false|undefined} Returns `false` if iteration was broke.
         *
         * @example
         * root.walkAtRules(rule => {
         *   if (isOld(rule.name)) rule.remove()
         * })
         *
         * let first = false
         * root.walkAtRules('charset', rule => {
         *   if (!first) {
         *     first = true
         *   } else {
         *     rule.remove()
         *   }
         * })
         */;


        _proto.walkAtRules = function walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk(function (child, i) {
              if (child.type === 'atrule') {
                return callback(child, i);
              }
            });
          }

          if (name instanceof RegExp) {
            return this.walk(function (child, i) {
              if (child.type === 'atrule' && name.test(child.name)) {
                return callback(child, i);
              }
            });
          }

          return this.walk(function (child, i) {
            if (child.type === 'atrule' && child.name === name) {
              return callback(child, i);
            }
          });
        }
        /**
         * Traverses the containers descendant nodes, calling callback
         * for each comment node.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {childIterator} callback Iterator receives each node and index.
         *
         * @return {false|undefined} Returns `false` if iteration was broke.
         *
         * @example
         * root.walkComments(comment => {
         *   comment.remove()
         * })
         */;


        _proto.walkComments = function walkComments(callback) {
          return this.walk(function (child, i) {
            if (child.type === 'comment') {
              return callback(child, i);
            }
          });
        }
        /**
         * Inserts new nodes to the end of the container.
         *
         * @param {...(Node|object|string|Node[])} children New nodes.
         *
         * @return {Node} This node for methods chain.
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
         * rule.append(decl1, decl2)
         *
         * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
         * root.append({ selector: 'a' })                       // rule
         * rule.append({ prop: 'color', value: 'black' })       // declaration
         * rule.append({ text: 'Comment' })                     // comment
         *
         * root.append('a {}')
         * root.first.append('color: black; z-index: 1')
         */;


        _proto.append = function append() {
          for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
            children[_key] = arguments[_key];
          }

          for (var _i = 0, _children = children; _i < _children.length; _i++) {
            var child = _children[_i];
            var nodes = this.normalize(child, this.last);

            for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
              var node = _step.value;
              this.nodes.push(node);
            }
          }

          return this;
        }
        /**
         * Inserts new nodes to the start of the container.
         *
         * @param {...(Node|object|string|Node[])} children New nodes.
         *
         * @return {Node} This node for methods chain.
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
         * rule.prepend(decl1, decl2)
         *
         * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
         * root.append({ selector: 'a' })                       // rule
         * rule.append({ prop: 'color', value: 'black' })       // declaration
         * rule.append({ text: 'Comment' })                     // comment
         *
         * root.append('a {}')
         * root.first.append('color: black; z-index: 1')
         */;


        _proto.prepend = function prepend() {
          for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            children[_key2] = arguments[_key2];
          }

          children = children.reverse();

          for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {
            var child = _step2.value;
            var nodes = this.normalize(child, this.first, 'prepend').reverse();

            for (var _iterator3 = _createForOfIteratorHelperLoose(nodes), _step3; !(_step3 = _iterator3()).done;) {
              var node = _step3.value;
              this.nodes.unshift(node);
            }

            for (var id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }

          return this;
        };

        _proto.cleanRaws = function cleanRaws(keepBetween) {
          _Node.prototype.cleanRaws.call(this, keepBetween);

          if (this.nodes) {
            for (var _iterator4 = _createForOfIteratorHelperLoose(this.nodes), _step4; !(_step4 = _iterator4()).done;) {
              var node = _step4.value;
              node.cleanRaws(keepBetween);
            }
          }
        }
        /**
         * Insert new node before old node within the container.
         *
         * @param {Node|number} exist             Child or childs index.
         * @param {Node|object|string|Node[]} add New node.
         *
         * @return {Node} This node for methods chain.
         *
         * @example
         * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
         */;


        _proto.insertBefore = function insertBefore(exist, add) {
          exist = this.index(exist);
          var type = exist === 0 ? 'prepend' : false;
          var nodes = this.normalize(add, this.nodes[exist], type).reverse();

          for (var _iterator5 = _createForOfIteratorHelperLoose(nodes), _step5; !(_step5 = _iterator5()).done;) {
            var node = _step5.value;
            this.nodes.splice(exist, 0, node);
          }

          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (exist <= index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          return this;
        }
        /**
         * Insert new node after old node within the container.
         *
         * @param {Node|number} exist             Child or childs index.
         * @param {Node|object|string|Node[]} add New node.
         *
         * @return {Node} This node for methods chain.
         */;


        _proto.insertAfter = function insertAfter(exist, add) {
          exist = this.index(exist);
          var nodes = this.normalize(add, this.nodes[exist]).reverse();

          for (var _iterator6 = _createForOfIteratorHelperLoose(nodes), _step6; !(_step6 = _iterator6()).done;) {
            var node = _step6.value;
            this.nodes.splice(exist + 1, 0, node);
          }

          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (exist < index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          return this;
        }
        /**
         * Removes node from the container and cleans the parent properties
         * from the node and its children.
         *
         * @param {Node|number} child Child or childs index.
         *
         * @return {Node} This node for methods chain
         *
         * @example
         * rule.nodes.length  //=> 5
         * rule.removeChild(decl)
         * rule.nodes.length  //=> 4
         * decl.parent        //=> undefined
         */;


        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.nodes[child].parent = undefined;
          this.nodes.splice(child, 1);
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          return this;
        }
        /**
         * Removes all children from the container
         * and cleans their parent properties.
         *
         * @return {Node} This node for methods chain.
         *
         * @example
         * rule.removeAll()
         * rule.nodes.length //=> 0
         */;


        _proto.removeAll = function removeAll() {
          for (var _iterator7 = _createForOfIteratorHelperLoose(this.nodes), _step7; !(_step7 = _iterator7()).done;) {
            var node = _step7.value;
            node.parent = undefined;
          }

          this.nodes = [];
          return this;
        }
        /**
         * Passes all declaration values within the container that match pattern
         * through callback, replacing those values with the returned result
         * of callback.
         *
         * This method is useful if you are using a custom unit or function
         * and need to iterate through all values.
         *
         * @param {string|RegExp} pattern      Replace pattern.
         * @param {object} opts                Options to speed up the search.
         * @param {string|string[]} opts.props An array of property names.
         * @param {string} opts.fast           String thats used to narrow down
         *                                     values and speed up the regexp search.
         * @param {function|string} callback   String to replace pattern or callback
         *                                     that returns a new value. The callback
         *                                     will receive the same arguments
         *                                     as those passed to a function parameter
         *                                     of `String#replace`.
         *
         * @return {Node} This node for methods chain.
         *
         * @example
         * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
         *   return 15 * parseInt(string) + 'px'
         * })
         */;


        _proto.replaceValues = function replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }

          this.walkDecls(function (decl) {
            if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
            if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;
            decl.value = decl.value.replace(pattern, callback);
          });
          return this;
        }
        /**
         * Returns `true` if callback returns `true`
         * for all of the containers children.
         *
         * @param {childCondition} condition Iterator returns true or false.
         *
         * @return {boolean} Is every child pass condition.
         *
         * @example
         * const noPrefixes = rule.every(i => i.prop[0] !== '-')
         */;


        _proto.every = function every(condition) {
          return this.nodes.every(condition);
        }
        /**
         * Returns `true` if callback returns `true` for (at least) one
         * of the containers children.
         *
         * @param {childCondition} condition Iterator returns true or false.
         *
         * @return {boolean} Is some child pass condition.
         *
         * @example
         * const hasPrefix = rule.some(i => i.prop[0] === '-')
         */;


        _proto.some = function some(condition) {
          return this.nodes.some(condition);
        }
        /**
         * Returns a `child`s index within the {@link Container#nodes} array.
         *
         * @param {Node} child Child of the current container.
         *
         * @return {number} Child index.
         *
         * @example
         * rule.index( rule.nodes[2] ) //=> 2
         */;


        _proto.index = function index(child) {
          if (typeof child === 'number') {
            return child;
          }

          return this.nodes.indexOf(child);
        }
        /**
         * The containers first child.
         *
         * @type {Node}
         *
         * @example
         * rule.first === rules.nodes[0]
         */;


        _proto.normalize = function normalize(nodes, sample) {
          var _this = this;

          if (typeof nodes === 'string') {
            var parse = require('./parse');

            nodes = cleanSource(parse(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);

            for (var _iterator8 = _createForOfIteratorHelperLoose(nodes), _step8; !(_step8 = _iterator8()).done;) {
              var i = _step8.value;
              if (i.parent) i.parent.removeChild(i, 'ignore');
            }
          } else if (nodes.type === 'root') {
            nodes = nodes.nodes.slice(0);

            for (var _iterator9 = _createForOfIteratorHelperLoose(nodes), _step9; !(_step9 = _iterator9()).done;) {
              var _i2 = _step9.value;
              if (_i2.parent) _i2.parent.removeChild(_i2, 'ignore');
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === 'undefined') {
              throw new Error('Value field is missed in node creation');
            } else if (typeof nodes.value !== 'string') {
              nodes.value = String(nodes.value);
            }

            nodes = [new _declaration.default(nodes)];
          } else if (nodes.selector) {
            var Rule = require('./rule');

            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            var AtRule = require('./at-rule');

            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new _comment.default(nodes)];
          } else {
            throw new Error('Unknown node type in node creation');
          }

          var processed = nodes.map(function (i) {
            if (i.parent) i.parent.removeChild(i);

            if (typeof i.raws.before === 'undefined') {
              if (sample && typeof sample.raws.before !== 'undefined') {
                i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
              }
            }

            i.parent = _this;
            return i;
          });
          return processed;
        }
        /**
         * @memberof Container#
         * @member {Node[]} nodes An array containing the containers children.
         *
         * @example
         * const root = postcss.parse('a { color: black }')
         * root.nodes.length           //=> 1
         * root.nodes[0].selector      //=> 'a'
         * root.nodes[0].nodes[0].prop //=> 'color'
         */;


        _createClass(Container, [{
          key: "first",
          get: function get() {
            if (!this.nodes) return undefined;
            return this.nodes[0];
          }
          /**
           * The containers last child.
           *
           * @type {Node}
           *
           * @example
           * rule.last === rule.nodes[rule.nodes.length - 1]
           */ },

        {
          key: "last",
          get: function get() {
            if (!this.nodes) return undefined;
            return this.nodes[this.nodes.length - 1];
          } }]);


        return Container;
      }(_node.default);

      var _default = Container;
      /**
       * @callback childCondition
       * @param {Node} node    Container child.
       * @param {number} index Child index.
       * @param {Node[]} nodes All container children.
       * @return {boolean}
       */

      /**
       * @callback childIterator
       * @param {Node} node    Container child.
       * @param {number} index Child index.
       * @return {false|undefined} Returning `false` will break iteration.
       */

      exports.default = _default;
      module.exports = exports.default;


    }, { "./at-rule": 125, "./comment": 126, "./declaration": 129, "./node": 134, "./parse": 135, "./rule": 142 }], 128: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _supportsColor = _interopRequireDefault(require("supports-color"));

      var _chalk = _interopRequireDefault(require("chalk"));

      var _terminalHighlight = _interopRequireDefault(require("./terminal-highlight"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      function _wrapNativeSuper(Class) {var _cache = typeof Map === "function" ? new Map() : undefined;_wrapNativeSuper = function _wrapNativeSuper(Class) {if (Class === null || !_isNativeFunction(Class)) return Class;if (typeof Class !== "function") {throw new TypeError("Super expression must either be null or a function");}if (typeof _cache !== "undefined") {if (_cache.has(Class)) return _cache.get(Class);_cache.set(Class, Wrapper);}function Wrapper() {return _construct(Class, arguments, _getPrototypeOf(this).constructor);}Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });return _setPrototypeOf(Wrapper, Class);};return _wrapNativeSuper(Class);}

      function _construct(Parent, args, Class) {if (_isNativeReflectConstruct()) {_construct = Reflect.construct;} else {_construct = function _construct(Parent, args, Class) {var a = [null];a.push.apply(a, args);var Constructor = Function.bind.apply(Parent, a);var instance = new Constructor();if (Class) _setPrototypeOf(instance, Class.prototype);return instance;};}return _construct.apply(null, arguments);}

      function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}

      function _isNativeFunction(fn) {return Function.toString.call(fn).indexOf("[native code]") !== -1;}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

      /**
       * The CSS parser throws this error for broken CSS.
       *
       * Custom parsers can throw this error for broken custom syntax using
       * the {@link Node#error} method.
       *
       * PostCSS will use the input source map to detect the original error location.
       * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
       * PostCSS will show the original position in the Sass file.
       *
       * If you need the position in the PostCSS input
       * (e.g., to debug the previous compiler), use `error.input.file`.
       *
       * @example
       * // Catching and checking syntax error
       * try {
       *   postcss.parse('a{')
       * } catch (error) {
       *   if (error.name === 'CssSyntaxError') {
       *     error //=> CssSyntaxError
       *   }
       * }
       *
       * @example
       * // Raising error from plugin
       * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
       */
      var CssSyntaxError = /*#__PURE__*/function (_Error) {
        _inheritsLoose(CssSyntaxError, _Error);

        /**
         * @param {string} message  Error message.
         * @param {number} [line]   Source line of the error.
         * @param {number} [column] Source column of the error.
         * @param {string} [source] Source code of the broken file.
         * @param {string} [file]   Absolute path to the broken file.
         * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
         */
        function CssSyntaxError(message, line, column, source, file, plugin) {
          var _this;

          _this = _Error.call(this, message) || this;
          /**
           * Always equal to `'CssSyntaxError'`. You should always check error type
           * by `error.name === 'CssSyntaxError'`
           * instead of `error instanceof CssSyntaxError`,
           * because npm could have several PostCSS versions.
           *
           * @type {string}
           *
           * @example
           * if (error.name === 'CssSyntaxError') {
           *   error //=> CssSyntaxError
           * }
           */

          _this.name = 'CssSyntaxError';
          /**
           * Error message.
           *
           * @type {string}
           *
           * @example
           * error.message //=> 'Unclosed block'
           */

          _this.reason = message;

          if (file) {
            /**
             * Absolute path to the broken file.
             *
             * @type {string}
             *
             * @example
             * error.file       //=> 'a.sass'
             * error.input.file //=> 'a.css'
             */
            _this.file = file;
          }

          if (source) {
            /**
             * Source code of the broken file.
             *
             * @type {string}
             *
             * @example
             * error.source       //=> 'a { b {} }'
             * error.input.column //=> 'a b { }'
             */
            _this.source = source;
          }

          if (plugin) {
            /**
             * Plugin name, if error came from plugin.
             *
             * @type {string}
             *
             * @example
             * error.plugin //=> 'postcss-vars'
             */
            _this.plugin = plugin;
          }

          if (typeof line !== 'undefined' && typeof column !== 'undefined') {
            /**
             * Source line of the error.
             *
             * @type {number}
             *
             * @example
             * error.line       //=> 2
             * error.input.line //=> 4
             */
            _this.line = line;
            /**
             * Source column of the error.
             *
             * @type {number}
             *
             * @example
             * error.column       //=> 1
             * error.input.column //=> 4
             */

            _this.column = column;
          }

          _this.setMessage();

          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError);
          }

          return _this;
        }

        var _proto = CssSyntaxError.prototype;

        _proto.setMessage = function setMessage() {
          /**
           * Full error text in the GNU error format
           * with plugin, file, line and column.
           *
           * @type {string}
           *
           * @example
           * error.message //=> 'a.css:1:1: Unclosed block'
           */
          this.message = this.plugin ? this.plugin + ': ' : '';
          this.message += this.file ? this.file : '<css input>';

          if (typeof this.line !== 'undefined') {
            this.message += ':' + this.line + ':' + this.column;
          }

          this.message += ': ' + this.reason;
        }
        /**
         * Returns a few lines of CSS source that caused the error.
         *
         * If the CSS has an input source map without `sourceContent`,
         * this method will return an empty string.
         *
         * @param {boolean} [color] Whether arrow will be colored red by terminal
         *                          color codes. By default, PostCSS will detect
         *                          color support by `process.stdout.isTTY`
         *                          and `process.env.NODE_DISABLE_COLORS`.
         *
         * @example
         * error.showSourceCode() //=> "  4 | }
         *                        //      5 | a {
         *                        //    > 6 |   bad
         *                        //        |   ^
         *                        //      7 | }
         *                        //      8 | b {"
         *
         * @return {string} Few lines of CSS source that caused the error.
         */;


        _proto.showSourceCode = function showSourceCode(color) {
          var _this2 = this;

          if (!this.source) return '';
          var css = this.source;

          if (_terminalHighlight.default) {
            if (typeof color === 'undefined') color = _supportsColor.default.stdout;
            if (color) css = (0, _terminalHighlight.default)(css);
          }

          var lines = css.split(/\r?\n/);
          var start = Math.max(this.line - 3, 0);
          var end = Math.min(this.line + 2, lines.length);
          var maxWidth = String(end).length;

          function mark(text) {
            if (color && _chalk.default.red) {
              return _chalk.default.red.bold(text);
            }

            return text;
          }

          function aside(text) {
            if (color && _chalk.default.gray) {
              return _chalk.default.gray(text);
            }

            return text;
          }

          return lines.slice(start, end).map(function (line, index) {
            var number = start + 1 + index;
            var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';

            if (number === _this2.line) {
              var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, ' ');
              return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
            }

            return ' ' + aside(gutter) + line;
          }).join('\n');
        }
        /**
         * Returns error position, message and source code of the broken part.
         *
         * @example
         * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
         *                  //    > 1 | a {
         *                  //        | ^"
         *
         * @return {string} Error position, message and source code.
         */;


        _proto.toString = function toString() {
          var code = this.showSourceCode();

          if (code) {
            code = '\n\n' + code + '\n';
          }

          return this.name + ': ' + this.message + code;
        }
        /**
         * @memberof CssSyntaxError#
         * @member {Input} input Input object with PostCSS internal information
         *                       about input file. If input has source map
         *                       from previous tool, PostCSS will use origin
         *                       (for example, Sass) source. You can use this
         *                       object to get PostCSS input source.
         *
         * @example
         * error.input.file //=> 'a.css'
         * error.file       //=> 'a.sass'
         */;


        return CssSyntaxError;
      }( /*#__PURE__*/_wrapNativeSuper(Error));

      var _default = CssSyntaxError;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./terminal-highlight": 3, "chalk": 3, "supports-color": 3 }], 129: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      /**
       * Represents a CSS declaration.
       *
       * @extends Node
       *
       * @example
       * const root = postcss.parse('a { color: black }')
       * const decl = root.first.first
       * decl.type       //=> 'decl'
       * decl.toString() //=> ' color: black'
       */
      var Declaration = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Declaration, _Node);

        function Declaration(defaults) {
          var _this;

          _this = _Node.call(this, defaults) || this;
          _this.type = 'decl';
          return _this;
        }
        /**
         * @memberof Declaration#
         * @member {string} prop The declarations property name.
         *
         * @example
         * const root = postcss.parse('a { color: black }')
         * const decl = root.first.first
         * decl.prop //=> 'color'
         */

        /**
         * @memberof Declaration#
         * @member {string} value The declarations value.
         *
         * @example
         * const root = postcss.parse('a { color: black }')
         * const decl = root.first.first
         * decl.value //=> 'black'
         */

        /**
         * @memberof Declaration#
         * @member {boolean} important `true` if the declaration
         *                             has an !important annotation.
         *
         * @example
         * const root = postcss.parse('a { color: black !important; color: red }')
         * root.first.first.important //=> true
         * root.first.last.important  //=> undefined
         */

        /**
         * @memberof Declaration#
         * @member {object} raws Information to generate byte-to-byte equal
         *                       node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `between`: the symbols between the property and value
         *   for declarations.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans declaration from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */


        return Declaration;
      }(_node.default);

      var _default = Declaration;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./node": 134 }], 130: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _path = _interopRequireDefault(require("path"));

      var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

      var _previousMap = _interopRequireDefault(require("./previous-map"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var sequence = 0;
      /**
       * Represents the source CSS.
       *
       * @example
       * const root  = postcss.parse(css, { from: file })
       * const input = root.source.input
       */

      var Input = /*#__PURE__*/function () {
        /**
         * @param {string} css    Input CSS source.
         * @param {object} [opts] {@link Processor#process} options.
         */
        function Input(css, opts) {
          if (opts === void 0) {
            opts = {};
          }

          if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {
            throw new Error("PostCSS received " + css + " instead of CSS string");
          }
          /**
           * Input CSS source
           *
           * @type {string}
           *
           * @example
           * const input = postcss.parse('a{}', { from: file }).input
           * input.css //=> "a{}"
           */


          this.css = css.toString();

          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }

          if (opts.from) {
            if (/^\w+:\/\//.test(opts.from) || _path.default.isAbsolute(opts.from)) {
              /**
               * The absolute path to the CSS source file defined
               * with the `from` option.
               *
               * @type {string}
               *
               * @example
               * const root = postcss.parse(css, { from: 'a.css' })
               * root.source.input.file //=> '/home/ai/a.css'
               */
              this.file = opts.from;
            } else {
              this.file = _path.default.resolve(opts.from);
            }
          }

          var map = new _previousMap.default(this.css, opts);

          if (map.text) {
            /**
             * The input source map passed from a compilation step before PostCSS
             * (for example, from Sass compiler).
             *
             * @type {PreviousMap}
             *
             * @example
             * root.source.input.map.consumer().sources //=> ['a.sass']
             */
            this.map = map;
            var file = map.consumer().file;
            if (!this.file && file) this.file = this.mapResolve(file);
          }

          if (!this.file) {
            sequence += 1;
            /**
             * The unique ID of the CSS source. It will be created if `from` option
             * is not provided (because PostCSS does not know the file path).
             *
             * @type {string}
             *
             * @example
             * const root = postcss.parse(css)
             * root.source.input.file //=> undefined
             * root.source.input.id   //=> "<input css 1>"
             */

            this.id = '<input css ' + sequence + '>';
          }

          if (this.map) this.map.file = this.from;
        }

        var _proto = Input.prototype;

        _proto.error = function error(message, line, column, opts) {
          if (opts === void 0) {
            opts = {};
          }

          var result;
          var origin = this.origin(line, column);

          if (origin) {
            result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
          } else {
            result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);
          }

          result.input = {
            line: line,
            column: column,
            source: this.css };

          if (this.file) result.input.file = this.file;
          return result;
        }
        /**
         * Reads the input source map and returns a symbol position
         * in the input source (e.g., in a Sass file that was compiled
         * to CSS before being passed to PostCSS).
         *
         * @param {number} line   Line in input CSS.
         * @param {number} column Column in input CSS.
         *
         * @return {filePosition} Position in input source.
         *
         * @example
         * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
         */;


        _proto.origin = function origin(line, column) {
          if (!this.map) return false;
          var consumer = this.map.consumer();
          var from = consumer.originalPositionFor({
            line: line,
            column: column });

          if (!from.source) return false;
          var result = {
            file: this.mapResolve(from.source),
            line: from.line,
            column: from.column };

          var source = consumer.sourceContentFor(from.source);
          if (source) result.source = source;
          return result;
        };

        _proto.mapResolve = function mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }

          return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);
        }
        /**
         * The CSS source identifier. Contains {@link Input#file} if the user
         * set the `from` option, or {@link Input#id} if they did not.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.from //=> "/home/ai/a.css"
         *
         * const root = postcss.parse(css)
         * root.source.input.from //=> "<input css 1>"
         */;


        _createClass(Input, [{
          key: "from",
          get: function get() {
            return this.file || this.id;
          } }]);


        return Input;
      }();

      var _default = Input;
      /**
       * @typedef  {object} filePosition
       * @property {string} file   Path to file.
       * @property {number} line   Source line in file.
       * @property {number} column Source column in file.
       */

      exports.default = _default;
      module.exports = exports.default;


    }, { "./css-syntax-error": 128, "./previous-map": 138, "path": 74 }], 131: [function (require, module, exports) {
      (function (process) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _mapGenerator = _interopRequireDefault(require("./map-generator"));

          var _stringify2 = _interopRequireDefault(require("./stringify"));

          var _warnOnce = _interopRequireDefault(require("./warn-once"));

          var _result = _interopRequireDefault(require("./result"));

          var _parse = _interopRequireDefault(require("./parse"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

          function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

          function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

          function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

          function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

          function isPromise(obj) {
            return typeof obj === 'object' && typeof obj.then === 'function';
          }
          /**
           * A Promise proxy for the result of PostCSS transformations.
           *
           * A `LazyResult` instance is returned by {@link Processor#process}.
           *
           * @example
           * const lazy = postcss([autoprefixer]).process(css)
           */


          var LazyResult = /*#__PURE__*/function () {
            function LazyResult(processor, css, opts) {
              this.stringified = false;
              this.processed = false;
              var root;

              if (typeof css === 'object' && css !== null && css.type === 'root') {
                root = css;
              } else if (css instanceof LazyResult || css instanceof _result.default) {
                root = css.root;

                if (css.map) {
                  if (typeof opts.map === 'undefined') opts.map = {};
                  if (!opts.map.inline) opts.map.inline = false;
                  opts.map.prev = css.map;
                }
              } else {
                var parser = _parse.default;
                if (opts.syntax) parser = opts.syntax.parse;
                if (opts.parser) parser = opts.parser;
                if (parser.parse) parser = parser.parse;

                try {
                  root = parser(css, opts);
                } catch (error) {
                  this.error = error;
                }
              }

              this.result = new _result.default(processor, root, opts);
            }
            /**
             * Returns a {@link Processor} instance, which will be used
             * for CSS transformations.
             *
             * @type {Processor}
             */


            var _proto = LazyResult.prototype;

            /**
             * Processes input CSS through synchronous plugins
             * and calls {@link Result#warnings()}.
             *
             * @return {Warning[]} Warnings from plugins.
             */
            _proto.warnings = function warnings() {
              return this.sync().warnings();
            }
            /**
             * Alias for the {@link LazyResult#css} property.
             *
             * @example
             * lazy + '' === lazy.css
             *
             * @return {string} Output CSS.
             */;


            _proto.toString = function toString() {
              return this.css;
            }
            /**
             * Processes input CSS through synchronous and asynchronous plugins
             * and calls `onFulfilled` with a Result instance. If a plugin throws
             * an error, the `onRejected` callback will be executed.
             *
             * It implements standard Promise API.
             *
             * @param {onFulfilled} onFulfilled Callback will be executed
             *                                  when all plugins will finish work.
             * @param {onRejected}  onRejected  Callback will be executed on any error.
             *
             * @return {Promise} Promise API to make queue.
             *
             * @example
             * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
             *   console.log(result.css)
             * })
             */;


            _proto.then = function then(onFulfilled, onRejected) {
              if (process.env.NODE_ENV !== 'production') {
                if (!('from' in this.opts)) {
                  (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
                }
              }

              return this.async().then(onFulfilled, onRejected);
            }
            /**
             * Processes input CSS through synchronous and asynchronous plugins
             * and calls onRejected for each error thrown in any plugin.
             *
             * It implements standard Promise API.
             *
             * @param {onRejected} onRejected Callback will be executed on any error.
             *
             * @return {Promise} Promise API to make queue.
             *
             * @example
             * postcss([autoprefixer]).process(css).then(result => {
             *   console.log(result.css)
             * }).catch(error => {
             *   console.error(error)
             * })
             */;


            _proto.catch = function _catch(onRejected) {
              return this.async().catch(onRejected);
            }
            /**
             * Processes input CSS through synchronous and asynchronous plugins
             * and calls onFinally on any error or when all plugins will finish work.
             *
             * It implements standard Promise API.
             *
             * @param {onFinally} onFinally Callback will be executed on any error or
             *                              when all plugins will finish work.
             *
             * @return {Promise} Promise API to make queue.
             *
             * @example
             * postcss([autoprefixer]).process(css).finally(() => {
             *   console.log('processing ended')
             * })
             */;


            _proto.finally = function _finally(onFinally) {
              return this.async().then(onFinally, onFinally);
            };

            _proto.handleError = function handleError(error, plugin) {
              try {
                this.error = error;

                if (error.name === 'CssSyntaxError' && !error.plugin) {
                  error.plugin = plugin.postcssPlugin;
                  error.setMessage();
                } else if (plugin.postcssVersion) {
                  if (process.env.NODE_ENV !== 'production') {
                    var pluginName = plugin.postcssPlugin;
                    var pluginVer = plugin.postcssVersion;
                    var runtimeVer = this.result.processor.version;
                    var a = pluginVer.split('.');
                    var b = runtimeVer.split('.');

                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                      console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
                    }
                  }
                }
              } catch (err) {
                if (console && console.error) console.error(err);
              }
            };

            _proto.asyncTick = function asyncTick(resolve, reject) {
              var _this = this;

              if (this.plugin >= this.processor.plugins.length) {
                this.processed = true;
                return resolve();
              }

              try {
                var plugin = this.processor.plugins[this.plugin];
                var promise = this.run(plugin);
                this.plugin += 1;

                if (isPromise(promise)) {
                  promise.then(function () {
                    _this.asyncTick(resolve, reject);
                  }).catch(function (error) {
                    _this.handleError(error, plugin);

                    _this.processed = true;
                    reject(error);
                  });
                } else {
                  this.asyncTick(resolve, reject);
                }
              } catch (error) {
                this.processed = true;
                reject(error);
              }
            };

            _proto.async = function async() {
              var _this2 = this;

              if (this.processed) {
                return new Promise(function (resolve, reject) {
                  if (_this2.error) {
                    reject(_this2.error);
                  } else {
                    resolve(_this2.stringify());
                  }
                });
              }

              if (this.processing) {
                return this.processing;
              }

              this.processing = new Promise(function (resolve, reject) {
                if (_this2.error) return reject(_this2.error);
                _this2.plugin = 0;

                _this2.asyncTick(resolve, reject);
              }).then(function () {
                _this2.processed = true;
                return _this2.stringify();
              });
              return this.processing;
            };

            _proto.sync = function sync() {
              if (this.processed) return this.result;
              this.processed = true;

              if (this.processing) {
                throw new Error('Use process(css).then(cb) to work with async plugins');
              }

              if (this.error) throw this.error;

              for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done;) {
                var plugin = _step.value;
                var promise = this.run(plugin);

                if (isPromise(promise)) {
                  throw new Error('Use process(css).then(cb) to work with async plugins');
                }
              }

              return this.result;
            };

            _proto.run = function run(plugin) {
              this.result.lastPlugin = plugin;

              try {
                return plugin(this.result.root, this.result);
              } catch (error) {
                this.handleError(error, plugin);
                throw error;
              }
            };

            _proto.stringify = function stringify() {
              if (this.stringified) return this.result;
              this.stringified = true;
              this.sync();
              var opts = this.result.opts;
              var str = _stringify2.default;
              if (opts.syntax) str = opts.syntax.stringify;
              if (opts.stringifier) str = opts.stringifier;
              if (str.stringify) str = str.stringify;
              var map = new _mapGenerator.default(str, this.result.root, this.result.opts);
              var data = map.generate();
              this.result.css = data[0];
              this.result.map = data[1];
              return this.result;
            };

            _createClass(LazyResult, [{
              key: "processor",
              get: function get() {
                return this.result.processor;
              }
              /**
               * Options from the {@link Processor#process} call.
               *
               * @type {processOptions}
               */ },

            {
              key: "opts",
              get: function get() {
                return this.result.opts;
              }
              /**
               * Processes input CSS through synchronous plugins, converts `Root`
               * to a CSS string and returns {@link Result#css}.
               *
               * This property will only work with synchronous plugins.
               * If the processor contains any asynchronous plugins
               * it will throw an error. This is why this method is only
               * for debug purpose, you should always use {@link LazyResult#then}.
               *
               * @type {string}
               * @see Result#css
               */ },

            {
              key: "css",
              get: function get() {
                return this.stringify().css;
              }
              /**
               * An alias for the `css` property. Use it with syntaxes
               * that generate non-CSS output.
               *
               * This property will only work with synchronous plugins.
               * If the processor contains any asynchronous plugins
               * it will throw an error. This is why this method is only
               * for debug purpose, you should always use {@link LazyResult#then}.
               *
               * @type {string}
               * @see Result#content
               */ },

            {
              key: "content",
              get: function get() {
                return this.stringify().content;
              }
              /**
               * Processes input CSS through synchronous plugins
               * and returns {@link Result#map}.
               *
               * This property will only work with synchronous plugins.
               * If the processor contains any asynchronous plugins
               * it will throw an error. This is why this method is only
               * for debug purpose, you should always use {@link LazyResult#then}.
               *
               * @type {SourceMapGenerator}
               * @see Result#map
               */ },

            {
              key: "map",
              get: function get() {
                return this.stringify().map;
              }
              /**
               * Processes input CSS through synchronous plugins
               * and returns {@link Result#root}.
               *
               * This property will only work with synchronous plugins. If the processor
               * contains any asynchronous plugins it will throw an error.
               *
               * This is why this method is only for debug purpose,
               * you should always use {@link LazyResult#then}.
               *
               * @type {Root}
               * @see Result#root
               */ },

            {
              key: "root",
              get: function get() {
                return this.sync().root;
              }
              /**
               * Processes input CSS through synchronous plugins
               * and returns {@link Result#messages}.
               *
               * This property will only work with synchronous plugins. If the processor
               * contains any asynchronous plugins it will throw an error.
               *
               * This is why this method is only for debug purpose,
               * you should always use {@link LazyResult#then}.
               *
               * @type {Message[]}
               * @see Result#messages
               */ },

            {
              key: "messages",
              get: function get() {
                return this.sync().messages;
              } }]);


            return LazyResult;
          }();

          var _default = LazyResult;
          /**
           * @callback onFulfilled
           * @param {Result} result
           */

          /**
           * @callback onRejected
           * @param {Error} error
           */

          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require('_process'));
    }, { "./map-generator": 133, "./parse": 135, "./result": 140, "./stringify": 144, "./warn-once": 147, "_process": 160 }], 132: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      /**
       * Contains helpers for safely splitting lists of CSS values,
       * preserving parentheses and quotes.
       *
       * @example
       * const list = postcss.list
       *
       * @namespace list
       */
      var list = {
        split: function split(string, separators, last) {
          var array = [];
          var current = '';
          var split = false;
          var func = 0;
          var quote = false;
          var escape = false;

          for (var i = 0; i < string.length; i++) {
            var letter = string[i];

            if (quote) {
              if (escape) {
                escape = false;
              } else if (letter === '\\') {
                escape = true;
              } else if (letter === quote) {
                quote = false;
              }
            } else if (letter === '"' || letter === '\'') {
              quote = letter;
            } else if (letter === '(') {
              func += 1;
            } else if (letter === ')') {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.indexOf(letter) !== -1) split = true;
            }

            if (split) {
              if (current !== '') array.push(current.trim());
              current = '';
              split = false;
            } else {
              current += letter;
            }
          }

          if (last || current !== '') array.push(current.trim());
          return array;
        },

        /**
         * Safely splits space-separated values (such as those for `background`,
         * `border-radius`, and other shorthand properties).
         *
         * @param {string} string Space-separated values.
         *
         * @return {string[]} Split values.
         *
         * @example
         * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
         */
        space: function space(string) {
          var spaces = [' ', '\n', '\t'];
          return list.split(string, spaces);
        },

        /**
         * Safely splits comma-separated values (such as those for `transition-*`
         * and `background` properties).
         *
         * @param {string} string Comma-separated values.
         *
         * @return {string[]} Split values.
         *
         * @example
         * postcss.list.comma('black, linear-gradient(white, black)')
         * //=> ['black', 'linear-gradient(white, black)']
         */
        comma: function comma(string) {
          return list.split(string, [','], true);
        } };

      var _default = list;
      exports.default = _default;
      module.exports = exports.default;


    }, {}], 133: [function (require, module, exports) {
      (function (Buffer) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _sourceMap = _interopRequireDefault(require("source-map"));

          var _path = _interopRequireDefault(require("path"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

          function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

          function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

          var MapGenerator = /*#__PURE__*/function () {
            function MapGenerator(stringify, root, opts) {
              this.stringify = stringify;
              this.mapOpts = opts.map || {};
              this.root = root;
              this.opts = opts;
            }

            var _proto = MapGenerator.prototype;

            _proto.isMap = function isMap() {
              if (typeof this.opts.map !== 'undefined') {
                return !!this.opts.map;
              }

              return this.previous().length > 0;
            };

            _proto.previous = function previous() {
              var _this = this;

              if (!this.previousMaps) {
                this.previousMaps = [];
                this.root.walk(function (node) {
                  if (node.source && node.source.input.map) {
                    var map = node.source.input.map;

                    if (_this.previousMaps.indexOf(map) === -1) {
                      _this.previousMaps.push(map);
                    }
                  }
                });
              }

              return this.previousMaps;
            };

            _proto.isInline = function isInline() {
              if (typeof this.mapOpts.inline !== 'undefined') {
                return this.mapOpts.inline;
              }

              var annotation = this.mapOpts.annotation;

              if (typeof annotation !== 'undefined' && annotation !== true) {
                return false;
              }

              if (this.previous().length) {
                return this.previous().some(function (i) {
                  return i.inline;
                });
              }

              return true;
            };

            _proto.isSourcesContent = function isSourcesContent() {
              if (typeof this.mapOpts.sourcesContent !== 'undefined') {
                return this.mapOpts.sourcesContent;
              }

              if (this.previous().length) {
                return this.previous().some(function (i) {
                  return i.withContent();
                });
              }

              return true;
            };

            _proto.clearAnnotation = function clearAnnotation() {
              if (this.mapOpts.annotation === false) return;
              var node;

              for (var i = this.root.nodes.length - 1; i >= 0; i--) {
                node = this.root.nodes[i];
                if (node.type !== 'comment') continue;

                if (node.text.indexOf('# sourceMappingURL=') === 0) {
                  this.root.removeChild(i);
                }
              }
            };

            _proto.setSourcesContent = function setSourcesContent() {
              var _this2 = this;

              var already = {};
              this.root.walk(function (node) {
                if (node.source) {
                  var from = node.source.input.from;

                  if (from && !already[from]) {
                    already[from] = true;

                    var relative = _this2.relative(from);

                    _this2.map.setSourceContent(relative, node.source.input.css);
                  }
                }
              });
            };

            _proto.applyPrevMaps = function applyPrevMaps() {
              for (var _iterator = _createForOfIteratorHelperLoose(this.previous()), _step; !(_step = _iterator()).done;) {
                var prev = _step.value;
                var from = this.relative(prev.file);

                var root = prev.root || _path.default.dirname(prev.file);

                var map = void 0;

                if (this.mapOpts.sourcesContent === false) {
                  map = new _sourceMap.default.SourceMapConsumer(prev.text);

                  if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                      return null;
                    });
                  }
                } else {
                  map = prev.consumer();
                }

                this.map.applySourceMap(map, from, this.relative(root));
              }
            };

            _proto.isAnnotation = function isAnnotation() {
              if (this.isInline()) {
                return true;
              }

              if (typeof this.mapOpts.annotation !== 'undefined') {
                return this.mapOpts.annotation;
              }

              if (this.previous().length) {
                return this.previous().some(function (i) {
                  return i.annotation;
                });
              }

              return true;
            };

            _proto.toBase64 = function toBase64(str) {
              if (Buffer) {
                return Buffer.from(str).toString('base64');
              }

              return window.btoa(unescape(encodeURIComponent(str)));
            };

            _proto.addAnnotation = function addAnnotation() {
              var content;

              if (this.isInline()) {
                content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
              } else if (typeof this.mapOpts.annotation === 'string') {
                content = this.mapOpts.annotation;
              } else {
                content = this.outputFile() + '.map';
              }

              var eol = '\n';
              if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';
              this.css += eol + '/*# sourceMappingURL=' + content + ' */';
            };

            _proto.outputFile = function outputFile() {
              if (this.opts.to) {
                return this.relative(this.opts.to);
              }

              if (this.opts.from) {
                return this.relative(this.opts.from);
              }

              return 'to.css';
            };

            _proto.generateMap = function generateMap() {
              this.generateString();
              if (this.isSourcesContent()) this.setSourcesContent();
              if (this.previous().length > 0) this.applyPrevMaps();
              if (this.isAnnotation()) this.addAnnotation();

              if (this.isInline()) {
                return [this.css];
              }

              return [this.css, this.map];
            };

            _proto.relative = function relative(file) {
              if (file.indexOf('<') === 0) return file;
              if (/^\w+:\/\//.test(file)) return file;
              var from = this.opts.to ? _path.default.dirname(this.opts.to) : '.';

              if (typeof this.mapOpts.annotation === 'string') {
                from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));
              }

              file = _path.default.relative(from, file);

              if (_path.default.sep === '\\') {
                return file.replace(/\\/g, '/');
              }

              return file;
            };

            _proto.sourcePath = function sourcePath(node) {
              if (this.mapOpts.from) {
                return this.mapOpts.from;
              }

              return this.relative(node.source.input.from);
            };

            _proto.generateString = function generateString() {
              var _this3 = this;

              this.css = '';
              this.map = new _sourceMap.default.SourceMapGenerator({
                file: this.outputFile() });

              var line = 1;
              var column = 1;
              var lines, last;
              this.stringify(this.root, function (str, node, type) {
                _this3.css += str;

                if (node && type !== 'end') {
                  if (node.source && node.source.start) {
                    _this3.map.addMapping({
                      source: _this3.sourcePath(node),
                      generated: {
                        line: line,
                        column: column - 1 },

                      original: {
                        line: node.source.start.line,
                        column: node.source.start.column - 1 } });


                  } else {
                    _this3.map.addMapping({
                      source: '<no source>',
                      original: {
                        line: 1,
                        column: 0 },

                      generated: {
                        line: line,
                        column: column - 1 } });


                  }
                }

                lines = str.match(/\n/g);

                if (lines) {
                  line += lines.length;
                  last = str.lastIndexOf('\n');
                  column = str.length - last;
                } else {
                  column += str.length;
                }

                if (node && type !== 'start') {
                  var p = node.parent || {
                    raws: {} };


                  if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
                    if (node.source && node.source.end) {
                      _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: {
                          line: line,
                          column: column - 2 },

                        original: {
                          line: node.source.end.line,
                          column: node.source.end.column - 1 } });


                    } else {
                      _this3.map.addMapping({
                        source: '<no source>',
                        original: {
                          line: 1,
                          column: 0 },

                        generated: {
                          line: line,
                          column: column - 1 } });


                    }
                  }
                }
              });
            };

            _proto.generate = function generate() {
              this.clearAnnotation();

              if (this.isMap()) {
                return this.generateMap();
              }

              var result = '';
              this.stringify(this.root, function (i) {
                result += i;
              });
              return [result];
            };

            return MapGenerator;
          }();

          var _default = MapGenerator;
          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "buffer": 4, "path": 74, "source-map": 159 }], 134: [function (require, module, exports) {
      (function (process) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

          var _stringifier = _interopRequireDefault(require("./stringifier"));

          var _stringify = _interopRequireDefault(require("./stringify"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function cloneNode(obj, parent) {
            var cloned = new obj.constructor();

            for (var i in obj) {
              if (!obj.hasOwnProperty(i)) continue;
              var value = obj[i];
              var type = typeof value;

              if (i === 'parent' && type === 'object') {
                if (parent) cloned[i] = parent;
              } else if (i === 'source') {
                cloned[i] = value;
              } else if (value instanceof Array) {
                cloned[i] = value.map(function (j) {
                  return cloneNode(j, cloned);
                });
              } else {
                if (type === 'object' && value !== null) value = cloneNode(value);
                cloned[i] = value;
              }
            }

            return cloned;
          }
          /**
           * All node classes inherit the following common methods.
           *
           * @abstract
           */


          var Node = /*#__PURE__*/function () {
            /**
             * @param {object} [defaults] Value for node properties.
             */
            function Node(defaults) {
              if (defaults === void 0) {
                defaults = {};
              }

              this.raws = {};

              if (process.env.NODE_ENV !== 'production') {
                if (typeof defaults !== 'object' && typeof defaults !== 'undefined') {
                  throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
                }
              }

              for (var name in defaults) {
                this[name] = defaults[name];
              }
            }
            /**
             * Returns a `CssSyntaxError` instance containing the original position
             * of the node in the source, showing line and column numbers and also
             * a small excerpt to facilitate debugging.
             *
             * If present, an input source map will be used to get the original position
             * of the source, even from a previous compilation step
             * (e.g., from Sass compilation).
             *
             * This method produces very useful error messages.
             *
             * @param {string} message     Error description.
             * @param {object} [opts]      Options.
             * @param {string} opts.plugin Plugin name that created this error.
             *                             PostCSS will set it automatically.
             * @param {string} opts.word   A word inside a nodes string that should
             *                             be highlighted as the source of the error.
             * @param {number} opts.index  An index inside a nodes string that should
             *                             be highlighted as the source of the error.
             *
             * @return {CssSyntaxError} Error object to throw it.
             *
             * @example
             * if (!variables[name]) {
             *   throw decl.error('Unknown variable ' + name, { word: name })
             *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
             *   //   color: $black
             *   // a
             *   //          ^
             *   //   background: white
             * }
             */


            var _proto = Node.prototype;

            _proto.error = function error(message, opts) {
              if (opts === void 0) {
                opts = {};
              }

              if (this.source) {
                var pos = this.positionBy(opts);
                return this.source.input.error(message, pos.line, pos.column, opts);
              }

              return new _cssSyntaxError.default(message);
            }
            /**
             * This method is provided as a convenience wrapper for {@link Result#warn}.
             *
             * @param {Result} result      The {@link Result} instance
             *                             that will receive the warning.
             * @param {string} text        Warning message.
             * @param {object} [opts]      Options
             * @param {string} opts.plugin Plugin name that created this warning.
             *                             PostCSS will set it automatically.
             * @param {string} opts.word   A word inside a nodes string that should
             *                             be highlighted as the source of the warning.
             * @param {number} opts.index  An index inside a nodes string that should
             *                             be highlighted as the source of the warning.
             *
             * @return {Warning} Created warning object.
             *
             * @example
             * const plugin = postcss.plugin('postcss-deprecated', () => {
             *   return (root, result) => {
             *     root.walkDecls('bad', decl => {
             *       decl.warn(result, 'Deprecated property bad')
             *     })
             *   }
             * })
             */;


            _proto.warn = function warn(result, text, opts) {
              var data = {
                node: this };


              for (var i in opts) {
                data[i] = opts[i];
              }

              return result.warn(text, data);
            }
            /**
             * Removes the node from its parent and cleans the parent properties
             * from the node and its children.
             *
             * @example
             * if (decl.prop.match(/^-webkit-/)) {
             *   decl.remove()
             * }
             *
             * @return {Node} Node to make calls chain.
             */;


            _proto.remove = function remove() {
              if (this.parent) {
                this.parent.removeChild(this);
              }

              this.parent = undefined;
              return this;
            }
            /**
             * Returns a CSS string representing the node.
             *
             * @param {stringifier|syntax} [stringifier] A syntax to use
             *                                           in string generation.
             *
             * @return {string} CSS string of this node.
             *
             * @example
             * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
             */;


            _proto.toString = function toString(stringifier) {
              if (stringifier === void 0) {
                stringifier = _stringify.default;
              }

              if (stringifier.stringify) stringifier = stringifier.stringify;
              var result = '';
              stringifier(this, function (i) {
                result += i;
              });
              return result;
            }
            /**
             * Returns an exact clone of the node.
             *
             * The resulting cloned node and its (cloned) children will retain
             * code style properties.
             *
             * @param {object} [overrides] New properties to override in the clone.
             *
             * @example
             * decl.raws.before    //=> "\n  "
             * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
             * cloned.raws.before  //=> "\n  "
             * cloned.toString()   //=> -moz-transform: scale(0)
             *
             * @return {Node} Clone of the node.
             */;


            _proto.clone = function clone(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }

              var cloned = cloneNode(this);

              for (var name in overrides) {
                cloned[name] = overrides[name];
              }

              return cloned;
            }
            /**
             * Shortcut to clone the node and insert the resulting cloned node
             * before the current node.
             *
             * @param {object} [overrides] Mew properties to override in the clone.
             *
             * @example
             * decl.cloneBefore({ prop: '-moz-' + decl.prop })
             *
             * @return {Node} New node
             */;


            _proto.cloneBefore = function cloneBefore(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }

              var cloned = this.clone(overrides);
              this.parent.insertBefore(this, cloned);
              return cloned;
            }
            /**
             * Shortcut to clone the node and insert the resulting cloned node
             * after the current node.
             *
             * @param {object} [overrides] New properties to override in the clone.
             *
             * @return {Node} New node.
             */;


            _proto.cloneAfter = function cloneAfter(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }

              var cloned = this.clone(overrides);
              this.parent.insertAfter(this, cloned);
              return cloned;
            }
            /**
             * Inserts node(s) before the current node and removes the current node.
             *
             * @param {...Node} nodes Mode(s) to replace current one.
             *
             * @example
             * if (atrule.name === 'mixin') {
             *   atrule.replaceWith(mixinRules[atrule.params])
             * }
             *
             * @return {Node} Current node to methods chain.
             */;


            _proto.replaceWith = function replaceWith() {
              if (this.parent) {
                for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
                  nodes[_key] = arguments[_key];
                }

                for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
                  var node = _nodes[_i];
                  this.parent.insertBefore(this, node);
                }

                this.remove();
              }

              return this;
            }
            /**
             * Returns the next child of the nodes parent.
             * Returns `undefined` if the current node is the last child.
             *
             * @return {Node|undefined} Next node.
             *
             * @example
             * if (comment.text === 'delete next') {
             *   const next = comment.next()
             *   if (next) {
             *     next.remove()
             *   }
             * }
             */;


            _proto.next = function next() {
              if (!this.parent) return undefined;
              var index = this.parent.index(this);
              return this.parent.nodes[index + 1];
            }
            /**
             * Returns the previous child of the nodes parent.
             * Returns `undefined` if the current node is the first child.
             *
             * @return {Node|undefined} Previous node.
             *
             * @example
             * const annotation = decl.prev()
             * if (annotation.type === 'comment') {
             *   readAnnotation(annotation.text)
             * }
             */;


            _proto.prev = function prev() {
              if (!this.parent) return undefined;
              var index = this.parent.index(this);
              return this.parent.nodes[index - 1];
            }
            /**
             * Insert new node before current node to current nodes parent.
             *
             * Just alias for `node.parent.insertBefore(node, add)`.
             *
             * @param {Node|object|string|Node[]} add New node.
             *
             * @return {Node} This node for methods chain.
             *
             * @example
             * decl.before('content: ""')
             */;


            _proto.before = function before(add) {
              this.parent.insertBefore(this, add);
              return this;
            }
            /**
             * Insert new node after current node to current nodes parent.
             *
             * Just alias for `node.parent.insertAfter(node, add)`.
             *
             * @param {Node|object|string|Node[]} add New node.
             *
             * @return {Node} This node for methods chain.
             *
             * @example
             * decl.after('color: black')
             */;


            _proto.after = function after(add) {
              this.parent.insertAfter(this, add);
              return this;
            };

            _proto.toJSON = function toJSON() {
              var fixed = {};

              for (var name in this) {
                if (!this.hasOwnProperty(name)) continue;
                if (name === 'parent') continue;
                var value = this[name];

                if (value instanceof Array) {
                  fixed[name] = value.map(function (i) {
                    if (typeof i === 'object' && i.toJSON) {
                      return i.toJSON();
                    } else {
                      return i;
                    }
                  });
                } else if (typeof value === 'object' && value.toJSON) {
                  fixed[name] = value.toJSON();
                } else {
                  fixed[name] = value;
                }
              }

              return fixed;
            }
            /**
             * Returns a {@link Node#raws} value. If the node is missing
             * the code style property (because the node was manually built or cloned),
             * PostCSS will try to autodetect the code style property by looking
             * at other nodes in the tree.
             *
             * @param {string} prop          Name of code style property.
             * @param {string} [defaultType] Name of default value, it can be missed
             *                               if the value is the same as prop.
             *
             * @example
             * const root = postcss.parse('a { background: white }')
             * root.nodes[0].append({ prop: 'color', value: 'black' })
             * root.nodes[0].nodes[1].raws.before   //=> undefined
             * root.nodes[0].nodes[1].raw('before') //=> ' '
             *
             * @return {string} Code style value.
             */;


            _proto.raw = function raw(prop, defaultType) {
              var str = new _stringifier.default();
              return str.raw(this, prop, defaultType);
            }
            /**
             * Finds the Root instance of the nodes tree.
             *
             * @example
             * root.nodes[0].nodes[0].root() === root
             *
             * @return {Root} Root parent.
             */;


            _proto.root = function root() {
              var result = this;

              while (result.parent) {
                result = result.parent;
              }

              return result;
            }
            /**
             * Clear the code style properties for the node and its children.
             *
             * @param {boolean} [keepBetween] Keep the raws.between symbols.
             *
             * @return {undefined}
             *
             * @example
             * node.raws.before  //=> ' '
             * node.cleanRaws()
             * node.raws.before  //=> undefined
             */;


            _proto.cleanRaws = function cleanRaws(keepBetween) {
              delete this.raws.before;
              delete this.raws.after;
              if (!keepBetween) delete this.raws.between;
            };

            _proto.positionInside = function positionInside(index) {
              var string = this.toString();
              var column = this.source.start.column;
              var line = this.source.start.line;

              for (var i = 0; i < index; i++) {
                if (string[i] === '\n') {
                  column = 1;
                  line += 1;
                } else {
                  column += 1;
                }
              }

              return {
                line: line,
                column: column };

            };

            _proto.positionBy = function positionBy(opts) {
              var pos = this.source.start;

              if (opts.index) {
                pos = this.positionInside(opts.index);
              } else if (opts.word) {
                var index = this.toString().indexOf(opts.word);
                if (index !== -1) pos = this.positionInside(index);
              }

              return pos;
            }
            /**
             * @memberof Node#
             * @member {string} type String representing the nodes type.
             *                       Possible values are `root`, `atrule`, `rule`,
             *                       `decl`, or `comment`.
             *
             * @example
             * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
             */

            /**
             * @memberof Node#
             * @member {Container} parent The nodes parent node.
             *
             * @example
             * root.nodes[0].parent === root
             */

            /**
             * @memberof Node#
             * @member {source} source The input source of the node.
             *
             * The property is used in source map generation.
             *
             * If you create a node manually (e.g., with `postcss.decl()`),
             * that node will not have a `source` property and will be absent
             * from the source map. For this reason, the plugin developer should
             * consider cloning nodes to create new ones (in which case the new nodes
             * source will reference the original, cloned node) or setting
             * the `source` property manually.
             *
             * ```js
             * // Bad
             * const prefixed = postcss.decl({
             *   prop: '-moz-' + decl.prop,
             *   value: decl.value
             * })
             *
             * // Good
             * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
             * ```
             *
             * ```js
             * if (atrule.name === 'add-link') {
             *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
             *   atrule.parent.insertBefore(atrule, rule)
             * }
             * ```
             *
             * @example
             * decl.source.input.from //=> '/home/ai/a.sass'
             * decl.source.start      //=> { line: 10, column: 2 }
             * decl.source.end        //=> { line: 10, column: 12 }
             */

            /**
             * @memberof Node#
             * @member {object} raws Information to generate byte-to-byte equal
             *                       node string as it was in the origin input.
             *
             * Every parser saves its own properties,
             * but the default CSS parser uses:
             *
             * * `before`: the space symbols before the node. It also stores `*`
             *   and `_` symbols before the declaration (IE hack).
             * * `after`: the space symbols after the last child of the node
             *   to the end of the node.
             * * `between`: the symbols between the property and value
             *   for declarations, selector and `{` for rules, or last parameter
             *   and `{` for at-rules.
             * * `semicolon`: contains true if the last child has
             *   an (optional) semicolon.
             * * `afterName`: the space between the at-rule name and its parameters.
             * * `left`: the space symbols between `/*` and the comments text.
             * * `right`: the space symbols between the comments text
             *   and <code>*&#47;</code>.
             * * `important`: the content of the important statement,
             *   if it is not just `!important`.
             *
             * PostCSS cleans selectors, declaration values and at-rule parameters
             * from comments and extra spaces, but it stores origin content in raws
             * properties. As such, if you dont change a declarations value,
             * PostCSS will use the raw value with comments.
             *
             * @example
             * const root = postcss.parse('a {\n  color:black\n}')
             * root.first.first.raws //=> { before: '\n  ', between: ':' }
             */;


            return Node;
          }();

          var _default = Node;
          /**
           * @typedef {object} position
           * @property {number} line   Source line in file.
           * @property {number} column Source column in file.
           */

          /**
           * @typedef {object} source
           * @property {Input} input    {@link Input} with input file
           * @property {position} start The starting position of the nodes source.
           * @property {position} end   The ending position of the nodes source.
           */

          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require('_process'));
    }, { "./css-syntax-error": 128, "./stringifier": 143, "./stringify": 144, "_process": 160 }], 135: [function (require, module, exports) {
      (function (process) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _parser = _interopRequireDefault(require("./parser"));

          var _input = _interopRequireDefault(require("./input"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function parse(css, opts) {
            var input = new _input.default(css, opts);
            var parser = new _parser.default(input);

            try {
              parser.parse();
            } catch (e) {
              if (process.env.NODE_ENV !== 'production') {
                if (e.name === 'CssSyntaxError' && opts && opts.from) {
                  if (/\.scss$/i.test(opts.from)) {
                    e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
                  } else if (/\.sass/i.test(opts.from)) {
                    e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
                  } else if (/\.less$/i.test(opts.from)) {
                    e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
                  }
                }
              }

              throw e;
            }

            return parser.root;
          }

          var _default = parse;
          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require('_process'));
    }, { "./input": 130, "./parser": 136, "_process": 160 }], 136: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _declaration = _interopRequireDefault(require("./declaration"));

      var _tokenize = _interopRequireDefault(require("./tokenize"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _atRule = _interopRequireDefault(require("./at-rule"));

      var _root = _interopRequireDefault(require("./root"));

      var _rule = _interopRequireDefault(require("./rule"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      var Parser = /*#__PURE__*/function () {
        function Parser(input) {
          this.input = input;
          this.root = new _root.default();
          this.current = this.root;
          this.spaces = '';
          this.semicolon = false;
          this.createTokenizer();
          this.root.source = {
            input: input,
            start: {
              line: 1,
              column: 1 } };


        }

        var _proto = Parser.prototype;

        _proto.createTokenizer = function createTokenizer() {
          this.tokenizer = (0, _tokenize.default)(this.input);
        };

        _proto.parse = function parse() {
          var token;

          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            switch (token[0]) {
              case 'space':
                this.spaces += token[1];
                break;

              case ';':
                this.freeSemicolon(token);
                break;

              case '}':
                this.end(token);
                break;

              case 'comment':
                this.comment(token);
                break;

              case 'at-word':
                this.atrule(token);
                break;

              case '{':
                this.emptyRule(token);
                break;

              default:
                this.other(token);
                break;}

          }

          this.endFile();
        };

        _proto.comment = function comment(token) {
          var node = new _comment.default();
          this.init(node, token[2], token[3]);
          node.source.end = {
            line: token[4],
            column: token[5] };

          var text = token[1].slice(2, -2);

          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        };

        _proto.emptyRule = function emptyRule(token) {
          var node = new _rule.default();
          this.init(node, token[2], token[3]);
          node.selector = '';
          node.raws.between = '';
          this.current = node;
        };

        _proto.other = function other(start) {
          var end = false;
          var type = null;
          var colon = false;
          var bracket = null;
          var brackets = [];
          var tokens = [];
          var token = start;

          while (token) {
            type = token[0];
            tokens.push(token);

            if (type === '(' || type === '[') {
              if (!bracket) bracket = token;
              brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
              if (type === ';') {
                if (colon) {
                  this.decl(tokens);
                  return;
                } else {
                  break;
                }
              } else if (type === '{') {
                this.rule(tokens);
                return;
              } else if (type === '}') {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ':') {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }

            token = this.tokenizer.nextToken();
          }

          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);

          if (end && colon) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== 'space' && token !== 'comment') break;
              this.tokenizer.back(tokens.pop());
            }

            this.decl(tokens);
          } else {
            this.unknownWord(tokens);
          }
        };

        _proto.rule = function rule(tokens) {
          tokens.pop();
          var node = new _rule.default();
          this.init(node, tokens[0][2], tokens[0][3]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, 'selector', tokens);
          this.current = node;
        };

        _proto.decl = function decl(tokens) {
          var node = new _declaration.default();
          this.init(node);
          var last = tokens[tokens.length - 1];

          if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
          }

          if (last[4]) {
            node.source.end = {
              line: last[4],
              column: last[5] };

          } else {
            node.source.end = {
              line: last[2],
              column: last[3] };

          }

          while (tokens[0][0] !== 'word') {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }

          node.source.start = {
            line: tokens[0][2],
            column: tokens[0][3] };

          node.prop = '';

          while (tokens.length) {
            var type = tokens[0][0];

            if (type === ':' || type === 'space' || type === 'comment') {
              break;
            }

            node.prop += tokens.shift()[1];
          }

          node.raws.between = '';
          var token;

          while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === 'word' && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }

              node.raws.between += token[1];
            }
          }

          if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }

          node.raws.between += this.spacesAndCommentsFromStart(tokens);
          this.precheckMissedSemicolon(tokens);

          for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];

            if (token[1].toLowerCase() === '!important') {
              node.important = true;
              var string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== ' !important') node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === 'important') {
              var cache = tokens.slice(0);
              var str = '';

              for (var j = i; j > 0; j--) {
                var _type = cache[j][0];

                if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                  break;
                }

                str = cache.pop()[1] + str;
              }

              if (str.trim().indexOf('!') === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache;
              }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
              break;
            }
          }

          this.raw(node, 'value', tokens);
          if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
        };

        _proto.atrule = function atrule(token) {
          var node = new _atRule.default();
          node.name = token[1].slice(1);

          if (node.name === '') {
            this.unnamedAtrule(node, token);
          }

          this.init(node, token[2], token[3]);
          var prev;
          var shift;
          var last = false;
          var open = false;
          var params = [];

          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            if (token[0] === ';') {
              node.source.end = {
                line: token[2],
                column: token[3] };

              this.semicolon = true;
              break;
            } else if (token[0] === '{') {
              open = true;
              break;
            } else if (token[0] === '}') {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];

                while (prev && prev[0] === 'space') {
                  prev = params[--shift];
                }

                if (prev) {
                  node.source.end = {
                    line: prev[4],
                    column: prev[5] };

                }
              }

              this.end(token);
              break;
            } else {
              params.push(token);
            }

            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }

          node.raws.between = this.spacesAndCommentsFromEnd(params);

          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);

            if (last) {
              token = params[params.length - 1];
              node.source.end = {
                line: token[4],
                column: token[5] };

              this.spaces = node.raws.between;
              node.raws.between = '';
            }
          } else {
            node.raws.afterName = '';
            node.params = '';
          }

          if (open) {
            node.nodes = [];
            this.current = node;
          }
        };

        _proto.end = function end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }

          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
          this.spaces = '';

          if (this.current.parent) {
            this.current.source.end = {
              line: token[2],
              column: token[3] };

            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        };

        _proto.endFile = function endFile() {
          if (this.current.parent) this.unclosedBlock();

          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }

          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        };

        _proto.freeSemicolon = function freeSemicolon(token) {
          this.spaces += token[1];

          if (this.current.nodes) {
            var prev = this.current.nodes[this.current.nodes.length - 1];

            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = '';
            }
          }
        } // Helpers
        ;

        _proto.init = function init(node, line, column) {
          this.current.push(node);
          node.source = {
            start: {
              line: line,
              column: column },

            input: this.input };

          node.raws.before = this.spaces;
          this.spaces = '';
          if (node.type !== 'comment') this.semicolon = false;
        };

        _proto.raw = function raw(node, prop, tokens) {
          var token, type;
          var length = tokens.length;
          var value = '';
          var clean = true;
          var next, prev;
          var pattern = /^([.|#])?([\w])+/i;

          for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];

            if (type === 'comment' && node.type === 'rule') {
              prev = tokens[i - 1];
              next = tokens[i + 1];

              if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {
                value += token[1];
              } else {
                clean = false;
              }

              continue;
            }

            if (type === 'comment' || type === 'space' && i === length - 1) {
              clean = false;
            } else {
              value += token[1];
            }
          }

          if (!clean) {
            var raw = tokens.reduce(function (all, i) {
              return all + i[1];
            }, '');
            node.raws[prop] = {
              value: value,
              raw: raw };

          }

          node[prop] = value;
        };

        _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
          var lastTokenType;
          var spaces = '';

          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
          }

          return spaces;
        };

        _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
          var next;
          var spaces = '';

          while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
          }

          return spaces;
        };

        _proto.spacesFromEnd = function spacesFromEnd(tokens) {
          var lastTokenType;
          var spaces = '';

          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
          }

          return spaces;
        };

        _proto.stringFrom = function stringFrom(tokens, from) {
          var result = '';

          for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }

          tokens.splice(from, tokens.length - from);
          return result;
        };

        _proto.colon = function colon(tokens) {
          var brackets = 0;
          var token, type, prev;

          for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
              brackets += 1;
            }

            if (type === ')') {
              brackets -= 1;
            }

            if (brackets === 0 && type === ':') {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === 'word' && prev[1] === 'progid') {
                continue;
              } else {
                return i;
              }
            }

            prev = token;
          }

          return false;
        } // Errors
        ;

        _proto.unclosedBracket = function unclosedBracket(bracket) {
          throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
        };

        _proto.unknownWord = function unknownWord(tokens) {
          throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);
        };

        _proto.unexpectedClose = function unexpectedClose(token) {
          throw this.input.error('Unexpected }', token[2], token[3]);
        };

        _proto.unclosedBlock = function unclosedBlock() {
          var pos = this.current.source.start;
          throw this.input.error('Unclosed block', pos.line, pos.column);
        };

        _proto.doubleColon = function doubleColon(token) {
          throw this.input.error('Double colon', token[2], token[3]);
        };

        _proto.unnamedAtrule = function unnamedAtrule(node, token) {
          throw this.input.error('At-rule without name', token[2], token[3]);
        };

        _proto.precheckMissedSemicolon = function precheckMissedSemicolon()
        /* tokens */
        {// Hook for Safe Parser
        };

        _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
          var colon = this.colon(tokens);
          if (colon === false) return;
          var founded = 0;
          var token;

          for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];

            if (token[0] !== 'space') {
              founded += 1;
              if (founded === 2) break;
            }
          }

          throw this.input.error('Missed semicolon', token[2], token[3]);
        };

        return Parser;
      }();

      exports.default = Parser;
      module.exports = exports.default;


    }, { "./at-rule": 125, "./comment": 126, "./declaration": 129, "./root": 141, "./rule": 142, "./tokenize": 145 }], 137: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _declaration = _interopRequireDefault(require("./declaration"));

      var _processor = _interopRequireDefault(require("./processor"));

      var _stringify = _interopRequireDefault(require("./stringify"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _atRule = _interopRequireDefault(require("./at-rule"));

      var _vendor = _interopRequireDefault(require("./vendor"));

      var _parse = _interopRequireDefault(require("./parse"));

      var _list = _interopRequireDefault(require("./list"));

      var _rule = _interopRequireDefault(require("./rule"));

      var _root = _interopRequireDefault(require("./root"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Create a new {@link Processor} instance that will apply `plugins`
       * as CSS processors.
       *
       * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
       *        See {@link Processor#use} for plugin format.
       *
       * @return {Processor} Processor to process multiple CSS.
       *
       * @example
       * import postcss from 'postcss'
       *
       * postcss(plugins).process(css, { from, to }).then(result => {
       *   console.log(result.css)
       * })
       *
       * @namespace postcss
       */
      function postcss() {
        for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
          plugins[_key] = arguments[_key];
        }

        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }

        return new _processor.default(plugins);
      }
      /**
       * Creates a PostCSS plugin with a standard API.
       *
       * The newly-wrapped function will provide both the name and PostCSS
       * version of the plugin.
       *
       * ```js
       * const processor = postcss([replace])
       * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
       * processor.plugins[0].postcssVersion //=> '6.0.0'
       * ```
       *
       * The plugin function receives 2 arguments: {@link Root}
       * and {@link Result} instance. The function should mutate the provided
       * `Root` node. Alternatively, you can create a new `Root` node
       * and override the `result.root` property.
       *
       * ```js
       * const cleaner = postcss.plugin('postcss-cleaner', () => {
       *   return (root, result) => {
       *     result.root = postcss.root()
       *   }
       * })
       * ```
       *
       * As a convenience, plugins also expose a `process` method so that you can use
       * them as standalone tools.
       *
       * ```js
       * cleaner.process(css, processOpts, pluginOpts)
       * // This is equivalent to:
       * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
       * ```
       *
       * Asynchronous plugins should return a `Promise` instance.
       *
       * ```js
       * postcss.plugin('postcss-import', () => {
       *   return (root, result) => {
       *     return new Promise( (resolve, reject) => {
       *       fs.readFile('base.css', (base) => {
       *         root.prepend(base)
       *         resolve()
       *       })
       *     })
       *   }
       * })
       * ```
       *
       * Add warnings using the {@link Node#warn} method.
       * Send data to other plugins using the {@link Result#messages} array.
       *
       * ```js
       * postcss.plugin('postcss-caniuse-test', () => {
       *   return (root, result) => {
       *     root.walkDecls(decl => {
       *       if (!caniuse.support(decl.prop)) {
       *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
       *       }
       *     })
       *   }
       * })
       * ```
       *
       * @param {string} name          PostCSS plugin name. Same as in `name`
       *                               property in `package.json`. It will be saved
       *                               in `plugin.postcssPlugin` property.
       * @param {function} initializer Will receive plugin options
       *                               and should return {@link pluginFunction}
       *
       * @return {Plugin} PostCSS plugin.
       */


      postcss.plugin = function plugin(name, initializer) {
        function creator() {
          var transformer = initializer.apply(void 0, arguments);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new _processor.default().version;
          return transformer;
        }

        var cache;
        Object.defineProperty(creator, 'postcss', {
          get: function get() {
            if (!cache) cache = creator();
            return cache;
          } });


        creator.process = function (css, processOpts, pluginOpts) {
          return postcss([creator(pluginOpts)]).process(css, processOpts);
        };

        return creator;
      };
      /**
       * Default function to convert a node tree into a CSS string.
       *
       * @param {Node} node       Start node for stringifing. Usually {@link Root}.
       * @param {builder} builder Function to concatenate CSS from nodes parts
       *                          or generate string and source map.
       *
       * @return {void}
       *
       * @function
       */


      postcss.stringify = _stringify.default;
      /**
       * Parses source css and returns a new {@link Root} node,
       * which contains the source CSS nodes.
       *
       * @param {string|toString} css   String with input CSS or any object
       *                                with toString() method, like a Buffer
       * @param {processOptions} [opts] Options with only `from` and `map` keys.
       *
       * @return {Root} PostCSS AST.
       *
       * @example
       * // Simple CSS concatenation with source map support
       * const root1 = postcss.parse(css1, { from: file1 })
       * const root2 = postcss.parse(css2, { from: file2 })
       * root1.append(root2).toResult().css
       *
       * @function
       */

      postcss.parse = _parse.default;
      /**
       * Contains the {@link vendor} module.
       *
       * @type {vendor}
       *
       * @example
       * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
       */

      postcss.vendor = _vendor.default;
      /**
       * Contains the {@link list} module.
       *
       * @member {list}
       *
       * @example
       * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
       */

      postcss.list = _list.default;
      /**
       * Creates a new {@link Comment} node.
       *
       * @param {object} [defaults] Properties for the new node.
       *
       * @return {Comment} New comment node
       *
       * @example
       * postcss.comment({ text: 'test' })
       */

      postcss.comment = function (defaults) {
        return new _comment.default(defaults);
      };
      /**
       * Creates a new {@link AtRule} node.
       *
       * @param {object} [defaults] Properties for the new node.
       *
       * @return {AtRule} new at-rule node
       *
       * @example
       * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
       */


      postcss.atRule = function (defaults) {
        return new _atRule.default(defaults);
      };
      /**
       * Creates a new {@link Declaration} node.
       *
       * @param {object} [defaults] Properties for the new node.
       *
       * @return {Declaration} new declaration node
       *
       * @example
       * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
       */


      postcss.decl = function (defaults) {
        return new _declaration.default(defaults);
      };
      /**
       * Creates a new {@link Rule} node.
       *
       * @param {object} [defaults] Properties for the new node.
       *
       * @return {Rule} new rule node
       *
       * @example
       * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
       */


      postcss.rule = function (defaults) {
        return new _rule.default(defaults);
      };
      /**
       * Creates a new {@link Root} node.
       *
       * @param {object} [defaults] Properties for the new node.
       *
       * @return {Root} new root node.
       *
       * @example
       * postcss.root({ after: '\n' }).toString() //=> "\n"
       */


      postcss.root = function (defaults) {
        return new _root.default(defaults);
      };

      var _default = postcss;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./at-rule": 125, "./comment": 126, "./declaration": 129, "./list": 132, "./parse": 135, "./processor": 139, "./root": 141, "./rule": 142, "./stringify": 144, "./vendor": 146 }], 138: [function (require, module, exports) {
      (function (Buffer) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _sourceMap = _interopRequireDefault(require("source-map"));

          var _path = _interopRequireDefault(require("path"));

          var _fs = _interopRequireDefault(require("fs"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function fromBase64(str) {
            if (Buffer) {
              return Buffer.from(str, 'base64').toString();
            } else {
              return window.atob(str);
            }
          }
          /**
           * Source map information from input CSS.
           * For example, source map after Sass compiler.
           *
           * This class will automatically find source map in input CSS or in file system
           * near input file (according `from` option).
           *
           * @example
           * const root = postcss.parse(css, { from: 'a.sass.css' })
           * root.input.map //=> PreviousMap
           */


          var PreviousMap = /*#__PURE__*/function () {
            /**
             * @param {string}         css    Input CSS source.
             * @param {processOptions} [opts] {@link Processor#process} options.
             */
            function PreviousMap(css, opts) {
              this.loadAnnotation(css);
              /**
               * Was source map inlined by data-uri to input CSS.
               *
               * @type {boolean}
               */

              this.inline = this.startWith(this.annotation, 'data:');
              var prev = opts.map ? opts.map.prev : undefined;
              var text = this.loadMap(opts.from, prev);
              if (text) this.text = text;
            }
            /**
             * Create a instance of `SourceMapGenerator` class
             * from the `source-map` library to work with source map information.
             *
             * It is lazy method, so it will create object only on first call
             * and then it will use cache.
             *
             * @return {SourceMapGenerator} Object with source map information.
             */


            var _proto = PreviousMap.prototype;

            _proto.consumer = function consumer() {
              if (!this.consumerCache) {
                this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);
              }

              return this.consumerCache;
            }
            /**
             * Does source map contains `sourcesContent` with input source text.
             *
             * @return {boolean} Is `sourcesContent` present.
             */;


            _proto.withContent = function withContent() {
              return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
            };

            _proto.startWith = function startWith(string, start) {
              if (!string) return false;
              return string.substr(0, start.length) === start;
            };

            _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {
              return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1].trim();
            };

            _proto.loadAnnotation = function loadAnnotation(css) {
              var annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg);

              if (annotations && annotations.length > 0) {
                // Locate the last sourceMappingURL to avoid picking up
                // sourceMappingURLs from comments, strings, etc.
                var lastAnnotation = annotations[annotations.length - 1];

                if (lastAnnotation) {
                  this.annotation = this.getAnnotationURL(lastAnnotation);
                }
              }
            };

            _proto.decodeInline = function decodeInline(text) {
              var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
              var baseUri = /^data:application\/json;base64,/;
              var uri = 'data:application/json,';

              if (this.startWith(text, uri)) {
                return decodeURIComponent(text.substr(uri.length));
              }

              if (baseCharsetUri.test(text) || baseUri.test(text)) {
                return fromBase64(text.substr(RegExp.lastMatch.length));
              }

              var encoding = text.match(/data:application\/json;([^,]+),/)[1];
              throw new Error('Unsupported source map encoding ' + encoding);
            };

            _proto.loadMap = function loadMap(file, prev) {
              if (prev === false) return false;

              if (prev) {
                if (typeof prev === 'string') {
                  return prev;
                } else if (typeof prev === 'function') {
                  var prevPath = prev(file);

                  if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {
                    return _fs.default.readFileSync(prevPath, 'utf-8').toString().trim();
                  } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                  }
                } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {
                  return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();
                } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {
                  return prev.toString();
                } else if (this.isMap(prev)) {
                  return JSON.stringify(prev);
                } else {
                  throw new Error('Unsupported previous source map format: ' + prev.toString());
                }
              } else if (this.inline) {
                return this.decodeInline(this.annotation);
              } else if (this.annotation) {
                var map = this.annotation;
                if (file) map = _path.default.join(_path.default.dirname(file), map);
                this.root = _path.default.dirname(map);

                if (_fs.default.existsSync && _fs.default.existsSync(map)) {
                  return _fs.default.readFileSync(map, 'utf-8').toString().trim();
                } else {
                  return false;
                }
              }
            };

            _proto.isMap = function isMap(map) {
              if (typeof map !== 'object') return false;
              return typeof map.mappings === 'string' || typeof map._mappings === 'string';
            };

            return PreviousMap;
          }();

          var _default = PreviousMap;
          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "buffer": 4, "fs": 3, "path": 74, "source-map": 159 }], 139: [function (require, module, exports) {
      (function (process) {(function () {
          "use strict";

          exports.__esModule = true;
          exports.default = void 0;

          var _lazyResult = _interopRequireDefault(require("./lazy-result"));

          function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

          function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

          function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

          function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

          /**
           * Contains plugins to process CSS. Create one `Processor` instance,
           * initialize its plugins, and then use that instance on numerous CSS files.
           *
           * @example
           * const processor = postcss([autoprefixer, precss])
           * processor.process(css1).then(result => console.log(result.css))
           * processor.process(css2).then(result => console.log(result.css))
           */
          var Processor = /*#__PURE__*/function () {
            /**
             * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
             *        See {@link Processor#use} for plugin format.
             */
            function Processor(plugins) {
              if (plugins === void 0) {
                plugins = [];
              }

              /**
               * Current PostCSS version.
               *
               * @type {string}
               *
               * @example
               * if (result.processor.version.split('.')[0] !== '6') {
               *   throw new Error('This plugin works only with PostCSS 6')
               * }
               */
              this.version = '7.0.35';
              /**
               * Plugins added to this processor.
               *
               * @type {pluginFunction[]}
               *
               * @example
               * const processor = postcss([autoprefixer, precss])
               * processor.plugins.length //=> 2
               */

              this.plugins = this.normalize(plugins);
            }
            /**
             * Adds a plugin to be used as a CSS processor.
             *
             * PostCSS plugin can be in 4 formats:
             * * A plugin created by {@link postcss.plugin} method.
             * * A function. PostCSS will pass the function a @{link Root}
             *   as the first argument and current {@link Result} instance
             *   as the second.
             * * An object with a `postcss` method. PostCSS will use that method
             *   as described in #2.
             * * Another {@link Processor} instance. PostCSS will copy plugins
             *   from that instance into this one.
             *
             * Plugins can also be added by passing them as arguments when creating
             * a `postcss` instance (see [`postcss(plugins)`]).
             *
             * Asynchronous plugins should return a `Promise` instance.
             *
             * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
             *                                                 or {@link Processor}
             *                                                 with plugins.
             *
             * @example
             * const processor = postcss()
             *   .use(autoprefixer)
             *   .use(precss)
             *
             * @return {Processes} Current processor to make methods chain.
             */


            var _proto = Processor.prototype;

            _proto.use = function use(plugin) {
              this.plugins = this.plugins.concat(this.normalize([plugin]));
              return this;
            }
            /**
             * Parses source CSS and returns a {@link LazyResult} Promise proxy.
             * Because some plugins can be asynchronous it doesnt make
             * any transformations. Transformations will be applied
             * in the {@link LazyResult} methods.
             *
             * @param {string|toString|Result} css String with input CSS or any object
             *                                     with a `toString()` method,
             *                                     like a Buffer. Optionally, send
             *                                     a {@link Result} instance
             *                                     and the processor will take
             *                                     the {@link Root} from it.
             * @param {processOptions} [opts]      Options.
             *
             * @return {LazyResult} Promise proxy.
             *
             * @example
             * processor.process(css, { from: 'a.css', to: 'a.out.css' })
             *   .then(result => {
             *      console.log(result.css)
             *   })
             */;


            _proto.process = function (_process) {
              function process(_x) {
                return _process.apply(this, arguments);
              }

              process.toString = function () {
                return _process.toString();
              };

              return process;
            }(function (css, opts) {
              if (opts === void 0) {
                opts = {};
              }

              if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
                if (process.env.NODE_ENV !== 'production') {
                  if (typeof console !== 'undefined' && console.warn) {
                    console.warn('You did not set any plugins, parser, or stringifier. ' + 'Right now, PostCSS does nothing. Pick plugins for your case ' + 'on https://www.postcss.parts/ and use them in postcss.config.js.');
                  }
                }
              }

              return new _lazyResult.default(this, css, opts);
            });

            _proto.normalize = function normalize(plugins) {
              var normalized = [];

              for (var _iterator = _createForOfIteratorHelperLoose(plugins), _step; !(_step = _iterator()).done;) {
                var i = _step.value;

                if (i.postcss === true) {
                  var plugin = i();
                  throw new Error('PostCSS plugin ' + plugin.postcssPlugin + ' requires PostCSS 8.\n' + 'Migration guide for end-users:\n' + 'https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users');
                }

                if (i.postcss) i = i.postcss;

                if (typeof i === 'object' && Array.isArray(i.plugins)) {
                  normalized = normalized.concat(i.plugins);
                } else if (typeof i === 'function') {
                  normalized.push(i);
                } else if (typeof i === 'object' && (i.parse || i.stringify)) {
                  if (process.env.NODE_ENV !== 'production') {
                    throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');
                  }
                } else if (typeof i === 'object' && i.postcssPlugin) {
                  throw new Error('PostCSS plugin ' + i.postcssPlugin + ' requires PostCSS 8.\n' + 'Migration guide for end-users:\n' + 'https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users');
                } else {
                  throw new Error(i + ' is not a PostCSS plugin');
                }
              }

              return normalized;
            };

            return Processor;
          }();

          var _default = Processor;
          /**
           * @callback builder
           * @param {string} part          Part of generated CSS connected to this node.
           * @param {Node}   node          AST node.
           * @param {"start"|"end"} [type] Nodes part type.
           */

          /**
           * @callback parser
           *
           * @param {string|toString} css   String with input CSS or any object
           *                                with toString() method, like a Buffer.
           * @param {processOptions} [opts] Options with only `from` and `map` keys.
           *
           * @return {Root} PostCSS AST
           */

          /**
           * @callback stringifier
           *
           * @param {Node} node       Start node for stringifing. Usually {@link Root}.
           * @param {builder} builder Function to concatenate CSS from nodes parts
           *                          or generate string and source map.
           *
           * @return {void}
           */

          /**
           * @typedef {object} syntax
           * @property {parser} parse          Function to generate AST by string.
           * @property {stringifier} stringify Function to generate string by AST.
           */

          /**
           * @typedef {object} toString
           * @property {function} toString
           */

          /**
           * @callback pluginFunction
           * @param {Root} root     Parsed input CSS.
           * @param {Result} result Result to set warnings or check other plugins.
           */

          /**
           * @typedef {object} Plugin
           * @property {function} postcss PostCSS plugin function.
           */

          /**
           * @typedef {object} processOptions
           * @property {string} from             The path of the CSS source file.
           *                                     You should always set `from`,
           *                                     because it is used in source map
           *                                     generation and syntax error messages.
           * @property {string} to               The path where youll put the output
           *                                     CSS file. You should always set `to`
           *                                     to generate correct source maps.
           * @property {parser} parser           Function to generate AST by string.
           * @property {stringifier} stringifier Class to generate string by AST.
           * @property {syntax} syntax           Object with `parse` and `stringify`.
           * @property {object} map              Source map options.
           * @property {boolean} map.inline                    Does source map should
           *                                                   be embedded in the output
           *                                                   CSS as a base64-encoded
           *                                                   comment.
           * @property {string|object|false|function} map.prev Source map content
           *                                                   from a previous
           *                                                   processing step
           *                                                   (for example, Sass).
           *                                                   PostCSS will try to find
           *                                                   previous map automatically,
           *                                                   so you could disable it by
           *                                                   `false` value.
           * @property {boolean} map.sourcesContent            Does PostCSS should set
           *                                                   the origin content to map.
           * @property {string|false} map.annotation           Does PostCSS should set
           *                                                   annotation comment to map.
           * @property {string} map.from                       Override `from` in maps
           *                                                   sources`.
           */

          exports.default = _default;
          module.exports = exports.default;


        }).call(this);}).call(this, require('_process'));
    }, { "./lazy-result": 131, "_process": 160 }], 140: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _warning = _interopRequireDefault(require("./warning"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      /**
       * Provides the result of the PostCSS transformations.
       *
       * A Result instance is returned by {@link LazyResult#then}
       * or {@link Root#toResult} methods.
       *
       * @example
       * postcss([autoprefixer]).process(css).then(result => {
       *  console.log(result.css)
       * })
       *
       * @example
       * const result2 = postcss.parse(css).toResult()
       */
      var Result = /*#__PURE__*/function () {
        /**
         * @param {Processor} processor Processor used for this transformation.
         * @param {Root}      root      Root node after all transformations.
         * @param {processOptions} opts Options from the {@link Processor#process}
         *                              or {@link Root#toResult}.
         */
        function Result(processor, root, opts) {
          /**
           * The Processor instance used for this transformation.
           *
           * @type {Processor}
           *
           * @example
           * for (const plugin of result.processor.plugins) {
           *   if (plugin.postcssPlugin === 'postcss-bad') {
           *     throw 'postcss-good is incompatible with postcss-bad'
           *   }
           * })
           */
          this.processor = processor;
          /**
           * Contains messages from plugins (e.g., warnings or custom messages).
           * Each message should have type and plugin properties.
           *
           * @type {Message[]}
           *
           * @example
           * postcss.plugin('postcss-min-browser', () => {
           *   return (root, result) => {
           *     const browsers = detectMinBrowsersByCanIUse(root)
           *     result.messages.push({
           *       type: 'min-browser',
           *       plugin: 'postcss-min-browser',
           *       browsers
           *     })
           *   }
           * })
           */

          this.messages = [];
          /**
           * Root node after all transformations.
           *
           * @type {Root}
           *
           * @example
           * root.toResult().root === root
           */

          this.root = root;
          /**
           * Options from the {@link Processor#process} or {@link Root#toResult} call
           * that produced this Result instance.
           *
           * @type {processOptions}
           *
           * @example
           * root.toResult(opts).opts === opts
           */

          this.opts = opts;
          /**
           * A CSS string representing of {@link Result#root}.
           *
           * @type {string}
           *
           * @example
           * postcss.parse('a{}').toResult().css //=> "a{}"
           */

          this.css = undefined;
          /**
           * An instance of `SourceMapGenerator` class from the `source-map` library,
           * representing changes to the {@link Result#root} instance.
           *
           * @type {SourceMapGenerator}
           *
           * @example
           * result.map.toJSON() //=> { version: 3, file: 'a.css',  }
           *
           * @example
           * if (result.map) {
           *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
           * }
           */

          this.map = undefined;
        }
        /**
         * Returns for @{link Result#css} content.
         *
         * @example
         * result + '' === result.css
         *
         * @return {string} String representing of {@link Result#root}.
         */


        var _proto = Result.prototype;

        _proto.toString = function toString() {
          return this.css;
        }
        /**
         * Creates an instance of {@link Warning} and adds it
         * to {@link Result#messages}.
         *
         * @param {string} text        Warning message.
         * @param {Object} [opts]      Warning options.
         * @param {Node}   opts.node   CSS node that caused the warning.
         * @param {string} opts.word   Word in CSS source that caused the warning.
         * @param {number} opts.index  Index in CSS node string that caused
         *                             the warning.
         * @param {string} opts.plugin Name of the plugin that created
         *                             this warning. {@link Result#warn} fills
         *                             this property automatically.
         *
         * @return {Warning} Created warning.
         */;


        _proto.warn = function warn(text, opts) {
          if (opts === void 0) {
            opts = {};
          }

          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }

          var warning = new _warning.default(text, opts);
          this.messages.push(warning);
          return warning;
        }
        /**
           * Returns warnings from plugins. Filters {@link Warning} instances
           * from {@link Result#messages}.
           *
           * @example
           * result.warnings().forEach(warn => {
           *   console.warn(warn.toString())
           * })
           *
           * @return {Warning[]} Warnings from plugins.
           */;


        _proto.warnings = function warnings() {
          return this.messages.filter(function (i) {
            return i.type === 'warning';
          });
        }
        /**
         * An alias for the {@link Result#css} property.
         * Use it with syntaxes that generate non-CSS output.
         *
         * @type {string}
         *
         * @example
         * result.css === result.content
         */;


        _createClass(Result, [{
          key: "content",
          get: function get() {
            return this.css;
          } }]);


        return Result;
      }();

      var _default = Result;
      /**
       * @typedef  {object} Message
       * @property {string} type   Message type.
       * @property {string} plugin Source PostCSS plugin name.
       */

      exports.default = _default;
      module.exports = exports.default;


    }, { "./warning": 148 }], 141: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

      function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

      function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      /**
       * Represents a CSS file and contains all its parsed nodes.
       *
       * @extends Container
       *
       * @example
       * const root = postcss.parse('a{color:black} b{z-index:2}')
       * root.type         //=> 'root'
       * root.nodes.length //=> 2
       */
      var Root = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Root, _Container);

        function Root(defaults) {
          var _this;

          _this = _Container.call(this, defaults) || this;
          _this.type = 'root';
          if (!_this.nodes) _this.nodes = [];
          return _this;
        }

        var _proto = Root.prototype;

        _proto.removeChild = function removeChild(child, ignore) {
          var index = this.index(child);

          if (!ignore && index === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index].raws.before;
          }

          return _Container.prototype.removeChild.call(this, child);
        };

        _proto.normalize = function normalize(child, sample, type) {
          var nodes = _Container.prototype.normalize.call(this, child);

          if (sample) {
            if (type === 'prepend') {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
                var node = _step.value;
                node.raws.before = sample.raws.before;
              }
            }
          }

          return nodes;
        }
        /**
         * Returns a {@link Result} instance representing the roots CSS.
         *
         * @param {processOptions} [opts] Options with only `to` and `map` keys.
         *
         * @return {Result} Result with current roots CSS.
         *
         * @example
         * const root1 = postcss.parse(css1, { from: 'a.css' })
         * const root2 = postcss.parse(css2, { from: 'b.css' })
         * root1.append(root2)
         * const result = root1.toResult({ to: 'all.css', map: true })
         */;


        _proto.toResult = function toResult(opts) {
          if (opts === void 0) {
            opts = {};
          }

          var LazyResult = require('./lazy-result');

          var Processor = require('./processor');

          var lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }
        /**
         * @memberof Root#
         * @member {object} raws Information to generate byte-to-byte equal
         *                       node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `after`: the space symbols after the last child to the end of file.
         * * `semicolon`: is the last child has an (optional) semicolon.
         *
         * @example
         * postcss.parse('a {}\n').raws //=> { after: '\n' }
         * postcss.parse('a {}').raws   //=> { after: '' }
         */;


        return Root;
      }(_container.default);

      var _default = Root;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./container": 127, "./lazy-result": 131, "./processor": 139 }], 142: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _list = _interopRequireDefault(require("./list"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;subClass.__proto__ = superClass;}

      /**
       * Represents a CSS rule: a selector followed by a declaration block.
       *
       * @extends Container
       *
       * @example
       * const root = postcss.parse('a{}')
       * const rule = root.first
       * rule.type       //=> 'rule'
       * rule.toString() //=> 'a{}'
       */
      var Rule = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Rule, _Container);

        function Rule(defaults) {
          var _this;

          _this = _Container.call(this, defaults) || this;
          _this.type = 'rule';
          if (!_this.nodes) _this.nodes = [];
          return _this;
        }
        /**
         * An array containing the rules individual selectors.
         * Groups of selectors are split at commas.
         *
         * @type {string[]}
         *
         * @example
         * const root = postcss.parse('a, b { }')
         * const rule = root.first
         *
         * rule.selector  //=> 'a, b'
         * rule.selectors //=> ['a', 'b']
         *
         * rule.selectors = ['a', 'strong']
         * rule.selector //=> 'a, strong'
         */


        _createClass(Rule, [{
          key: "selectors",
          get: function get() {
            return _list.default.comma(this.selector);
          },
          set: function set(values) {
            var match = this.selector ? this.selector.match(/,\s*/) : null;
            var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
            this.selector = values.join(sep);
          }
          /**
           * @memberof Rule#
           * @member {string} selector The rules full selector represented
           *                           as a string.
           *
           * @example
           * const root = postcss.parse('a, b { }')
           * const rule = root.first
           * rule.selector //=> 'a, b'
           */

          /**
           * @memberof Rule#
           * @member {object} raws Information to generate byte-to-byte equal
           *                       node string as it was in the origin input.
           *
           * Every parser saves its own properties,
           * but the default CSS parser uses:
           *
           * * `before`: the space symbols before the node. It also stores `*`
           *   and `_` symbols before the declaration (IE hack).
           * * `after`: the space symbols after the last child of the node
           *   to the end of the node.
           * * `between`: the symbols between the property and value
           *   for declarations, selector and `{` for rules, or last parameter
           *   and `{` for at-rules.
           * * `semicolon`: contains `true` if the last child has
           *   an (optional) semicolon.
           * * `ownSemicolon`: contains `true` if there is semicolon after rule.
           *
           * PostCSS cleans selectors from comments and extra spaces,
           * but it stores origin content in raws properties.
           * As such, if you dont change a declarations value,
           * PostCSS will use the raw value with comments.
           *
           * @example
           * const root = postcss.parse('a {\n  color:black\n}')
           * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
           */ }]);



        return Rule;
      }(_container.default);

      var _default = Rule;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./container": 127, "./list": 132 }], 143: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;
      var DEFAULT_RAW = {
        colon: ': ',
        indent: '    ',
        beforeDecl: '\n',
        beforeRule: '\n',
        beforeOpen: ' ',
        beforeClose: '\n',
        beforeComment: '\n',
        after: '\n',
        emptyBody: '',
        commentLeft: ' ',
        commentRight: ' ',
        semicolon: false };


      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }

      var Stringifier = /*#__PURE__*/function () {
        function Stringifier(builder) {
          this.builder = builder;
        }

        var _proto = Stringifier.prototype;

        _proto.stringify = function stringify(node, semicolon) {
          this[node.type](node, semicolon);
        };

        _proto.root = function root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        };

        _proto.comment = function comment(node) {
          var left = this.raw(node, 'left', 'commentLeft');
          var right = this.raw(node, 'right', 'commentRight');
          this.builder('/*' + left + node.text + right + '*/', node);
        };

        _proto.decl = function decl(node, semicolon) {
          var between = this.raw(node, 'between', 'colon');
          var string = node.prop + between + this.rawValue(node, 'value');

          if (node.important) {
            string += node.raws.important || ' !important';
          }

          if (semicolon) string += ';';
          this.builder(string, node);
        };

        _proto.rule = function rule(node) {
          this.block(node, this.rawValue(node, 'selector'));

          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, 'end');
          }
        };

        _proto.atrule = function atrule(node, semicolon) {
          var name = '@' + node.name;
          var params = node.params ? this.rawValue(node, 'params') : '';

          if (typeof node.raws.afterName !== 'undefined') {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          if (node.nodes) {
            this.block(node, name + params);
          } else {
            var end = (node.raws.between || '') + (semicolon ? ';' : '');
            this.builder(name + params + end, node);
          }
        };

        _proto.body = function body(node) {
          var last = node.nodes.length - 1;

          while (last > 0) {
            if (node.nodes[last].type !== 'comment') break;
            last -= 1;
          }

          var semicolon = this.raw(node, 'semicolon');

          for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            var before = this.raw(child, 'before');
            if (before) this.builder(before);
            this.stringify(child, last !== i || semicolon);
          }
        };

        _proto.block = function block(node, start) {
          var between = this.raw(node, 'between', 'beforeOpen');
          this.builder(start + between + '{', node, 'start');
          var after;

          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, 'after');
          } else {
            after = this.raw(node, 'after', 'emptyBody');
          }

          if (after) this.builder(after);
          this.builder('}', node, 'end');
        };

        _proto.raw = function raw(node, own, detect) {
          var value;
          if (!detect) detect = own; // Already had

          if (own) {
            value = node.raws[own];
            if (typeof value !== 'undefined') return value;
          }

          var parent = node.parent; // Hack for first rule in CSS

          if (detect === 'before') {
            if (!parent || parent.type === 'root' && parent.first === node) {
              return '';
            }
          } // Floating child without parent


          if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

          var root = node.root();
          if (!root.rawCache) root.rawCache = {};

          if (typeof root.rawCache[detect] !== 'undefined') {
            return root.rawCache[detect];
          }

          if (detect === 'before' || detect === 'after') {
            return this.beforeAfter(node, detect);
          } else {
            var method = 'raw' + capitalize(detect);

            if (this[method]) {
              value = this[method](root, node);
            } else {
              root.walk(function (i) {
                value = i.raws[own];
                if (typeof value !== 'undefined') return false;
              });
            }
          }

          if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
          root.rawCache[detect] = value;
          return value;
        };

        _proto.rawSemicolon = function rawSemicolon(root) {
          var value;
          root.walk(function (i) {
            if (i.nodes && i.nodes.length && i.last.type === 'decl') {
              value = i.raws.semicolon;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        };

        _proto.rawEmptyBody = function rawEmptyBody(root) {
          var value;
          root.walk(function (i) {
            if (i.nodes && i.nodes.length === 0) {
              value = i.raws.after;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        };

        _proto.rawIndent = function rawIndent(root) {
          if (root.raws.indent) return root.raws.indent;
          var value;
          root.walk(function (i) {
            var p = i.parent;

            if (p && p !== root && p.parent && p.parent === root) {
              if (typeof i.raws.before !== 'undefined') {
                var parts = i.raws.before.split('\n');
                value = parts[parts.length - 1];
                value = value.replace(/[^\s]/g, '');
                return false;
              }
            }
          });
          return value;
        };

        _proto.rawBeforeComment = function rawBeforeComment(root, node) {
          var value;
          root.walkComments(function (i) {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;

              if (value.indexOf('\n') !== -1) {
                value = value.replace(/[^\n]+$/, '');
              }

              return false;
            }
          });

          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (value) {
            value = value.replace(/[^\s]/g, '');
          }

          return value;
        };

        _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {
          var value;
          root.walkDecls(function (i) {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;

              if (value.indexOf('\n') !== -1) {
                value = value.replace(/[^\n]+$/, '');
              }

              return false;
            }
          });

          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeRule');
          } else if (value) {
            value = value.replace(/[^\s]/g, '');
          }

          return value;
        };

        _proto.rawBeforeRule = function rawBeforeRule(root) {
          var value;
          root.walk(function (i) {
            if (i.nodes && (i.parent !== root || root.first !== i)) {
              if (typeof i.raws.before !== 'undefined') {
                value = i.raws.before;

                if (value.indexOf('\n') !== -1) {
                  value = value.replace(/[^\n]+$/, '');
                }

                return false;
              }
            }
          });
          if (value) value = value.replace(/[^\s]/g, '');
          return value;
        };

        _proto.rawBeforeClose = function rawBeforeClose(root) {
          var value;
          root.walk(function (i) {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== 'undefined') {
                value = i.raws.after;

                if (value.indexOf('\n') !== -1) {
                  value = value.replace(/[^\n]+$/, '');
                }

                return false;
              }
            }
          });
          if (value) value = value.replace(/[^\s]/g, '');
          return value;
        };

        _proto.rawBeforeOpen = function rawBeforeOpen(root) {
          var value;
          root.walk(function (i) {
            if (i.type !== 'decl') {
              value = i.raws.between;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        };

        _proto.rawColon = function rawColon(root) {
          var value;
          root.walkDecls(function (i) {
            if (typeof i.raws.between !== 'undefined') {
              value = i.raws.between.replace(/[^\s:]/g, '');
              return false;
            }
          });
          return value;
        };

        _proto.beforeAfter = function beforeAfter(node, detect) {
          var value;

          if (node.type === 'decl') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (node.type === 'comment') {
            value = this.raw(node, null, 'beforeComment');
          } else if (detect === 'before') {
            value = this.raw(node, null, 'beforeRule');
          } else {
            value = this.raw(node, null, 'beforeClose');
          }

          var buf = node.parent;
          var depth = 0;

          while (buf && buf.type !== 'root') {
            depth += 1;
            buf = buf.parent;
          }

          if (value.indexOf('\n') !== -1) {
            var indent = this.raw(node, null, 'indent');

            if (indent.length) {
              for (var step = 0; step < depth; step++) {
                value += indent;
              }
            }
          }

          return value;
        };

        _proto.rawValue = function rawValue(node, prop) {
          var value = node[prop];
          var raw = node.raws[prop];

          if (raw && raw.value === value) {
            return raw.raw;
          }

          return value;
        };

        return Stringifier;
      }();

      var _default = Stringifier;
      exports.default = _default;
      module.exports = exports.default;


    }, {}], 144: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      var _stringifier = _interopRequireDefault(require("./stringifier"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function stringify(node, builder) {
        var str = new _stringifier.default(builder);
        str.stringify(node);
      }

      var _default = stringify;
      exports.default = _default;
      module.exports = exports.default;


    }, { "./stringifier": 143 }], 145: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = tokenizer;
      var SINGLE_QUOTE = '\''.charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = '\\'.charCodeAt(0);
      var SLASH = '/'.charCodeAt(0);
      var NEWLINE = '\n'.charCodeAt(0);
      var SPACE = ' '.charCodeAt(0);
      var FEED = '\f'.charCodeAt(0);
      var TAB = '\t'.charCodeAt(0);
      var CR = '\r'.charCodeAt(0);
      var OPEN_SQUARE = '['.charCodeAt(0);
      var CLOSE_SQUARE = ']'.charCodeAt(0);
      var OPEN_PARENTHESES = '('.charCodeAt(0);
      var CLOSE_PARENTHESES = ')'.charCodeAt(0);
      var OPEN_CURLY = '{'.charCodeAt(0);
      var CLOSE_CURLY = '}'.charCodeAt(0);
      var SEMICOLON = ';'.charCodeAt(0);
      var ASTERISK = '*'.charCodeAt(0);
      var COLON = ':'.charCodeAt(0);
      var AT = '@'.charCodeAt(0);
      var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
      var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\\/("'\n]/;
      var RE_HEX_ESCAPE = /[a-f0-9]/i;

      function tokenizer(input, options) {
        if (options === void 0) {
          options = {};
        }

        var css = input.css.valueOf();
        var ignore = options.ignoreErrors;
        var code, next, quote, lines, last, content, escape;
        var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
        var length = css.length;
        var offset = -1;
        var line = 1;
        var pos = 0;
        var buffer = [];
        var returned = [];

        function position() {
          return pos;
        }

        function unclosed(what) {
          throw input.error('Unclosed ' + what, line, pos - offset);
        }

        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }

        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length) return;
          var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css.charCodeAt(pos);

          if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
            offset = pos;
            line += 1;
          }

          switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED:
              next = pos;

              do {
                next += 1;
                code = css.charCodeAt(next);

                if (code === NEWLINE) {
                  offset = next;
                  line += 1;
                }
              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

              currentToken = ['space', css.slice(pos, next)];
              pos = next - 1;
              break;

            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES:
              var controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, line, pos - offset];
              break;

            case OPEN_PARENTHESES:
              prev = buffer.length ? buffer.pop()[1] : '';
              n = css.charCodeAt(pos + 1);

              if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                next = pos;

                do {
                  escaped = false;
                  next = css.indexOf(')', next + 1);

                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed('bracket');
                    }
                  }

                  escapePos = next;

                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);

                currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
                pos = next;
              } else {
                next = css.indexOf(')', pos + 1);
                content = css.slice(pos, next + 1);

                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ['(', '(', line, pos - offset];
                } else {
                  currentToken = ['brackets', content, line, pos - offset, line, next - offset];
                  pos = next;
                }
              }

              break;

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:
              quote = code === SINGLE_QUOTE ? '\'' : '"';
              next = pos;

              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);

                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed('string');
                  }
                }

                escapePos = next;

                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              content = css.slice(pos, next + 1);
              lines = content.split('\n');
              last = lines.length - 1;

              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }

              currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];
              offset = nextOffset;
              line = nextLine;
              pos = next;
              break;

            case AT:
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);

              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }

              currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
              pos = next;
              break;

            case BACKSLASH:
              next = pos;
              escape = true;

              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape = !escape;
              }

              code = css.charCodeAt(next + 1);

              if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next += 1;

                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                    next += 1;
                  }

                  if (css.charCodeAt(next + 1) === SPACE) {
                    next += 1;
                  }
                }
              }

              currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
              pos = next;
              break;

            default:
              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                next = css.indexOf('*/', pos + 2) + 1;

                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css.length;
                  } else {
                    unclosed('comment');
                  }
                }

                content = css.slice(pos, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];
                offset = nextOffset;
                line = nextLine;
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);

                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }

                currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
                buffer.push(currentToken);
                pos = next;
              }

              break;}


          pos++;
          return currentToken;
        }

        function back(token) {
          returned.push(token);
        }

        return {
          back: back,
          nextToken: nextToken,
          endOfFile: endOfFile,
          position: position };

      }

      module.exports = exports.default;


    }, {}], 146: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      /**
       * Contains helpers for working with vendor prefixes.
       *
       * @example
       * const vendor = postcss.vendor
       *
       * @namespace vendor
       */
      var vendor = {
        /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} vendor prefix or empty string
         *
         * @example
         * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
         * postcss.vendor.prefix('tab-size')      //=> ''
         */
        prefix: function prefix(prop) {
          var match = prop.match(/^(-\w+-)/);

          if (match) {
            return match[0];
          }

          return '';
        },

        /**
           * Returns the input string stripped of its vendor prefix.
           *
           * @param {string} prop String with or without vendor prefix.
           *
           * @return {string} String name without vendor prefixes.
           *
           * @example
           * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
           */
        unprefixed: function unprefixed(prop) {
          return prop.replace(/^-\w+-/, '');
        } };

      var _default = vendor;
      exports.default = _default;
      module.exports = exports.default;


    }, {}], 147: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = warnOnce;
      var printed = {};

      function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;

        if (typeof console !== 'undefined' && console.warn) {
          console.warn(message);
        }
      }

      module.exports = exports.default;


    }, {}], 148: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.default = void 0;

      /**
       * Represents a plugins warning. It can be created using {@link Node#warn}.
       *
       * @example
       * if (decl.important) {
       *   decl.warn(result, 'Avoid !important', { word: '!important' })
       * }
       */
      var Warning = /*#__PURE__*/function () {
        /**
         * @param {string} text        Warning message.
         * @param {Object} [opts]      Warning options.
         * @param {Node}   opts.node   CSS node that caused the warning.
         * @param {string} opts.word   Word in CSS source that caused the warning.
         * @param {number} opts.index  Index in CSS node string that caused
         *                             the warning.
         * @param {string} opts.plugin Name of the plugin that created
         *                             this warning. {@link Result#warn} fills
         *                             this property automatically.
         */
        function Warning(text, opts) {
          if (opts === void 0) {
            opts = {};
          }

          /**
           * Type to filter warnings from {@link Result#messages}.
           * Always equal to `"warning"`.
           *
           * @type {string}
           *
           * @example
           * const nonWarning = result.messages.filter(i => i.type !== 'warning')
           */
          this.type = 'warning';
          /**
           * The warning message.
           *
           * @type {string}
           *
           * @example
           * warning.text //=> 'Try to avoid !important'
           */

          this.text = text;

          if (opts.node && opts.node.source) {
            var pos = opts.node.positionBy(opts);
            /**
             * Line in the input file with this warnings source.
             * @type {number}
             *
             * @example
             * warning.line //=> 5
             */

            this.line = pos.line;
            /**
             * Column in the input file with this warnings source.
             *
             * @type {number}
             *
             * @example
             * warning.column //=> 6
             */

            this.column = pos.column;
          }

          for (var opt in opts) {
            this[opt] = opts[opt];
          }
        }
        /**
         * Returns a warning position and message.
         *
         * @example
         * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
         *
         * @return {string} Warning position and message.
         */


        var _proto = Warning.prototype;

        _proto.toString = function toString() {
          if (this.node) {
            return this.node.error(this.text, {
              plugin: this.plugin,
              index: this.index,
              word: this.word }).
            message;
          }

          if (this.plugin) {
            return this.plugin + ': ' + this.text;
          }

          return this.text;
        }
        /**
         * @memberof Warning#
         * @member {string} plugin The name of the plugin that created
         *                         it will fill this property automatically.
         *                         this warning. When you call {@link Node#warn}
         *
         * @example
         * warning.plugin //=> 'postcss-important'
         */

        /**
         * @memberof Warning#
         * @member {Node} node Contains the CSS node that caused the warning.
         *
         * @example
         * warning.node.toString() //=> 'color: white !important'
         */;


        return Warning;
      }();

      var _default = Warning;
      exports.default = _default;
      module.exports = exports.default;


    }, {}], 149: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = require('./util');
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";

      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? new Map() : Object.create(null);
      }

      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };

      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };

      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };

      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };

      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }

        throw new Error('"' + aStr + '" is not in the set.');
      };

      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };

      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };

      exports.ArraySet = ArraySet;

    }, { "./util": 158 }], 150: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       *
       * Based on the Base 64 VLQ implementation in Closure Compiler:
       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
       *
       * Copyright 2011 The Closure Compiler Authors. All rights reserved.
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are
       * met:
       *
       *  * Redistributions of source code must retain the above copyright
       *    notice, this list of conditions and the following disclaimer.
       *  * Redistributions in binary form must reproduce the above
       *    copyright notice, this list of conditions and the following
       *    disclaimer in the documentation and/or other materials provided
       *    with the distribution.
       *  * Neither the name of Google Inc. nor the names of its
       *    contributors may be used to endorse or promote products derived
       *    from this software without specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       */

      var base64 = require('./base64');

      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011

      var VLQ_BASE_SHIFT = 5;

      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;

      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;

      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0 ?
        (-aValue << 1) + 1 :
        (aValue << 1) + 0;
      }

      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ?
        -shifted :
        shifted;
      }

      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;

        var vlq = toVLQSigned(aValue);

        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);

        return encoded;
      };

      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;

        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }

          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }

          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);

        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };

    }, { "./base64": 151 }], 151: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };

      /**
       * Decode a single base 64 character code digit to an integer. Returns -1 on
       * failure.
       */
      exports.decode = function (charCode) {
        var bigA = 65; // 'A'
        var bigZ = 90; // 'Z'

        var littleA = 97; // 'a'
        var littleZ = 122; // 'z'

        var zero = 48; // '0'
        var nine = 57; // '9'

        var plus = 43; // '+'
        var slash = 47; // '/'

        var littleOffset = 26;
        var numberOffset = 52;

        // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }

        // 26 - 51: abcdefghijklmnopqrstuvwxyz
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }

        // 52 - 61: 0123456789
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }

        // 62: +
        if (charCode == plus) {
          return 62;
        }

        // 63: /
        if (charCode == slash) {
          return 63;
        }

        // Invalid base64 digit.
        return -1;
      };

    }, {}], 152: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;

      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        } else
        if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }

          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else
        {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }

          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }

      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }

        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
        aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }

        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }

        return index;
      };

    }, {}], 153: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2014 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = require('./util');

      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA ||
        util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }

      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }

      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach =
      function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };

      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };

      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };

      exports.MappingList = MappingList;

    }, { "./util": 158 }], 154: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      // It turns out that some (most?) JavaScript engines don't self-host
      // `Array.prototype.sort`. This makes sense because C++ will likely remain
      // faster than JS when doing raw CPU-intensive sorting. However, when using a
      // custom comparator function, calling back and forth between the VM's C++ and
      // JIT'd JS is rather slow *and* loses JIT type information, resulting in
      // worse generated code for the comparator function than would be optimal. In
      // fact, when sorting with a comparator, these costs outweigh the benefits of
      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
      // a ~3500ms mean speed-up in `bench/bench.html`.

      /**
       * Swap the elements indexed by `x` and `y` in the array `ary`.
       *
       * @param {Array} ary
       *        The array.
       * @param {Number} x
       *        The index of the first item.
       * @param {Number} y
       *        The index of the second item.
       */
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }

      /**
       * Returns a random integer within the range `low .. high` inclusive.
       *
       * @param {Number} low
       *        The lower bound on the range.
       * @param {Number} high
       *        The upper bound on the range.
       */
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }

      /**
       * The Quick Sort algorithm.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       * @param {Number} p
       *        Start index of the array
       * @param {Number} r
       *        End index of the array
       */
      function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.

        if (p < r) {
          // (1) Partitioning.
          //
          // The partitioning chooses a pivot between `p` and `r` and moves all
          // elements that are less than or equal to the pivot to the before it, and
          // all the elements that are greater than it after it. The effect is that
          // once partition is done, the pivot is in the exact place it will be when
          // the array is put in sorted order, and it will not need to be moved
          // again. This runs in O(n) time.

          // Always choose a random pivot so that an input array which is reverse
          // sorted does not cause O(n^2) running time.
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;

          swap(ary, pivotIndex, r);
          var pivot = ary[r];

          // Immediately after `j` is incremented in this loop, the following hold
          // true:
          //
          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
          //
          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }

          swap(ary, i + 1, j);
          var q = i + 1;

          // (2) Recurse on each half.

          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }

      /**
       * Sort the given array in-place with the given comparator function.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       */
      exports.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };

    }, {}], 155: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = require('./util');
      var binarySearch = require('./binary-search');
      var ArraySet = require('./array-set').ArraySet;
      var base64VLQ = require('./base64-vlq');
      var quickSort = require('./quick-sort').quickSort;

      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }

        return sourceMap.sections != null ?
        new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) :
        new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }

      SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };

      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;

      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.

      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        configurable: true,
        enumerable: true,
        get: function () {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }

          return this.__generatedMappings;
        } });


      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        configurable: true,
        enumerable: true,
        get: function () {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }

          return this.__originalMappings;
        } });


      SourceMapConsumer.prototype._charIsMappingSeparator =
      function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
      function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };

      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;

      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;

      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
      function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");}


        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name) };

        }, this).forEach(aCallback, context);
      };

      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number is 1-based.
       *   - column: Optional. the column number in the original source.
       *    The column number is 0-based.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *    line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *    The column number is 0-based.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor =
      function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, 'line');

        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
        // returns the index of the closest mapping less than the needle. By
        // setting needle.originalColumn to 0, we thus find the last mapping for
        // the given line, provided such a mapping exists.
        var needle = {
          source: util.getArg(aArgs, 'source'),
          originalLine: line,
          originalColumn: util.getArg(aArgs, 'column', 0) };


        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }

        var mappings = [];

        var index = this._findMapping(needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND);
        if (index >= 0) {
          var mapping = this._originalMappings[index];

          if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) });


              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while (mapping &&
            mapping.originalLine === line &&
            mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) });


              mapping = this._originalMappings[++index];
            }
          }
        }

        return mappings;
      };

      exports.SourceMapConsumer = SourceMapConsumer;

      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The first parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * The second parameter, if given, is a string whose value is the URL
       * at which the source map was found.  This URL is used to compute the
       * sources array.
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }

        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);

        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }

        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }

        sources = sources.
        map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function (source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ?
          util.relative(sourceRoot, source) :
          source;
        });

        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);

        this._absoluteSources = this._sources.toArray().map(function (s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });

        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }

      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

      /**
       * Utility function to find the index of a source.  Returns -1 if not
       * found.
       */
      BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }

        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }

        // Maybe aSource is an absolute URL as returned by |sources|.  In
        // this case we can't simply undo the transform.
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }

        return -1;
      };

      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @param String aSourceMapURL
       *        The URL at which the source map can be found (optional)
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap =
      function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);

        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
        smc.sourceRoot);
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function (s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });

        // Because we are modifying the entries (by converting string sources and
        // names to indices into the sources and names ArraySets), we have to make
        // a copy of the entry or else bad things happen. Shared mutable state
        // strikes again! See github issue #191.

        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];

        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;

          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;

            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }

            destOriginalMappings.push(destMapping);
          }

          destGeneratedMappings.push(destMapping);
        }

        quickSort(smc.__originalMappings, util.compareByOriginalPositions);

        return smc;
      };

      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;

      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._absoluteSources.slice();
        } });


      /**
       * Provide the JIT with a nice shape / hidden class.
       */
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings =
      function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;

        while (index < length) {
          if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else
          if (aStr.charAt(index) === ',') {
            index++;
          } else
          {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;

            // Because each offset is encoded relative to the previous one,
            // many segments often have the same encoding. We can exploit this
            // fact by caching the parsed variable length fields of each segment,
            // allowing us to avoid a second parse if we encounter the same
            // segment again.
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);

            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }

              if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
              }

              if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
              }

              cachedSegments[str] = segment;
            }

            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;

            if (segment.length > 1) {
              // Original source.
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];

              // Original line.
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              // Lines are stored 0-based
              mapping.originalLine += 1;

              // Original column.
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;

              if (segment.length > 4) {
                // Original name.
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }

            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
              originalMappings.push(mapping);
            }
          }
        }

        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;

        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };

      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping =
      function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
      aColumnName, aComparator, aBias) {
        // To return the position we are searching for, we must first find the
        // mapping for the given position and then return the opposite position it
        // points to. Because the mappings are sorted, we can use binary search to
        // find the best mapping.

        if (aNeedle[aLineName] <= 0) {
          throw new TypeError('Line must be greater than or equal to 1, got ' +
          aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError('Column must be greater than or equal to 0, got ' +
          aNeedle[aColumnName]);
        }

        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };

      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans =
      function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];

          // Mappings do not contain a field for the last generated columnt. We
          // can come up with an optimistic estimate, however, by assuming that
          // mappings are contiguous (i.e. given two consecutive mappings, the
          // first mapping ends where the second one starts).
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];

            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }

          // The last mapping for each line spans the entire line.
          mapping.lastGeneratedColumn = Infinity;
        }
      };

      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor =
      function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column') };


        var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));


        if (index >= 0) {
          var mapping = this._generatedMappings[index];

          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: name };

          }
        }

        return {
          source: null,
          line: null,
          column: null,
          name: null };

      };

      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
      function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) {return sc == null;});
      };

      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor =
      function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }

        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }

        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }

        var url;
        if (this.sourceRoot != null && (
        url = util.urlParse(this.sourceRoot))) {
          // XXX: file:// URIs and absolute paths lead to unexpected behavior for
          // many users. We can help them out when they expect file:// URIs to
          // behave like it would if they were running a local HTTP server. See
          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" &&
          this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }

          if ((!url.path || url.path == "/") &&
          this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }

        // This function is used recursively from
        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
        // don't want to throw if we can't find the source - we just want to
        // return null, so we provide a flag to exit gracefully.
        if (nullOnMissing) {
          return null;
        } else
        {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };

      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor =
      function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, 'source');
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null };

        }

        var needle = {
          source: source,
          originalLine: util.getArg(aArgs, 'line'),
          originalColumn: util.getArg(aArgs, 'column') };


        var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));


        if (index >= 0) {
          var mapping = this._originalMappings[index];

          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null) };

          }
        }

        return {
          line: null,
          column: null,
          lastColumn: null };

      };

      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The first parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * The second parameter, if given, is a string whose value is the URL
       * at which the source map was found.  This URL is used to compute the
       * sources array.
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }

        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');

        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }

        this._sources = new ArraySet();
        this._names = new ArraySet();

        var lastOffset = {
          line: -1,
          column: 0 };

        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');

          if (offsetLine < lastOffset.line ||
          offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;

          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1 },

            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL) };

        });
      }

      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;

      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        } });


      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor =
      function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column') };


        // Find the section containing the generated position we're trying to map
        // to an original position.
        var sectionIndex = binarySearch.search(needle, this._sections,
        function (needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return needle.generatedColumn -
          section.generatedOffset.generatedColumn;
        });
        var section = this._sections[sectionIndex];

        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null };

        }

        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (
          section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (
          section.generatedOffset.generatedLine === needle.generatedLine ?
          section.generatedOffset.generatedColumn - 1 :
          0),
          bias: aArgs.bias });

      };

      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
      function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function (s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };

      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor =
      function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];

          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else
        {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };

      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based. 
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor =
      function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];

          // Only consider this section if the requested source is in the list of
          // sources of the consumer.
          if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (
              section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (
              section.generatedOffset.generatedLine === generatedPosition.line ?
              section.generatedOffset.generatedColumn - 1 :
              0) };

            return ret;
          }
        }

        return {
          line: null,
          column: null };

      };

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings =
      function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];

            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);

            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }

            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
              source: source,
              generatedLine: mapping.generatedLine + (
              section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (
              section.generatedOffset.generatedLine === mapping.generatedLine ?
              section.generatedOffset.generatedColumn - 1 :
              0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: name };


            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }

        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };

      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

    }, { "./array-set": 149, "./base64-vlq": 150, "./binary-search": 152, "./quick-sort": 154, "./util": 158 }], 156: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var base64VLQ = require('./base64-vlq');
      var util = require('./util');
      var ArraySet = require('./array-set').ArraySet;
      var MappingList = require('./mapping-list').MappingList;

      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }

      SourceMapGenerator.prototype._version = 3;

      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
      function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot: sourceRoot });

        aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn } };



          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }

            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn };


            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }

          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }

          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }

          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };

      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
      function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, 'generated');
        var original = util.getArg(aArgs, 'original', null);
        var source = util.getArg(aArgs, 'source', null);
        var name = util.getArg(aArgs, 'name', null);

        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }

        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }

        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }

        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name });

      };

      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
      function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }

        if (aSourceContent != null) {
          // Add the source content to the _sourcesContents map.
          // Create a new _sourcesContents map if the property is null.
          if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          // Remove the source file from the _sourcesContents map.
          // If the _sourcesContents map is empty, set the property to null.
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };

      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
      function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        // If aSourceFile is omitted, we will use the file property of the SourceMap
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.');

          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        // Make "sourceFile" relative if an absolute Url is passed.
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        // Applying the SourceMap can add and remove items from the sources and
        // the names array.
        var newSources = new ArraySet();
        var newNames = new ArraySet();

        // Find mappings for the "sourceFile"
        this._mappings.unsortedForEach(function (mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn });

            if (original.source != null) {
              // Copy mapping
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }

          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }

          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }

        }, this);
        this._sources = newSources;
        this._names = newNames;

        // Copy sourcesContents of applied map.
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
          }
        }, this);
      };

      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
      function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
      aName) {
        // When aOriginal is truthy but has empty values for .line and .column,
        // it is most likely a programmer error. In this case we throw a very
        // specific error message to try to guide them the right way.
        // For example: https://github.com/Polymer/polymer-bundler/pull/519
        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
          'original.line and original.column are not numbers -- you probably meant to omit ' +
          'the original mapping entirely and only map the generated position. If so, pass ' +
          'null for the original mapping instead of an object with empty or null values.');

        }

        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated &&
        aGenerated.line > 0 && aGenerated.column >= 0 &&
        !aOriginal && !aSource && !aName) {
          // Case 1.
          return;
        } else
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated &&
        aOriginal && 'line' in aOriginal && 'column' in aOriginal &&
        aGenerated.line > 0 && aGenerated.column >= 0 &&
        aOriginal.line > 0 && aOriginal.column >= 0 &&
        aSource) {
          // Cases 2 and 3.
          return;
        } else
        {
          throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName }));

        }
      };

      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
      function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;

        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = '';

          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ';';
              previousGeneratedLine++;
            }
          } else
          {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ',';
            }
          }

          next += base64VLQ.encode(mapping.generatedColumn -
          previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;

          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;

            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 -
            previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;

            next += base64VLQ.encode(mapping.originalColumn -
            previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;

            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }

          result += next;
        }

        return result;
      };

      SourceMapGenerator.prototype._generateSourcesContent =
      function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ?
          this._sourcesContents[key] :
          null;
        }, this);
      };

      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
      function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings() };

        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }

        return map;
      };

      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
      function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };

      exports.SourceMapGenerator = SourceMapGenerator;

    }, { "./array-set": 149, "./base64-vlq": 150, "./mapping-list": 153, "./util": 158 }], 157: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
      var util = require('./util');

      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;

      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;

      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";

      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }

      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
      function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        // The SourceNode we want to fill with the generated code
        // and the SourceMap
        var node = new SourceNode();

        // All even indices of this array are one line of the generated code,
        // while all odd indices are the newlines between two adjacent lines
        // (since `REGEX_NEWLINE` captures its match).
        // Processed fragments are accessed by calling `shiftNextLine`.
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function () {
          var lineContents = getNextLine();
          // The last line of a file might not have a newline.
          var newLine = getNextLine() || "";
          return lineContents + newLine;

          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
          }
        };

        // We need to remember the position of "remainingLines"
        var lastGeneratedLine = 1,lastGeneratedColumn = 0;

        // The generate SourceNodes we need a code range.
        // To extract it current and last mapping is used.
        // Here we store the last mapping.
        var lastMapping = null;

        aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
              // Associate first line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
              // The remaining code is added without mapping
            } else {
              // There is no new line in between.
              // Associate the code between "lastGeneratedColumn" and
              // "mapping.generatedColumn" with "lastMapping"
              var nextLine = remainingLines[remainingLinesIndex] || '';
              var code = nextLine.substr(0, mapping.generatedColumn -
              lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
              lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              // No more remaining code, continue
              lastMapping = mapping;
              return;
            }
          }
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        // We have processed all mappings.
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          // and add the remaining lines without any mapping
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }

        // Copy sourcesContent into SourceNode
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });

        return node;

        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === undefined) {
            node.add(code);
          } else {
            var source = aRelativePath ?
            util.join(aRelativePath, mapping.source) :
            mapping.source;
            node.add(new SourceNode(mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name));
          }
        }
      };

      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        } else
        if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else
        {
          throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);

        }
        return this;
      };

      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else
        if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else
        {
          throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);

        }
        return this;
      };

      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else
          {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                line: this.line,
                column: this.column,
                name: this.name });
            }
          }
        }
      };

      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };

      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else
        if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else
        {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };

      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
      function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };

      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
      function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }

        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };

      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };

      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0 };

        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null &&
          original.line !== null &&
          original.column !== null) {
            if (lastOriginalSource !== original.source ||
            lastOriginalLine !== original.line ||
            lastOriginalColumn !== original.column ||
            lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column },

                generated: {
                  line: generated.line,
                  column: generated.column },

                name: original.name });

            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column } });


            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column },

                  generated: {
                    line: generated.line,
                    column: generated.column },

                  name: original.name });

              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });

        return { code: generated.code, map: map };
      };

      exports.SourceNode = SourceNode;

    }, { "./source-map-generator": 156, "./util": 158 }], 158: [function (require, module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;

      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;

      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5] };

      }
      exports.urlParse = urlParse;

      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;

      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consecutive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);

        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');

        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }

        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;

      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }

        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }

        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }

        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }

        var joined = aPath.charAt(0) === '/' ?
        aPath :
        normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;

      exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
      };

      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }

        aRoot = aRoot.replace(/\/$/, '');

        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }

          // If the only part of the root that is left is the scheme (i.e. http://,
          // file:///, etc.), one or more slashes (/), or simply nothing at all, we
          // have exhausted all components, so the path is not relative to the root.
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }

          ++level;
        }

        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;

      var supportsNullProto = function () {
        var obj = Object.create(null);
        return !('__proto__' in obj);
      }();

      function identity(s) {
        return s;
      }

      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return '$' + aStr;
        }

        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;

      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }

        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;

      function isProtoString(s) {
        if (!s) {
          return false;
        }

        var length = s.length;

        if (length < 9 /* "__proto__".length */) {
            return false;
          }

        if (s.charCodeAt(length - 1) !== 95 /* '_' */ ||
        s.charCodeAt(length - 2) !== 95 /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95 /* '_' */ ||
        s.charCodeAt(length - 9) !== 95 /* '_' */) {
            return false;
          }

        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36 /* '$' */) {
              return false;
            }
        }

        return true;
      }

      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;

      /**
       * Comparator between two mappings with deflated source and name indices where
       * the generated positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }

        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }

        if (aStr1 === null) {
          return 1; // aStr2 !== null
        }

        if (aStr2 === null) {
          return -1; // aStr1 !== null
        }

        if (aStr1 > aStr2) {
          return 1;
        }

        return -1;
      }

      /**
       * Comparator between two mappings with inflated source and name strings where
       * the generated positions are compared.
       */
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }

        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }

        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

      /**
       * Strip any JSON XSSI avoidance prefix from the string (as documented
       * in the source maps specification), and then parse the string as
       * JSON.
       */
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
      }
      exports.parseSourceMapInput = parseSourceMapInput;

      /**
       * Compute the URL of a source given the the source root, the source's
       * URL, and the source map's URL.
       */
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || '';

        if (sourceRoot) {
          // This follows what Chrome does.
          if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
          }
          // The spec says:
          //   Line 4: An optional source root, useful for relocating source
          //   files on a server or removing repeated values in the
          //   sources entry.  This value is prepended to the individual
          //   entries in the source field.
          sourceURL = sourceRoot + sourceURL;
        }

        // Historically, SourceMapConsumer did not take the sourceMapURL as
        // a parameter.  This mode is still somewhat supported, which is why
        // this code block is conditional.  However, it's preferable to pass
        // the source map URL to SourceMapConsumer, so that this function
        // can implement the source URL resolution algorithm as outlined in
        // the spec.  This block is basically the equivalent of:
        //    new URL(sourceURL, sourceMapURL).toString()
        // ... except it avoids using URL, which wasn't available in the
        // older releases of node still supported by this library.
        //
        // The spec says:
        //   If the sources are not absolute URLs after prepending of the
        //   sourceRoot, the sources are resolved relative to the
        //   SourceMap (like resolving script src in a html document).
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }

        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;

    }, {}], 159: [function (require, module, exports) {
      /*
       * Copyright 2009-2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE.txt or:
       * http://opensource.org/licenses/BSD-3-Clause
       */
      exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
      exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
      exports.SourceNode = require('./lib/source-node').SourceNode;

    }, { "./lib/source-map-consumer": 155, "./lib/source-map-generator": 156, "./lib/source-node": 157 }], 160: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }


      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }



      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {return [];};

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {return '/';};
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {return 0;};

    }, {}], 161: [function (require, module, exports) {
      (function (global) {(function () {
          /*! https://mths.be/punycode v1.4.1 by @mathias */
          ;(function (root) {

            /** Detect free variables */
            var freeExports = typeof exports == 'object' && exports &&
            !exports.nodeType && exports;
            var freeModule = typeof module == 'object' && module &&
            !module.nodeType && module;
            var freeGlobal = typeof global == 'object' && global;
            if (
            freeGlobal.global === freeGlobal ||
            freeGlobal.window === freeGlobal ||
            freeGlobal.self === freeGlobal)
            {
              root = freeGlobal;
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,

            /** Highest positive signed 32-bit float value */
            maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

            /** Bootstring parameters */
            base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128, // 0x80
            delimiter = '-', // '\x2D'

            /** Regular expressions */
            regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
            regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

            /** Error messages */
            errors = {
              'overflow': 'Overflow: input needs wider integers to process',
              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
              'invalid-input': 'Invalid input' },


            /** Convenience shortcuts */
            baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,

            /** Temporary variable */
            key;

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw new RangeError(errors[type]);
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@');
              var result = '';
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E');
              var labels = string.split('.');
              var encoded = map(labels, fn).join('.');
              return result + encoded;
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) {// low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                  value -= 0x10000;
                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                  value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,
              /** Cached calculation results */
              baseMinusT;

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                  if (index >= inputLength) {
                    error('invalid-input');
                  }

                  digit = basicToDigit(input.charCodeAt(index++));

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }

                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                  if (digit < t) {
                    break;
                  }

                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }

                  w *= baseMinusT;

                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);

              }

              return ucs2encode(output);
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],
              /** `inputLength` will hold the number of code points in `input`. */
              inputLength,
              /** Cached calculation results */
              handledCPCountPlusOne,
              baseMinusT,
              qMinusT;

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);

              // Cache the length
              inputLength = input.length;

              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }

              handledCPCount = basicLength = output.length;

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base;; /* no condition */k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(
                      stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));

                      q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }

                ++delta;
                ++n;

              }
              return output.join('');
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string) ?
                decode(string.slice(4).toLowerCase()) :
                string;
              });
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ?
                'xn--' + encode(string) :
                string;
              });
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              'version': '1.4.1',
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode },

              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode };


            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (
            typeof define == 'function' &&
            typeof define.amd == 'object' &&
            define.amd)
            {
              define('punycode', function () {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
              } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              // in Rhino or a web browser
              root.punycode = punycode;
            }

          })(this);

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 162: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      // If obj.hasOwnProperty has been overridden, then calling
      // obj.hasOwnProperty(prop) will break.
      // See: https://github.com/joyent/node/issues/1707
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      module.exports = function (qs, sep, eq, options) {
        sep = sep || '&';
        eq = eq || '=';
        var obj = {};

        if (typeof qs !== 'string' || qs.length === 0) {
          return obj;
        }

        var regexp = /\+/g;
        qs = qs.split(sep);

        var maxKeys = 1000;
        if (options && typeof options.maxKeys === 'number') {
          maxKeys = options.maxKeys;
        }

        var len = qs.length;
        // maxKeys <= 0 means that we should not limit keys count
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }

        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,vstr,k,v;

          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = '';
          }

          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);

          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }

        return obj;
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };

    }, {}], 163: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var stringifyPrimitive = function (v) {
        switch (typeof v) {
          case 'string':
            return v;

          case 'boolean':
            return v ? 'true' : 'false';

          case 'number':
            return isFinite(v) ? v : '';

          default:
            return '';}

      };

      module.exports = function (obj, sep, eq, name) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
          obj = undefined;
        }

        if (typeof obj === 'object') {
          return map(objectKeys(obj), function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (isArray(obj[k])) {
              return map(obj[k], function (v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);

        }

        if (!name) return '';
        return encodeURIComponent(stringifyPrimitive(name)) + eq +
        encodeURIComponent(stringifyPrimitive(obj));
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };

      function map(xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          res.push(f(xs[i], i));
        }
        return res;
      }

      var objectKeys = Object.keys || function (obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
        }
        return res;
      };

    }, {}], 164: [function (require, module, exports) {
      'use strict';

      exports.decode = exports.parse = require('./decode');
      exports.encode = exports.stringify = require('./encode');

    }, { "./decode": 162, "./encode": 163 }], 165: [function (require, module, exports) {
      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
        factory(global.SPECIFICITY = {});
      })(this, function (exports) {'use strict';

        // Calculate the specificity for a selector by dividing it into simple selectors and counting them
        var calculate = function (input) {
          var selectors,
          selector,
          i,
          len,
          results = [];

          // Separate input by commas
          selectors = input.split(',');

          for (i = 0, len = selectors.length; i < len; i += 1) {
            selector = selectors[i];
            if (selector.length > 0) {
              results.push(calculateSingle(selector));
            }
          }

          return results;
        };

        /**
         * Calculates the specificity of CSS selectors
         * http://www.w3.org/TR/css3-selectors/#specificity
         *
         * Returns an object with the following properties:
         *  - selector: the input
         *  - specificity: e.g. 0,1,0,0
         *  - parts: array with details about each part of the selector that counts towards the specificity
         *  - specificityArray: e.g. [0, 1, 0, 0]
         */
        var calculateSingle = function (input) {
          var selector = input,
          findMatch,
          typeCount = {
            'a': 0,
            'b': 0,
            'c': 0 },

          parts = [],
          // The following regular expressions assume that selectors matching the preceding regular expressions have been removed
          attributeRegex = /(\[[^\]]+\])/g,
          idRegex = /(#[^\#\s\+>~\.\[:\)]+)/g,
          classRegex = /(\.[^\s\+>~\.\[:\)]+)/g,
          pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi,
          // A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()
          // The negation psuedo class (:not) is filtered out because specificity is calculated on its argument
          // :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules
          pseudoClassWithBracketsRegex = /(:(?!not|global|local)[\w-]+\([^\)]*\))/gi,
          // A regex for other pseudo classes, which don't have brackets
          pseudoClassRegex = /(:(?!not|global|local)[^\s\+>~\.\[:]+)/g,
          elementRegex = /([^\s\+>~\.\[:]+)/g;

          // Find matches for a regular expression in a string and push their details to parts
          // Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
          findMatch = function (regex, type) {
            var matches, i, len, match, index, length;
            if (regex.test(selector)) {
              matches = selector.match(regex);
              for (i = 0, len = matches.length; i < len; i += 1) {
                typeCount[type] += 1;
                match = matches[i];
                index = selector.indexOf(match);
                length = match.length;
                parts.push({
                  selector: input.substr(index, length),
                  type: type,
                  index: index,
                  length: length });

                // Replace this simple selector with whitespace so it won't be counted in further simple selectors
                selector = selector.replace(match, Array(length + 1).join(' '));
              }
            }
          };

          // Replace escaped characters with plain text, using the "A" character
          // https://www.w3.org/TR/CSS21/syndata.html#characters
          (function () {
            var replaceWithPlainText = function (regex) {
              var matches, i, len, match;
              if (regex.test(selector)) {
                matches = selector.match(regex);
                for (i = 0, len = matches.length; i < len; i += 1) {
                  match = matches[i];
                  selector = selector.replace(match, Array(match.length + 1).join('A'));
                }
              }
            },
            // Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character
            escapeHexadecimalRegex = /\\[0-9A-Fa-f]{6}\s?/g,
            // Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character
            escapeHexadecimalRegex2 = /\\[0-9A-Fa-f]{1,5}\s/g,
            // Matches a backslash followed by any character
            escapeSpecialCharacter = /\\./g;

            replaceWithPlainText(escapeHexadecimalRegex);
            replaceWithPlainText(escapeHexadecimalRegex2);
            replaceWithPlainText(escapeSpecialCharacter);
          })();

          // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
          (function () {
            var regex = /{[^]*/gm,
            matches,i,len,match;
            if (regex.test(selector)) {
              matches = selector.match(regex);
              for (i = 0, len = matches.length; i < len; i += 1) {
                match = matches[i];
                selector = selector.replace(match, Array(match.length + 1).join(' '));
              }
            }
          })();

          // Add attribute selectors to parts collection (type b)
          findMatch(attributeRegex, 'b');

          // Add ID selectors to parts collection (type a)
          findMatch(idRegex, 'a');

          // Add class selectors to parts collection (type b)
          findMatch(classRegex, 'b');

          // Add pseudo-element selectors to parts collection (type c)
          findMatch(pseudoElementRegex, 'c');

          // Add pseudo-class selectors to parts collection (type b)
          findMatch(pseudoClassWithBracketsRegex, 'b');
          findMatch(pseudoClassRegex, 'b');

          // Remove universal selector and separator characters
          selector = selector.replace(/[\*\s\+>~]/g, ' ');

          // Remove any stray dots or hashes which aren't attached to words
          // These may be present if the user is live-editing this selector
          selector = selector.replace(/[#\.]/g, ' ');

          // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
          // Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity
          selector = selector.replace(/:not/g, '    ');
          selector = selector.replace(/:local/g, '      ');
          selector = selector.replace(/:global/g, '       ');
          selector = selector.replace(/[\(\)]/g, ' ');

          // The only things left should be element selectors (type c)
          findMatch(elementRegex, 'c');

          // Order the parts in the order they appear in the original selector
          // This is neater for external apps to deal with
          parts.sort(function (a, b) {
            return a.index - b.index;
          });

          return {
            selector: input,
            specificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),
            specificityArray: [0, typeCount.a, typeCount.b, typeCount.c],
            parts: parts };

        };

        /**
         * Compares two CSS selectors for specificity
         * Alternatively you can replace one of the CSS selectors with a specificity array
         *
         *  - it returns -1 if a has a lower specificity than b
         *  - it returns 1 if a has a higher specificity than b
         *  - it returns 0 if a has the same specificity than b
         */
        var compare = function (a, b) {
          var aSpecificity,
          bSpecificity,
          i;

          if (typeof a === 'string') {
            if (a.indexOf(',') !== -1) {
              throw 'Invalid CSS selector';
            } else {
              aSpecificity = calculateSingle(a)['specificityArray'];
            }
          } else if (Array.isArray(a)) {
            if (a.filter(function (e) {return typeof e === 'number';}).length !== 4) {
              throw 'Invalid specificity array';
            } else {
              aSpecificity = a;
            }
          } else {
            throw 'Invalid CSS selector or specificity array';
          }

          if (typeof b === 'string') {
            if (b.indexOf(',') !== -1) {
              throw 'Invalid CSS selector';
            } else {
              bSpecificity = calculateSingle(b)['specificityArray'];
            }
          } else if (Array.isArray(b)) {
            if (b.filter(function (e) {return typeof e === 'number';}).length !== 4) {
              throw 'Invalid specificity array';
            } else {
              bSpecificity = b;
            }
          } else {
            throw 'Invalid CSS selector or specificity array';
          }

          for (i = 0; i < 4; i += 1) {
            if (aSpecificity[i] < bSpecificity[i]) {
              return -1;
            } else if (aSpecificity[i] > bSpecificity[i]) {
              return 1;
            }
          }

          return 0;
        };

        exports.calculate = calculate;
        exports.compare = compare;

        Object.defineProperty(exports, '__esModule', { value: true });

      });

    }, {}], 166: [function (require, module, exports) {
      var SKIP = 'skip';
      var CHECK = 'check';
      var ONLY = 'only';

      module.exports = function (options, callback) {
        var source = options.source;
        var target = options.target;

        var skipComments = options.comments ? options.comments === SKIP : true;
        var skipStrings = options.strings ? options.strings === SKIP : true;
        var skipFunctionNames = options.functionNames ? options.functionNames === SKIP : true;
        var skipFunctionArguments = options.functionArguments === SKIP;
        var skipParentheticals = options.parentheticals === SKIP;

        var onceOptionUsed = false;
        Object.keys(options).forEach(function (key) {
          if (options[key] !== ONLY) return;
          if (!onceOptionUsed) {
            onceOptionUsed = true;
          } else {
            throw new Error('Only one syntax feature option can be the "only" one to check');
          }
        });

        var onlyComments = options.comments === ONLY;
        var onlyStrings = options.strings === ONLY;
        var onlyFunctionNames = options.functionNames === ONLY;
        var onlyFunctionArguments = options.functionArguments === ONLY;
        var onlyParentheticals = options.parentheticals === ONLY;

        var insideString = false;
        var insideComment = false;
        var insideSingleLineComment = false;
        var insideParens = false;
        var insideFunctionArguments = false;
        var openingParenCount = 0;
        var matchCount = 0;
        var openingQuote;

        var targetIsArray = Array.isArray(target);

        // If the target is just a string, it is easy to check whether
        // some index of the source matches it.
        // If the target is an array of strings, though, we have to
        // check whether some index of the source matches *any* of
        // those target strings (stopping after the first match).
        var getMatch = function () {
          if (!targetIsArray) {
            return getMatchBase.bind(null, target);
          }
          return function (index) {
            for (var ti = 0, tl = target.length; ti < tl; ti++) {
              var checkResult = getMatchBase(target[ti], index);
              if (checkResult) return checkResult;
            }
            return false;
          };
        }();

        function getMatchBase(targetString, index) {
          var targetStringLength = targetString.length;

          // Target is a single character
          if (targetStringLength === 1 && source[index] !== targetString) return false;

          // Target is multiple characters
          if (source.substr(index, targetStringLength) !== targetString) return false;

          return {
            insideParens: insideParens,
            insideFunctionArguments: insideFunctionArguments,
            insideComment: insideComment,
            insideString: insideString,
            startIndex: index,
            endIndex: index + targetStringLength,
            target: targetString };

        }

        for (var i = 0, l = source.length; i < l; i++) {
          var currentChar = source[i];

          // Register the beginning of a comment
          if (
          !insideString && !insideComment &&
          currentChar === "/" &&
          source[i - 1] !== "\\" // escaping
          ) {
              // standard comments
              if (source[i + 1] === "*") {
                insideComment = true;
                continue;
              }
              // single-line comments
              if (source[i + 1] === "/") {
                insideComment = true;
                insideSingleLineComment = true;
                continue;
              }
            }

          if (insideComment) {
            // Register the end of a standard comment
            if (
            !insideSingleLineComment &&
            currentChar === "*" &&
            source[i - 1] !== "\\" // escaping
            && source[i + 1] === "/" &&
            source[i - 1] !== "/" // don't end if it's /*/
            ) {
                insideComment = false;
                continue;
              }

            // Register the end of a single-line comment
            if (
            insideSingleLineComment &&
            currentChar === "\n")
            {
              insideComment = false;
              insideSingleLineComment = false;
            }

            if (skipComments) continue;
          }

          // Register the beginning of a string
          if (!insideComment && !insideString && (currentChar === "\"" || currentChar === "'")) {
            if (source[i - 1] === "\\") continue; // escaping

            openingQuote = currentChar;
            insideString = true;

            // For string-quotes rule
            if (target === currentChar) handleMatch(getMatch(i));
            continue;
          }

          if (insideString) {
            // Register the end of a string
            if (currentChar === openingQuote) {
              if (source[i - 1] === "\\") continue; // escaping
              insideString = false;
              continue;
            }

            if (skipStrings) continue;
          }

          // Register the beginning of parens/functions
          if (!insideString && !insideComment && currentChar === "(") {
            // Keep track of opening parentheticals so that we
            // know when the outermost function (possibly
            // containing nested functions) is closing
            openingParenCount++;

            insideParens = true;
            // Only inside a function if there is a function name
            // before the opening paren
            if (/[a-zA-Z]/.test(source[i - 1])) {
              insideFunctionArguments = true;
            }

            if (target === "(") handleMatch(getMatch(i));
            continue;
          }

          if (insideParens) {
            // Register the end of a function
            if (currentChar === ")") {
              openingParenCount--;
              // Do this here so the match is still technically inside a function
              if (target === ")") handleMatch(getMatch(i));
              if (openingParenCount === 0) {
                insideParens = false;
                insideFunctionArguments = false;
              }
              continue;
            }
          }

          var isFunctionName = /^[a-zA-Z]*\(/.test(source.slice(i));
          if (skipFunctionNames && isFunctionName) continue;
          if (onlyFunctionNames && !isFunctionName) continue;

          var match = getMatch(i);

          if (!match) continue;
          handleMatch(match);
          if (options.once) return;
        }

        function handleMatch(match) {
          if (onlyParentheticals && !insideParens) return;
          if (skipParentheticals && insideParens) return;
          if (onlyFunctionArguments && !insideFunctionArguments) return;
          if (skipFunctionArguments && insideFunctionArguments) return;
          if (onlyStrings && !insideString) return;
          if (onlyComments && !insideComment) return;
          matchCount++;
          callback(match, matchCount);
        }
      };

    }, {}], 167: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      const COMMAND_PREFIX = 'stylelint-';
      const disableCommand = `${COMMAND_PREFIX}disable`;
      const enableCommand = `${COMMAND_PREFIX}enable`;
      const disableLineCommand = `${COMMAND_PREFIX}disable-line`;
      const disableNextLineCommand = `${COMMAND_PREFIX}disable-next-line`;
      const ALL_RULES = 'all';

      /** @typedef {import('postcss/lib/comment')} PostcssComment */
      /** @typedef {import('postcss').Root} PostcssRoot */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */

      /**
       * @param {PostcssComment} comment
       * @param {number} start
       * @param {boolean} strictStart
       * @param {string|undefined} description
       * @param {number} [end]
       * @param {boolean} [strictEnd]
       * @returns {DisabledRange}
       */
      function createDisableRange(comment, start, strictStart, description, end, strictEnd) {
        return {
          comment,
          start,
          end: end || undefined,
          strictStart,
          strictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,
          description };

      }

      /**
       * Run it like a plugin ...
       * @param {PostcssRoot} root
       * @param {PostcssResult} result
       * @returns {PostcssResult}
       */
      module.exports = function (root, result) {
        result.stylelint = result.stylelint || {
          disabledRanges: {},
          ruleSeverities: {},
          customMessages: {} };


        /**
         * Most of the functions below work via side effects mutating this object
         * @type {DisabledRangeObject}
         */
        const disabledRanges = {
          all: [] };


        result.stylelint.disabledRanges = disabledRanges;

        // Work around postcss/postcss-scss#109 by merging adjacent `//` comments
        // into a single node before passing to `checkComment`.

        /** @type {PostcssComment?} */
        let inlineEnd;

        root.walkComments( /** @type {PostcssComment} */comment => {
          if (inlineEnd) {
            // Ignore comments already processed by grouping with a previous one.
            if (inlineEnd === comment) inlineEnd = null;

            return;
          }

          const next = comment.next();

          // If any of these conditions are not met, do not merge comments.
          if (
          !(
          isInlineComment(comment) &&
          isStylelintCommand(comment) &&
          next &&
          next.type === 'comment' && (
          comment.text.includes('--') || next.text.startsWith('--'))))

          {
            checkComment(comment);

            return;
          }

          let lastLine = comment.source && comment.source.end && comment.source.end.line || 0;
          const fullComment = comment.clone();

          /** @type {PostcssComment} */
          let current = next;

          while (isInlineComment(current) && !isStylelintCommand(current)) {
            const currentLine = current.source && current.source.end && current.source.end.line || 0;

            if (lastLine + 1 !== currentLine) break;

            fullComment.text += `\n${current.text}`;

            if (fullComment.source && current.source) {
              fullComment.source.end = current.source.end;
            }

            inlineEnd = current;
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            const next = current.next();

            if (!next || next.type !== 'comment') break;

            current = next;
            lastLine = currentLine;
          }
          checkComment(fullComment);
        });

        return result;

        /**
         * @param {PostcssComment} comment
         */
        function isInlineComment(comment) {
          // We check both here because the Sass parser uses `raws.inline` to indicate
          // inline comments, while the Less parser uses `inline`.
          return comment.inline || comment.raws.inline;
        }

        /**
         * @param {PostcssComment} comment
         */
        function isStylelintCommand(comment) {
          return comment.text.startsWith(disableCommand) || comment.text.startsWith(enableCommand);
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableLineCommand(comment) {
          if (comment.source && comment.source.start) {
            const line = comment.source.start.line;
            const description = getDescription(comment.text);

            getCommandRules(disableLineCommand, comment.text).forEach(ruleName => {
              disableLine(comment, line, ruleName, description);
            });
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableNextLineCommand(comment) {
          if (comment.source && comment.source.end) {
            const line = comment.source.end.line;
            const description = getDescription(comment.text);

            getCommandRules(disableNextLineCommand, comment.text).forEach(ruleName => {
              disableLine(comment, line + 1, ruleName, description);
            });
          }
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {string|undefined} description
         */
        function disableLine(comment, line, ruleName, description) {
          if (ruleIsDisabled(ALL_RULES)) {
            throw comment.error('All rules have already been disabled', {
              plugin: 'stylelint' });

          }

          if (ruleName === ALL_RULES) {
            Object.keys(disabledRanges).forEach(disabledRuleName => {
              if (ruleIsDisabled(disabledRuleName)) return;

              const strict = disabledRuleName === ALL_RULES;

              startDisabledRange(comment, line, disabledRuleName, strict, description);
              endDisabledRange(line, disabledRuleName, strict);
            });
          } else {
            if (ruleIsDisabled(ruleName)) {
              throw comment.error(`"${ruleName}" has already been disabled`, {
                plugin: 'stylelint' });

            }

            startDisabledRange(comment, line, ruleName, true, description);
            endDisabledRange(line, ruleName, true);
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableCommand(comment) {
          const description = getDescription(comment.text);

          getCommandRules(disableCommand, comment.text).forEach(ruleToDisable => {
            const isAllRules = ruleToDisable === ALL_RULES;

            if (ruleIsDisabled(ruleToDisable)) {
              throw comment.error(
              isAllRules ?
              'All rules have already been disabled' :
              `"${ruleToDisable}" has already been disabled`,
              {
                plugin: 'stylelint' });


            }

            if (comment.source && comment.source.start) {
              const line = comment.source.start.line;

              if (isAllRules) {
                Object.keys(disabledRanges).forEach(ruleName => {
                  startDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);
                });
              } else {
                startDisabledRange(comment, line, ruleToDisable, true, description);
              }
            }
          });
        }

        /**
         * @param {PostcssComment} comment
         */
        function processEnableCommand(comment) {
          getCommandRules(enableCommand, comment.text).forEach(ruleToEnable => {
            // TODO TYPES
            // need fallback if endLine will be undefined
            const endLine = /** @type {number} */comment.source &&
            comment.source.end &&
            comment.source.end.line;

            if (ruleToEnable === ALL_RULES) {
              if (
              Object.values(disabledRanges).every(
              ranges => ranges.length === 0 || typeof ranges[ranges.length - 1].end === 'number'))

              {
                throw comment.error('No rules have been disabled', {
                  plugin: 'stylelint' });

              }

              Object.keys(disabledRanges).forEach(ruleName => {
                if (!_.get(_.last(disabledRanges[ruleName]), 'end')) {
                  endDisabledRange(endLine, ruleName, ruleName === ALL_RULES);
                }
              });

              return;
            }

            if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {
              // Get a starting point from the where all rules were disabled
              if (!disabledRanges[ruleToEnable]) {
                disabledRanges[ruleToEnable] = disabledRanges.all.map(({ start, end, description }) =>
                createDisableRange(comment, start, false, description, end, false));

              } else {
                const range = _.last(disabledRanges[ALL_RULES]);

                if (range) {
                  disabledRanges[ruleToEnable].push(_extends({}, range));
                }
              }

              endDisabledRange(endLine, ruleToEnable, true);

              return;
            }

            if (ruleIsDisabled(ruleToEnable)) {
              endDisabledRange(endLine, ruleToEnable, true);

              return;
            }

            throw comment.error(`"${ruleToEnable}" has not been disabled`, {
              plugin: 'stylelint' });

          });
        }

        /**
         * @param {PostcssComment} comment
         */
        function checkComment(comment) {
          const text = comment.text;

          // Ignore comments that are not relevant commands

          if (text.indexOf(COMMAND_PREFIX) !== 0) {
            return result;
          }

          if (text.startsWith(disableLineCommand)) {
            processDisableLineCommand(comment);
          } else if (text.startsWith(disableNextLineCommand)) {
            processDisableNextLineCommand(comment);
          } else if (text.startsWith(disableCommand)) {
            processDisableCommand(comment);
          } else if (text.startsWith(enableCommand)) {
            processEnableCommand(comment);
          }
        }

        /**
         * @param {string} command
         * @param {string} fullText
         * @returns {string[]}
         */
        function getCommandRules(command, fullText) {
          const rules = fullText.
          slice(command.length).
          split(/\s-{2,}\s/u)[0] // Allow for description (f.e. /* stylelint-disable a, b -- Description */).
          .trim().
          split(',').
          filter(Boolean).
          map(r => r.trim());

          if (_.isEmpty(rules)) {
            return [ALL_RULES];
          }

          return rules;
        }

        /**
         * @param {string} fullText
         * @returns {string|undefined}
         */
        function getDescription(fullText) {
          const descriptionStart = fullText.indexOf('--');

          if (descriptionStart === -1) return;

          return fullText.slice(descriptionStart + 2).trim();
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         * @param {string|undefined} description
         */
        function startDisabledRange(comment, line, ruleName, strict, description) {
          const rangeObj = createDisableRange(comment, line, strict, description);

          ensureRuleRanges(ruleName);
          disabledRanges[ruleName].push(rangeObj);
        }

        /**
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         */
        function endDisabledRange(line, ruleName, strict) {
          const lastRangeForRule = _.last(disabledRanges[ruleName]);

          if (!lastRangeForRule) {
            return;
          }

          // Add an `end` prop to the last range of that rule
          lastRangeForRule.end = line;
          lastRangeForRule.strictEnd = strict;
        }

        /**
         * @param {string} ruleName
         */
        function ensureRuleRanges(ruleName) {
          if (!disabledRanges[ruleName]) {
            disabledRanges[ruleName] = disabledRanges.all.map(({ comment, start, end, description }) =>
            createDisableRange(comment, start, false, description, end, false));

          }
        }

        /**
         * @param {string} ruleName
         * @returns {boolean}
         */
        function ruleIsDisabled(ruleName) {
          if (disabledRanges[ruleName] === undefined) return false;

          if (_.last(disabledRanges[ruleName]) === undefined) return false;

          if (_.get(_.last(disabledRanges[ruleName]), 'end') === undefined) return true;

          return false;
        }
      };

    }, { "lodash": 68 }], 168: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('postcss').NodeSource} NodeSource */
      /** @typedef {import('stylelint').StylelintResult} StylelintResult */

      /**
       * @param {PostcssResult} [postcssResult]
       * @param {import('stylelint').StylelintCssSyntaxError} [cssSyntaxError]
       * @return {StylelintResult}
       */
      module.exports = function (postcssResult, cssSyntaxError) {
        /** @type {StylelintResult} */
        let stylelintResult;
        /** @type {string | undefined} */
        let source;

        if (postcssResult && postcssResult.root) {
          if (postcssResult.root.source) {
            source = postcssResult.root.source.input.file;

            if (!source && 'id' in postcssResult.root.source.input) {
              source = postcssResult.root.source.input.id;
            }
          }

          // Strip out deprecation warnings from the messages
          const deprecationMessages = _.remove(postcssResult.messages, {
            stylelintType: 'deprecation' });

          const deprecations = deprecationMessages.map(deprecationMessage => {
            return {
              text: deprecationMessage.text,
              reference: deprecationMessage.stylelintReference };

          });

          // Also strip out invalid options
          const invalidOptionMessages = _.remove(postcssResult.messages, {
            stylelintType: 'invalidOption' });

          const invalidOptionWarnings = invalidOptionMessages.map(invalidOptionMessage => {
            return {
              text: invalidOptionMessage.text };

          });

          const parseErrors = _.remove(postcssResult.messages, {
            stylelintType: 'parseError' });


          // This defines the stylelint result object that formatters receive
          stylelintResult = {
            source,
            deprecations,
            invalidOptionWarnings,
            // TODO TYPES check which types are valid? postcss? stylelint?
            /* eslint-disable-next-line object-shorthand */
            parseErrors: /** @type {any} */parseErrors,
            errored: postcssResult.stylelint.stylelintError,
            warnings: postcssResult.messages.map(message => {
              return {
                line: message.line,
                column: message.column,
                rule: message.rule,
                severity: message.severity,
                text: message.text };

            }),
            ignored: postcssResult.stylelint.ignored,
            _postcssResult: postcssResult };

        } else if (cssSyntaxError) {
          if (cssSyntaxError.name !== 'CssSyntaxError') {
            throw cssSyntaxError;
          }

          stylelintResult = {
            source: cssSyntaxError.file || '<input css 1>',
            deprecations: [],
            invalidOptionWarnings: [],
            parseErrors: [],
            errored: true,
            warnings: [
            {
              line: cssSyntaxError.line,
              column: cssSyntaxError.column,
              rule: cssSyntaxError.name,
              severity: 'error',
              text: `${cssSyntaxError.reason} (${cssSyntaxError.name})` }] };



        } else {
          throw new Error(
          'createPartialStylelintResult must be called with either postcssResult or CssSyntaxError');

        }

        return stylelintResult;
      };

    }, { "lodash": 68 }], 169: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').StylelintRule} StylelintRule */

      /**
       * @param {string} ruleName
       * @param {StylelintRule} rule
       * @returns {{ruleName: string, rule: StylelintRule}}
       */
      module.exports = function (ruleName, rule) {
        return {
          ruleName,
          rule };

      };

    }, {}], 170: [function (require, module, exports) {
      (function (process, __dirname) {(function () {
          'use strict';

          const _ = require('lodash');
          /* const augmentConfig = require('./augmentConfig'); */
          const createStylelintResult = require('./createStylelintResult');
          /* const getConfigForFile = require('./getConfigForFile'); */
          const getConfigForFile = async stylelint => ({
            config: require('./normalizeAllRuleSettings')(stylelint._options.config) });

          const getPostcssResult = require('./getPostcssResult');
          /* const isPathIgnored = require('./isPathIgnored'); */
          const isPathIgnored = async () => false;
          const lintSource = require('./lintSource');
          const path = require('path');
          /* const { cosmiconfig } = require('cosmiconfig'); */

          const IS_TEST = process.env.NODE_ENV === 'test';
          const STOP_DIR = IS_TEST ? path.resolve(__dirname, '..') : undefined;

          /** @typedef {import('stylelint').StylelintInternalApi} StylelintInternalApi */

          /**
           * The stylelint "internal API" is passed among functions
           * so that methods on a stylelint instance can invoke
           * each other while sharing options and caches
           * @param {import('stylelint').StylelintStandaloneOptions} options
           * @returns {StylelintInternalApi}
           */
          module.exports = function (options = {}) {
            /** @type {Partial<StylelintInternalApi>} */
            const stylelint = { _options: options };

            // Two separate explorers so they can each have their own transform
            // function whose results are cached by cosmiconfig
            /* stylelint._fullExplorer = cosmiconfig('stylelint', {
            	// @ts-ignore TODO TYPES found out which cosmiconfig types are valid
            	transform: _.partial(
            		augmentConfig.augmentConfigFull,
            		 (stylelint),
            	),
            	stopDir: STOP_DIR,
            }); */
            // @ts-ignore TODO TYPES found out which cosmiconfig types are valid
            /* stylelint._extendExplorer = cosmiconfig(null, {
            	transform: _.partial(
            		augmentConfig.augmentConfigExtended,
            		 (stylelint),
            	),
            	stopDir: STOP_DIR,
            }); */

            stylelint._specifiedConfigCache = new Map();
            stylelint._postcssResultCache = new Map();
            stylelint._createStylelintResult = _.partial(
            createStylelintResult,
            /** @type{StylelintInternalApi} */stylelint);

            stylelint._getPostcssResult = _.partial(
            getPostcssResult,
            /** @type{StylelintInternalApi} */stylelint);

            stylelint._lintSource = _.partial(lintSource, /** @type{StylelintInternalApi} */stylelint);

            stylelint.getConfigForFile = _.partial(
            getConfigForFile,
            /** @type{StylelintInternalApi} */stylelint);

            stylelint.isPathIgnored = _.partial(
            isPathIgnored,
            /** @type{StylelintInternalApi} */stylelint);


            return (/** @type{StylelintInternalApi} */stylelint);
          };

        }).call(this);}).call(this, require('_process'), "/node_modules/stylelint/lib");
    }, { "./createStylelintResult": 171, "./getPostcssResult": 177, "./lintSource": 180, "./normalizeAllRuleSettings": 182, "_process": 160, "lodash": 68, "path": 74 }], 171: [function (require, module, exports) {
      'use strict';

      const createPartialStylelintResult = require('./createPartialStylelintResult');

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('postcss').NodeSource} NodeSource */
      /** @typedef {import('stylelint').StylelintResult} StylelintResult */

      /**
       * @param {import('stylelint').StylelintInternalApi} stylelint
       * @param {PostcssResult} [postcssResult]
       * @param {string} [filePath]
       * @param {import('stylelint').StylelintCssSyntaxError} [cssSyntaxError]
       * @return {Promise<StylelintResult>}
       */
      module.exports = function (stylelint, postcssResult, filePath, cssSyntaxError) {
        let stylelintResult = createPartialStylelintResult(postcssResult, cssSyntaxError);

        return stylelint.getConfigForFile(filePath).then(configForFile => {
          // TODO TYPES handle possible null here
          const config = /** @type {{ config: import('stylelint').StylelintConfig, filepath: string }} */configForFile.
          config;
          const file = stylelintResult.source || cssSyntaxError && cssSyntaxError.file;

          if (config.resultProcessors) {
            config.resultProcessors.forEach(resultProcessor => {
              // Result processors might just mutate the result object,
              // or might return a new one
              const returned = resultProcessor(stylelintResult, file);

              if (returned) {
                stylelintResult = returned;
              }
            });
          }

          return stylelintResult;
        });
      };

    }, { "./createPartialStylelintResult": 168 }], 172: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss/lib/comment')} PostcssComment */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */
      /** @typedef {import('stylelint').StylelintDisableOptionsReport} StylelintDisableOptionsReport */

      /**
       * @param {import('stylelint').StylelintResult[]} results
       */
      module.exports = function (results) {
        results.forEach(result => {
          // File with `CssSyntaxError` have not `_postcssResult`
          if (!result._postcssResult) {
            return;
          }

          const rangeData = result._postcssResult.stylelint.disabledRanges;

          /** @type {Set<PostcssComment>} */
          const alreadyReported = new Set();

          Object.keys(rangeData).forEach(rule => {
            rangeData[rule].forEach(range => {
              if (range.description) return;

              if (alreadyReported.has(range.comment)) return;

              alreadyReported.add(range.comment);

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) return;

              result.warnings.push({
                text: `Disable for "${rule}" is missing a description`,
                rule: '--report-descriptionless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: 'error' });

            });
          });
        });
      };

    }, {}], 173: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /**
       * @type {import('stylelint').Formatter}
       */
      const formatter = (results) =>
      _.flatMap(results, (result) =>
      result.warnings.map(
      (warning) =>
      `${result.source}: ` +
      `line ${warning.line}, ` +
      `col ${warning.column}, ` +
      `${warning.severity} - ` +
      `${warning.text}`)).

      join('\n');

      module.exports = formatter;

    }, { "lodash": 68 }], 174: [function (require, module, exports) {
      'use strict';

      const importLazy = require('import-lazy');

      module.exports = {
        compact: importLazy(() => require('./compactFormatter'))(),
        json: importLazy(() => require('./jsonFormatter'))(),
        /* string: importLazy(() => require('./stringFormatter'))(), */
        string: () => {},
        unix: importLazy(() => require('./unixFormatter'))(),
        /* verbose: importLazy(() => require('./verboseFormatter'))(), */
        verbose: () => {} };


    }, { "./compactFormatter": 173, "./jsonFormatter": 175, "./unixFormatter": 176, "import-lazy": 13 }], 175: [function (require, module, exports) {
      'use strict';

      /**
       * Omit any properties starting with `_`, which are fake-private
       *
       * @type {import('stylelint').Formatter}
       */
      module.exports = function jsonFormatter(results) {
        const cleanedResults = results.map((result) =>
        Object.entries(result).
        filter(([key]) => !key.startsWith('_')).
        reduce(( /** @type {{ [key: string]: any }} */obj, [key, value]) => {
          obj[key] = value;

          return obj;
        }, {}));


        return JSON.stringify(cleanedResults);
      };

    }, {}], 176: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /**
       * @type {import('stylelint').Formatter}
       */
      const unixFormatter = results => {
        const lines = _.flatMap(results, (result) =>
        result.warnings.map(
        (warning) =>
        `${result.source}:${warning.line}:${warning.column}: ` +
        `${warning.text} [${warning.severity}]\n`));


        const total = lines.length;
        let output = lines.join('');

        if (total > 0) {
          output += `\n${total} problem${total !== 1 ? 's' : ''}\n`;
        }

        return output;
      };

      module.exports = unixFormatter;

    }, { "lodash": 68 }], 177: [function (require, module, exports) {
      'use strict';

      /* const fs = require('fs'); */
      const LazyResult = require('postcss/lib/lazy-result');
      const postcss = require('postcss');
      const syntaxes = require('./syntaxes');

      /** @typedef {import('postcss').Result} Result */
      /** @typedef {import('postcss').Syntax} Syntax */
      /** @typedef {import('stylelint').CustomSyntax} CustomSyntax */
      /** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */
      /** @typedef {import('stylelint').StylelintInternalApi} StylelintInternalApi */

      const postcssProcessor = postcss();

      /**
       * @param {StylelintInternalApi} stylelint
       * @param {GetPostcssOptions} options
       *
       * @returns {Promise<Result>}
       */
      module.exports = function (stylelint, options = {}) {
        const cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;

        if (cached) return Promise.resolve(cached);

        /** @type {Promise<string> | undefined} */
        let getCode;

        if (options.code !== undefined) {
          getCode = Promise.resolve(options.code);
        } else if (options.filePath) {
          getCode = readFile(options.filePath);
        }

        if (!getCode) {
          throw new Error('code or filePath required');
        }

        return getCode.
        then(code => {
          /** @type {Syntax | null} */
          let syntax = null;

          if (stylelint._options.customSyntax) {
            syntax = getCustomSyntax(stylelint._options.customSyntax);
          } else if (stylelint._options.syntax) {
            if (stylelint._options.syntax === 'css') {
              syntax = cssSyntax(stylelint);
            } else {
              const keys = Object.keys(syntaxes);

              if (!keys.includes(stylelint._options.syntax)) {
                throw new Error(
                `You must use a valid syntax option, either: css, ${keys.
                slice(0, -1).
                join(', ')} or ${keys.slice(-1)}`);

              }

              syntax = syntaxes[stylelint._options.syntax];
            }
          } else if (!(options.codeProcessors && options.codeProcessors.length)) {
            /* const autoSyntax = require('postcss-syntax'); */
            const autoSyntax = config => config.css;

            // TODO: investigate why lazy import HTML syntax causes
            // JS files with the word "html" to throw TypeError
            // https://github.com/stylelint/stylelint/issues/4793
            const rest = _objectWithoutPropertiesLoose(syntaxes, ["html"]);

            syntax = autoSyntax(_extends({
              css: cssSyntax(stylelint),
              jsx: syntaxes['css-in-js'] },
            rest));

          }

          const postcssOptions = {
            from: options.filePath,
            syntax };


          const source = options.code ? options.codeFilename : options.filePath;
          let preProcessedCode = code;

          if (options.codeProcessors && options.codeProcessors.length) {
            if (stylelint._options.fix) {
              // eslint-disable-next-line no-console
              console.warn(
              'Autofix is incompatible with processors and will be disabled. Are you sure you need a processor?');

              stylelint._options.fix = false;
            }

            options.codeProcessors.forEach(codeProcessor => {
              preProcessedCode = codeProcessor(preProcessedCode, source);
            });
          }

          const result = new LazyResult(postcssProcessor, preProcessedCode, postcssOptions);

          return result;
        }).
        then(postcssResult => {
          if (options.filePath) {
            stylelint._postcssResultCache.set(options.filePath, postcssResult);
          }

          return postcssResult;
        });
      };

      /**
       * @param {CustomSyntax} customSyntax
       * @returns {Syntax}
       */
      function getCustomSyntax(customSyntax) {
        let resolved;

        if (typeof customSyntax === 'string') {
          try {
            resolved = require(customSyntax);
          } catch (error) {
            throw new Error(
            `Cannot resolve custom syntax module ${customSyntax}. Check that module ${customSyntax} is available and spelled correctly.`);

          }

          /*
           * PostCSS allows for syntaxes that only contain a parser, however,
           * it then expects the syntax to be set as the `parse` option.
           */
          if (!resolved.parse) {
            resolved = {
              parse: resolved,
              stringify: postcss.stringify };

          }

          return resolved;
        }

        if (typeof customSyntax === 'object') {
          if (typeof customSyntax.parse === 'function') {
            resolved = _extends({}, customSyntax);
          } else {
            throw new Error(
            `An object provided to the "customSyntax" option must have a "parse" property. Ensure the "parse" property exists and its value is a function.`);

          }

          return resolved;
        }

        throw new Error(`Custom syntax must be a string or a Syntax object`);
      }

      /**
       * @param {string} filePath
       * @returns {Promise<string>}
       */
      /* function readFile(filePath) {
      	return new Promise((resolve, reject) => {
      		fs.readFile(filePath, 'utf8', (err, content) => {
      			if (err) {
      				return reject(err);
      			}
      
      			resolve(content);
      		});
      	});
      } */
      function readFile() {}

      /**
       * @param {StylelintInternalApi} stylelint
       * @returns {Syntax}
       */
      function cssSyntax(stylelint) {
        return {
          parse: stylelint._options.fix ? require('postcss-safe-parser') : postcss.parse,
          stringify: postcss.stringify };

      }

    }, { "./syntaxes": 411, "postcss": 137, "postcss-safe-parser": 88, "postcss/lib/lazy-result": 131 }], 178: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').RangeType} RangeType */

      /**
       * @param {import('stylelint').StylelintResult[]} results
       */
      module.exports = function (results) {
        results.forEach(result => {
          // File with `CssSyntaxError` have not `_postcssResult`
          if (!result._postcssResult) {
            return;
          }

          if (!result._postcssResult.stylelint.config) {
            // Linting error
            return;
          }

          const configRules = result._postcssResult.stylelint.config.rules || {};

          const usedRules = new Set(Object.keys(configRules));

          usedRules.add('all');

          const rangeData = result._postcssResult.stylelint.disabledRanges;
          const disabledRules = Object.keys(rangeData);

          disabledRules.forEach(rule => {
            if (usedRules.has(rule)) {
              return;
            }

            rangeData[rule].forEach(range => {
              if (!range.strictStart && !range.strictEnd) {
                return;
              }

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) return;

              result.warnings.push({
                text: `Rule "${rule}" isn't enabled`,
                rule: '--report-invalid-scope-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: 'error' });

            });
          });
        });
      };

    }, {}], 179: [function (require, module, exports) {
      'use strict';

      const assignDisabledRanges = require('./assignDisabledRanges');
      const get = require('lodash/get');
      const getOsEol = require('./utils/getOsEol');
      const reportUnknownRuleNames = require('./reportUnknownRuleNames');
      const rulesOrder = require('./rules');

      /** @typedef {import('stylelint').StylelintStandaloneOptions} StylelintStandaloneOptions */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').StylelintConfig} StylelintConfig */

      /**
       * @param {StylelintStandaloneOptions} stylelintOptions
       * @param {PostcssResult} postcssResult
       * @param {StylelintConfig} config
       * @returns {Promise<any>}
       */
      function lintPostcssResult(stylelintOptions, postcssResult, config) {
        postcssResult.stylelint.ruleSeverities = {};
        postcssResult.stylelint.customMessages = {};
        postcssResult.stylelint.stylelintError = false;
        postcssResult.stylelint.quiet = config.quiet;
        postcssResult.stylelint.config = config;

        /** @type {string} */
        let newline;
        const postcssDoc = postcssResult.root;

        if (postcssDoc) {
          if (!('type' in postcssDoc)) {
            throw new Error('Unexpected Postcss root object!');
          }

          // @ts-ignore TODO TYPES property css does not exists
          const newlineMatch = postcssDoc.source && postcssDoc.source.input.css.match(/\r?\n/);

          newline = newlineMatch ? newlineMatch[0] : getOsEol();

          assignDisabledRanges(postcssDoc, postcssResult);
        }

        if (stylelintOptions.ignoreDisables) {
          postcssResult.stylelint.ignoreDisables = true;
        }

        if (stylelintOptions.reportNeedlessDisables) {
          postcssResult.stylelint.reportNeedlessDisables = true;
        }

        const isFileFixCompatible = isFixCompatible(postcssResult);

        if (!isFileFixCompatible) {
          postcssResult.stylelint.disableWritingFix = true;
        }

        const postcssRoots = /** @type {import('postcss').Root[]} */postcssDoc &&
        postcssDoc.constructor.name === 'Document' ?
        postcssDoc.nodes :
        [postcssDoc];

        // Promises for the rules. Although the rule code runs synchronously now,
        // the use of Promises makes it compatible with the possibility of async
        // rules down the line.
        /** @type {Array<Promise<any>>} */
        const performRules = [];

        const rules = config.rules ?
        Object.keys(config.rules).sort(
        (a, b) => Object.keys(rulesOrder).indexOf(a) - Object.keys(rulesOrder).indexOf(b)) :

        [];

        rules.forEach(ruleName => {
          const ruleFunction = rulesOrder[ruleName] || get(config, ['pluginFunctions', ruleName]);

          if (ruleFunction === undefined) {
            performRules.push(
            Promise.all(
            postcssRoots.map((postcssRoot) =>
            reportUnknownRuleNames(ruleName, postcssRoot, postcssResult))));




            return;
          }

          const ruleSettings = get(config, ['rules', ruleName]);

          if (ruleSettings === null || ruleSettings[0] === null) {
            return;
          }

          const primaryOption = ruleSettings[0];
          const secondaryOptions = ruleSettings[1];

          // Log the rule's severity in the PostCSS result
          const defaultSeverity = config.defaultSeverity || 'error';

          postcssResult.stylelint.ruleSeverities[ruleName] = get(
          secondaryOptions,
          'severity',
          defaultSeverity);

          postcssResult.stylelint.customMessages[ruleName] = get(secondaryOptions, 'message');

          performRules.push(
          Promise.all(
          postcssRoots.map((postcssRoot) =>
          ruleFunction(primaryOption, secondaryOptions, {
            fix:
            stylelintOptions.fix &&
            // Next two conditionals are temporary measures until #2643 is resolved
            isFileFixCompatible &&
            !postcssResult.stylelint.disabledRanges[ruleName],
            newline })(
          postcssRoot, postcssResult))));



        });

        return Promise.all(performRules);
      }

      /**
       * There are currently some bugs in the autofixer of Stylelint.
       * The autofixer does not yet adhere to stylelint-disable comments, so if there are disabled
       * ranges we can not autofix this document. More info in issue #2643.
       *
       * @param {PostcssResult} postcssResult
       * @returns {boolean}
       */
      function isFixCompatible({ stylelint }) {
        // Check for issue #2643
        if (stylelint.disabledRanges.all.length) return false;

        return true;
      }

      module.exports = lintPostcssResult;

    }, { "./assignDisabledRanges": 167, "./reportUnknownRuleNames": 192, "./rules": 291, "./utils/getOsEol": 433, "lodash/get": 62 }], 180: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          const lintPostcssResult = require('./lintPostcssResult');
          const path = require('path');

          /** @typedef {import('stylelint').StylelintInternalApi} StylelintInternalApi */
          /** @typedef {import('stylelint').GetLintSourceOptions} Options */
          /** @typedef {import('postcss').Result} Result */
          /** @typedef {import('stylelint').PostcssResult} PostcssResult */
          /** @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult */

          /**
           * Run stylelint on a PostCSS Result, either one that is provided
           * or one that we create
           * @param {StylelintInternalApi} stylelint
           * @param {Options} options
           * @returns {Promise<PostcssResult>}
           */
          module.exports = function lintSource(stylelint, options = {}) {
            if (!options.filePath && options.code === undefined && !options.existingPostcssResult) {
              return Promise.reject(new Error('You must provide filePath, code, or existingPostcssResult'));
            }

            const isCodeNotFile = options.code !== undefined;

            const inputFilePath = isCodeNotFile ? options.codeFilename : options.filePath;

            if (inputFilePath !== undefined && !path.isAbsolute(inputFilePath)) {
              if (isCodeNotFile) {
                return Promise.reject(new Error('codeFilename must be an absolute path'));
              }

              return Promise.reject(new Error('filePath must be an absolute path'));
            }

            const getIsIgnored = stylelint.isPathIgnored(inputFilePath).catch(err => {
              if (isCodeNotFile && err.code === 'ENOENT') return false;

              throw err;
            });

            return getIsIgnored.then(isIgnored => {
              if (isIgnored) {
                /** @type {PostcssResult} */
                let postcssResult;

                if (options.existingPostcssResult) {
                  postcssResult = Object.assign(options.existingPostcssResult, {
                    stylelint: createEmptyStylelintPostcssResult() });

                } else {
                  postcssResult = createEmptyPostcssResult(inputFilePath);
                }

                return postcssResult;
              }

              const configSearchPath = stylelint._options.configFile || inputFilePath;

              const getConfig = stylelint.getConfigForFile(configSearchPath).catch(err => {
                if (isCodeNotFile && err.code === 'ENOENT') return stylelint.getConfigForFile(process.cwd());

                throw err;
              });

              return getConfig.then(result => {
                if (!result) {
                  throw new Error('Config file not found');
                }

                const config = result.config;
                const existingPostcssResult = options.existingPostcssResult;
                const stylelintResult = {
                  ruleSeverities: {},
                  customMessages: {},
                  disabledRanges: {} };


                if (existingPostcssResult) {
                  const stylelintPostcssResult = Object.assign(existingPostcssResult, {
                    stylelint: stylelintResult });


                  return lintPostcssResult(stylelint._options, stylelintPostcssResult, config).then(
                  () => stylelintPostcssResult);

                }

                return stylelint.
                _getPostcssResult({
                  code: options.code,
                  codeFilename: options.codeFilename,
                  filePath: inputFilePath,
                  codeProcessors: config.codeProcessors }).

                then(postcssResult => {
                  const stylelintPostcssResult = Object.assign(postcssResult, {
                    stylelint: stylelintResult });


                  return lintPostcssResult(stylelint._options, stylelintPostcssResult, config).then(
                  () => stylelintPostcssResult);

                });
              });
            });
          };

          /**
           * @returns {StylelintPostcssResult}
           */
          function createEmptyStylelintPostcssResult() {
            return {
              ruleSeverities: {},
              customMessages: {},
              disabledRanges: {},
              ignored: true,
              stylelintError: false };

          }

          /**
           * @param {string} [filePath]
           * @returns {PostcssResult}
           */
          function createEmptyPostcssResult(filePath) {
            return {
              root: {
                source: {
                  input: { file: filePath } } },


              messages: [],
              opts: undefined,
              stylelint: createEmptyStylelintPostcssResult(),
              warn: () => {} };

          }

        }).call(this);}).call(this, require('_process'));
    }, { "./lintPostcssResult": 179, "_process": 160, "path": 74 }], 181: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const putIfAbsent = require('./utils/putIfAbsent');

      /** @typedef {import('postcss/lib/comment')} PostcssComment */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */

      /**
       * @param {import('stylelint').StylelintResult[]} results
       */
      module.exports = function (results) {
        results.forEach(result => {
          // File with `CssSyntaxError` have not `_postcssResult`
          if (!result._postcssResult) {
            return;
          }

          /** @type {{[ruleName: string]: Array<DisabledRange>}} */
          const rangeData = _.cloneDeep(result._postcssResult.stylelint.disabledRanges);

          if (!rangeData) {
            return;
          }

          const disabledWarnings = result._postcssResult.stylelint.disabledWarnings || [];

          // A map from `stylelint-disable` comments to the set of rules that
          // are usefully disabled by each comment. We track this
          // comment-by-comment rather than range-by-range because ranges that
          // disable *all* rules are duplicated for each rule they apply to in
          // practice.
          /** @type {Map<PostcssComment, Set<string>>}} */
          const usefulDisables = new Map();

          for (const warning of disabledWarnings) {
            const rule = warning.rule;
            const ruleRanges = rangeData[rule];

            if (ruleRanges) {
              for (const range of ruleRanges) {
                if (isWarningInRange(warning, range)) {
                  putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
                }
              }
            }

            for (const range of rangeData.all) {
              if (isWarningInRange(warning, range)) {
                putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
              }
            }
          }

          const rangeEntries = Object.entries(rangeData);

          // Get rid of the duplicated ranges for each `all` rule. We only care
          // if the entire `all` rule is useful as a whole or not.
          for (const range of rangeData.all) {
            for (const [rule, ranges] of rangeEntries) {
              if (rule === 'all') continue;

              _.remove(ranges, otherRange => range.comment === otherRange.comment);
            }
          }

          for (const [rule, ranges] of rangeEntries) {
            for (const range of ranges) {
              const useful = usefulDisables.get(range.comment) || new Set();

              // Only emit a warning if this range's comment isn't useful for this rule.
              // For the special rule "all", only emit a warning if it's not useful for
              // *any* // rules, becuase it covers all of them.
              if (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Needless disable for "${rule}"`,
                rule: '--report-needless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: 'error' });

            }
          }
        });
      };

      /**
       * @param {import('stylelint').DisabledWarning} warning
       * @param {RangeType} range
       * @return {boolean}
       */
      function isWarningInRange(warning, range) {
        const line = warning.line;

        // Need to check if range.end exist, because line number type cannot be compared to undefined
        return (
          range.start <= line && (
          range.end !== undefined && range.end >= line || range.end === undefined));

      }

    }, { "./utils/putIfAbsent": 494, "lodash": 68 }], 182: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const normalizeRuleSettings = require('./normalizeRuleSettings');
      const rules = require('./rules');

      /** @typedef {import('stylelint').StylelintConfigRules} StylelintConfigRules */
      /** @typedef {import('stylelint').StylelintConfig} StylelintConfig */

      /**
       * @param {StylelintConfig} config
       * @return {StylelintConfig}
       */
      function normalizeAllRuleSettings(config) {
        /** @type {StylelintConfigRules} */
        const normalizedRules = {};

        if (!config.rules) return config;

        Object.keys(config.rules).forEach(ruleName => {
          const rawRuleSettings = _.get(config, ['rules', ruleName]);

          const rule = rules[ruleName] || _.get(config, ['pluginFunctions', ruleName]);

          if (!rule) {
            normalizedRules[ruleName] = [];
          } else {
            normalizedRules[ruleName] = normalizeRuleSettings(
            rawRuleSettings,
            ruleName,
            _.get(rule, 'primaryOptionArray'));

          }
        });

        config.rules = normalizedRules;

        return config;
      }

      module.exports = normalizeAllRuleSettings;

    }, { "./normalizeRuleSettings": 183, "./rules": 291, "lodash": 68 }], 183: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const rules = require('./rules');

      // Rule settings can take a number of forms, e.g.
      // a. "rule-name": null
      // b. "rule-name": [null, ...]
      // c. "rule-name": primaryOption
      // d. "rule-name": [primaryOption]
      // e. "rule-name": [primaryOption, secondaryOption]
      // Where primaryOption can be anything: primitive, Object, or Array.

      /**
       * This function normalizes all the possibilities into the
       * standard form: [primaryOption, secondaryOption]
       * Except in the cases with null, a & b, in which case
       * null is returned
       * @param {import('stylelint').StylelintConfigRuleSettings} rawSettings
       * @param {string} ruleName
       * @param {boolean} [primaryOptionArray] If primaryOptionArray is not provided, we try to get it from the, rules themselves, which will not work for plugins
       * @return {[any, Object] | Array<any | [any, Object]> | null}
       */
      module.exports = function (
      rawSettings,
      ruleName,
      // If primaryOptionArray is not provided, we try to get it from the
      // rules themselves, which will not work for plugins
      primaryOptionArray)
      {
        if (rawSettings === null) {
          return null;
        }

        if (!Array.isArray(rawSettings)) {
          return [rawSettings];
        }
        // Everything below is an array ...

        if (rawSettings[0] === null) {
          return null;
        }

        if (primaryOptionArray === undefined) {
          const rule = rules[ruleName];

          primaryOptionArray = _.get(rule, 'primaryOptionArray');
        }

        if (!primaryOptionArray) {
          return rawSettings;
        }
        // Everything below is a rule that CAN have an array for a primary option ...
        // (they might also have something else, e.g. rule-properties-order can
        // have the string "alphabetical")

        if (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {
          return rawSettings;
        }

        if (
        rawSettings.length === 2 &&
        !_.isPlainObject(rawSettings[0]) &&
        _.isPlainObject(rawSettings[1]))
        {
          return rawSettings;
        }

        return [rawSettings];
      };

    }, { "./rules": 291, "lodash": 68 }], 184: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          const _ = require('lodash');
          const createStylelint = require('./createStylelint');
          const path = require('path');
          const postcss = require('postcss');
          //'block-no-empty': bool || Array

          module.exports = postcss.plugin('stylelint', (options = {}) => {
            const tailoredOptions = options.rules ? { config: options } : options;
            const stylelint = createStylelint(tailoredOptions);

            return (root, result) => {
              let filePath = options.from || _.get(root, 'source.input.file');

              if (filePath !== undefined && !path.isAbsolute(filePath)) {
                filePath = path.join(process.cwd(), filePath);
              }

              return stylelint._lintSource({
                filePath,
                existingPostcssResult: result });

            };
          });

        }).call(this);}).call(this, require('_process'));
    }, { "./createStylelint": 170, "_process": 160, "lodash": 68, "path": 74, "postcss": 137 }], 185: [function (require, module, exports) {
      'use strict';

      const descriptionlessDisables = require('./descriptionlessDisables');
      const invalidScopeDisables = require('./invalidScopeDisables');
      const needlessDisables = require('./needlessDisables');
      const reportDisables = require('./reportDisables');

      /** @typedef {import('stylelint').Formatter} Formatter */
      /** @typedef {import('stylelint').StylelintResult} StylelintResult */
      /** @typedef {import('stylelint').StylelintStandaloneOptions} StylelintStandaloneOptions */
      /** @typedef {import('stylelint').StylelintStandaloneReturnValue} StylelintStandaloneReturnValue */

      /**
       * @param {StylelintResult[]} stylelintResults
       * @param {StylelintStandaloneOptions} options
       * @param {Formatter} formatter
       *
       * @returns {StylelintStandaloneReturnValue}
       */
      function prepareReturnValue(stylelintResults, options, formatter) {
        const {
          reportNeedlessDisables,
          reportInvalidScopeDisables,
          reportDescriptionlessDisables,
          maxWarnings } =
        options;

        reportDisables(stylelintResults);

        if (reportNeedlessDisables) needlessDisables(stylelintResults);

        if (reportInvalidScopeDisables) invalidScopeDisables(stylelintResults);

        if (reportDescriptionlessDisables) descriptionlessDisables(stylelintResults);

        const errored = stylelintResults.some(
        result => result.errored || result.parseErrors.length > 0);


        /** @type {StylelintStandaloneReturnValue} */
        const returnValue = {
          errored,
          results: [],
          output: '',
          reportedDisables: [] };


        if (maxWarnings !== undefined) {
          const foundWarnings = stylelintResults.reduce((count, file) => {
            return count + file.warnings.length;
          }, 0);

          if (foundWarnings > maxWarnings) {
            returnValue.maxWarningsExceeded = { maxWarnings, foundWarnings };
          }
        }

        returnValue.output = formatter(stylelintResults, returnValue);
        returnValue.results = stylelintResults;

        return returnValue;
      }

      module.exports = prepareReturnValue;

    }, { "./descriptionlessDisables": 172, "./invalidScopeDisables": 178, "./needlessDisables": 181, "./reportDisables": 191 }], 186: [function (require, module, exports) {
      'use strict';

      const keywordSets = {};

      keywordSets.nonLengthUnits = new Set([
      // Relative length units
      '%',
      // Time length units
      's',
      'ms',
      // Angle
      'deg',
      'grad',
      'turn',
      'rad',
      // Frequency
      'Hz',
      'kHz',
      // Resolution
      'dpi',
      'dpcm',
      'dppx']);


      keywordSets.lengthUnits = new Set([
      // Relative length units
      'em',
      'ex',
      'ch',
      'rem',
      // Viewport-percentage lengths
      'vh',
      'vw',
      'vmin',
      'vmax',
      'vm',
      // Absolute length units
      'px',
      'mm',
      'cm',
      'in',
      'pt',
      'pc',
      'q',
      // Flexible length units
      'fr']);


      keywordSets.units = uniteSets(keywordSets.nonLengthUnits, keywordSets.lengthUnits);

      keywordSets.colorFunctionNames = new Set(['rgb', 'rgba', 'hsl', 'hsla', 'hwb', 'gray']);

      keywordSets.camelCaseFunctionNames = new Set([
      'translateX',
      'translateY',
      'translateZ',
      'scaleX',
      'scaleY',
      'scaleZ',
      'rotateX',
      'rotateY',
      'rotateZ',
      'skewX',
      'skewY']);


      keywordSets.basicKeywords = new Set(['initial', 'inherit', 'unset']);

      keywordSets.systemFontValues = uniteSets(keywordSets.basicKeywords, [
      'caption',
      'icon',
      'menu',
      'message-box',
      'small-caption',
      'status-bar']);


      keywordSets.fontFamilyKeywords = uniteSets(keywordSets.basicKeywords, [
      'serif',
      'sans-serif',
      'cursive',
      'fantasy',
      'monospace',
      'system-ui']);


      keywordSets.fontWeightRelativeKeywords = new Set(['bolder', 'lighter']);

      keywordSets.fontWeightAbsoluteKeywords = new Set(['bold']);

      keywordSets.fontWeightNumericKeywords = new Set([
      '100',
      '200',
      '300',
      '400',
      '500',
      '600',
      '700',
      '800',
      '900']);


      keywordSets.fontWeightKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontWeightRelativeKeywords,
      keywordSets.fontWeightAbsoluteKeywords,
      keywordSets.fontWeightNumericKeywords);


      keywordSets.animationNameKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.animationTimingFunctionKeywords = uniteSets(keywordSets.basicKeywords, [
      'linear',
      'ease',
      'ease-in',
      'ease-in-out',
      'ease-out',
      'step-start',
      'step-end',
      'steps',
      'cubic-bezier']);


      keywordSets.animationIterationCountKeywords = new Set(['infinite']);

      keywordSets.animationDirectionKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'reverse',
      'alternate',
      'alternate-reverse']);


      keywordSets.animationFillModeKeywords = new Set(['none', 'forwards', 'backwards', 'both']);

      keywordSets.animationPlayStateKeywords = uniteSets(keywordSets.basicKeywords, [
      'running',
      'paused']);


      // cf. https://developer.mozilla.org/en-US/docs/Web/CSS/animation
      keywordSets.animationShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.animationNameKeywords,
      keywordSets.animationTimingFunctionKeywords,
      keywordSets.animationIterationCountKeywords,
      keywordSets.animationDirectionKeywords,
      keywordSets.animationFillModeKeywords,
      keywordSets.animationPlayStateKeywords);


      // These are the ones that can have single-colon notation
      keywordSets.levelOneAndTwoPseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter']);


      // These are the ones that require double-colon notation
      keywordSets.levelThreePseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter',
      'selection',
      'spelling-error',
      'grammar-error',
      'backdrop',
      'marker',
      'placeholder',
      'shadow',
      'slotted',
      'content']);


      keywordSets.shadowTreePseudoElements = new Set(['part']);

      keywordSets.vendorSpecificPseudoElements = new Set([
      '-moz-progress-bar',
      '-moz-range-progress',
      '-moz-range-thumb',
      '-moz-range-track',
      '-ms-browse',
      '-ms-check',
      '-ms-clear',
      '-ms-expand',
      '-ms-fill',
      '-ms-fill-lower',
      '-ms-fill-upper',
      '-ms-reveal',
      '-ms-thumb',
      '-ms-ticks-after',
      '-ms-ticks-before',
      '-ms-tooltip',
      '-ms-track',
      '-ms-value',
      '-webkit-progress-bar',
      '-webkit-progress-value',
      '-webkit-slider-runnable-track',
      '-webkit-slider-thumb']);


      keywordSets.pseudoElements = uniteSets(
      keywordSets.levelOneAndTwoPseudoElements,
      keywordSets.levelThreePseudoElements,
      keywordSets.vendorSpecificPseudoElements,
      keywordSets.shadowTreePseudoElements);


      keywordSets.aNPlusBNotationPseudoClasses = new Set([
      'nth-column',
      'nth-last-column',
      'nth-last-of-type',
      'nth-of-type']);


      keywordSets.linguisticPseudoClasses = new Set(['dir', 'lang']);

      keywordSets.atRulePagePseudoClasses = new Set(['first', 'right', 'left', 'blank']);

      keywordSets.logicalCombinationsPseudoClasses = new Set(['has', 'is', 'matches', 'not', 'where']);

      keywordSets.aNPlusBOfSNotationPseudoClasses = new Set(['nth-child', 'nth-last-child']);

      keywordSets.otherPseudoClasses = new Set([
      'active',
      'any-link',
      'blank',
      'checked',
      'contains',
      'current',
      'default',
      'defined',
      'disabled',
      'drop',
      'empty',
      'enabled',
      'first-child',
      'first-of-type',
      'focus',
      'focus-ring',
      'focus-within',
      'focus-visible',
      'fullscreen',
      'future',
      'host',
      'host-context',
      'hover',
      'indeterminate',
      'in-range',
      'invalid',
      'last-child',
      'last-of-type',
      'link',
      'only-child',
      'only-of-type',
      'optional',
      'out-of-range',
      'past',
      'placeholder-shown',
      'playing',
      'paused',
      'read-only',
      'read-write',
      'required',
      'root',
      'scope',
      'target',
      'user-error',
      'user-invalid',
      'val',
      'valid',
      'visited']);


      keywordSets.webkitProprietaryPseudoElements = new Set([
      'scrollbar',
      'scrollbar-button',
      'scrollbar-track',
      'scrollbar-track-piece',
      'scrollbar-thumb',
      'scrollbar-corner',
      'resize']);


      keywordSets.webkitProprietaryPseudoClasses = new Set([
      'horizontal',
      'vertical',
      'decrement',
      'increment',
      'start',
      'end',
      'double-button',
      'single-button',
      'no-button',
      'corner-present',
      'window-inactive']);


      keywordSets.pseudoClasses = uniteSets(
      keywordSets.aNPlusBNotationPseudoClasses,
      keywordSets.linguisticPseudoClasses,
      keywordSets.logicalCombinationsPseudoClasses,
      keywordSets.aNPlusBOfSNotationPseudoClasses,
      keywordSets.otherPseudoClasses);


      keywordSets.shorthandTimeProperties = new Set(['transition', 'animation']);

      keywordSets.longhandTimeProperties = new Set([
      'transition-duration',
      'transition-delay',
      'animation-duration',
      'animation-delay']);


      keywordSets.timeProperties = uniteSets(
      keywordSets.shorthandTimeProperties,
      keywordSets.longhandTimeProperties);


      keywordSets.camelCaseKeywords = new Set([
      'optimizeSpeed',
      'optimizeQuality',
      'optimizeLegibility',
      'geometricPrecision',
      'currentColor',
      'crispEdges',
      'visiblePainted',
      'visibleFill',
      'visibleStroke',
      'sRGB',
      'linearRGB']);


      // https://developer.mozilla.org/docs/Web/CSS/counter-increment
      keywordSets.counterIncrementKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.counterResetKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.gridRowKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridColumnKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridAreaKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      // https://developer.mozilla.org/ru/docs/Web/CSS/list-style-type
      keywordSets.listStyleTypeKeywords = uniteSets(keywordSets.basicKeywords, [
      'none',
      'disc',
      'circle',
      'square',
      'decimal',
      'cjk-decimal',
      'decimal-leading-zero',
      'lower-roman',
      'upper-roman',
      'lower-greek',
      'lower-alpha',
      'lower-latin',
      'upper-alpha',
      'upper-latin',
      'arabic-indic',
      'armenian',
      'bengali',
      'cambodian',
      'cjk-earthly-branch',
      'cjk-ideographic',
      'devanagari',
      'ethiopic-numeric',
      'georgian',
      'gujarati',
      'gurmukhi',
      'hebrew',
      'hiragana',
      'hiragana-iroha',
      'japanese-formal',
      'japanese-informal',
      'kannada',
      'katakana',
      'katakana-iroha',
      'khmer',
      'korean-hangul-formal',
      'korean-hanja-formal',
      'korean-hanja-informal',
      'lao',
      'lower-armenian',
      'malayalam',
      'mongolian',
      'myanmar',
      'oriya',
      'persian',
      'simp-chinese-formal',
      'simp-chinese-informal',
      'tamil',
      'telugu',
      'thai',
      'tibetan',
      'trad-chinese-formal',
      'trad-chinese-informal',
      'upper-armenian',
      'disclosure-open',
      'disclosure-closed',
      // Non-standard extensions (without prefixe)
      'ethiopic-halehame',
      'ethiopic-halehame-am',
      'ethiopic-halehame-ti-er',
      'ethiopic-halehame-ti-et',
      'hangul',
      'hangul-consonant',
      'urdu']);


      keywordSets.listStylePositionKeywords = uniteSets(keywordSets.basicKeywords, ['inside', 'outside']);

      keywordSets.listStyleImageKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.listStyleShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.listStyleTypeKeywords,
      keywordSets.listStylePositionKeywords,
      keywordSets.listStyleImageKeywords);


      keywordSets.fontStyleKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'italic',
      'oblique']);


      keywordSets.fontVariantKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'none',
      'historical-forms',
      'none',
      'common-ligatures',
      'no-common-ligatures',
      'discretionary-ligatures',
      'no-discretionary-ligatures',
      'historical-ligatures',
      'no-historical-ligatures',
      'contextual',
      'no-contextual',
      'small-caps',
      'small-caps',
      'all-small-caps',
      'petite-caps',
      'all-petite-caps',
      'unicase',
      'titling-caps',
      'lining-nums',
      'oldstyle-nums',
      'proportional-nums',
      'tabular-nums',
      'diagonal-fractions',
      'stacked-fractions',
      'ordinal',
      'slashed-zero',
      'jis78',
      'jis83',
      'jis90',
      'jis04',
      'simplified',
      'traditional',
      'full-width',
      'proportional-width',
      'ruby']);


      keywordSets.fontStretchKeywords = uniteSets(keywordSets.basicKeywords, [
      'semi-condensed',
      'condensed',
      'extra-condensed',
      'ultra-condensed',
      'semi-expanded',
      'expanded',
      'extra-expanded',
      'ultra-expanded']);


      keywordSets.fontSizeKeywords = uniteSets(keywordSets.basicKeywords, [
      'xx-small',
      'x-small',
      'small',
      'medium',
      'large',
      'x-large',
      'xx-large',
      'larger',
      'smaller']);


      keywordSets.lineHeightKeywords = uniteSets(keywordSets.basicKeywords, ['normal']);

      keywordSets.fontShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontStyleKeywords,
      keywordSets.fontVariantKeywords,
      keywordSets.fontWeightKeywords,
      keywordSets.fontStretchKeywords,
      keywordSets.fontSizeKeywords,
      keywordSets.lineHeightKeywords,
      keywordSets.fontFamilyKeywords);


      keywordSets.keyframeSelectorKeywords = new Set(['from', 'to']);

      // https://www.w3.org/TR/css-page-3/#syntax-page-selector
      keywordSets.pageMarginAtRules = new Set([
      'top-left-corner',
      'top-left',
      'top-center',
      'top-right',
      'top-right-corner',
      'bottom-left-corner',
      'bottom-left',
      'bottom-center',
      'bottom-right',
      'bottom-right-corner',
      'left-top',
      'left-middle',
      'left-bottom',
      'right-top',
      'right-middle',
      'right-bottom']);


      // https://developer.mozilla.org/en/docs/Web/CSS/At-rule
      keywordSets.atRules = uniteSets(keywordSets.pageMarginAtRules, [
      'annotation',
      'apply',
      'character-variant',
      'charset',
      'counter-style',
      'custom-media',
      'custom-selector',
      'document',
      'font-face',
      'font-feature-values',
      'import',
      'keyframes',
      'media',
      'namespace',
      'nest',
      'ornaments',
      'page',
      'styleset',
      'stylistic',
      'supports',
      'swash',
      'viewport']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.deprecatedMediaFeatureNames = new Set([
      'device-aspect-ratio',
      'device-height',
      'device-width',
      'max-device-aspect-ratio',
      'max-device-height',
      'max-device-width',
      'min-device-aspect-ratio',
      'min-device-height',
      'min-device-width']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.mediaFeatureNames = uniteSets(keywordSets.deprecatedMediaFeatureNames, [
      'any-hover',
      'any-pointer',
      'aspect-ratio',
      'color',
      'color-gamut',
      'color-index',
      'forced-colors',
      'grid',
      'height',
      'hover',
      'inverted-colors',
      'light-level',
      'max-aspect-ratio',
      'max-color',
      'max-color-index',
      'max-height',
      'max-monochrome',
      'max-resolution',
      'max-width',
      'min-aspect-ratio',
      'min-color',
      'min-color-index',
      'min-height',
      'min-monochrome',
      'min-resolution',
      'min-width',
      'monochrome',
      'orientation',
      'overflow-block',
      'overflow-inline',
      'pointer',
      'prefers-color-scheme',
      'prefers-reduced-motion',
      'prefers-reduced-transparency',
      'resolution',
      'scan',
      'scripting',
      'update',
      'width']);


      // https://www.w3.org/TR/CSS22/ui.html#system-colors
      keywordSets.systemColors = new Set([
      'activeborder',
      'activecaption',
      'appworkspace',
      'background',
      'buttonface',
      'buttonhighlight',
      'buttonshadow',
      'buttontext',
      'captiontext',
      'graytext',
      'highlight',
      'highlighttext',
      'inactiveborder',
      'inactivecaption',
      'inactivecaptiontext',
      'infobackground',
      'infotext',
      'menu',
      'menutext',
      'scrollbar',
      'threeddarkshadow',
      'threedface',
      'threedhighlight',
      'threedlightshadow',
      'threedshadow',
      'window',
      'windowframe',
      'windowtext']);


      // htmlTags includes only "standard" tags. So we augment it with older tags etc.
      keywordSets.nonStandardHtmlTags = new Set([
      'acronym',
      'applet',
      'basefont',
      'big',
      'blink',
      'center',
      'content',
      'dir',
      'font',
      'frame',
      'frameset',
      'hgroup',
      'isindex',
      'keygen',
      'listing',
      'marquee',
      'noembed',
      'plaintext',
      'spacer',
      'strike',
      'tt',
      'xmp']);


      /**
       * @param {(string[] | Set<string>)[]} args
       */
      function uniteSets(...args) {
        return new Set(
        Array.from(args).reduce(( /** @type {string[]} */result, set) => {
          return result.concat(Array.from(set));
        }, []));

      }

      module.exports = keywordSets;

    }, {}], 187: [function (require, module, exports) {
      'use strict';

      module.exports = ['calc'];

    }, {}], 188: [function (require, module, exports) {
      'use strict';

      module.exports = {
        aliceblue: ['#f0f8ff', '#fff0f8ff'],
        antiquewhite: ['#faebd7', '#fffaebd7'],
        aqua: ['#00ffff', '#ff00ffff', '#0ff', '#f0ff'],
        aquamarine: ['#7fffd4', '#ff7fffd4'],
        azure: ['#f0ffff', '#fff0ffff'],
        beige: ['#f5f5dc', '#fff5f5dc'],
        bisque: ['#ffe4c4', '#ffffe4c4'],
        black: ['#000000', '#ff000000', '#000', '#f000'],
        blanchedalmond: ['#ffebcd', '#ffffebcd'],
        blue: ['#0000ff', '#ff0000ff', '#00f', '#f00f'],
        blueviolet: ['#8a2be2', '#ff8a2be2'],
        brown: ['#a52a2a', '#ffa52a2a'],
        burlywood: ['#deb887', '#ffdeb887'],
        cadetblue: ['#5f9ea0', '#ff5f9ea0'],
        chartreuse: ['#7fff00', '#ff7fff00'],
        chocolate: ['#d2691e', '#ffd2691e'],
        coral: ['#ff7f50', '#ffff7f50'],
        cornflowerblue: ['#6495ed', '#ff6495ed'],
        cornsilk: ['#fff8dc', '#fffff8dc'],
        crimson: ['#dc143c', '#ffdc143c'],
        cyan: ['#00ffff', '#ff00ffff', '#0ff', '#f0ff'],
        darkblue: ['#00008b', '#ff00008b'],
        darkcyan: ['#008b8b', '#ff008b8b'],
        darkgoldenrod: ['#b8860b', '#ffb8860b'],
        darkgray: ['#a9a9a9', '#ffa9a9a9'],
        darkgreen: ['#006400', '#ff006400'],
        darkgrey: ['#a9a9a9', '#ffa9a9a9'],
        darkkhaki: ['#bdb76b', '#ffbdb76b'],
        darkmagenta: ['#8b008b', '#ff8b008b'],
        darkolivegreen: ['#556b2f', '#ff556b2f'],
        darkorange: ['#ff8c00', '#ffff8c00'],
        darkorchid: ['#9932cc', '#ff9932cc'],
        darkred: ['#8b0000', '#ff8b0000'],
        darksalmon: ['#e9967a', '#ffe9967a'],
        darkseagreen: ['#8fbc8f', '#ff8fbc8f'],
        darkslateblue: ['#483d8b', '#ff483d8b'],
        darkslategray: ['#2f4f4f', '#ff2f4f4f'],
        darkslategrey: ['#2f4f4f', '#ff2f4f4f'],
        darkturquoise: ['#00ced1', '#ff00ced1'],
        darkviolet: ['#9400d3', '#ff9400d3'],
        deeppink: ['#ff1493', '#ffff1493'],
        deepskyblue: ['#00bfff', '#ff00bfff'],
        dimgray: ['#696969', '#ff696969'],
        dimgrey: ['#696969', '#ff696969'],
        dodgerblue: ['#1e90ff', '#ff1e90ff'],
        firebrick: ['#b22222', '#ffb22222'],
        floralwhite: ['#fffaf0', '#fffffaf0'],
        forestgreen: ['#228b22', '#ff228b22'],
        fuchsia: ['#ff00ff', '#ffff00ff', '#f0f', '#ff0f'],
        gainsboro: ['#dcdcdc', '#ffdcdcdc'],
        ghostwhite: ['#f8f8ff', '#fff8f8ff'],
        gold: ['#ffd700', '#ffffd700'],
        goldenrod: ['#daa520', '#ffdaa520'],
        gray: ['#808080', '#ff808080'],
        green: ['#008000', '#ff008000'],
        greenyellow: ['#adff2f', '#ffadff2f'],
        grey: ['#808080', '#ff808080'],
        honeydew: ['#f0fff0', '#fff0fff0'],
        hotpink: ['#ff69b4', '#ffff69b4'],
        indianred: ['#cd5c5c', '#ffcd5c5c'],
        indigo: ['#4b0082', '#ff4b0082'],
        ivory: ['#fffff0', '#fffffff0'],
        khaki: ['#f0e68c', '#fff0e68c'],
        lavender: ['#e6e6fa', '#ffe6e6fa'],
        lavenderblush: ['#fff0f5', '#fffff0f5'],
        lawngreen: ['#7cfc00', '#ff7cfc00'],
        lemonchiffon: ['#fffacd', '#fffffacd'],
        lightblue: ['#add8e6', '#ffadd8e6'],
        lightcoral: ['#f08080', '#fff08080'],
        lightcyan: ['#e0ffff', '#ffe0ffff'],
        lightgoldenrodyellow: ['#fafad2', '#fffafad2'],
        lightgray: ['#d3d3d3', '#ffd3d3d3'],
        lightgreen: ['#90ee90', '#ff90ee90'],
        lightgrey: ['#d3d3d3', '#ffd3d3d3'],
        lightpink: ['#ffb6c1', '#ffffb6c1'],
        lightsalmon: ['#ffa07a', '#ffffa07a'],
        lightseagreen: ['#20b2aa', '#ff20b2aa'],
        lightskyblue: ['#87cefa', '#ff87cefa'],
        lightslategray: ['#778899', '#ff778899', '#789', '#f789'],
        lightslategrey: ['#778899', '#ff778899', '#789', '#f789'],
        lightsteelblue: ['#b0c4de', '#ffb0c4de'],
        lightyellow: ['#ffffe0', '#ffffffe0'],
        lime: ['#00ff00', '#ff00ff00', '#0f0', '#f0f0'],
        limegreen: ['#32cd32', '#ff32cd32'],
        linen: ['#faf0e6', '#fffaf0e6'],
        magenta: ['#ff00ff', '#ffff00ff', '#f0f', '#ff0f'],
        maroon: ['#800000', '#ff800000'],
        mediumaquamarine: ['#66cdaa', '#ff66cdaa'],
        mediumblue: ['#0000cd', '#ff0000cd'],
        mediumorchid: ['#ba55d3', '#ffba55d3'],
        mediumpurple: ['#9370db', '#ff9370db'],
        mediumseagreen: ['#3cb371', '#ff3cb371'],
        mediumslateblue: ['#7b68ee', '#ff7b68ee'],
        mediumspringgreen: ['#00fa9a', '#ff00fa9a'],
        mediumturquoise: ['#48d1cc', '#ff48d1cc'],
        mediumvioletred: ['#c71585', '#ffc71585'],
        midnightblue: ['#191970', '#ff191970'],
        mintcream: ['#f5fffa', '#fff5fffa'],
        mistyrose: ['#ffe4e1', '#ffffe4e1'],
        moccasin: ['#ffe4b5', '#ffffe4b5'],
        navajowhite: ['#ffdead', '#ffffdead'],
        navy: ['#000080', '#ff000080'],
        oldlace: ['#fdf5e6', '#fffdf5e6'],
        olive: ['#808000', '#ff808000'],
        olivedrab: ['#6b8e23', '#ff6b8e23'],
        orange: ['#ffa500', '#ffffa500'],
        orangered: ['#ff4500', '#ffff4500'],
        orchid: ['#da70d6', '#ffda70d6'],
        palegoldenrod: ['#eee8aa', '#ffeee8aa'],
        palegreen: ['#98fb98', '#ff98fb98'],
        paleturquoise: ['#afeeee', '#ffafeeee'],
        palevioletred: ['#db7093', '#ffdb7093'],
        papayawhip: ['#ffefd5', '#ffffefd5'],
        peachpuff: ['#ffdab9', '#ffffdab9'],
        peru: ['#cd853f', '#ffcd853f'],
        pink: ['#ffc0cb', '#ffffc0cb'],
        plum: ['#dda0dd', '#ffdda0dd'],
        powderblue: ['#b0e0e6', '#ffb0e0e6'],
        purple: ['#800080', '#ff800080'],
        rebeccapurple: ['#663399', '#ff663399', '#639', '#f639'],
        red: ['#ff0000', '#ffff0000', '#f00', '#ff00'],
        rosybrown: ['#bc8f8f', '#ffbc8f8f'],
        royalblue: ['#4169e1', '#ff4169e1'],
        saddlebrown: ['#8b4513', '#ff8b4513'],
        salmon: ['#fa8072', '#fffa8072'],
        sandybrown: ['#f4a460', '#fff4a460'],
        seagreen: ['#2e8b57', '#ff2e8b57'],
        seashell: ['#fff5ee', '#fffff5ee'],
        sienna: ['#a0522d', '#ffa0522d'],
        silver: ['#c0c0c0', '#ffc0c0c0'],
        skyblue: ['#87ceeb', '#ff87ceeb'],
        slateblue: ['#6a5acd', '#ff6a5acd'],
        slategray: ['#708090', '#ff708090'],
        slategrey: ['#708090', '#ff708090'],
        snow: ['#fffafa', '#fffffafa'],
        springgreen: ['#00ff7f', '#ff00ff7f'],
        steelblue: ['#4682b4', '#ff4682b4'],
        tan: ['#d2b48c', '#ffd2b48c'],
        teal: ['#008080', '#ff008080'],
        thistle: ['#d8bfd8', '#ffd8bfd8'],
        tomato: ['#ff6347', '#ffff6347'],
        turquoise: ['#40e0d0', '#ff40e0d0'],
        violet: ['#ee82ee', '#ffee82ee'],
        wheat: ['#f5deb3', '#fff5deb3'],
        white: ['#ffffff', '#ffffffff', '#fff', '#ffff'],
        whitesmoke: ['#f5f5f5', '#fff5f5f5'],
        yellow: ['#ffff00', '#ffffff00', '#ff0', '#fff0'],
        yellowgreen: ['#9acd32', '#ff9acd32'] };


    }, {}], 189: [function (require, module, exports) {
      'use strict';

      const propertySets = {};

      propertySets.acceptCustomIdents = new Set([
      'animation',
      'animation-name',
      'font',
      'font-family',
      'counter-increment',
      'grid-row',
      'grid-column',
      'grid-area',
      'list-style',
      'list-style-type']);


      module.exports = propertySets;

    }, {}], 190: [function (require, module, exports) {
      'use strict';

      module.exports = {
        margin: ['margin-top', 'margin-bottom', 'margin-left', 'margin-right'],
        padding: ['padding-top', 'padding-bottom', 'padding-left', 'padding-right'],
        background: [
        'background-image',
        'background-size',
        'background-position',
        'background-repeat',
        'background-origin',
        'background-clip',
        'background-attachment',
        'background-color'],

        font: [
        'font-style',
        'font-variant',
        'font-weight',
        'font-stretch',
        'font-size',
        'font-family',
        'line-height'],

        border: [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width',
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style',
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'border-top': ['border-top-width', 'border-top-style', 'border-top-color'],
        'border-bottom': ['border-bottom-width', 'border-bottom-style', 'border-bottom-color'],
        'border-left': ['border-left-width', 'border-left-style', 'border-left-color'],
        'border-right': ['border-right-width', 'border-right-style', 'border-right-color'],
        'border-width': [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width'],

        'border-style': [
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style'],

        'border-color': [
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'list-style': ['list-style-type', 'list-style-position', 'list-style-image'],
        'border-radius': [
        'border-top-right-radius',
        'border-top-left-radius',
        'border-bottom-right-radius',
        'border-bottom-left-radius'],

        transition: [
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'],

        animation: [
        'animation-name',
        'animation-duration',
        'animation-timing-function',
        'animation-delay',
        'animation-iteration-count',
        'animation-direction',
        'animation-fill-mode',
        'animation-play-state'],

        'border-block-end': [
        'border-block-end-width',
        'border-block-end-style',
        'border-block-end-color'],

        'border-block-start': [
        'border-block-start-width',
        'border-block-start-style',
        'border-block-start-color'],

        'border-image': [
        'border-image-source',
        'border-image-slice',
        'border-image-width',
        'border-image-outset',
        'border-image-repeat'],

        'border-inline-end': [
        'border-inline-end-width',
        'border-inline-end-style',
        'border-inline-end-color'],

        'border-inline-start': [
        'border-inline-start-width',
        'border-inline-start-style',
        'border-inline-start-color'],

        'column-rule': ['column-rule-width', 'column-rule-style', 'column-rule-color'],
        columns: ['column-width', 'column-count'],
        flex: ['flex-grow', 'flex-shrink', 'flex-basis'],
        'flex-flow': ['flex-direction', 'flex-wrap'],
        grid: [
        'grid-template-rows',
        'grid-template-columns',
        'grid-template-areas',
        'grid-auto-rows',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-column-gap',
        'grid-row-gap'],

        'grid-area': ['grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end'],
        'grid-column': ['grid-column-start', 'grid-column-end'],
        'grid-gap': ['grid-row-gap', 'grid-column-gap'],
        'grid-row': ['grid-row-start', 'grid-row-end'],
        'grid-template': ['grid-template-columns', 'grid-template-rows', 'grid-template-areas'],
        outline: ['outline-color', 'outline-style', 'outline-width'],
        'text-decoration': ['text-decoration-color', 'text-decoration-style', 'text-decoration-line'],
        'text-emphasis': ['text-emphasis-style', 'text-emphasis-color'],
        mask: [
        'mask-image',
        'mask-mode',
        'mask-position',
        'mask-size',
        'mask-repeat',
        'mask-origin',
        'mask-clip',
        'mask-composite'] };



    }, {}], 191: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisabledRange */

      /**
       * Returns a report describing which `results` (if any) contain disabled ranges
       * for rules that disallow disables via `reportDisables: true`.
       *
       * @param {import('stylelint').StylelintResult[]} results
       */
      module.exports = function (results) {
        results.forEach(result => {
          // File with `CssSyntaxError` don't have `_postcssResult`s.
          if (!result._postcssResult) {
            return;
          }

          /** @type {{[ruleName: string]: Array<RangeType>}} */
          const rangeData = result._postcssResult.stylelint.disabledRanges;

          if (!rangeData) return;

          const config = result._postcssResult.stylelint.config;

          // If no rules actually disallow disables, don't bother looking for ranges
          // that correspond to disabled rules.
          if (!Object.values(_.get(config, 'rules', {})).some(reportDisablesForRule)) {
            return [];
          }

          Object.keys(rangeData).forEach(rule => {
            rangeData[rule].forEach(range => {
              if (!reportDisablesForRule(_.get(config, ['rules', rule], []))) return;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) return;

              result.warnings.push({
                text: `Rule "${rule}" may not be disabled`,
                rule: 'reportDisables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: 'error' });

            });
          });
        });
      };

      /**
       * @param {[any, object]|null} options
       * @return {boolean}
       */
      function reportDisablesForRule(options) {
        if (!options) return false;

        return _.get(options[1], 'reportDisables', false);
      }

    }, { "lodash": 68 }], 192: [function (require, module, exports) {
      'use strict';

      const levenshtein = require('fastest-levenshtein');
      const rules = require('./rules');

      const MAX_LEVENSHTEIN_DISTANCE = 6;
      const MAX_SUGGESTIONS_COUNT = 3;

      /**
       * @param {string} ruleName
       * @return {string[]}
       */
      function extractSuggestions(ruleName) {
        const suggestions = new Array(MAX_LEVENSHTEIN_DISTANCE);

        for (let i = 0; i < suggestions.length; i++) {
          suggestions[i] = [];
        }

        Object.keys(rules).forEach(existRuleName => {
          const distance = levenshtein.distance(existRuleName, ruleName);

          if (distance <= MAX_LEVENSHTEIN_DISTANCE) {
            suggestions[distance - 1].push(existRuleName);
          }
        });

        /** @type {string[]} */
        let result = [];

        for (let i = 0; i < suggestions.length; i++) {
          if (suggestions[i].length > 0) {
            if (i < 3) {
              return suggestions[i].slice(0, MAX_SUGGESTIONS_COUNT);
            }

            result = result.concat(suggestions[i]);
          }
        }

        return result.slice(0, MAX_SUGGESTIONS_COUNT);
      }

      /**
       * @param {string} ruleName
       * @param {string[]} [suggestions=[]]
       * @return {string}
       */
      function rejectMessage(ruleName, suggestions = []) {
        return `Unknown rule ${ruleName}.${
        suggestions.length > 0 ? ` Did you mean ${suggestions.join(', ')}?` : ''
        }`;
      }

      /** @type {Map<string, string[]>} */
      const cache = new Map();

      /**
       * @param {string} unknownRuleName
       * @param {import('postcss').Root} postcssRoot
       * @param {import('stylelint').PostcssResult} postcssResult
       * @returns {void}
       */
      module.exports = function reportUnknownRuleNames(unknownRuleName, postcssRoot, postcssResult) {
        const suggestions = cache.has(unknownRuleName) ?
        /** @type {string[]} */cache.get(unknownRuleName) :
        extractSuggestions(unknownRuleName);
        const warningProperties = {
          severity: 'error',
          rule: unknownRuleName,
          node: postcssRoot,
          index: 0 };


        cache.set(unknownRuleName, suggestions);
        postcssResult.warn(rejectMessage(unknownRuleName, suggestions), warningProperties);
      };

    }, { "./rules": 291, "fastest-levenshtein": 8 }], 193: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'alpha-value-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const ALPHA_PROPS = ['opacity', 'shape-image-threshold'];
      const ALPHA_FUNCS = ['hsl', 'hsla', 'hwb', 'lab', 'lch', 'rgb', 'rgba'];

      function rule(primary, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['number', 'percentage'] },

          {
            actual: options,
            possible: {
              exceptProperties: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getValue(decl));

            parsedValue.walk(node => {
              let alpha;

              if (ALPHA_PROPS.includes(decl.prop.toLowerCase())) {
                alpha = findAlphaInValue(node);
              } else {
                if (node.type !== 'function') return;

                if (!ALPHA_FUNCS.includes(node.value.toLowerCase())) return;

                alpha = findAlphaInFunction(node);
              }

              if (!alpha) return;

              const { value } = alpha;

              if (!isStandardSyntaxValue(value)) return;

              if (!isNumber(value) && !isPercentage(value)) return;

              const optionFuncs = {
                number: {
                  expFunc: isNumber,
                  fixFunc: asNumber },

                percentage: {
                  expFunc: isPercentage,
                  fixFunc: asPercentage } };



              let expectation = primary;

              if (optionsMatches(options, 'exceptProperties', decl.prop)) {
                expectation = Object.keys(optionFuncs).filter(key => key !== expectation);
              }

              if (optionFuncs[expectation].expFunc(value)) return;

              const fixed = optionFuncs[expectation].fixFunc(value);
              const unfixed = value;

              if (context.fix) {
                alpha.value = fixed;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index: declarationValueIndex(decl) + alpha.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setValue(decl, parsedValue.toString());
            }
          });
        };
      }

      function asPercentage(value) {
        return `${Number((value * 100).toPrecision(3))}%`;
      }

      function asNumber(value) {
        const { number } = valueParser.unit(value);

        return Number((number / 100).toPrecision(3));
      }

      function findAlphaInValue(node) {
        return node.type === 'word' || node.type === 'function' ? node : false;
      }

      function findAlphaInFunction(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');

        if (args.length === 4) return args[3];

        return false;
      }

      function isPercentage(value) {
        const { unit } = valueParser.unit(value);

        return unit && unit === '%';
      }

      function isNumber(value) {
        const { unit } = valueParser.unit(value);

        return unit === '';
      }

      function getValue(decl) {
        return decl.raws.value ? decl.raws.value.raw : decl.value;
      }

      function setValue(decl, value) {
        if (decl.raws.value) decl.raws.value.raw = value;else
        decl.value = value;

        return decl;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxValue": 482, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 194: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'at-rule-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      function rule(listInput) {
        // To allow for just a string as a parameter (not only arrays of strings)
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (list.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 195: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'at-rule-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      function rule(listInput) {
        // To allow for just a string as a parameter (not only arrays of strings)
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'at-rule-disallowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (!list.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 196: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'at-rule-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      function rule(listInput) {
        // To allow for just a string as a parameter (not only arrays of strings)
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (!list.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 197: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterBlocklessAtRule');
      const isBlocklessAtRuleAfterSameNameBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before at-rule',
        rejected: 'Unexpected empty line before at-rule' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never'] },

          {
            actual: options,
            possible: {
              except: [
              'after-same-name',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless',
              'first-nested'],

              ignore: [
              'after-comment',
              'first-nested',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless'],

              ignoreAtRules: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const isNested = atRule.parent.type !== 'root';

            // Ignore the first node
            if (isFirstNodeOfRoot(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (optionsMatches(options, 'ignoreAtRules', atRule.name)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            if (
            optionsMatches(options, 'ignore', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(atRule)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            // and following another blockless at-rule with the same name
            if (
            optionsMatches(options, 'ignore', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the expectation if the node is inside a block
            if (optionsMatches(options, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(atRule)) {
              return;
            }

            const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);
            let expectEmptyLineBefore = expectation === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(options, 'except', 'after-same-name') &&
            isAtRuleAfterSameNameAtRule(atRule) ||
            optionsMatches(options, 'except', 'inside-block') && isNested ||
            optionsMatches(options, 'except', 'first-nested') && isFirstNested(atRule) ||
            optionsMatches(options, 'except', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule) ||
            optionsMatches(options, 'except', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(atRule, context.newline);
              } else {
                removeEmptyLinesBefore(atRule, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: atRule, result, ruleName });
          });
        };
      }

      function isAtRuleAfterSameNameAtRule(atRule) {
        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        return previousNode && previousNode.type === 'atrule' && previousNode.name === atRule.name;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 415, "../../utils/getPreviousNonSharedLineCommentNode": 434, "../../utils/hasEmptyLine": 439, "../../utils/isAfterComment": 445, "../../utils/isBlocklessAtRuleAfterBlocklessAtRule": 448, "../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule": 449, "../../utils/isFirstNested": 458, "../../utils/isFirstNodeOfRoot": 459, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesBefore": 497, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 198: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            const expectedName = expectation === 'lower' ? name.toLowerCase() : name.toUpperCase();

            if (name === expectedName) {
              return;
            }

            if (context.fix) {
              atRule.name = expectedName;

              return;
            }

            report({
              message: messages.expected(name, expectedName),
              node: atRule,
              ruleName,
              result });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 199: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected newline after at-rule name "${name}"` });


      function rule(expectation) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../atRuleNameSpaceChecker": 207 }], 200: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected single space after at-rule name "${name}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            atRule => {
              atRule.raws.afterName = atRule.raws.afterName.replace(/^\s*/, ' ');
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../atRuleNameSpaceChecker": 207 }], 201: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'at-rule-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: atRule => `Unexpected unknown at-rule "${atRule}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreAtRules: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            // Return early if at-rule is to be ignored
            if (optionsMatches(options, 'ignoreAtRules', atRule.name)) {
              return;
            }

            if (vendor.prefix(name) || keywordSets.atRules.has(name.toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(`@${name}`),
              node: atRule,
              ruleName,
              result });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 202: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-property-required-list';

      const messages = ruleMessages(ruleName, {
        expected: (property, atRule) => `Expected property "${property}" for at-rule "${atRule}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const { name, nodes } = atRule;
            const atRuleName = name.toLowerCase();

            if (!list[atRuleName]) {
              return;
            }

            list[atRuleName].forEach(property => {
              const propertyName = property.toLowerCase();

              const hasProperty = nodes.find(
              ({ type, prop }) => type === 'decl' && prop.toLowerCase() === propertyName);


              if (hasProperty) {
                return;
              }

              return report({
                message: messages.expected(propertyName, atRuleName),
                node: atRule,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 203: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-property-requirelist';

      const messages = ruleMessages(ruleName, {
        expected: (property, atRule) => `Expected property "${property}" for at-rule "${atRule}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'at-rule-property-required-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const { name, nodes } = atRule;
            const atRuleName = name.toLowerCase();

            if (!list[atRuleName]) {
              return;
            }

            list[atRuleName].forEach(property => {
              const propertyName = property.toLowerCase();

              const hasProperty = nodes.find(
              ({ type, prop }) => type === 'decl' && prop.toLowerCase() === propertyName);


              if (hasProperty) {
                return;
              }

              return report({
                message: messages.expected(propertyName, atRuleName),
                node: atRule,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 204: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"' });


      function rule(actual, secondary, context) {
        const checker = whitespaceChecker('newline', actual, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual,
            possible: ['always'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const nextNode = atRule.next();

            if (!nextNode) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              err: msg => {
                if (context.fix) {
                  nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                } else {
                  report({
                    message: msg,
                    node: atRule,
                    index: atRule.toString().length + 1,
                    result,
                    ruleName });

                }
              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 437, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/nextNonCommentNode": 488, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 205: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"' });


      function rule(expectation) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const nodeString = rawNodeString(atRule);

            checker.before({
              source: nodeString,
              index: nodeString.length,
              err: m => {
                report({
                  message: m,
                  node: atRule,
                  index: nodeString.length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 437, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 206: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'at-rule-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      function rule(listInput) {
        // To allow for just a string as a parameter (not only arrays of strings)
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'at-rule-allowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (list.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 471, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 207: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxAtRule = require('../utils/isStandardSyntaxAtRule');
      const report = require('../utils/report');

      module.exports = function (options) {
        options.root.walkAtRules(atRule => {
          if (!isStandardSyntaxAtRule(atRule)) {
            return;
          }

          checkColon(
          `@${atRule.name}${atRule.raws.afterName || ''}${atRule.params}`,
          atRule.name.length,
          atRule);

        });

        function checkColon(source, index, node) {
          options.locationChecker({
            source,
            index,
            err: m => {
              if (options.fix) {
                options.fix(node);

                return;
              }

              report({
                message: m,
                node,
                index,
                result: options.result,
                ruleName: options.checkedRuleName });

            },
            errTarget: `@${node.name}` });

        }
      };

    }, { "../utils/isStandardSyntaxAtRule": 471, "../utils/report": 498 }], 208: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const addEmptyLineAfter = require('../../utils/addEmptyLineAfter');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLineAfter = require('../../utils/removeEmptyLinesAfter');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before closing brace',
        rejected: 'Unexpected empty line before closing brace' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always-multi-line', 'never'] },

          {
            actual: options,
            possible: {
              except: ['after-closing-brace'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Get whitespace after ""}", ignoring extra semicolon
            const before = (statement.raws.after || '').replace(/;+/, '');

            // Calculate index
            const statementString = statement.toString();
            let index = statementString.length - 1;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // Set expectation
            const expectEmptyLineBefore = (() => {
              const childNodeTypes = statement.nodes.map(item => item.type);

              // Reverse the primary options if `after-closing-brace` is set
              if (
              optionsMatches(options, 'except', 'after-closing-brace') &&
              statement.type === 'atrule' &&
              !childNodeTypes.includes('decl'))
              {
                return expectation === 'never';
              }

              return Boolean(
              expectation === 'always-multi-line' && !isSingleLineString(blockString(statement)));

            })();

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineAfter(statement, context.newline);
              } else {
                removeEmptyLineAfter(statement, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              result,
              ruleName,
              node: statement,
              index });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineAfter": 414, "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/hasEmptyLine": 439, "../../utils/isSingleLineString": 470, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesAfter": 496, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 209: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "}"',
        expectedAfterSingleLine: () => 'Expected newline after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected newline after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: options,
            possible: {
              ignoreAtRules: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            if (!hasBlock(statement)) {
              return;
            }

            if (optionsMatches(options, 'ignoreAtRules', statement.name)) {
              return;
            }

            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            // Allow an end-of-line comment x spaces after the brace
            const nextNodeIsSingleLineComment =
            nextNode.type === 'comment' &&
            !/[^ ]/.test(nextNode.raws.before || '') &&
            !nextNode.toString().includes('\n');

            const nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;

            if (!nodeToCheck) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nodeToCheck);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            // Only check one after, because there might be other
            // spaces handled by the indentation rule
            checker.afterOneOnly({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    const index = nodeToCheck.raws.before.search(/\r?\n/);

                    if (index >= 0) {
                      nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);
                    } else {
                      nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                    }

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    nodeToCheck.raws.before = '';

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/optionsMatches": 490, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "lodash": 68 }], 210: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: 'Expected newline before "}"',
        expectedBeforeMultiLine: 'Expected newline before "}" of a multi-line block',
        rejectedBeforeMultiLine: 'Unexpected whitespace before "}" of a multi-line block' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Ignore extra semicolon
            const after = (statement.raws.after || '').replace(/;+/, '');

            if (after === undefined) {
              return;
            }

            const blockIsMultiLine = !isSingleLineString(blockString(statement));
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // We're really just checking whether a
            // newline *starts* the block's final space -- between
            // the last declaration and the closing brace. We can
            // ignore any other whitespace between them, because that
            // will be checked by the indentation rule.
            if (!after.startsWith('\n') && !after.startsWith('\r\n')) {
              if (expectation === 'always') {
                complain(messages.expectedBefore);
              } else if (blockIsMultiLine && expectation === 'always-multi-line') {
                complain(messages.expectedBeforeMultiLine);
              }
            }

            if (after !== '' && blockIsMultiLine && expectation === 'never-multi-line') {
              complain(messages.rejectedBeforeMultiLine);
            }

            function complain(message) {
              if (context.fix) {
                if (expectation.startsWith('always')) {
                  const firstWhitespaceIndex = statement.raws.after.search(/\s/);
                  const newlineBefore =
                  firstWhitespaceIndex >= 0 ?
                  statement.raws.after.slice(0, firstWhitespaceIndex) :
                  statement.raws.after;
                  const newlineAfter =
                  firstWhitespaceIndex >= 0 ? statement.raws.after.slice(firstWhitespaceIndex) : '';
                  const newlineIndex = newlineAfter.search(/\r?\n/);

                  if (newlineIndex >= 0) {
                    statement.raws.after = newlineBefore + newlineAfter.slice(newlineIndex);
                  } else {
                    statement.raws.after = newlineBefore + context.newline + newlineAfter;
                  }

                  return;
                }

                if (expectation === 'never-multi-line') {
                  statement.raws.after = statement.raws.after.replace(/\s/g, '');

                  return;
                }
              }

              report({
                message,
                result,
                ruleName,
                node: statement,
                index });

            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/isSingleLineString": 470, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 211: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "}"',
        rejectedAfter: () => 'Unexpected whitespace after "}"',
        expectedAfterSingleLine: () => 'Expected single space after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      function rule(expectation) {
        const checker = whitespaceChecker('space', expectation, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nextNode);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            checker.after({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 212: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "}"',
        rejectedBefore: () => 'Unexpected whitespace before "}"',
        expectedBeforeSingleLine: () => 'Expected single space before "}" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "}" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "}" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "}" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = blockString(statement);
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length - 1,
              err: msg => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    statement.raws.after = statement.raws.after.replace(/\s*$/, ' ');

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    statement.raws.after = statement.raws.after.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 213: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty block' });


      function rule(primary, options = {}) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: _.isBoolean },

          {
            actual: options,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(options, 'ignore', 'comments');

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            if (!hasEmptyBlock(statement) && !ignoreComments) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            const hasCommentsOnly = statement.nodes.every(node => node.type === 'comment');

            if (!hasCommentsOnly) {
              return;
            }

            let index = beforeBlockString(statement, { noRawBefore: true }).length;

            // For empty blocks when using SugarSS parser
            if (statement.raws.between === undefined) {
              index--;
            }

            report({
              message: messages.rejected,
              node: statement,
              index,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 214: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "{"',
        expectedAfterMultiLine: () => 'Expected newline after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const backupCommentNextBefores = new Map();

            // next node with checking newlines after comment
            function nextNode(startNode) {
              if (!startNode || !startNode.next) return null;

              if (startNode.type === 'comment') {
                const reNewLine = /\r?\n/;
                const newLineMatch = reNewLine.test(startNode.raws.before);

                const next = startNode.next();

                if (next && newLineMatch && !reNewLine.test(next.raws.before)) {
                  backupCommentNextBefores.set(next, next.raws.before);
                  next.raws.before = startNode.raws.before;
                }

                return nextNode(next);
              }

              return startNode;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNode(statement.first);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    const index = nodeToCheck.raws.before.search(/\r?\n/);

                    if (index >= 0) {
                      nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);
                    } else {
                      nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                    }

                    backupCommentNextBefores.delete(nodeToCheck);

                    return;
                  }

                  if (expectation === 'never-multi-line') {
                    // Restore the `before` of the node next to the comment node.
                    backupCommentNextBefores.forEach((before, node) => {
                      node.raws.before = before;
                    });
                    backupCommentNextBefores.clear();

                    // Fix
                    const reNewLine = /\r?\n/;
                    let fixTarget = statement.first;

                    while (fixTarget) {
                      if (reNewLine.test(fixTarget.raws.before)) {
                        fixTarget.raws.before = fixTarget.raws.before.replace(/\r?\n/g, '');
                      }

                      if (fixTarget.type !== 'comment') {
                        break;
                      }

                      fixTarget = fixTarget.next();
                    }
                    nodeToCheck.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });


            // Restore the `before` of the node next to the comment node.
            backupCommentNextBefores.forEach((before, node) => {
              node.raws.before = before;
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 215: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before "{"',
        expectedBeforeSingleLine: () => 'Expected newline before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected newline before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.beforeAllowingIndentation({
              lineCheckStr: blockString(statement),
              source,
              index: source.length,
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    const spaceIndex = statement.raws.between.search(/\s+$/);

                    if (spaceIndex >= 0) {
                      statement.raws.between =
                      statement.raws.between.slice(0, spaceIndex) +
                      context.newline +
                      statement.raws.between.slice(spaceIndex);
                    } else {
                      statement.raws.between += context.newline;
                    }

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    statement.raws.between = statement.raws.between.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 216: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "{"',
        rejectedAfter: () => 'Unexpected whitespace after "{"',
        expectedAfterSingleLine: () => 'Expected single space after "{" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "{" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            checker.after({
              source: blockString(statement),
              index: 0,
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    statement.first.raws.before = ' ';

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    statement.first.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 217: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "{"',
        rejectedBefore: () => 'Unexpected whitespace before "{"',
        expectedBeforeSingleLine: () => 'Expected single space before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: options,
            possible: {
              ignoreAtRules: [_.isString, _.isRegExp],
              ignoreSelectors: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (optionsMatches(options, 'ignoreAtRules', statement.name)) {
              return;
            }

            // Return early if selector is to be ignored
            if (optionsMatches(options, 'ignoreSelectors', statement.selector)) {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    statement.raws.between = ' ';

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    statement.raws.between = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/blockString": 418, "../../utils/hasBlock": 437, "../../utils/hasEmptyBlock": 438, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "lodash": 68 }], 218: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-function-notation';

      const messages = ruleMessages(ruleName, {
        expected: primary => `Expected ${primary} color-function notation` });


      const LEGACY_FUNCS = ['rgba', 'hsla'];
      const LEGACY_NOTATION_FUNCS = ['rgb', 'rgba', 'hsl', 'hsla'];

      function rule(primary, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['modern', 'legacy'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getValue(decl));

            parsedValue.walk(node => {
              const { value, type, sourceIndex, nodes } = node;

              if (type !== 'function') return;

              if (!LEGACY_NOTATION_FUNCS.includes(value.toLowerCase())) return;

              if (primary === 'modern' && !hasCommas(node)) return;

              if (primary === 'legacy' && hasCommas(node)) return;

              if (context.fix && primary === 'modern') {
                let commaCount = 0;

                // Convert punctuation
                node.nodes = nodes.map(childNode => {
                  if (isComma(childNode)) {
                    // Non-alpha commas to space and alpha commas to slashes
                    if (commaCount < 2) {
                      childNode.type = 'space';
                      childNode.value = atLeastOneSpace(childNode.after);
                      commaCount++;
                    } else {
                      childNode.value = '/';
                      childNode.before = atLeastOneSpace(childNode.before);
                      childNode.after = atLeastOneSpace(childNode.after);
                    }
                  }

                  return childNode;
                });

                // Remove trailing 'a' from legacy function name
                if (LEGACY_FUNCS.includes(node.value.toLowerCase())) {
                  node.value = node.value.slice(0, -1);
                }

                needsFix = true;

                return;
              }

              report({
                message: messages.expected(primary),
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setValue(decl, parsedValue.toString());
            }
          });
        };
      }

      function atLeastOneSpace(whitespace) {
        return whitespace !== '' ? whitespace : ' ';
      }

      function isComma(node) {
        return node.type === 'div' && node.value === ',';
      }

      function hasCommas(node) {
        return node.nodes && node.nodes.some(childNode => isComma(childNode));
      }

      function getValue(decl) {
        return decl.raws.value ? decl.raws.value.raw : decl.value;
      }

      function setValue(decl, value) {
        if (decl.raws.value) decl.raws.value.raw = value;else
        decl.value = value;

        return decl;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 219: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blurFunctionArguments = require('../../utils/blurFunctionArguments');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const declString = blurFunctionArguments(decl.toString(), 'url');
            const fixPositions = [];

            styleSearch({ source: declString, target: '#' }, match => {
              const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex));

              if (!hexMatch) {
                return;
              }

              const hexValue = hexMatch[0];
              const hexValueLower = hexValue.toLowerCase();
              const hexValueUpper = hexValue.toUpperCase();
              const expectedHex = expectation === 'lower' ? hexValueLower : hexValueUpper;

              if (hexValue === expectedHex) {
                return;
              }

              if (context.fix) {
                fixPositions.unshift({
                  expectedHex,
                  currentHex: hexValue,
                  startIndex: match.startIndex });


                return;
              }

              report({
                message: messages.expected(hexValue, expectedHex),
                node: decl,
                index: match.startIndex,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              const declProp = decl.prop;
              const declBetween = decl.raws.between;

              fixPositions.forEach(fixPosition => {
                // 1  it's a # length
                decl.value = replaceHex(
                decl.value,
                fixPosition.currentHex,
                fixPosition.expectedHex,
                fixPosition.startIndex - declProp.length - declBetween.length - 1);

              });
            }
          });
        };
      }

      function replaceHex(input, searchString, replaceString, startIndex) {
        const offset = startIndex + 1;
        const stringStart = input.slice(0, offset);
        const stringEnd = input.slice(offset + searchString.length);

        return stringStart + replaceString + stringEnd;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blurFunctionArguments": 420, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 220: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blurFunctionArguments = require('../../utils/blurFunctionArguments');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-length';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, _, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['short', 'long'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const declString = blurFunctionArguments(decl.toString(), 'url');
            const fixPositions = [];

            styleSearch({ source: declString, target: '#' }, match => {
              const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex));

              if (!hexMatch) {
                return;
              }

              const hexValue = hexMatch[0];

              if (expectation === 'long' && hexValue.length !== 4 && hexValue.length !== 5) {
                return;
              }

              if (expectation === 'short' && (hexValue.length < 6 || !canShrink(hexValue))) {
                return;
              }

              const variant = expectation === 'long' ? longer : shorter;
              const expectedHex = variant(hexValue);

              if (context.fix) {
                fixPositions.unshift({
                  expectedHex,
                  currentHex: hexValue,
                  startIndex: match.startIndex });


                return;
              }

              report({
                message: messages.expected(hexValue, expectedHex),
                node: decl,
                index: match.startIndex,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              const declProp = decl.prop;
              const declBetween = decl.raws.between;

              fixPositions.forEach(fixPosition => {
                // 1  it's a # length
                decl.value = replaceHex(
                decl.value,
                fixPosition.currentHex,
                fixPosition.expectedHex,
                fixPosition.startIndex - declProp.length - declBetween.length - 1);

              });
            }
          });
        };
      }

      function canShrink(hex) {
        hex = hex.toLowerCase();

        return (
          hex[1] === hex[2] &&
          hex[3] === hex[4] &&
          hex[5] === hex[6] && (
          hex.length === 7 || hex.length === 9 && hex[7] === hex[8]));

      }

      function shorter(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i += 2) {
          hexVariant += hex[i];
        }

        return hexVariant;
      }

      function longer(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i++) {
          hexVariant += hex[i] + hex[i];
        }

        return hexVariant;
      }

      function replaceHex(input, searchString, replaceString, startIndex) {
        const offset = startIndex + 1;
        const stringStart = input.slice(0, offset);
        const stringEnd = input.slice(offset + searchString.length);

        return stringStart + replaceString + stringEnd;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blurFunctionArguments": 420, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 221: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      // these algorithms are sourced from https://drafts.csswg.org/css-color/#color-conversion-code

      function lin_sRGB(RGB) {
        // convert an array of sRGB values in the range 0.0 - 1.0
        // to linear light (un-companded) form.
        // https://en.wikipedia.org/wiki/SRGB
        return RGB.map(val => {
          if (val < 0.04045) {
            return val / 12.92;
          }

          return Math.pow((val + 0.055) / 1.055, 2.4);
        });
      }

      function matrixMultiple3d(matrix, vector) {
        return [
        matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],
        matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],
        matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]];

      }

      function srgb2xyz(srgb) {
        return matrixMultiple3d(
        [
        [0.4124564, 0.3575761, 0.1804375],
        [0.2126729, 0.7151522, 0.072175],
        [0.0193339, 0.119192, 0.9503041]],

        srgb);

      }

      function chromaticAdaptationD65_D50(xyz) {
        return matrixMultiple3d(
        [
        [1.0478112, 0.0228866, -0.050127],
        [0.0295424, 0.9904844, -0.0170491],
        [-0.0092345, 0.0150436, 0.7521316]],

        xyz);

      }

      function xyz2lab(xyzIn) {
        // Assuming XYZ is relative to D50, convert to CIE Lab
        // from CIE standard, which now defines these as a rational fraction
        const  = 216 / 24389; // 6^3/29^3
        const  = 24389 / 27; // 29^3/3^3
        const white = [0.9642, 1.0, 0.8249]; // D50 reference white

        // compute xyz, which is XYZ scaled relative to reference white
        const xyz = xyzIn.map((value, i) => value / white[i]);

        // now compute f
        const f = xyz.map(value => {
          if (value > ) {
            return Math.cbrt(value);
          }

          return ( * value + 16) / 116;
        });

        return [
        116 * f[1] - 16, // L
        500 * (f[0] - f[1]), // a
        200 * (f[1] - f[2]) // b
        ];
      }

      function rgb2hsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        let h;
        let s;
        let l;
        const M = Math.max(r, g, b);
        const m = Math.min(r, g, b);
        const d = M - m;

        if (d === 0) {
          h = 0;
        } else if (M === r) {
          h = (g - b) / d % 6;
        } else if (M === g) {
          h = (b - r) / d + 2;
        } else {
          h = (r - g) / d + 4;
        }

        h *= 60;

        if (h < 0) {
          h += 360;
        }

        l = (M + m) / 2;

        if (d === 0) {
          s = 0;
        } else {
          s = d / (1 - Math.abs(2 * l - 1));
        }

        s *= 100;
        l *= 100;

        return [Math.round(h), Math.round(s), Math.round(l)];
      }

      function rgb2hwb(rgb_r, rgb_g, rgb_b) {
        rgb_r /= 255;
        rgb_g /= 255;
        rgb_b /= 255;

        const w = Math.min(rgb_r, rgb_g, rgb_b);
        const v = Math.max(rgb_r, rgb_g, rgb_b);

        const b = 1 - v;

        if (v === w) {
          return [0, Math.round(w * 100), Math.round(b * 100)];
        }

        const f = rgb_r === w ? rgb_g - rgb_b : rgb_g === w ? rgb_b - rgb_r : rgb_r - rgb_g;
        const i = rgb_r === w ? 3 : rgb_g === w ? 5 : 1;

        return [
        Math.round((i - f / (v - w)) / 6 * 360) % 360,
        Math.round(w * 100),
        Math.round(b * 100)];

      }

      function perc255(value) {
        return `${Math.round(value * 100 / 255)}%`;
      }

      function generateColorFuncs(hexString) {
        if (hexString.length !== 7) {
          throw new Error(
          `Invalid hex string color definition (${hexString}) - expected 6 character hex string`);

        }

        const rgb = [0, 0, 0];

        for (let i = 0; i < 3; i += 1) {
          rgb[i] = parseInt(hexString.substr(2 * i + 1, 2), 16);
        }

        const hsl = rgb2hsl(rgb[0], rgb[1], rgb[2]);
        const hwb = rgb2hwb(rgb[0], rgb[1], rgb[2]);
        const func = [];
        const rgbStr = `${rgb[0]},${rgb[1]},${rgb[2]}`;
        const rgbPercStr = `${perc255(rgb[0])},${perc255(rgb[1])},${perc255(rgb[2])}`;
        const hslStr = `${hsl[0]},${hsl[1]}%,${hsl[2]}%`;
        const hwbStr = `${hwb[0]},${hwb[1]}%,${hwb[2]}%`;

        // *very* convoluted process, just to be able to establish if the color
        // is gray -- or not.
        const linRgb = lin_sRGB([rgb[0] / 255, rgb[1] / 255, rgb[2] / 255]);
        const xyz_d65 = srgb2xyz(linRgb);
        const xyz_d50 = chromaticAdaptationD65_D50(xyz_d65);
        const lab = xyz2lab(xyz_d50);

        func.push(`rgb(${rgbStr})`);
        func.push(`rgba(${rgbStr},1)`);
        func.push(`rgba(${rgbStr},100%)`);
        func.push(`rgb(${rgbPercStr})`);
        func.push(`rgba(${rgbPercStr},1)`);
        func.push(`rgba(${rgbPercStr},100%)`);
        func.push(`hsl(${hslStr})`);
        func.push(`hsla(${hslStr},1)`);
        func.push(`hsla(${hslStr},100%)`);
        func.push(`hwb(${hwbStr})`);
        func.push(`hwb(${hwbStr},1)`);
        func.push(`hwb(${hwbStr},100%)`);

        // technically, this should be 0 - but then #808080 wouldn't even be gray
        if (lab[1] * lab[1] < 0.01 && lab[2] * lab[2] < 0.01) {
          // yay! gray!
          const grayStr = Math.round(lab[0]);

          func.push(`gray(${grayStr})`);
          func.push(`gray(${grayStr},1)`);
          func.push(`gray(${grayStr},100%)`);
          func.push(`gray(${grayStr}%)`);
          func.push(`gray(${grayStr}%,1)`);
          func.push(`gray(${grayStr}%,100%)`);
        }

        return func;
      }

      module.exports = generateColorFuncs;

    }, {}], 222: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const keywordSets = require('../../reference/keywordSets');
      const namedColorDataHex = require('../../reference/namedColorData');
      const optionsMatches = require('../../utils/optionsMatches');
      const propertySets = require('../../reference/propertySets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const generateColorFuncs = require('./generateColorFuncs');

      const ruleName = 'color-named';

      const messages = ruleMessages(ruleName, {
        expected: (named, original) => `Expected "${original}" to be "${named}"`,
        rejected: named => `Unexpected named color "${named}"` });


      // Todo tested on case insensivity
      const NODE_TYPES = ['word', 'function'];

      function rule(expectation, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['never', 'always-where-possible'] },

          {
            actual: options,
            possible: {
              ignoreProperties: [_.isString, _.isRegExp],
              ignore: ['inside-function'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const namedColors = Object.keys(namedColorDataHex);
          const namedColorData = {};

          namedColors.forEach(name => {
            const hex = namedColorDataHex[name];

            namedColorData[name] = {
              hex,
              func: generateColorFuncs(hex[0]) };

          });

          root.walkDecls(decl => {
            if (propertySets.acceptCustomIdents.has(decl.prop)) {
              return;
            }

            // Return early if the property is to be ignored
            if (optionsMatches(options, 'ignoreProperties', decl.prop)) {
              return;
            }

            valueParser(decl.value).walk(node => {
              const value = node.value;
              const type = node.type;
              const sourceIndex = node.sourceIndex;

              if (optionsMatches(options, 'ignore', 'inside-function') && type === 'function') {
                return false;
              }

              if (!isStandardSyntaxFunction(node)) {
                return false;
              }

              if (!isStandardSyntaxValue(value)) {
                return;
              }

              // Return early if neither a word nor a function
              if (!NODE_TYPES.includes(type)) {
                return;
              }

              // Check for named colors for "never" option
              if (
              expectation === 'never' &&
              type === 'word' &&
              namedColors.includes(value.toLowerCase()))
              {
                complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex);

                return;
              }

              // Check "always-where-possible" option ...
              if (expectation !== 'always-where-possible') {
                return;
              }

              // First by checking for alternative color function representations ...
              if (type === 'function' && keywordSets.colorFunctionNames.has(value.toLowerCase())) {
                // Remove all spaces to match what's in `representations`
                const normalizedFunctionString = valueParser.stringify(node).replace(/\s+/g, '');
                let namedColor;

                for (let i = 0, l = namedColors.length; i < l; i++) {
                  namedColor = namedColors[i];

                  if (namedColorData[namedColor].func.includes(normalizedFunctionString.toLowerCase())) {
                    complain(
                    messages.expected(namedColor, normalizedFunctionString),
                    decl,
                    declarationValueIndex(decl) + sourceIndex);


                    return; // Exit as soon as a problem is found
                  }
                }

                return;
              }

              // Then by checking for alternative hex representations
              let namedColor;

              for (let i = 0, l = namedColors.length; i < l; i++) {
                namedColor = namedColors[i];

                if (namedColorData[namedColor].hex.includes(value.toLowerCase())) {
                  complain(
                  messages.expected(namedColor, value),
                  decl,
                  declarationValueIndex(decl) + sourceIndex);


                  return; // Exit as soon as a problem is found
                }
              }
            });
          });

          function complain(message, node, index) {
            report({
              result,
              ruleName,
              message,
              node,
              index });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../reference/namedColorData": 188, "../../reference/propertySets": 189, "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/isStandardSyntaxValue": 482, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "./generateColorFuncs": 221, "lodash": 68, "postcss-value-parser": 120 }], 223: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-no-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected hex color "${hex}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const declString = decl.toString();

            styleSearch({ source: declString, target: '#' }, match => {
              // If there's not a colon, comma, or whitespace character before, we'll assume this is
              // not intended to be a hex color, but is instead something like the
              // hash in a url() argument
              if (!/[:,\s]/.test(declString[match.startIndex - 1])) {
                return;
              }

              const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex));

              if (!hexMatch) {
                return;
              }

              const hexValue = hexMatch[0];

              report({
                message: messages.rejected(hexValue),
                node: decl,
                index: match.startIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 224: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isValidHex = require('../../utils/isValidHex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'color-no-invalid-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected invalid hex color "${hex}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(({ value, type, sourceIndex }) => {
              if (type === 'function' && value.endsWith('url')) return false;

              if (type !== 'word') return;

              const hexMatch = /^#[0-9A-Za-z]+/.exec(value);

              if (!hexMatch) return;

              const hexValue = hexMatch[0];

              if (isValidHex(hexValue)) return;

              report({
                message: messages.rejected(hexValue),
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isValidHex": 484, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 225: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSharedLineComment = require('../../utils/isSharedLineComment');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before comment',
        rejected: 'Unexpected empty line before comment' });


      const stylelintCommandPrefix = 'stylelint-';

      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never'] },

          {
            actual: options,
            possible: {
              except: ['first-nested'],
              ignore: ['stylelint-commands', 'after-comment'],
              ignoreComments: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // Ignore the first node
            if (isFirstNodeOfRoot(comment)) {
              return;
            }

            // Optionally ignore stylelint commands
            if (
            comment.text.startsWith(stylelintCommandPrefix) &&
            optionsMatches(options, 'ignore', 'stylelint-commands'))
            {
              return;
            }

            // Optionally ignore newlines between comments
            if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(comment)) {
              return;
            }

            // Ignore comments matching the ignoreComments option.
            if (optionsMatches(options, 'ignoreComments', comment.text)) {
              return;
            }

            // Ignore shared-line comments
            if (isSharedLineComment(comment)) {
              return;
            }

            // Ignore SCSS comments
            if (comment.raws.inline || comment.inline) {
              return;
            }

            const expectEmptyLineBefore = (() => {
              if (optionsMatches(options, 'except', 'first-nested') && isFirstNested(comment)) {
                return false;
              }

              return expectation === 'always';
            })();

            const before = comment.raws.before || '';
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(comment, context.newline);
              } else {
                removeEmptyLinesBefore(comment, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: comment,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 415, "../../utils/hasEmptyLine": 439, "../../utils/isAfterComment": 445, "../../utils/isFirstNested": 458, "../../utils/isFirstNodeOfRoot": 459, "../../utils/isSharedLineComment": 469, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesBefore": 497, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 226: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty comment' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // To ignore inline SCSS comments
            if (comment.raws.inline || comment.inline) {
              return;
            }

            // To ignore comments that are not empty
            if (comment.text && comment.text.length !== 0) {
              return;
            }

            report({
              message: messages.rejected,
              node: comment,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 227: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected comment to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkComments(comment => {
            const text = comment.text;

            if (normalizedPattern.test(text)) {
              return;
            }

            report({
              message: messages.expected(pattern),
              node: comment,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 228: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');

      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-whitespace-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected whitespace after "/*"',
        rejectedOpening: 'Unexpected whitespace after "/*"',
        expectedClosing: 'Expected whitespace before "*/"',
        rejectedClosing: 'Unexpected whitespace before "*/"' });


      function rule(expectation, options, context) {
        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            if (comment.raws.inline || comment.inline) {
              return;
            }

            const rawComment = comment.toString();
            const firstFourChars = rawComment.substr(0, 4);

            // Return early if sourcemap or copyright comment
            if (/^\/\*[#!]\s/.test(firstFourChars)) {
              return;
            }

            const leftMatches = rawComment.match(/(^\/\*+)(\s)?/);
            const rightMatches = rawComment.match(/(\s)?(\*+\/)$/);
            const opener = leftMatches[1];
            const leftSpace = leftMatches[2] || '';
            const rightSpace = rightMatches[1] || '';
            const closer = rightMatches[2];

            if (expectation === 'never' && leftSpace !== '') {
              complain(messages.rejectedOpening, opener.length);
            }

            if (expectation === 'always' && !isWhitespace(leftSpace)) {
              complain(messages.expectedOpening, opener.length);
            }

            if (expectation === 'never' && rightSpace !== '') {
              complain(messages.rejectedClosing, comment.toString().length - closer.length - 1);
            }

            if (expectation === 'always' && !isWhitespace(rightSpace)) {
              complain(messages.expectedClosing, comment.toString().length - closer.length - 1);
            }

            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function addWhitespaceBefore(comment) {
              if (comment.text.startsWith('*')) {
                comment.text = comment.text.replace(/^(\*+)/, `$1 `);
              } else {
                comment.raws.left = ' ';
              }
            }

            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function addWhitespaceAfter(comment) {
              if (_.last(comment.text) === '*') {
                comment.text = comment.text.replace(/(\*+)$/, ` $1`);
              } else {
                comment.raws.right = ' ';
              }
            }

            function complain(message, index) {
              if (context.fix) {
                if (expectation === 'never') {
                  comment.raws.left = '';
                  comment.raws.right = '';
                  comment.text = comment.text.replace(/^(\*+)(\s+)?/, '$1').replace(/(\s+)?(\*+)$/, '$2');
                } else {
                  if (!leftSpace) {
                    addWhitespaceBefore(comment);
                  }

                  if (!rightSpace) {
                    addWhitespaceAfter(comment);
                  }
                }

                return;
              }

              report({
                message,
                index,
                result,
                ruleName,
                node: comment });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isWhitespace": 486, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 229: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const containsString = require('../../utils/containsString');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-word-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: pattern => `Unexpected word matching pattern "${pattern}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'comment-word-disallowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkComments(comment => {
            const text = comment.text;
            const rawComment = comment.toString();
            const firstFourChars = rawComment.substr(0, 4);

            // Return early if sourcemap
            if (firstFourChars === '/*# ') {
              return;
            }

            const matchesWord = matchesStringOrRegExp(text, list) || containsString(text, list);

            if (!matchesWord) {
              return;
            }

            report({
              message: messages.rejected(matchesWord.pattern),
              node: comment,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/containsString": 424, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 230: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const containsString = require('../../utils/containsString');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-word-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: pattern => `Unexpected word matching pattern "${pattern}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            const text = comment.text;
            const rawComment = comment.toString();
            const firstFourChars = rawComment.substr(0, 4);

            // Return early if sourcemap
            if (firstFourChars === '/*# ') {
              return;
            }

            const matchesWord = matchesStringOrRegExp(text, list) || containsString(text, list);

            if (!matchesWord) {
              return;
            }

            report({
              message: messages.rejected(matchesWord.pattern),
              node: comment,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/containsString": 424, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 231: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'custom-media-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom media query name to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() !== 'custom-media') {
              return;
            }

            const customMediaName = atRule.params.match(/^--(\S+)\b/)[1];

            if (regexpPattern.test(customMediaName)) {
              return;
            }

            report({
              message: messages.expected(pattern),
              node: atRule,
              index: atRuleParamIndex(atRule),
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 232: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'custom-property-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before custom property',
        rejected: 'Unexpected empty line before custom property' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never'] },

          {
            actual: options,
            possible: {
              except: ['first-nested', 'after-comment', 'after-custom-property'],
              ignore: ['after-comment', 'first-nested', 'inside-single-line-block'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (!isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(options, 'ignore', 'inside-single-line-block') &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = expectation === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(options, 'except', 'after-custom-property') && isAfterCustomProperty(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: decl,
              result,
              ruleName });

          });
        };
      }

      function isAfterCustomProperty(decl) {
        const prevNode = getPreviousNonSharedLineCommentNode(decl);

        return prevNode && prevNode.prop && isCustomProperty(prevNode.prop);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 415, "../../utils/blockString": 418, "../../utils/getPreviousNonSharedLineCommentNode": 434, "../../utils/hasEmptyLine": 439, "../../utils/isAfterComment": 445, "../../utils/isCustomProperty": 455, "../../utils/isFirstNested": 458, "../../utils/isSingleLineString": 470, "../../utils/isStandardSyntaxDeclaration": 473, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesBefore": 497, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 233: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'custom-property-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom property name to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isCustomProperty(prop)) {
              return;
            }

            if (regexpPattern.test(prop.slice(2))) {
              return;
            }

            report({
              message: messages.expected(pattern),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 234: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "!"',
        rejectedAfter: () => 'Unexpected whitespace after "!"' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const value = decl.raws.value ? decl.raws.value.raw : decl.value;
              let target;
              let setFixed;

              if (bangIndex < value.length) {
                target = value;
                // TODO: Issue #4985
                // eslint-disable-next-line no-shadow
                setFixed = value => {
                  if (decl.raws.value) {
                    decl.raws.value.raw = value;
                  } else {
                    decl.value = value;
                  }
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= value.length;
                // TODO: Issue #4985
                // eslint-disable-next-line no-shadow
                setFixed = value => {
                  decl.raws.important = value;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex + 1);
              const targetAfter = target.slice(bangIndex + 1);

              if (expectation === 'always') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (expectation === 'never') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ''));

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../declarationBangSpaceChecker": 258 }], 235: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "!"',
        rejectedBefore: () => 'Unexpected whitespace before "!"' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const value = decl.raws.value ? decl.raws.value.raw : decl.value;
              let target;
              let setFixed;

              if (bangIndex < value.length) {
                target = value;
                // TODO: Issue #4985
                // eslint-disable-next-line no-shadow
                setFixed = value => {
                  if (decl.raws.value) {
                    decl.raws.value.raw = value;
                  } else {
                    decl.value = value;
                  }
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= value.length;
                // TODO: Issue #4985
                // eslint-disable-next-line no-shadow
                setFixed = value => {
                  decl.raws.important = value;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex);
              const targetAfter = target.slice(bangIndex);

              if (expectation === 'always') {
                // eslint-disable-next-line prefer-template
                setFixed(targetBefore.replace(/\s*$/, '') + ' ' + targetAfter);

                return true;
              }

              if (expectation === 'never') {
                setFixed(targetBefore.replace(/\s*$/, '') + targetAfter);

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../declarationBangSpaceChecker": 258 }], 236: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-no-duplicate-properties';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected duplicate "${property}"` });


      function rule(on, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: on },
          {
            actual: options,
            possible: {
              ignore: ['consecutive-duplicates', 'consecutive-duplicates-with-different-values'],
              ignoreProperties: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            const decls = [];
            const values = [];

            eachDecl(decl => {
              const prop = decl.prop;
              const value = decl.value;

              if (!isStandardSyntaxProperty(prop)) {
                return;
              }

              if (isCustomProperty(prop)) {
                return;
              }

              // Return early if the property is to be ignored
              if (optionsMatches(options, 'ignoreProperties', prop)) {
                return;
              }

              // Ignore the src property as commonly duplicated in at-fontface
              if (prop.toLowerCase() === 'src') {
                return;
              }

              const indexDuplicate = decls.indexOf(prop.toLowerCase());

              if (indexDuplicate !== -1) {
                if (optionsMatches(options, 'ignore', 'consecutive-duplicates-with-different-values')) {
                  // if duplicates are not consecutive
                  if (indexDuplicate !== decls.length - 1) {
                    report({
                      message: messages.rejected(prop),
                      node: decl,
                      result,
                      ruleName });


                    return;
                  }

                  // if values of consecutive duplicates are equal
                  if (value === values[indexDuplicate]) {
                    report({
                      message: messages.rejected(value),
                      node: decl,
                      result,
                      ruleName });


                    return;
                  }

                  return;
                }

                if (
                optionsMatches(options, 'ignore', 'consecutive-duplicates') &&
                indexDuplicate === decls.length - 1)
                {
                  return;
                }

                report({
                  message: messages.rejected(prop),
                  node: decl,
                  result,
                  ruleName });

              }

              decls.push(prop.toLowerCase());
              values.push(value.toLowerCase());
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/eachDeclarationBlock": 426, "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 237: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-redundant-longhand-properties';

      const messages = ruleMessages(ruleName, {
        expected: props => `Expected shorthand property "${props}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreShorthands: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          const longhandProperties = _.transform(shorthandData, (result, values, key) => {
            if (optionsMatches(options, 'ignoreShorthands', key)) {
              return;
            }

            values.forEach(value => {
              (result[value] || (result[value] = [])).push(key);
            });
          });

          eachDeclarationBlock(root, eachDecl => {
            const longhandDeclarations = {};

            eachDecl(decl => {
              const prop = decl.prop.toLowerCase();
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop);

              const shorthandProperties = longhandProperties[unprefixedProp];

              if (!shorthandProperties) {
                return;
              }

              shorthandProperties.forEach(shorthandProperty => {
                const prefixedShorthandProperty = prefix + shorthandProperty;

                if (!longhandDeclarations[prefixedShorthandProperty]) {
                  longhandDeclarations[prefixedShorthandProperty] = [];
                }

                longhandDeclarations[prefixedShorthandProperty].push(prop);

                const prefixedShorthandData = shorthandData[shorthandProperty].map(item => {
                  return prefix + item;
                });

                if (
                !_.isEqual(
                prefixedShorthandData.sort(),
                longhandDeclarations[prefixedShorthandProperty].sort()))

                {
                  return;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.expected(prefixedShorthandProperty) });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/shorthandData": 190, "../../utils/eachDeclarationBlock": 426, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 238: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-shorthand-property-overrides';

      const messages = ruleMessages(ruleName, {
        rejected: (shorthand, original) => `Unexpected shorthand "${shorthand}" after "${original}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            const declarations = {};

            eachDecl(decl => {
              const prop = decl.prop;
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop).toLowerCase();

              const overrideables = shorthandData[unprefixedProp.toLowerCase()];

              if (!overrideables) {
                declarations[prop.toLowerCase()] = prop;

                return;
              }

              overrideables.forEach(longhandProp => {
                if (!Object.prototype.hasOwnProperty.call(declarations, prefix + longhandProp)) {
                  return;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.rejected(prop, declarations[prefix + longhandProp]) });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/shorthandData": 190, "../../utils/eachDeclarationBlock": 426, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504 }], 239: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-block-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"',
        expectedAfterMultiLine: () => 'Expected newline after ";" in a multi-line declaration block',
        rejectedAfterMultiLine: () => 'Unexpected newline after ";" in a multi-line declaration block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextNode = decl.next();

            if (!nextNode) {
              return;
            }

            // Allow end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    const index = nodeToCheck.raws.before.search(/\r?\n/);

                    if (index >= 0) {
                      nodeToCheck.raws.before = nodeToCheck.raws.before.slice(index);
                    } else {
                      nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                    }

                    return;
                  }

                  if (expectation === 'never-multi-line') {
                    nodeToCheck.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/nextNonCommentNode": 488, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 240: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-block-semicolon-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ";"',
        expectedBeforeMultiLine: () => 'Expected newline before ";" in a multi-line declaration block',
        rejectedBeforeMultiLine: () =>
        'Unexpected whitespace before ";" in a multi-line declaration block' });


      function rule(expectation) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parentRule = decl.parent;

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.beforeAllowingIndentation({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 241: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-block-semicolon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ";"',
        rejectedAfter: () => 'Unexpected whitespace after ";"',
        expectedAfterSingleLine: () =>
        'Expected single space after ";" in a single-line declaration block',
        rejectedAfterSingleLine: () =>
        'Unexpected whitespace after ";" in a single-line declaration block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextDecl = decl.next();

            if (!nextDecl) {
              return;
            }

            checker.after({
              source: rawNodeString(nextDecl),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (expectation.startsWith('always')) {
                    nextDecl.raws.before = ' ';

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    nextDecl.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/rawNodeString": 495, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 242: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const blockString = require('../../utils/blockString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-block-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"',
        expectedBeforeSingleLine: () =>
        'Expected single space before ";" in a single-line declaration block',
        rejectedBeforeSingleLine: () =>
        'Unexpected whitespace before ";" in a single-line declaration block' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.before({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  const value = decl.raws.value ? decl.raws.value.raw : decl.value;

                  if (expectation.startsWith('always')) {
                    if (decl.important) {
                      decl.raws.important = ' !important ';
                    } else if (decl.raws.value) {
                      decl.raws.value.raw = value.replace(/\s*$/, ' ');
                    } else {
                      decl.value = value.replace(/\s*$/, ' ');
                    }

                    return;
                  }

                  if (expectation.startsWith('never')) {
                    if (decl.important) {
                      decl.raws.important = decl.raws.important.replace(/\s*$/, '');
                    } else if (decl.raws.value) {
                      decl.raws.value.raw = value.replace(/\s*$/, '');
                    } else {
                      decl.value = value.replace(/\s*$/, '');
                    }

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 418, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 243: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-single-line-max-declarations';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} ${max === 1 ? 'declaration' : 'declarations'}` });


      function rule(quantity) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: quantity,
            possible: [_.isNumber] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isSingleLineString(blockString(rule))) {
              return;
            }

            if (!rule.nodes) {
              return;
            }

            const decls = rule.nodes.filter(node => node.type === 'decl');

            if (decls.length <= quantity) {
              return;
            }

            report({
              message: messages.expected(quantity),
              node: rule,
              index: beforeBlockString(rule, { noRawBefore: true }).length,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/blockString": 418, "../../utils/isSingleLineString": 470, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 244: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-trailing-semicolon';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a trailing semicolon',
        rejected: 'Unexpected trailing semicolon' });


      function rule(expectation, _, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.parent === root) {
              return;
            }

            if (atRule !== atRule.parent.last) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            checkLastNode(atRule);
          });

          root.walkDecls(decl => {
            if (decl.parent.type === 'object') {
              return;
            }

            if (decl !== decl.parent.last) {
              return;
            }

            checkLastNode(decl);
          });

          function checkLastNode(node) {
            let message;

            if (expectation === 'always') {
              if (node.parent.raws.semicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = true;

                if (node.type === 'atrule') {
                  node.raws.between = '';
                  node.parent.raws.after = ' ';
                }

                return;
              }

              message = messages.expected;
            } else if (expectation === 'never') {
              if (!node.parent.raws.semicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = false;

                return;
              }

              message = messages.rejected;
            }

            report({
              message,
              node,
              index: node.toString().trim().length - 1,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 437, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 245: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ":"',
        expectedAfterMultiLine: () => 'Expected newline after ":" with a multi-line declaration' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            // Get the raw prop, and only the prop
            const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

            // The extra characters tacked onto the end ensure that there is a character to check
            // after the colon. Otherwise, with `background:pink` the character after the
            const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

            for (let i = 0, l = propPlusColon.length; i < l; i++) {
              if (propPlusColon[i] !== ':') {
                continue;
              }

              const indexToCheck = /^[^\S\r\n]*\/\*/.test(propPlusColon.slice(i + 1)) ?
              propPlusColon.indexOf('*/', i) + 1 :
              i;

              checker.afterOneOnly({
                source: propPlusColon,
                index: indexToCheck,
                lineCheckStr: decl.value,
                err: m => {
                  if (context.fix) {
                    const between = decl.raws.between;
                    const betweenStart = declarationValueIndex(decl) - between.length;
                    const sliceIndex = indexToCheck - betweenStart + 1;
                    const betweenBefore = between.slice(0, sliceIndex);
                    const betweenAfter = between.slice(sliceIndex);

                    if (/^\s*\r?\n/.test(betweenAfter)) {
                      decl.raws.between = betweenBefore + betweenAfter.replace(/^[^\S\r\n]*/, '');
                    } else {
                      decl.raws.between = betweenBefore + context.newline + betweenAfter;
                    }

                    return;
                  }

                  report({
                    message: m,
                    node: decl,
                    index: indexToCheck,
                    result,
                    ruleName });

                } });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxDeclaration": 473, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505 }], 246: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"',
        expectedAfterSingleLine: () => 'Expected single space after ":" with a single-line declaration' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (expectation.startsWith('always')) {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ': ');

                return true;
              }

              if (expectation === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ':');

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../declarationColonSpaceChecker": 259 }], 247: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (expectation === 'always') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, ' ') + between.slice(colonIndex);

                return true;
              }

              if (expectation === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, '') + between.slice(colonIndex);

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../declarationColonSpaceChecker": 259 }], 248: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isAfterStandardPropertyDeclaration = require('../../utils/isAfterStandardPropertyDeclaration');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before declaration',
        rejected: 'Unexpected empty line before declaration' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never'] },

          {
            actual: options,
            possible: {
              except: ['first-nested', 'after-comment', 'after-declaration'],
              ignore: [
              'after-comment',
              'after-declaration',
              'first-nested',
              'inside-single-line-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            // Ignore the first node
            if (isFirstNodeOfRoot(decl)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(options, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if a declaration precedes it
            if (
            optionsMatches(options, 'ignore', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(options, 'ignore', 'inside-single-line-block') &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = expectation === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(options, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(options, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(options, 'except', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: decl, result, ruleName });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 415, "../../utils/blockString": 418, "../../utils/hasEmptyLine": 439, "../../utils/isAfterComment": 445, "../../utils/isAfterStandardPropertyDeclaration": 447, "../../utils/isCustomProperty": 455, "../../utils/isFirstNested": 458, "../../utils/isFirstNodeOfRoot": 459, "../../utils/isSingleLineString": 470, "../../utils/isStandardSyntaxDeclaration": 473, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesBefore": 497, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 249: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.important) {
              return;
            }

            report({
              message: messages.rejected,
              node: decl,
              word: 'important',
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 250: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propList = _.find(list, (units, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || (unit && propList.indexOf(unit.toLowerCase())) !== -1) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 251: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'declaration-property-unit-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propList = _.find(list, (units, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || unit && !propList.includes(unit.toLowerCase())) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 252: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propList = _.find(list, (units, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || unit && !propList.includes(unit.toLowerCase())) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 253: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-unit-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'declaration-property-unit-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propList = _.find(list, (units, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || (unit && propList.indexOf(unit.toLowerCase())) !== -1) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 254: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propList = _.find(list, (values, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (_.isEmpty(propList)) {
              return;
            }

            if (matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 255: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'declaration-property-value-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propList = _.find(list, (values, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (_.isEmpty(propList)) {
              return;
            }

            if (!matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 256: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propList = _.find(list, (values, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (_.isEmpty(propList)) {
              return;
            }

            if (!matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 257: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-property-value-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'declaration-property-value-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propList = _.find(list, (values, propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (_.isEmpty(propList)) {
              return;
            }

            if (matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 258: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkDecls(decl => {
          const indexOffset = declarationValueIndex(decl);
          const declString = decl.toString();
          const valueString = decl.toString().slice(indexOffset);

          if (!valueString.includes('!')) {
            return;
          }

          styleSearch({ source: valueString, target: '!' }, match => {
            check(declString, match.startIndex + indexOffset, decl);
          });
        });

        function check(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message: m,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/declarationValueIndex": 425, "../utils/report": 498, "style-search": 166 }], 259: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const report = require('../utils/report');

      module.exports = function (opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl)) {
            return;
          }

          // Get the raw prop, and only the prop
          const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

          // The extra characters tacked onto the end ensure that there is a character to check
          // after the colon. Otherwise, with `background:pink` the character after the
          const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

          for (let i = 0, l = propPlusColon.length; i < l; i++) {
            if (propPlusColon[i] !== ':') {
              continue;
            }

            opts.locationChecker({
              source: propPlusColon,
              index: i,
              lineCheckStr: decl.value,
              err: m => {
                if (opts.fix && opts.fix(decl, i)) {
                  return;
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.prop.toString().length + 1,
                  result: opts.result,
                  ruleName: opts.checkedRuleName });

              } });

            break;
          }
        });
      };

    }, { "../utils/declarationValueIndex": 425, "../utils/isStandardSyntaxDeclaration": 473, "../utils/report": 498 }], 260: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const rangeOperators = ['>=', '<=', '>', '<', '='];
      const styleSearch = require('style-search');

      module.exports = function (atRule, cb) {
        if (atRule.name.toLowerCase() !== 'media') {
          return;
        }

        const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

        styleSearch({ source: params, target: rangeOperators }, match => {
          const before = params[match.startIndex - 1];

          if (before === '>' || before === '<') {
            return;
          }

          cb(match, params, atRule);
        });
      };

    }, { "style-search": 166 }], 261: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const findFontFamily = require('../../utils/findFontFamily');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'font-family-name-quotes';

      const messages = ruleMessages(ruleName, {
        expected: family => `Expected quotes around "${family}"`,
        rejected: family => `Unexpected quotes around "${family}"` });


      function isSystemFontKeyword(font) {
        if (font.startsWith('-apple-')) {
          return true;
        }

        if (font === 'BlinkMacSystemFont') {
          return true;
        }

        return false;
      }

      // "To avoid mistakes in escaping, it is recommended to quote font family names
      // that contain white space, digits, or punctuation characters other than hyphens"
      // (https://www.w3.org/TR/CSS2/fonts.html#font-family-prop)
      function quotesRecommended(family) {
        return !/^[-a-zA-Z]+$/.test(family);
      }

      // Quotes are required if the family is not a valid CSS identifier
      // (regexes from https://mathiasbynens.be/notes/unquoted-font-family)
      function quotesRequired(family) {
        return family.split(/\s+/).some(word => {
          return /^(-?\d|--)/.test(word) || !/^[-_a-zA-Z0-9\u{00A0}-\u{10FFFF}]+$/u.test(word);
        });
      }

      function rule(expectation) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always-where-required', 'always-where-recommended', 'always-unless-keyword'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            fontFamilies.forEach(fontFamilyNode => {
              let rawFamily = fontFamilyNode.value;

              if (fontFamilyNode.quote) {
                rawFamily = fontFamilyNode.quote + rawFamily + fontFamilyNode.quote;
              }

              checkFamilyName(rawFamily, decl);
            });
          });

          function checkFamilyName(rawFamily, decl) {
            if (!isStandardSyntaxValue(rawFamily)) {
              return;
            }

            if (isVariable(rawFamily)) {
              return;
            }

            const hasQuotes = rawFamily.startsWith("'") || rawFamily.startsWith('"');

            // Clean the family of its quotes
            const family = rawFamily.replace(/^['"]|['"]$/g, '');

            // Disallow quotes around (case-insensitive) keywords
            // and system font keywords in all cases
            if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
              if (hasQuotes) {
                return complain(messages.rejected(family), family, decl);
              }

              return;
            }

            const required = quotesRequired(family);
            const recommended = quotesRecommended(family);

            switch (expectation) {
              case 'always-unless-keyword':
                if (!hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }

                return;

              case 'always-where-recommended':
                if (!recommended && hasQuotes) {
                  return complain(messages.rejected(family), family, decl);
                }

                if (recommended && !hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }

                return;

              case 'always-where-required':
                if (!required && hasQuotes) {
                  return complain(messages.rejected(family), family, decl);
                }

                if (required && !hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }}

          }

          function complain(message, family, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              word: family });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/findFontFamily": 429, "../../utils/isStandardSyntaxValue": 482, "../../utils/isVariable": 485, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 262: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'font-family-no-duplicate-names';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected duplicate name ${name}` });


      const isFamilyNameKeyword = (node) =>
      !node.quote && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreFontFamilyNames: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            const keywords = new Set();
            const familyNames = new Set();

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            fontFamilies.forEach(fontFamilyNode => {
              const family = fontFamilyNode.value.trim();

              if (optionsMatches(options, 'ignoreFontFamilyNames', fontFamilyNode.value.trim())) {
                return;
              }

              if (isFamilyNameKeyword(fontFamilyNode)) {
                if (keywords.has(family.toLowerCase())) {
                  complain(
                  messages.rejected(family),
                  declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                  decl);


                  return;
                }

                keywords.add(family);

                return;
              }

              if (familyNames.has(family)) {
                complain(
                messages.rejected(family),
                declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                decl);


                return;
              }

              familyNames.add(family);
            });
          });

          function complain(message, index, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              index });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/findFontFamily": 429, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 263: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const _ = require('lodash');

      const ruleName = 'font-family-no-missing-generic-family-keyword';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing generic font family' });


      const isFamilyNameKeyword = (node) =>
      !node.quote && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreFontFamilies: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            // Ignore @font-face
            if (
            decl.parent &&
            decl.parent.type === 'atrule' &&
            decl.parent.name.toLowerCase() === 'font-face')
            {
              return;
            }

            if (decl.prop === 'font' && keywordSets.systemFontValues.has(decl.value.toLowerCase())) {
              return;
            }

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            if (fontFamilies.some(isFamilyNameKeyword)) {
              return;
            }

            if (postcss.list.space(decl.value).some(isVariable)) {
              return;
            }

            if (fontFamilies.some(node => optionsMatches(options, 'ignoreFontFamilies', node.value))) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.rejected,
              node: decl,
              index: declarationValueIndex(decl) + fontFamilies[fontFamilies.length - 1].sourceIndex });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/findFontFamily": 429, "../../utils/isVariable": 485, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss": 137 }], 264: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isNumbery = require('../../utils/isNumbery');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'font-weight-notation';

      const messages = ruleMessages(ruleName, {
        expected: type => `Expected ${type} font-weight notation`,
        invalidNamed: name => `Unexpected invalid font-weight name "${name}"` });


      const INHERIT_KEYWORD = 'inherit';
      const INITIAL_KEYWORD = 'initial';
      const NORMAL_KEYWORD = 'normal';
      const WEIGHTS_WITH_KEYWORD_EQUIVALENTS = ['400', '700'];

      function rule(expectation, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['numeric', 'named-where-possible'] },

          {
            actual: options,
            possible: {
              ignore: ['relative'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'font-weight') {
              checkWeight(decl.value, decl);
            }

            if (decl.prop.toLowerCase() === 'font') {
              checkFont(decl);
            }
          });

          function checkFont(decl) {
            const valueList = postcss.list.space(decl.value);
            // We do not need to more carefully distinguish font-weight
            // numbers from unitless line-heights because line-heights in
            // `font` values need to be part of a font-size/line-height pair
            const hasNumericFontWeight = valueList.some(isNumbery);

            for (const value of postcss.list.space(decl.value)) {
              if (
              value.toLowerCase() === NORMAL_KEYWORD && !hasNumericFontWeight ||
              isNumbery(value) ||
              value.toLowerCase() !== NORMAL_KEYWORD &&
              keywordSets.fontWeightKeywords.has(value.toLowerCase()))
              {
                checkWeight(value, decl);

                return;
              }
            }
          }

          function checkWeight(weightValue, decl) {
            if (!isStandardSyntaxValue(weightValue)) {
              return;
            }

            if (isVariable(weightValue)) {
              return;
            }

            if (
            weightValue.toLowerCase() === INHERIT_KEYWORD ||
            weightValue.toLowerCase() === INITIAL_KEYWORD)
            {
              return;
            }

            if (
            optionsMatches(options, 'ignore', 'relative') &&
            keywordSets.fontWeightRelativeKeywords.has(weightValue.toLowerCase()))
            {
              return;
            }

            const weightValueOffset = decl.value.indexOf(weightValue);

            if (expectation === 'numeric') {
              if (decl.parent.type === 'atrule' && decl.parent.name.toLowerCase() === 'font-face') {
                const weightValueNumbers = postcss.list.space(weightValue);

                if (!weightValueNumbers.every(isNumbery)) {
                  return complain(messages.expected('numeric'));
                }

                return;
              }

              if (!isNumbery(weightValue)) {
                return complain(messages.expected('numeric'));
              }
            }

            if (expectation === 'named-where-possible') {
              if (isNumbery(weightValue)) {
                if (WEIGHTS_WITH_KEYWORD_EQUIVALENTS.includes(weightValue)) {
                  complain(messages.expected('named'));
                }

                return;
              }

              if (
              !keywordSets.fontWeightKeywords.has(weightValue.toLowerCase()) &&
              weightValue.toLowerCase() !== NORMAL_KEYWORD)
              {
                return complain(messages.invalidNamed(weightValue));
              }
            }

            function complain(message) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + weightValueOffset });

            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/isNumbery": 465, "../../utils/isStandardSyntaxValue": 482, "../../utils/isVariable": 485, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss": 137 }], 265: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (matchesStringOrRegExp(vendor.unprefixed(node.value), list)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 266: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'function-disallowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (!matchesStringOrRegExp(vendor.unprefixed(node.value), list)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 267: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxMathFunction = require('../../utils/isStandardSyntaxMathFunction');
      const parseCalcExpression = require('../../utils/parseCalcExpression');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-calc-no-invalid';

      const messages = ruleMessages(ruleName, {
        expectedExpression: () => 'Expected a valid expression',
        expectedSpaceBeforeOperator: operator => `Expected space before "${operator}" operator`,
        expectedSpaceAfterOperator: operator => `Expected space after "${operator}" operator`,
        rejectedDivisionByZero: () => 'Unexpected division by zero',
        expectedValidResolvedType: (operator) =>
        `Expected to be compatible with the left and right argument types of "${operator}" operation.` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const checked = [];

            valueParser(decl.value).walk(node => {
              if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {
                return;
              }

              const mathFunction = valueParser.stringify(node);

              if (!isStandardSyntaxMathFunction(mathFunction)) {
                return;
              }

              if (checked.includes(node)) {
                return;
              }

              checked.push(...getCalcNodes(node));

              checked.push(...node.nodes);

              let ast;

              try {
                ast = parseCalcExpression(mathFunction);
              } catch (e) {
                if (e.hash && e.hash.loc) {
                  complain(messages.expectedExpression(), node.sourceIndex + e.hash.loc.range[0]);

                  return;
                }

                throw e;
              }

              verifyMathExpressions(ast, node);
            });

            function complain(message, valueIndex) {
              report({
                message,
                node: decl,
                index: declarationValueIndex(decl) + valueIndex,
                result,
                ruleName });

            }

            /**
             * Verify that each operation expression is valid.
             * Reports when a invalid operation expression is found.
             * @param {object} expression expression node.
             * @param {object} node calc function node.
             * @returns {void}
             */
            function verifyMathExpressions(expression, node) {
              if (expression.type === 'MathExpression') {
                const { operator, left, right } = expression;

                if (operator === '+' || operator === '-') {
                  if (expression.source.operator.end.index === right.source.start.index) {
                    complain(
                    messages.expectedSpaceAfterOperator(operator),
                    node.sourceIndex + expression.source.operator.end.index);

                  }

                  if (expression.source.operator.start.index === left.source.end.index) {
                    complain(
                    messages.expectedSpaceBeforeOperator(operator),
                    node.sourceIndex + expression.source.operator.start.index);

                  }
                } else if (operator === '/') {
                  if (
                  right.type === 'Value' && right.value === 0 ||
                  right.type === 'MathExpression' && getNumber(right) === 0)
                  {
                    complain(
                    messages.rejectedDivisionByZero(),
                    node.sourceIndex + expression.source.operator.end.index);

                  }
                }

                if (getResolvedType(expression) === 'invalid') {
                  complain(
                  messages.expectedValidResolvedType(operator),
                  node.sourceIndex + expression.source.operator.start.index);

                }

                verifyMathExpressions(expression.left, node);
                verifyMathExpressions(expression.right, node);
              }
            }
          });
        };
      }

      function getCalcNodes(node) {
        if (node.type !== 'function') {
          return [];
        }

        const functionName = node.value.toLowerCase();
        const result = [];

        if (functionName === 'calc') {
          result.push(node);
        }

        if (!functionName || functionName === 'calc') {
          // find nested calc
          for (const c of node.nodes) {
            result.push(...getCalcNodes(c));
          }
        }

        return result;
      }

      function getNumber(mathExpression) {
        const { left, right } = mathExpression;

        const leftValue =
        left.type === 'Value' ? left.value : left.type === 'MathExpression' ? getNumber(left) : null;
        const rightValue =
        right.type === 'Value' ?
        right.value :
        right.type === 'MathExpression' ?
        getNumber(right) :
        null;

        if (leftValue == null || rightValue == null) {
          return null;
        }

        switch (mathExpression.operator) {
          case '+':
            return leftValue + rightValue;
          case '-':
            return leftValue - rightValue;
          case '*':
            return leftValue * rightValue;
          case '/':
            return leftValue / rightValue;}


        return null;
      }

      function getResolvedType(mathExpression) {
        const { left: leftExpression, operator, right: rightExpression } = mathExpression;
        let left =
        leftExpression.type === 'MathExpression' ?
        getResolvedType(leftExpression) :
        leftExpression.type;
        let right =
        rightExpression.type === 'MathExpression' ?
        getResolvedType(rightExpression) :
        rightExpression.type;

        if (left === 'Function' || left === 'invalid') {
          left = 'UnknownValue';
        }

        if (right === 'Function' || right === 'invalid') {
          right = 'UnknownValue';
        }

        switch (operator) {
          case '+':
          case '-':
            if (left === 'UnknownValue' || right === 'UnknownValue') {
              return 'UnknownValue';
            }

            if (left === right) {
              return left;
            }

            if (left === 'Value' || right === 'Value') {
              return 'invalid';
            }

            if (left === 'PercentageValue') {
              return right;
            }

            if (right === 'PercentageValue') {
              return left;
            }

            return 'invalid';
          case '*':
            if (left === 'UnknownValue' || right === 'UnknownValue') {
              return 'UnknownValue';
            }

            if (left === 'Value') {
              return right;
            }

            if (right === 'Value') {
              return left;
            }

            return 'invalid';
          case '/':
            if (right === 'UnknownValue') {
              return 'UnknownValue';
            }

            if (right === 'Value') {
              return left;
            }

            return 'invalid';}


        return 'UnknownValue';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxMathFunction": 475, "../../utils/parseCalcExpression": 491, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 268: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const balancedMatch = require('balanced-match');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-calc-no-unspaced-operator';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}" operator`,
        expectedAfter: operator => `Expected single space after "${operator}" operator`,
        expectedOperatorBeforeSign: operator => `Expected an operator before sign "${operator}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          function complain(message, node, index) {
            report({ message, node, index, result, ruleName });
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(node => {
              if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') {
                return;
              }

              const nodeText = valueParser.stringify(node);
              const parensMatch = balancedMatch('(', ')', nodeText);

              if (!parensMatch) {
                throw new Error(`No parens match: "${nodeText}"`);
              }

              const rawExpression = parensMatch.body;
              const expressionIndex =
              decl.source.start.column +
              decl.prop.length +
              (decl.raws.between || '').length +
              node.sourceIndex;
              const expression = blurVariables(rawExpression);

              checkSymbol('+');
              checkSymbol('-');
              checkSymbol('*');
              checkSymbol('/');

              function checkSymbol(symbol) {
                const styleSearchOptions = {
                  source: expression,
                  target: symbol,
                  functionArguments: 'skip' };


                styleSearch(styleSearchOptions, match => {
                  const index = match.startIndex;

                  // Deal with signs.
                  // (@ and $ are considered "digits" here to allow for variable syntaxes
                  // that permit signs in front of variables, e.g. `-$number`)
                  // As is "." to deal with fractional numbers without a leading zero
                  if ((symbol === '+' || symbol === '-') && /[\d@$.]/.test(expression[index + 1])) {
                    const expressionBeforeSign = expression.substr(0, index);

                    // Ignore signs that directly follow a opening bracket
                    if (expressionBeforeSign[expressionBeforeSign.length - 1] === '(') {
                      return;
                    }

                    // Ignore signs at the beginning of the expression
                    if (/^\s*$/.test(expressionBeforeSign)) {
                      return;
                    }

                    // Otherwise, ensure that there is a real operator preceding them
                    if (/[*/+-]\s*$/.test(expressionBeforeSign)) {
                      return;
                    }

                    // And if not, complain
                    complain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index);

                    return;
                  }

                  const beforeOk =
                  expression[index - 1] === ' ' && !isWhitespace(expression[index - 2]) ||
                  newlineBefore(expression, index - 1);

                  if (!beforeOk) {
                    complain(messages.expectedBefore(symbol), decl, expressionIndex + index);
                  }

                  const afterOk =
                  expression[index + 1] === ' ' && !isWhitespace(expression[index + 2]) ||
                  expression[index + 1] === '\n' ||
                  expression.substr(index + 1, 2) === '\r\n';

                  if (!afterOk) {
                    complain(messages.expectedAfter(symbol), decl, expressionIndex + index);
                  }
                });
              }
            });
          });
        };
      }

      function blurVariables(source) {
        return source.replace(/[$@][^)\s]+|#{.+?}/g, '0');
      }

      function newlineBefore(str, startIndex) {
        let index = startIndex;

        while (index && isWhitespace(str[index])) {
          if (str[index] === '\n') return true;

          index--;
        }

        return false;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isWhitespace": 486, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "balanced-match": 1, "postcss-value-parser": 120, "style-search": 166 }], 269: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line function',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line function' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) => {
              return fixer({
                div,
                index,
                nodes,
                expectation,
                position: 'after',
                symb: context.newline });

            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../functionCommaSpaceChecker": 287, "../functionCommaSpaceFix": 288 }], 270: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line function',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line function' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) => {
              return fixer({
                div,
                index,
                nodes,
                expectation,
                position: 'before',
                symb: context.newline });

            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../functionCommaSpaceChecker": 287, "../functionCommaSpaceFix": 288 }], 271: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line function',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line function' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) => {
              return fixer({
                div,
                index,
                nodes,
                expectation,
                position: 'after',
                symb: ' ' });

            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../functionCommaSpaceChecker": 287, "../functionCommaSpaceFix": 288 }], 272: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line function',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line function' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) => {
              return fixer({
                div,
                index,
                nodes,
                expectation,
                position: 'before',
                symb: ' ' });

            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../functionCommaSpaceChecker": 287, "../functionCommaSpaceFix": 288 }], 273: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (!matchesStringOrRegExp(vendor.unprefixed(node.value), list)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 274: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-linear-gradient-no-nonstandard-direction';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected nonstandard direction' });


      function isStandardDirection(source, withToPrefix) {
        const regexp = withToPrefix ?
        /^to (top|left|bottom|right)(?: (top|left|bottom|right))?$/ :
        /^(top|left|bottom|right)(?: (top|left|bottom|right))?$/;

        const matches = source.match(regexp);

        if (!matches) {
          return false;
        }

        if (matches.length === 2) {
          return true;
        }

        // Cannot repeat side-or-corner, e.g. "to top top"
        if (matches.length === 3 && matches[1] !== matches[2]) {
          return true;
        }

        return false;
      }

      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              functionArgumentsSearch(
              valueParser.stringify(valueNode).toLowerCase(),
              'linear-gradient',
              (expression, expressionIndex) => {
                const firstArg = expression.split(',')[0].trim();

                // If the first arg is not standard, return early
                if (!isStandardSyntaxValue(firstArg)) {
                  return;
                }

                // If the first character is a number, we can assume the user intends an angle
                if (/[\d.]/.test(firstArg[0])) {
                  if (/^[\d.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {
                    return;
                  }

                  complain();

                  return;
                }

                // The first argument may not be a direction: it may be an angle,
                // or a color stop (in which case user gets default direction, "to bottom")
                // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax
                if (!/left|right|top|bottom/.test(firstArg)) {
                  return;
                }

                const withToPrefix = !vendor.prefix(valueNode.value);

                if (!isStandardDirection(firstArg, withToPrefix)) {
                  complain();
                }

                function complain() {
                  report({
                    message: messages.rejected,
                    node: decl,
                    index: declarationValueIndex(decl) + valueNode.sourceIndex + expressionIndex,
                    result,
                    ruleName });

                }
              });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/functionArgumentsSearch": 430, "../../utils/isStandardSyntaxValue": 482, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "postcss-value-parser": 120 }], 275: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function placeIndexOnValueStart(decl) {
        return decl.prop.length + decl.raws.between.length - 1;
      }

      function rule(max, options, context) {
        const maxAdjacentNewlines = max + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: _.isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            const stringValue = decl.raws.value ? decl.raws.value.raw : decl.value;
            const splittedValue = [];
            let sourceIndexStart = 0;

            valueParser(stringValue).walk(node => {
              if (
              node.type !== 'function' /* ignore non functions */ ||
              node.value.length === 0 /* ignore sass lists */)
                {
                  return;
                }

              const stringifiedNode = valueParser.stringify(node);

              if (
              !violatedLFNewLinesRegex.test(stringifiedNode) &&
              !violatedCRLFNewLinesRegex.test(stringifiedNode))
              {
                return;
              }

              if (context.fix) {
                const newNodeString = stringifiedNode.
                replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
                replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

                splittedValue.push([
                stringValue.slice(sourceIndexStart, node.sourceIndex),
                newNodeString]);

                sourceIndexStart = node.sourceIndex + stringifiedNode.length;
              } else {
                report({
                  message: messages.expected(max),
                  node: decl,
                  index: placeIndexOnValueStart(decl) + node.sourceIndex,
                  result,
                  ruleName });

              }
            });

            if (context.fix && splittedValue.length > 0) {
              const updatedValue =
              splittedValue.reduce((acc, curr) => acc + curr[0] + curr[1], '') +
              stringValue.slice(sourceIndexStart);

              if (decl.raws.value) {
                decl.raws.value.raw = updatedValue;
              } else {
                decl.value = updatedValue;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 276: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const keywordSets = require('../../reference/keywordSets');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const mapLowercaseFunctionNamesToCamelCase = new Map();

      keywordSets.camelCaseFunctionNames.forEach(func => {
        mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);
      });

      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['lower', 'upper'] },

          {
            actual: options,
            possible: {
              ignoreFunctions: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            let needFix = false;
            const parsed = valueParser(decl.raws.value ? decl.raws.value.raw : decl.value);

            parsed.walk(node => {
              if (node.type !== 'function' || !isStandardSyntaxFunction(node)) {
                return;
              }

              const functionName = node.value;
              const functionNameLowerCase = functionName.toLowerCase();

              const ignoreFunctions = options && options.ignoreFunctions || [];

              if (ignoreFunctions.length > 0 && matchesStringOrRegExp(functionName, ignoreFunctions)) {
                return;
              }

              let expectedFunctionName = null;

              if (
              expectation === 'lower' &&
              mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase))
              {
                expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);
              } else if (expectation === 'lower') {
                expectedFunctionName = functionNameLowerCase;
              } else {
                expectedFunctionName = functionName.toUpperCase();
              }

              if (functionName === expectedFunctionName) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedFunctionName;

                return;
              }

              report({
                message: messages.expected(functionName, expectedFunctionName),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              const statement = parsed.toString();

              if (decl.raws.value) {
                decl.raws.value.raw = statement;
              } else {
                decl.value = statement;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 277: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-newline-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected newline after "("',
        expectedClosing: 'Expected newline before ")"',
        expectedOpeningMultiLine: 'Expected newline after "(" in a multi-line function',
        rejectedOpeningMultiLine: 'Unexpected whitespace after "(" in a multi-line function',
        expectedClosingMultiLine: 'Expected newline before ")" in a multi-line function',
        rejectedClosingMultiLine: 'Unexpected whitespace before ")" in a multi-line function' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = _.get(decl, 'raws.value.raw', decl.value);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isMultiLine = !isSingleLineString(functionString);

              function containsNewline(str) {
                return str.includes('\n');
              }

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;
              const checkBefore = getCheckBefore(valueNode);

              if (expectation === 'always' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline);
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline);
                } else {
                  complain(messages.expectedOpeningMultiLine, openingIndex);
                }
              }

              if (isMultiLine && expectation === 'never-multi-line' && checkBefore !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForNever(valueNode);
                } else {
                  complain(messages.rejectedOpeningMultiLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;
              const checkAfter = getCheckAfter(valueNode);

              if (expectation === 'always' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline);
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (isMultiLine && expectation === 'always-multi-line' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline);
                } else {
                  complain(messages.expectedClosingMultiLine, closingIndex);
                }
              }

              if (isMultiLine && expectation === 'never-multi-line' && checkAfter !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForNever(valueNode);
                } else {
                  complain(messages.rejectedClosingMultiLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              if (!decl.raws.value) {
                decl.value = parsedValue.toString();
              } else {
                decl.raws.value.raw = parsedValue.toString();
              }
            }

            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      }

      function getCheckBefore(valueNode) {
        let before = valueNode.before;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            before += node.value;
            continue;
          }

          break;
        }

        return before;
      }

      function getCheckAfter(valueNode) {
        let after = '';

        for (const node of valueNode.nodes.slice().reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            after = node.value + after;
            continue;
          }

          break;
        }

        after += valueNode.after;

        return after;
      }

      function fixBeforeForAlways(valueNode, newline) {
        let target;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            target = node;
            continue;
          }

          break;
        }

        if (target) {
          target.value = newline + target.value;
        } else {
          valueNode.before = newline + valueNode.before;
        }
      }

      function fixBeforeForNever(valueNode) {
        valueNode.before = '';

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      function fixAfterForAlways(valueNode, newline) {
        valueNode.after = newline + valueNode.after;
      }

      function fixAfterForNever(valueNode) {
        valueNode.after = '';

        for (const node of valueNode.nodes.slice().reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isSingleLineString": 470, "../../utils/isStandardSyntaxFunction": 474, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 278: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"',
        expectedOpeningSingleLine: 'Expected single space after "(" in a single-line function',
        rejectedOpeningSingleLine: 'Unexpected whitespace after "(" in a single-line function',
        expectedClosingSingleLine: 'Expected single space before ")" in a single-line function',
        rejectedClosingSingleLine: 'Unexpected whitespace before ")" in a single-line function' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = _.get(decl, 'raws.value.raw', decl.value);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              // Ignore function without parameters
              if (!valueNode.nodes.length) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isSingleLine = isSingleLineString(functionString);

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;

              if (expectation === 'always' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (expectation === 'never' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpening, openingIndex);
                }
              }

              if (isSingleLine && expectation === 'always-single-line' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpeningSingleLine, openingIndex);
                }
              }

              if (isSingleLine && expectation === 'never-single-line' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpeningSingleLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;

              if (expectation === 'always' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (expectation === 'never' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosing, closingIndex);
                }
              }

              if (isSingleLine && expectation === 'always-single-line' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosingSingleLine, closingIndex);
                }
              }

              if (isSingleLine && expectation === 'never-single-line' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosingSingleLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              if (!decl.raws.value) {
                decl.value = parsedValue.toString();
              } else {
                decl.raws.value.raw = parsedValue.toString();
              }
            }

            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isSingleLineString": 470, "../../utils/isStandardSyntaxFunction": 474, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 279: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-no-scheme-relative';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected scheme-relative url' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const url = _.trim(args, ' \'"');

              if (!isStandardSyntaxUrl(url) || !url.startsWith('//')) {
                return;
              }

              report({
                message: messages.rejected,
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 430, "../../utils/isStandardSyntaxUrl": 481, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 280: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-quotes';

      const messages = ruleMessages(ruleName, {
        expected: () => 'Expected quotes',
        rejected: () => 'Unexpected quotes' });


      function rule(expectation, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never'] },

          {
            actual: options,
            possible: {
              except: ['empty'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(checkAtRuleParams);
          root.walkDecls(checkDeclParams);

          function checkDeclParams(decl) {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              checkArgs(args, decl, index, 'url');
            });
          }

          function checkAtRuleParams(atRule) {
            const atRuleParamsLowerCase = atRule.params.toLowerCase();

            functionArgumentsSearch(atRuleParamsLowerCase, 'url', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'url-prefix', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url-prefix');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'domain', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'domain');
            });
          }

          function checkArgs(args, node, index, functionName) {
            let shouldHasQuotes = expectation === 'always';

            const leftTrimmedArgs = args.trimStart();

            if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
              return;
            }

            const complaintIndex = index + args.length - leftTrimmedArgs.length;
            const hasQuotes = leftTrimmedArgs.startsWith("'") || leftTrimmedArgs.startsWith('"');

            const trimmedArg = args.trim();
            const isEmptyArgument = ['', "''", '""'].includes(trimmedArg);

            if (optionsMatches(options, 'except', 'empty') && isEmptyArgument) {
              shouldHasQuotes = !shouldHasQuotes;
            }

            if (shouldHasQuotes) {
              if (hasQuotes) {
                return;
              }

              complain(messages.expected(functionName), node, complaintIndex);
            } else {
              if (!hasQuotes) {
                return;
              }

              complain(messages.rejected(functionName), node, complaintIndex);
            }
          }

          function complain(message, node, index) {
            report({
              message,
              node,
              index,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/functionArgumentsSearch": 430, "../../utils/isStandardSyntaxUrl": 481, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 281: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-scheme-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = _.trim(args, ' ');

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = _.trim(unspacedUrlString, '\'"');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (matchesStringOrRegExp(scheme, list)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 430, "../../utils/getSchemeFromUrl": 435, "../../utils/isStandardSyntaxUrl": 481, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 282: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-scheme-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'function-url-scheme-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = _.trim(args, ' ');

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = _.trim(unspacedUrlString, '\'"');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (!matchesStringOrRegExp(scheme, list)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 430, "../../utils/getSchemeFromUrl": 435, "../../utils/isStandardSyntaxUrl": 481, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 283: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-scheme-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = _.trim(args, ' ');

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = _.trim(unspacedUrlString, '\'"');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (!matchesStringOrRegExp(scheme, list)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 430, "../../utils/getSchemeFromUrl": 435, "../../utils/isStandardSyntaxUrl": 481, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 284: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-scheme-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'function-url-scheme-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = _.trim(args, ' ');

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = _.trim(unspacedUrlString, '\'"');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (matchesStringOrRegExp(scheme, list)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 430, "../../utils/getSchemeFromUrl": 435, "../../utils/isStandardSyntaxUrl": 481, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 285: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'function-allowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (matchesStringOrRegExp(vendor.unprefixed(node.value), list)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxFunction": 474, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-value-parser": 120 }], 286: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-whitespace-after';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected whitespace after ")"',
        rejected: 'Unexpected whitespace after ")"' });


      const ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);

      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex, fix) {
            styleSearch(
            {
              source: value,
              target: ')',
              functionArguments: 'only' },

            match => {
              checkClosingParen(value, match.startIndex + 1, node, getIndex, fix);
            });

          }

          function checkClosingParen(source, index, node, getIndex, fix) {
            const nextChar = source[index];

            if (expectation === 'always') {
              // Allow for the next character to be a single empty space,
              // another closing parenthesis, a comma, or the end of the value
              if (nextChar === ' ') {
                return;
              }

              if (nextChar === '\n') {
                return;
              }

              if (source.substr(index, 2) === '\r\n') {
                return;
              }

              if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
                return;
              }

              if (fix) {
                fix(index);

                return;
              }

              report({
                message: messages.expected,
                node,
                index: getIndex(node) + index,
                result,
                ruleName });

            } else if (expectation === 'never') {
              if (isWhitespace(nextChar)) {
                if (fix) {
                  fix(index);

                  return;
                }

                report({
                  message: messages.rejected,
                  node,
                  index: getIndex(node) + index,
                  result,
                  ruleName });

              }
            }
          }

          function createFixer(value) {
            let fixed = '';
            let lastIndex = 0;
            let applyFix;

            if (expectation === 'always') {
              applyFix = index => {
                // eslint-disable-next-line prefer-template
                fixed += value.slice(lastIndex, index) + ' ';
                lastIndex = index;
              };
            } else if (expectation === 'never') {
              applyFix = index => {
                let whitespaceEndIndex = index + 1;

                while (whitespaceEndIndex < value.length && isWhitespace(value[whitespaceEndIndex])) {
                  whitespaceEndIndex++;
                }
                fixed += value.slice(lastIndex, index);
                lastIndex = whitespaceEndIndex;
              };
            }

            return {
              applyFix,
              get hasFixed() {
                return Boolean(lastIndex);
              },
              get fixed() {
                return fixed + value.slice(lastIndex);
              } };

          }

          root.walkAtRules(/^import$/i, atRule => {
            const param = _.get(atRule, 'raws.params.raw', atRule.params);
            const fixer = context.fix && createFixer(param);

            check(atRule, param, atRuleParamIndex, fixer && fixer.applyFix);

            if (fixer && fixer.hasFixed) {
              if (atRule.raws.params) {
                atRule.raws.params.raw = fixer.fixed;
              } else {
                atRule.params = fixer.fixed;
              }
            }
          });
          root.walkDecls(decl => {
            const value = _.get(decl, 'raws.value.raw', decl.value);
            const fixer = context.fix && createFixer(value);

            check(decl, value, declarationValueIndex, fixer && fixer.applyFix);

            if (fixer && fixer.hasFixed) {
              if (decl.raws.value) {
                decl.raws.value.raw = fixer.fixed;
              } else {
                decl.value = fixer.fixed;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/isWhitespace": 486, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "style-search": 166 }], 287: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../utils/isStandardSyntaxFunction');
      const report = require('../utils/report');
      const valueParser = require('postcss-value-parser');

      module.exports = function (opts) {
        opts.root.walkDecls(decl => {
          const declValue = _.get(decl, 'raws.value.raw', decl.value);

          let hasFixed;
          const parsedValue = valueParser(declValue);

          parsedValue.walk(valueNode => {
            if (valueNode.type !== 'function') {
              return;
            }

            if (!isStandardSyntaxFunction(valueNode)) {
              return;
            }

            // Ignore `url()` arguments, which may contain data URIs or other funky stuff
            if (valueNode.value.toLowerCase() === 'url') {
              return;
            }

            const argumentStrings = valueNode.nodes.map(node => valueParser.stringify(node));

            const functionArguments = (() => {
              // Remove function name and parens
              let result = valueNode.before + argumentStrings.join('') + valueNode.after;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              result = result.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return result;
            })();

            /**
             * Gets the index of the comma for checking.
             * @param {Node} commaNode The comma node
             * @param {number} nodeIndex The index of the comma node
             * @returns {number} The index of the comma for checking
             */
            function getCommaCheckIndex(commaNode, nodeIndex) {
              let commaBefore =
              valueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              commaBefore = commaBefore.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return commaBefore.length;
            }

            const commaDataList = [];

            valueNode.nodes.forEach((node, nodeIndex) => {
              if (node.type !== 'div' || node.value !== ',') {
                return;
              }

              const checkIndex = getCommaCheckIndex(node, nodeIndex);

              commaDataList.push({
                commaNode: node,
                checkIndex,
                nodeIndex });

            });

            for (const { commaNode, checkIndex, nodeIndex } of commaDataList) {
              opts.locationChecker({
                source: functionArguments,
                index: checkIndex,
                err: message => {
                  const index =
                  declarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;

                  if (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {
                    hasFixed = true;

                    return;
                  }

                  report({
                    index,
                    message,
                    node: decl,
                    result: opts.result,
                    ruleName: opts.checkedRuleName });

                } });

            }
          });

          if (hasFixed) {
            if (!decl.raws.value) {
              decl.value = parsedValue.toString();
            } else {
              decl.raws.value.raw = parsedValue.toString();
            }
          }
        });
      };

    }, { "../utils/declarationValueIndex": 425, "../utils/isStandardSyntaxFunction": 474, "../utils/report": 498, "lodash": 68, "postcss-value-parser": 120 }], 288: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      module.exports = function (params) {
        const { div, index, nodes, expectation, position, symb } = params;

        if (expectation.startsWith('always')) {
          div[position] = symb;

          return true;
        }

        if (expectation.startsWith('never')) {
          div[position] = '';

          for (let i = index + 1; i < nodes.length; i++) {
            const node = nodes[i];

            if (node.type === 'comment') {
              continue;
            }

            if (node.type === 'space') {
              node.value = '';
              continue;
            }

            break;
          }

          return true;
        }
      };

    }, {}], 289: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'hue-degree-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];
      const HUE_THIRD_ARG_FUNCS = ['lch'];
      const HUE_FUNCS = [...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS];

      function rule(primary, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['angle', 'number'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getValue(decl));

            parsedValue.walk(node => {
              if (node.type !== 'function') return;

              if (!HUE_FUNCS.includes(node.value.toLowerCase())) return;

              const hue = findHue(node);

              if (!hue) return;

              const { value } = hue;

              if (!isStandardSyntaxValue(value)) return;

              if (!isDegree(value) && !isNumber(value)) return;

              if (primary === 'angle' && isDegree(value)) return;

              if (primary === 'number' && isNumber(value)) return;

              const fixed = primary === 'angle' ? asDegree(value) : asNumber(value);
              const unfixed = value;

              if (context.fix) {
                hue.value = fixed;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index: declarationValueIndex(decl) + hue.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setValue(decl, parsedValue.toString());
            }
          });
        };
      }

      function asDegree(value) {
        return `${value}deg`;
      }

      function asNumber(value) {
        const { number } = valueParser.unit(value);

        return number;
      }

      function findHue(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');
        const value = node.value.toLowerCase();

        if (HUE_FIRST_ARG_FUNCS.includes(value)) {
          return args[0];
        }

        if (HUE_THIRD_ARG_FUNCS.includes(value)) {
          return args[2];
        }

        return false;
      }

      function isDegree(value) {
        const { unit } = valueParser.unit(value);

        return unit && unit.toLowerCase() === 'deg';
      }

      function isNumber(value) {
        const { unit } = valueParser.unit(value);

        return unit === '';
      }

      function getValue(decl) {
        return decl.raws.value ? decl.raws.value.raw : decl.value;
      }

      function setValue(decl, value) {
        if (decl.raws.value) decl.raws.value.raw = value;else
        decl.value = value;

        return decl;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxValue": 482, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 290: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'indentation';
      const messages = ruleMessages(ruleName, {
        expected: x => `Expected indentation of ${x}` });


      /**
       * @param {number|"tab"} space - Number of whitespaces to expect, or else
       *   keyword "tab" for single `\t`
       * @param {object} [options]
       */
      function rule(space, options = {}, context) {
        const isTab = space === 'tab';
        const indentChar = isTab ? '\t' : ' '.repeat(space);
        const warningWord = isTab ? 'tab' : 'space';

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: space,
            possible: [_.isNumber, 'tab'] },

          {
            actual: options,
            possible: {
              baseIndentLevel: [_.isNumber, 'auto'],
              except: ['block', 'value', 'param'],
              ignore: ['value', 'param', 'inside-parens'],
              indentInsideParens: ['twice', 'once-at-root-twice-in-block'],
              indentClosingBrace: [_.isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Cycle through all nodes using walk.
          root.walk(node => {
            if (node.type === 'root') {
              // Ignore nested template literals root in css-in-js lang
              return;
            }

            const nodeLevel = indentationLevel(node);

            // Cut out any * and _ hacks from `before`
            const before = (node.raws.before || '').replace(/[*_]$/, '');
            const after = node.raws.after || '';
            const parent = node.parent;

            const expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel);

            // Only inspect the spaces before the node
            // if this is the first node in root
            // or there is a newline in the `before` string.
            // (If there is no newline before a node,
            // there is no "indentation" to check.)
            const isFirstChild = parent.type === 'root' && parent.first === node;
            const lastIndexOfNewline = before.lastIndexOf('\n');

            // Inspect whitespace in the `before` string that is
            // *after* the *last* newline character,
            // because anything besides that is not indentation for this node:
            // it is some other kind of separation, checked by some separate rule
            if (
            (lastIndexOfNewline !== -1 ||
            isFirstChild && (!getDocument(parent) || parent.raws.beforeStart.endsWith('\n'))) &&
            before.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation)
            {
              if (context.fix) {
                if (isFirstChild && _.isString(node.raws.before)) {
                  node.raws.before = node.raws.before.replace(
                  /^[ \t]*(?=\S|$)/,
                  expectedOpeningBraceIndentation);

                }

                node.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(nodeLevel)),
                  node,
                  result,
                  ruleName });

              }
            }

            // Only blocks have the `after` string to check.
            // Only inspect `after` strings that start with a newline;
            // otherwise there's no indentation involved.
            // And check `indentClosingBrace` to see if it should be indented an extra level.
            const closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel;
            const expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);

            if (
            hasBlock(node) &&
            after &&
            after.includes('\n') &&
            after.slice(after.lastIndexOf('\n') + 1) !== expectedClosingBraceIndentation)
            {
              if (context.fix) {
                node.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(closingBraceLevel)),
                  node,
                  index: node.toString().length - 1,
                  result,
                  ruleName });

              }
            }

            // If this is a declaration, check the value
            if (node.value) {
              checkValue(node, nodeLevel);
            }

            // If this is a rule, check the selector
            if (node.selector) {
              checkSelector(node, nodeLevel);
            }

            // If this is an at rule, check the params
            if (node.type === 'atrule') {
              checkAtRuleParams(node, nodeLevel);
            }
          });

          function indentationLevel(node, level = 0) {
            if (node.parent.type === 'root') {
              return level + getRootBaseIndentLevel(node.parent, options.baseIndentLevel, space);
            }

            let calculatedLevel;

            // Indentation level equals the ancestor nodes
            // separating this node from root; so recursively
            // run this operation
            calculatedLevel = indentationLevel(node.parent, level + 1);

            // If options.except includes "block",
            // blocks are taken down one from their calculated level
            // (all blocks are the same level as their parents)
            if (
            optionsMatches(options, 'except', 'block') && (
            node.type === 'rule' || node.type === 'atrule') &&
            hasBlock(node))
            {
              calculatedLevel--;
            }

            return calculatedLevel;
          }

          function checkValue(decl, declLevel) {
            if (!decl.value.includes('\n')) {
              return;
            }

            if (optionsMatches(options, 'ignore', 'value')) {
              return;
            }

            const declString = decl.toString();
            const valueLevel = optionsMatches(options, 'except', 'value') ? declLevel : declLevel + 1;

            checkMultilineBit(declString, valueLevel, decl);
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkSelector(rule, ruleLevel) {
            const selector = rule.selector;

            // Less mixins have params, and they should be indented extra
            if (rule.params) {
              ruleLevel += 1;
            }

            checkMultilineBit(selector, ruleLevel, rule);
          }

          function checkAtRuleParams(atRule, ruleLevel) {
            if (optionsMatches(options, 'ignore', 'param')) {
              return;
            }

            // @nest and SCSS's @at-root rules should be treated like regular rules, not expected
            // to have their params (selectors) indented
            const paramLevel =
            optionsMatches(options, 'except', 'param') ||
            atRule.name === 'nest' ||
            atRule.name === 'at-root' ?
            ruleLevel :
            ruleLevel + 1;

            checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);
          }

          function checkMultilineBit(source, newlineIndentLevel, node) {
            if (!source.includes('\n')) {
              return;
            }

            // Data for current node fixing
            const fixPositions = [];

            // `outsideParens` because function arguments and also non-standard parenthesized stuff like
            // Sass maps are ignored to allow for arbitrary indentation
            let parentheticalDepth = 0;

            styleSearch(
            {
              source,
              target: '\n',
              outsideParens: optionsMatches(options, 'ignore', 'inside-parens') },

            (match, matchCount) => {
              const precedesClosingParenthesis = /^[ \t]*\)/.test(source.slice(match.startIndex + 1));

              if (
              optionsMatches(options, 'ignore', 'inside-parens') && (
              precedesClosingParenthesis || match.insideParens))
              {
                return;
              }

              let expectedIndentLevel = newlineIndentLevel;

              // Modififications for parenthetical content
              if (!optionsMatches(options, 'ignore', 'inside-parens') && match.insideParens) {
                // If the first match in is within parentheses, reduce the parenthesis penalty
                if (matchCount === 1) parentheticalDepth -= 1;

                // Account for windows line endings
                let newlineIndex = match.startIndex;

                if (source[match.startIndex - 1] === '\r') {
                  newlineIndex--;
                }

                const followsOpeningParenthesis = /\([ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningParenthesis) {
                  parentheticalDepth += 1;
                }

                const followsOpeningBrace = /{[ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningBrace) {
                  parentheticalDepth += 1;
                }

                const startingClosingBrace = /^[ \t]*}/.test(source.slice(match.startIndex + 1));

                if (startingClosingBrace) {
                  parentheticalDepth -= 1;
                }

                expectedIndentLevel += parentheticalDepth;

                // Past this point, adjustments to parentheticalDepth affect next line

                if (precedesClosingParenthesis) {
                  parentheticalDepth -= 1;
                }

                switch (options.indentInsideParens) {
                  case 'twice':
                    if (!precedesClosingParenthesis || options.indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  case 'once-at-root-twice-in-block':
                    if (node.parent === node.root()) {
                      if (precedesClosingParenthesis && !options.indentClosingBrace) {
                        expectedIndentLevel -= 1;
                      }

                      break;
                    }

                    if (!precedesClosingParenthesis || options.indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  default:
                    if (precedesClosingParenthesis && !options.indentClosingBrace) {
                      expectedIndentLevel -= 1;
                    }}

              }

              // Starting at the index after the newline, we want to
              // check that the whitespace characters (excluding newlines) before the first
              // non-whitespace character equal the expected indentation
              const afterNewlineSpaceMatches = /^([ \t]*)\S/.exec(source.slice(match.startIndex + 1));

              if (!afterNewlineSpaceMatches) {
                return;
              }

              const afterNewlineSpace = afterNewlineSpaceMatches[1];
              const expectedIndentation = indentChar.repeat(
              expectedIndentLevel > 0 ? expectedIndentLevel : 0);


              if (afterNewlineSpace !== expectedIndentation) {
                if (context.fix) {
                  // Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string
                  fixPositions.unshift({
                    expectedIndentation,
                    currentIndentation: afterNewlineSpace,
                    startIndex: match.startIndex });

                } else {
                  report({
                    message: messages.expected(legibleExpectation(expectedIndentLevel)),
                    node,
                    index: match.startIndex + afterNewlineSpace.length + 1,
                    result,
                    ruleName });

                }
              }
            });


            if (fixPositions.length) {
              if (node.type === 'rule') {
                fixPositions.forEach(fixPosition => {
                  node.selector = replaceIndentation(
                  node.selector,
                  fixPosition.currentIndentation,
                  fixPosition.expectedIndentation,
                  fixPosition.startIndex);

                });
              }

              if (node.type === 'decl') {
                const declProp = node.prop;
                const declBetween = node.raws.between;

                fixPositions.forEach(fixPosition => {
                  if (fixPosition.startIndex < declProp.length + declBetween.length) {
                    node.raws.between = replaceIndentation(
                    declBetween,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length);

                  } else {
                    node.value = replaceIndentation(
                    node.value,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length - declBetween.length);

                  }
                });
              }

              if (node.type === 'atrule') {
                const atRuleName = node.name;
                const atRuleAfterName = node.raws.afterName;
                const atRuleParams = node.params;

                fixPositions.forEach(fixPosition => {
                  // 1  it's a @ length
                  if (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {
                    node.raws.afterName = replaceIndentation(
                    atRuleAfterName,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - 1);

                  } else {
                    node.params = replaceIndentation(
                    atRuleParams,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1);

                  }
                });
              }
            }
          }
        };

        function legibleExpectation(level) {
          const count = isTab ? level : level * space;
          const quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;

          return `${count} ${quantifiedWarningWord}`;
        }
      }

      function getRootBaseIndentLevel(root, baseIndentLevel, space) {
        const document = getDocument(root);

        if (!document) {
          return 0;
        }

        let indentLevel = root.source.baseIndentLevel;

        if (!Number.isSafeInteger(indentLevel)) {
          indentLevel = inferRootIndentLevel(root, baseIndentLevel, () =>
          inferDocIndentSize(document, space));

          root.source.baseIndentLevel = indentLevel;
        }

        return indentLevel;
      }

      function getDocument(node) {
        const document = node.document;

        if (document) {
          return document;
        }

        const root = node.root();

        return root && root.document;
      }

      function inferDocIndentSize(document, space) {
        let indentSize = document.source.indentSize;

        if (Number.isSafeInteger(indentSize)) {
          return indentSize;
        }

        const source = document.source.input.css;
        const indents = source.match(/^ *(?=\S)/gm);

        if (indents) {
          const scores = {};
          let lastIndentSize = 0;
          let lastLeadingSpacesLength = 0;
          const vote = leadingSpacesLength => {
            if (leadingSpacesLength) {
              lastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;

              if (lastIndentSize > 1) {
                if (scores[lastIndentSize]) {
                  scores[lastIndentSize]++;
                } else {
                  scores[lastIndentSize] = 1;
                }
              }
            } else {
              lastIndentSize = 0;
            }

            lastLeadingSpacesLength = leadingSpacesLength;
          };

          indents.forEach(leadingSpaces => {
            vote(leadingSpaces.length);
          });

          let bestScore = 0;

          for (const indentSizeDate in scores) {
            if (Object.prototype.hasOwnProperty.call(scores, indentSizeDate)) {
              const score = scores[indentSizeDate];

              if (score > bestScore) {
                bestScore = score;
                indentSize = indentSizeDate;
              }
            }
          }
        }

        indentSize = Number(indentSize) || indents && indents[0].length || Number(space) || 2;
        document.source.indentSize = indentSize;

        return indentSize;
      }

      function inferRootIndentLevel(root, baseIndentLevel, indentSize) {
        function getIndentLevel(indent) {
          let tabCount = indent.match(/\t/g);

          tabCount = tabCount ? tabCount.length : 0;
          let spaceCount = indent.match(/ /g);

          spaceCount = spaceCount ? Math.round(spaceCount.length / indentSize()) : 0;

          return tabCount + spaceCount;
        }

        if (!Number.isSafeInteger(baseIndentLevel)) {
          let source = root.source.input.css;

          source = source.replace(/^[^\r\n]+/, firstLine => {
            if (/(?:^|\n)([ \t]*)$/.test(root.raws.beforeStart)) {
              return RegExp.$1 + firstLine;
            }

            return '';
          });

          const indents = source.match(/^[ \t]*(?=\S)/gm);

          if (indents) {
            return Math.min(...indents.map(getIndentLevel));
          }

          baseIndentLevel = 1;
        }

        const indents = [];
        const foundIndents = /(?:^|\n)([ \t]*)\S[^\r\n]*(?:\r?\n\s*)*$/m.exec(root.raws.beforeStart);

        // The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.
        if (foundIndents) {
          let shortest = Number.MAX_SAFE_INTEGER;
          let i = 0;

          while (++i < foundIndents.length) {
            const current = getIndentLevel(foundIndents[i]);

            if (current < shortest) {
              shortest = current;

              if (shortest === 0) {
                break;
              }
            }
          }

          if (shortest !== Number.MAX_SAFE_INTEGER) {
            indents.push(new Array(shortest).fill(' ').join(''));
          }
        }

        const after = root.raws.after;

        if (after) {
          let afterEnd;

          if (after.endsWith('\n')) {
            const document = root.document;

            if (document) {
              const nextRoot = document.nodes[document.nodes.indexOf(root) + 1];

              if (nextRoot) {
                afterEnd = nextRoot.raws.beforeStart;
              } else {
                afterEnd = document.raws.afterEnd;
              }
            } else {
              // Nested root node in css-in-js lang
              const parent = root.parent;

              const nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];

              if (nextRoot) {
                afterEnd = nextRoot.raws.beforeStart;
              } else {
                afterEnd = root.raws.afterEnd;
              }
            }
          } else {
            afterEnd = after;
          }

          indents.push(afterEnd.match(/^[ \t]*/)[0]);
        }

        if (indents.length) {
          return Math.max(...indents.map(getIndentLevel)) + baseIndentLevel;
        }

        return baseIndentLevel;
      }

      function fixIndentation(str, whitespace) {
        if (!_.isString(str)) {
          return str;
        }

        return str.replace(/\n[ \t]*(?=\S|$)/g, `\n${whitespace}`);
      }

      function replaceIndentation(input, searchString, replaceString, startIndex) {
        const offset = startIndex + 1;
        const stringStart = input.slice(0, offset);
        const stringEnd = input.slice(offset + searchString.length);

        return stringStart + replaceString + stringEnd;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 417, "../../utils/hasBlock": 437, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "style-search": 166 }], 291: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const importLazy = require('import-lazy');

      /** @typedef {import('stylelint').StylelintRule} StylelintRule */

      /** @type {{[k: string]: StylelintRule}} */
      const rules = {
        'alpha-value-notation': importLazy(() => require('./alpha-value-notation'))(),
        'at-rule-allowed-list': importLazy(() => require('./at-rule-allowed-list'))(),
        'at-rule-blacklist': importLazy(() => require('./at-rule-blacklist'))(),
        'at-rule-disallowed-list': importLazy(() => require('./at-rule-disallowed-list'))(),
        'at-rule-empty-line-before': importLazy(() => require('./at-rule-empty-line-before'))(),
        'at-rule-name-case': importLazy(() => require('./at-rule-name-case'))(),
        'at-rule-name-newline-after': importLazy(() => require('./at-rule-name-newline-after'))(),
        'at-rule-semicolon-space-before': importLazy(() => require('./at-rule-semicolon-space-before'))(),
        'at-rule-name-space-after': importLazy(() => require('./at-rule-name-space-after'))(),
        'at-rule-no-unknown': importLazy(() => require('./at-rule-no-unknown'))(),
        /* 'at-rule-no-vendor-prefix': importLazy(() => require('./at-rule-no-vendor-prefix'))(), */
        'at-rule-property-required-list': importLazy(() => require('./at-rule-property-required-list'))(),
        'at-rule-property-requirelist': importLazy(() => require('./at-rule-property-requirelist'))(),
        'at-rule-semicolon-newline-after': importLazy(() =>
        require('./at-rule-semicolon-newline-after'))(),

        'at-rule-whitelist': importLazy(() => require('./at-rule-whitelist'))(),
        'block-closing-brace-empty-line-before': importLazy(() =>
        require('./block-closing-brace-empty-line-before'))(),

        'block-closing-brace-newline-after': importLazy(() =>
        require('./block-closing-brace-newline-after'))(),

        'block-closing-brace-newline-before': importLazy(() =>
        require('./block-closing-brace-newline-before'))(),

        'block-closing-brace-space-after': importLazy(() =>
        require('./block-closing-brace-space-after'))(),

        'block-closing-brace-space-before': importLazy(() =>
        require('./block-closing-brace-space-before'))(),

        'block-no-empty': importLazy(() => require('./block-no-empty'))(),
        'block-opening-brace-newline-after': importLazy(() =>
        require('./block-opening-brace-newline-after'))(),

        'block-opening-brace-newline-before': importLazy(() =>
        require('./block-opening-brace-newline-before'))(),

        'block-opening-brace-space-after': importLazy(() =>
        require('./block-opening-brace-space-after'))(),

        'block-opening-brace-space-before': importLazy(() =>
        require('./block-opening-brace-space-before'))(),

        'color-function-notation': importLazy(() => require('./color-function-notation'))(),
        'color-hex-case': importLazy(() => require('./color-hex-case'))(),
        'color-hex-length': importLazy(() => require('./color-hex-length'))(),
        'color-named': importLazy(() => require('./color-named'))(),
        'color-no-hex': importLazy(() => require('./color-no-hex'))(),
        'color-no-invalid-hex': importLazy(() => require('./color-no-invalid-hex'))(),
        'comment-empty-line-before': importLazy(() => require('./comment-empty-line-before'))(),
        'comment-no-empty': importLazy(() => require('./comment-no-empty'))(),
        'comment-pattern': importLazy(() => require('./comment-pattern'))(),
        'comment-whitespace-inside': importLazy(() => require('./comment-whitespace-inside'))(),
        'comment-word-blacklist': importLazy(() => require('./comment-word-blacklist'))(),
        'comment-word-disallowed-list': importLazy(() => require('./comment-word-disallowed-list'))(),
        'custom-media-pattern': importLazy(() => require('./custom-media-pattern'))(),
        'custom-property-empty-line-before': importLazy(() =>
        require('./custom-property-empty-line-before'))(),

        'custom-property-pattern': importLazy(() => require('./custom-property-pattern'))(),
        'declaration-bang-space-after': importLazy(() => require('./declaration-bang-space-after'))(),
        'declaration-bang-space-before': importLazy(() => require('./declaration-bang-space-before'))(),
        'declaration-block-no-duplicate-properties': importLazy(() =>
        require('./declaration-block-no-duplicate-properties'))(),

        'declaration-block-no-redundant-longhand-properties': importLazy(() =>
        require('./declaration-block-no-redundant-longhand-properties'))(),

        'declaration-block-no-shorthand-property-overrides': importLazy(() =>
        require('./declaration-block-no-shorthand-property-overrides'))(),

        'declaration-block-semicolon-newline-after': importLazy(() =>
        require('./declaration-block-semicolon-newline-after'))(),

        'declaration-block-semicolon-newline-before': importLazy(() =>
        require('./declaration-block-semicolon-newline-before'))(),

        'declaration-block-semicolon-space-after': importLazy(() =>
        require('./declaration-block-semicolon-space-after'))(),

        'declaration-block-semicolon-space-before': importLazy(() =>
        require('./declaration-block-semicolon-space-before'))(),

        'declaration-block-single-line-max-declarations': importLazy(() =>
        require('./declaration-block-single-line-max-declarations'))(),

        'declaration-block-trailing-semicolon': importLazy(() =>
        require('./declaration-block-trailing-semicolon'))(),

        'declaration-colon-newline-after': importLazy(() =>
        require('./declaration-colon-newline-after'))(),

        'declaration-colon-space-after': importLazy(() => require('./declaration-colon-space-after'))(),
        'declaration-colon-space-before': importLazy(() => require('./declaration-colon-space-before'))(),
        'declaration-empty-line-before': importLazy(() => require('./declaration-empty-line-before'))(),
        'declaration-no-important': importLazy(() => require('./declaration-no-important'))(),
        'declaration-property-unit-allowed-list': importLazy(() =>
        require('./declaration-property-unit-allowed-list'))(),

        'declaration-property-unit-blacklist': importLazy(() =>
        require('./declaration-property-unit-blacklist'))(),

        'declaration-property-unit-disallowed-list': importLazy(() =>
        require('./declaration-property-unit-disallowed-list'))(),

        'declaration-property-unit-whitelist': importLazy(() =>
        require('./declaration-property-unit-whitelist'))(),

        'declaration-property-value-allowed-list': importLazy(() =>
        require('./declaration-property-value-allowed-list'))(),

        'declaration-property-value-blacklist': importLazy(() =>
        require('./declaration-property-value-blacklist'))(),

        'declaration-property-value-disallowed-list': importLazy(() =>
        require('./declaration-property-value-disallowed-list'))(),

        'declaration-property-value-whitelist': importLazy(() =>
        require('./declaration-property-value-whitelist'))(),

        'font-family-no-missing-generic-family-keyword': importLazy(() =>
        require('./font-family-no-missing-generic-family-keyword'))(),

        'font-family-name-quotes': importLazy(() => require('./font-family-name-quotes'))(),
        'font-family-no-duplicate-names': importLazy(() => require('./font-family-no-duplicate-names'))(),
        'font-weight-notation': importLazy(() => require('./font-weight-notation'))(),
        'function-allowed-list': importLazy(() => require('./function-allowed-list'))(),
        'function-blacklist': importLazy(() => require('./function-blacklist'))(),
        'function-calc-no-invalid': importLazy(() => require('./function-calc-no-invalid'))(),
        'function-calc-no-unspaced-operator': importLazy(() =>
        require('./function-calc-no-unspaced-operator'))(),

        'function-comma-newline-after': importLazy(() => require('./function-comma-newline-after'))(),
        'function-comma-newline-before': importLazy(() => require('./function-comma-newline-before'))(),
        'function-comma-space-after': importLazy(() => require('./function-comma-space-after'))(),
        'function-comma-space-before': importLazy(() => require('./function-comma-space-before'))(),
        'function-disallowed-list': importLazy(() => require('./function-disallowed-list'))(),
        'function-linear-gradient-no-nonstandard-direction': importLazy(() =>
        require('./function-linear-gradient-no-nonstandard-direction'))(),

        'function-max-empty-lines': importLazy(() => require('./function-max-empty-lines'))(),
        'function-name-case': importLazy(() => require('./function-name-case'))(),
        'function-parentheses-newline-inside': importLazy(() =>
        require('./function-parentheses-newline-inside'))(),

        'function-parentheses-space-inside': importLazy(() =>
        require('./function-parentheses-space-inside'))(),

        'function-url-no-scheme-relative': importLazy(() =>
        require('./function-url-no-scheme-relative'))(),

        'function-url-quotes': importLazy(() => require('./function-url-quotes'))(),
        'function-url-scheme-allowed-list': importLazy(() =>
        require('./function-url-scheme-allowed-list'))(),

        'function-url-scheme-blacklist': importLazy(() => require('./function-url-scheme-blacklist'))(),
        'function-url-scheme-disallowed-list': importLazy(() =>
        require('./function-url-scheme-disallowed-list'))(),

        'function-url-scheme-whitelist': importLazy(() => require('./function-url-scheme-whitelist'))(),
        'function-whitespace-after': importLazy(() => require('./function-whitespace-after'))(),
        'function-whitelist': importLazy(() => require('./function-whitelist'))(),
        'hue-degree-notation': importLazy(() => require('./hue-degree-notation'))(),
        'keyframe-declaration-no-important': importLazy(() =>
        require('./keyframe-declaration-no-important'))(),

        'keyframes-name-pattern': importLazy(() => require('./keyframes-name-pattern'))(),
        'length-zero-no-unit': importLazy(() => require('./length-zero-no-unit'))(),
        linebreaks: importLazy(() => require('./linebreaks'))(),
        'max-empty-lines': importLazy(() => require('./max-empty-lines'))(),
        'max-line-length': importLazy(() => require('./max-line-length'))(),
        'max-nesting-depth': importLazy(() => require('./max-nesting-depth'))(),
        'media-feature-colon-space-after': importLazy(() =>
        require('./media-feature-colon-space-after'))(),

        'media-feature-colon-space-before': importLazy(() =>
        require('./media-feature-colon-space-before'))(),

        'media-feature-name-allowed-list': importLazy(() =>
        require('./media-feature-name-allowed-list'))(),

        'media-feature-name-blacklist': importLazy(() => require('./media-feature-name-blacklist'))(),
        'media-feature-name-case': importLazy(() => require('./media-feature-name-case'))(),
        'media-feature-name-disallowed-list': importLazy(() =>
        require('./media-feature-name-disallowed-list'))(),

        'media-feature-name-no-unknown': importLazy(() => require('./media-feature-name-no-unknown'))(),
        /* 'media-feature-name-no-vendor-prefix': importLazy(() =>
        	require('./media-feature-name-no-vendor-prefix'),
        )(), */
        'media-feature-name-value-allowed-list': importLazy(() =>
        require('./media-feature-name-value-allowed-list'))(),

        'media-feature-name-value-whitelist': importLazy(() =>
        require('./media-feature-name-value-whitelist'))(),

        'media-feature-name-whitelist': importLazy(() => require('./media-feature-name-whitelist'))(),
        'media-feature-parentheses-space-inside': importLazy(() =>
        require('./media-feature-parentheses-space-inside'))(),

        'media-feature-range-operator-space-after': importLazy(() =>
        require('./media-feature-range-operator-space-after'))(),

        'media-feature-range-operator-space-before': importLazy(() =>
        require('./media-feature-range-operator-space-before'))(),

        'media-query-list-comma-newline-after': importLazy(() =>
        require('./media-query-list-comma-newline-after'))(),

        'media-query-list-comma-newline-before': importLazy(() =>
        require('./media-query-list-comma-newline-before'))(),

        'media-query-list-comma-space-after': importLazy(() =>
        require('./media-query-list-comma-space-after'))(),

        'media-query-list-comma-space-before': importLazy(() =>
        require('./media-query-list-comma-space-before'))(),

        'no-descending-specificity': importLazy(() => require('./no-descending-specificity'))(),
        'no-duplicate-at-import-rules': importLazy(() => require('./no-duplicate-at-import-rules'))(),
        'no-duplicate-selectors': importLazy(() => require('./no-duplicate-selectors'))(),
        'no-empty-source': importLazy(() => require('./no-empty-source'))(),
        'no-empty-first-line': importLazy(() => require('./no-empty-first-line'))(),
        'no-eol-whitespace': importLazy(() => require('./no-eol-whitespace'))(),
        'no-extra-semicolons': importLazy(() => require('./no-extra-semicolons'))(),
        'no-invalid-double-slash-comments': importLazy(() =>
        require('./no-invalid-double-slash-comments'))(),

        'no-missing-end-of-source-newline': importLazy(() =>
        require('./no-missing-end-of-source-newline'))(),

        'no-unknown-animations': importLazy(() => require('./no-unknown-animations'))(),
        'number-leading-zero': importLazy(() => require('./number-leading-zero'))(),
        'number-max-precision': importLazy(() => require('./number-max-precision'))(),
        'number-no-trailing-zeros': importLazy(() => require('./number-no-trailing-zeros'))(),
        'property-allowed-list': importLazy(() => require('./property-allowed-list'))(),
        'property-blacklist': importLazy(() => require('./property-blacklist'))(),
        'property-case': importLazy(() => require('./property-case'))(),
        'property-disallowed-list': importLazy(() => require('./property-disallowed-list'))(),
        'property-no-unknown': importLazy(() => require('./property-no-unknown'))(),
        /* 'property-no-vendor-prefix': importLazy(() => require('./property-no-vendor-prefix'))(), */
        'property-whitelist': importLazy(() => require('./property-whitelist'))(),
        'rule-empty-line-before': importLazy(() => require('./rule-empty-line-before'))(),
        'selector-attribute-brackets-space-inside': importLazy(() =>
        require('./selector-attribute-brackets-space-inside'))(),

        'selector-attribute-name-disallowed-list': importLazy(() =>
        require('./selector-attribute-name-disallowed-list'))(),

        'selector-attribute-operator-allowed-list': importLazy(() =>
        require('./selector-attribute-operator-allowed-list'))(),

        'selector-attribute-operator-blacklist': importLazy(() =>
        require('./selector-attribute-operator-blacklist'))(),

        'selector-attribute-operator-disallowed-list': importLazy(() =>
        require('./selector-attribute-operator-disallowed-list'))(),

        'selector-attribute-operator-space-after': importLazy(() =>
        require('./selector-attribute-operator-space-after'))(),

        'selector-attribute-operator-space-before': importLazy(() =>
        require('./selector-attribute-operator-space-before'))(),

        'selector-attribute-operator-whitelist': importLazy(() =>
        require('./selector-attribute-operator-whitelist'))(),

        'selector-attribute-quotes': importLazy(() => require('./selector-attribute-quotes'))(),
        'selector-class-pattern': importLazy(() => require('./selector-class-pattern'))(),
        'selector-combinator-allowed-list': importLazy(() =>
        require('./selector-combinator-allowed-list'))(),

        'selector-combinator-blacklist': importLazy(() => require('./selector-combinator-blacklist'))(),
        'selector-combinator-disallowed-list': importLazy(() =>
        require('./selector-combinator-disallowed-list'))(),

        'selector-combinator-space-after': importLazy(() =>
        require('./selector-combinator-space-after'))(),

        'selector-combinator-space-before': importLazy(() =>
        require('./selector-combinator-space-before'))(),

        'selector-combinator-whitelist': importLazy(() => require('./selector-combinator-whitelist'))(),
        'selector-descendant-combinator-no-non-space': importLazy(() =>
        require('./selector-descendant-combinator-no-non-space'))(),

        'selector-id-pattern': importLazy(() => require('./selector-id-pattern'))(),
        'selector-list-comma-newline-after': importLazy(() =>
        require('./selector-list-comma-newline-after'))(),

        'selector-list-comma-newline-before': importLazy(() =>
        require('./selector-list-comma-newline-before'))(),

        'selector-list-comma-space-after': importLazy(() =>
        require('./selector-list-comma-space-after'))(),

        'selector-list-comma-space-before': importLazy(() =>
        require('./selector-list-comma-space-before'))(),

        'selector-max-attribute': importLazy(() => require('./selector-max-attribute'))(),
        'selector-max-class': importLazy(() => require('./selector-max-class'))(),
        'selector-max-combinators': importLazy(() => require('./selector-max-combinators'))(),
        'selector-max-compound-selectors': importLazy(() =>
        require('./selector-max-compound-selectors'))(),

        'selector-max-empty-lines': importLazy(() => require('./selector-max-empty-lines'))(),
        'selector-max-id': importLazy(() => require('./selector-max-id'))(),
        'selector-max-pseudo-class': importLazy(() => require('./selector-max-pseudo-class'))(),
        'selector-max-specificity': importLazy(() => require('./selector-max-specificity'))(),
        'selector-max-type': importLazy(() => require('./selector-max-type'))(),
        'selector-max-universal': importLazy(() => require('./selector-max-universal'))(),
        'selector-nested-pattern': importLazy(() => require('./selector-nested-pattern'))(),
        'selector-no-qualifying-type': importLazy(() => require('./selector-no-qualifying-type'))(),
        /* 'selector-no-vendor-prefix': importLazy(() => require('./selector-no-vendor-prefix'))(), */
        'selector-pseudo-class-allowed-list': importLazy(() =>
        require('./selector-pseudo-class-allowed-list'))(),

        'selector-pseudo-class-blacklist': importLazy(() =>
        require('./selector-pseudo-class-blacklist'))(),

        'selector-pseudo-class-case': importLazy(() => require('./selector-pseudo-class-case'))(),
        'selector-pseudo-class-disallowed-list': importLazy(() =>
        require('./selector-pseudo-class-disallowed-list'))(),

        'selector-pseudo-class-no-unknown': importLazy(() =>
        require('./selector-pseudo-class-no-unknown'))(),

        'selector-pseudo-class-parentheses-space-inside': importLazy(() =>
        require('./selector-pseudo-class-parentheses-space-inside'))(),

        'selector-pseudo-class-whitelist': importLazy(() =>
        require('./selector-pseudo-class-whitelist'))(),

        'selector-pseudo-element-allowed-list': importLazy(() =>
        require('./selector-pseudo-element-allowed-list'))(),

        'selector-pseudo-element-blacklist': importLazy(() =>
        require('./selector-pseudo-element-blacklist'))(),

        'selector-pseudo-element-case': importLazy(() => require('./selector-pseudo-element-case'))(),
        'selector-pseudo-element-colon-notation': importLazy(() =>
        require('./selector-pseudo-element-colon-notation'))(),

        'selector-pseudo-element-disallowed-list': importLazy(() =>
        require('./selector-pseudo-element-disallowed-list'))(),

        'selector-pseudo-element-no-unknown': importLazy(() =>
        require('./selector-pseudo-element-no-unknown'))(),

        'selector-pseudo-element-whitelist': importLazy(() =>
        require('./selector-pseudo-element-whitelist'))(),

        'selector-type-case': importLazy(() => require('./selector-type-case'))(),
        'selector-type-no-unknown': importLazy(() => require('./selector-type-no-unknown'))(),
        'shorthand-property-no-redundant-values': importLazy(() =>
        require('./shorthand-property-no-redundant-values'))(),

        'string-no-newline': importLazy(() => require('./string-no-newline'))(),
        'string-quotes': importLazy(() => require('./string-quotes'))(),
        'time-min-milliseconds': importLazy(() => require('./time-min-milliseconds'))(),
        'unicode-bom': importLazy(() => require('./unicode-bom'))(),
        'unit-allowed-list': importLazy(() => require('./unit-allowed-list'))(),
        'unit-blacklist': importLazy(() => require('./unit-blacklist'))(),
        'unit-case': importLazy(() => require('./unit-case'))(),
        'unit-disallowed-list': importLazy(() => require('./unit-disallowed-list'))(),
        'unit-no-unknown': importLazy(() => require('./unit-no-unknown'))(),
        'unit-whitelist': importLazy(() => require('./unit-whitelist'))(),
        'value-keyword-case': importLazy(() => require('./value-keyword-case'))(),
        'value-list-comma-newline-after': importLazy(() => require('./value-list-comma-newline-after'))(),
        'value-list-comma-newline-before': importLazy(() =>
        require('./value-list-comma-newline-before'))(),

        'value-list-comma-space-after': importLazy(() => require('./value-list-comma-space-after'))(),
        'value-list-comma-space-before': importLazy(() => require('./value-list-comma-space-before'))(),
        'value-list-max-empty-lines': importLazy(() => require('./value-list-max-empty-lines'))(),
        /* 'value-no-vendor-prefix': importLazy(() => require('./value-no-vendor-prefix'))(), */
        indentation: importLazy(() => require('./indentation'))() /* Placedhere for better autofixing */ };


      module.exports = rules;

    }, { "./alpha-value-notation": 193, "./at-rule-allowed-list": 194, "./at-rule-blacklist": 195, "./at-rule-disallowed-list": 196, "./at-rule-empty-line-before": 197, "./at-rule-name-case": 198, "./at-rule-name-newline-after": 199, "./at-rule-name-space-after": 200, "./at-rule-no-unknown": 201, "./at-rule-property-required-list": 202, "./at-rule-property-requirelist": 203, "./at-rule-semicolon-newline-after": 204, "./at-rule-semicolon-space-before": 205, "./at-rule-whitelist": 206, "./block-closing-brace-empty-line-before": 208, "./block-closing-brace-newline-after": 209, "./block-closing-brace-newline-before": 210, "./block-closing-brace-space-after": 211, "./block-closing-brace-space-before": 212, "./block-no-empty": 213, "./block-opening-brace-newline-after": 214, "./block-opening-brace-newline-before": 215, "./block-opening-brace-space-after": 216, "./block-opening-brace-space-before": 217, "./color-function-notation": 218, "./color-hex-case": 219, "./color-hex-length": 220, "./color-named": 222, "./color-no-hex": 223, "./color-no-invalid-hex": 224, "./comment-empty-line-before": 225, "./comment-no-empty": 226, "./comment-pattern": 227, "./comment-whitespace-inside": 228, "./comment-word-blacklist": 229, "./comment-word-disallowed-list": 230, "./custom-media-pattern": 231, "./custom-property-empty-line-before": 232, "./custom-property-pattern": 233, "./declaration-bang-space-after": 234, "./declaration-bang-space-before": 235, "./declaration-block-no-duplicate-properties": 236, "./declaration-block-no-redundant-longhand-properties": 237, "./declaration-block-no-shorthand-property-overrides": 238, "./declaration-block-semicolon-newline-after": 239, "./declaration-block-semicolon-newline-before": 240, "./declaration-block-semicolon-space-after": 241, "./declaration-block-semicolon-space-before": 242, "./declaration-block-single-line-max-declarations": 243, "./declaration-block-trailing-semicolon": 244, "./declaration-colon-newline-after": 245, "./declaration-colon-space-after": 246, "./declaration-colon-space-before": 247, "./declaration-empty-line-before": 248, "./declaration-no-important": 249, "./declaration-property-unit-allowed-list": 250, "./declaration-property-unit-blacklist": 251, "./declaration-property-unit-disallowed-list": 252, "./declaration-property-unit-whitelist": 253, "./declaration-property-value-allowed-list": 254, "./declaration-property-value-blacklist": 255, "./declaration-property-value-disallowed-list": 256, "./declaration-property-value-whitelist": 257, "./font-family-name-quotes": 261, "./font-family-no-duplicate-names": 262, "./font-family-no-missing-generic-family-keyword": 263, "./font-weight-notation": 264, "./function-allowed-list": 265, "./function-blacklist": 266, "./function-calc-no-invalid": 267, "./function-calc-no-unspaced-operator": 268, "./function-comma-newline-after": 269, "./function-comma-newline-before": 270, "./function-comma-space-after": 271, "./function-comma-space-before": 272, "./function-disallowed-list": 273, "./function-linear-gradient-no-nonstandard-direction": 274, "./function-max-empty-lines": 275, "./function-name-case": 276, "./function-parentheses-newline-inside": 277, "./function-parentheses-space-inside": 278, "./function-url-no-scheme-relative": 279, "./function-url-quotes": 280, "./function-url-scheme-allowed-list": 281, "./function-url-scheme-blacklist": 282, "./function-url-scheme-disallowed-list": 283, "./function-url-scheme-whitelist": 284, "./function-whitelist": 285, "./function-whitespace-after": 286, "./hue-degree-notation": 289, "./indentation": 290, "./keyframe-declaration-no-important": 292, "./keyframes-name-pattern": 293, "./length-zero-no-unit": 294, "./linebreaks": 295, "./max-empty-lines": 296, "./max-line-length": 297, "./max-nesting-depth": 298, "./media-feature-colon-space-after": 299, "./media-feature-colon-space-before": 300, "./media-feature-name-allowed-list": 301, "./media-feature-name-blacklist": 302, "./media-feature-name-case": 303, "./media-feature-name-disallowed-list": 304, "./media-feature-name-no-unknown": 305, "./media-feature-name-value-allowed-list": 306, "./media-feature-name-value-whitelist": 307, "./media-feature-name-whitelist": 308, "./media-feature-parentheses-space-inside": 309, "./media-feature-range-operator-space-after": 310, "./media-feature-range-operator-space-before": 311, "./media-query-list-comma-newline-after": 312, "./media-query-list-comma-newline-before": 313, "./media-query-list-comma-space-after": 314, "./media-query-list-comma-space-before": 315, "./no-descending-specificity": 318, "./no-duplicate-at-import-rules": 319, "./no-duplicate-selectors": 320, "./no-empty-first-line": 321, "./no-empty-source": 322, "./no-eol-whitespace": 323, "./no-extra-semicolons": 324, "./no-invalid-double-slash-comments": 325, "./no-missing-end-of-source-newline": 326, "./no-unknown-animations": 327, "./number-leading-zero": 328, "./number-max-precision": 329, "./number-no-trailing-zeros": 330, "./property-allowed-list": 331, "./property-blacklist": 332, "./property-case": 333, "./property-disallowed-list": 334, "./property-no-unknown": 335, "./property-whitelist": 336, "./rule-empty-line-before": 338, "./selector-attribute-brackets-space-inside": 339, "./selector-attribute-name-disallowed-list": 340, "./selector-attribute-operator-allowed-list": 341, "./selector-attribute-operator-blacklist": 342, "./selector-attribute-operator-disallowed-list": 343, "./selector-attribute-operator-space-after": 344, "./selector-attribute-operator-space-before": 345, "./selector-attribute-operator-whitelist": 346, "./selector-attribute-quotes": 347, "./selector-class-pattern": 348, "./selector-combinator-allowed-list": 349, "./selector-combinator-blacklist": 350, "./selector-combinator-disallowed-list": 351, "./selector-combinator-space-after": 352, "./selector-combinator-space-before": 353, "./selector-combinator-whitelist": 354, "./selector-descendant-combinator-no-non-space": 355, "./selector-id-pattern": 356, "./selector-list-comma-newline-after": 357, "./selector-list-comma-newline-before": 358, "./selector-list-comma-space-after": 359, "./selector-list-comma-space-before": 360, "./selector-max-attribute": 361, "./selector-max-class": 362, "./selector-max-combinators": 363, "./selector-max-compound-selectors": 364, "./selector-max-empty-lines": 365, "./selector-max-id": 366, "./selector-max-pseudo-class": 367, "./selector-max-specificity": 368, "./selector-max-type": 369, "./selector-max-universal": 370, "./selector-nested-pattern": 371, "./selector-no-qualifying-type": 372, "./selector-pseudo-class-allowed-list": 373, "./selector-pseudo-class-blacklist": 374, "./selector-pseudo-class-case": 375, "./selector-pseudo-class-disallowed-list": 376, "./selector-pseudo-class-no-unknown": 377, "./selector-pseudo-class-parentheses-space-inside": 378, "./selector-pseudo-class-whitelist": 379, "./selector-pseudo-element-allowed-list": 380, "./selector-pseudo-element-blacklist": 381, "./selector-pseudo-element-case": 382, "./selector-pseudo-element-colon-notation": 383, "./selector-pseudo-element-disallowed-list": 384, "./selector-pseudo-element-no-unknown": 385, "./selector-pseudo-element-whitelist": 386, "./selector-type-case": 387, "./selector-type-no-unknown": 388, "./shorthand-property-no-redundant-values": 392, "./string-no-newline": 393, "./string-quotes": 394, "./time-min-milliseconds": 395, "./unicode-bom": 396, "./unit-allowed-list": 397, "./unit-blacklist": 398, "./unit-case": 399, "./unit-disallowed-list": 400, "./unit-no-unknown": 401, "./unit-whitelist": 402, "./value-keyword-case": 403, "./value-list-comma-newline-after": 404, "./value-list-comma-newline-before": 405, "./value-list-comma-space-after": 406, "./value-list-comma-space-before": 407, "./value-list-max-empty-lines": 408, "import-lazy": 13 }], 292: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'keyframe-declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
            atRuleKeyframes.walkDecls(decl => {
              if (!decl.important) {
                return;
              }

              report({
                message: messages.rejected,
                node: decl,
                word: 'important',
                result,
                ruleName });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 293: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'keyframes-name-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (keyframeName, pattern) =>
        `Expected keyframe name "${keyframeName}" to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const regex = _.isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkAtRules(/keyframes/i, keyframesNode => {
            const value = keyframesNode.params;

            if (regex.test(value)) {
              return;
            }

            report({
              index: atRuleParamIndex(keyframesNode),
              message: messages.expected(value, pattern),
              node: keyframesNode,
              ruleName,
              result });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 294: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const beforeBlockString = require('../../utils/beforeBlockString');
      const blurComments = require('../../utils/blurComments');
      const hasBlock = require('../../utils/hasBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isLessVariable = require('../../utils/isLessVariable');
      const isMathFunction = require('../../utils/isMathFunction');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'length-zero-no-unit';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected unit' });


      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'line-height') {
              return;
            }

            const stringValue = blurComments(decl.toString());
            const ignorableIndexes = new Array(stringValue.length).fill(false);
            const parsedValue = valueParser(stringValue);

            parsedValue.walk((node, nodeIndex, nodes) => {
              if (decl.prop.toLowerCase() === 'font' && node.type === 'div' && node.value === '/') {
                const lineHeightNode = nodes[nodeIndex + 1];
                const lineHeightNodeValue = valueParser.stringify(lineHeightNode);

                for (let i = 0; i < lineHeightNodeValue.length; i++) {
                  ignorableIndexes[lineHeightNode.sourceIndex + i] = true;
                }

                return;
              }

              if (node.type !== 'function') {
                return;
              }

              // TODO: Issue #4985
              // eslint-disable-next-line no-shadow
              const stringValue = valueParser.stringify(node);
              const ignoreFlag = isMathFunction(node);

              for (let i = 0; i < stringValue.length; i++) {
                ignorableIndexes[node.sourceIndex + i] = ignoreFlag;
              }
            });

            check(stringValue, decl, ignorableIndexes);
          });

          root.walkAtRules(atRule => {
            // Ignore Less variables
            if (isLessVariable(atRule)) {
              return;
            }

            const source = hasBlock(atRule) ?
            beforeBlockString(atRule, { noRawBefore: true }) :
            atRule.toString();

            check(source, atRule);
          });

          function check(value, node, ignorableIndexes = []) {
            if (optionsMatches(secondary, 'ignore', 'custom-properties') && isCustomProperty(value)) {
              return;
            }

            const fixPositions = [];

            styleSearch({ source: value, target: '0' }, match => {
              const index = match.startIndex;

              // Given a 0 somewhere in the full property value (not in a string, thanks
              // to styleSearch) we need to isolate the value that contains the zero.
              // To do so, we'll find the last index before the 0 of a character that would
              // divide one value in a list from another, and the next index of such a
              // character; then we build a substring from those indexes, which we can
              // assess.

              // If a single value includes multiple 0's (e.g. 100.01px), we don't want
              // each 0 to be treated as a separate value, possibly resulting in multiple
              // warnings for the same value (e.g. 0.00px).
              //
              // This check prevents that from happening: we build and check against a
              // Set containing all the indexes that are part of a value already validated.
              if (ignorableIndexes[index]) {
                return;
              }

              const prevValueBreakIndex = _.findLastIndex(value.substr(0, index), char => {
                return [' ', ',', ')', '(', '#', ':', '\n', '\t'].includes(char);
              });

              // Ignore hex colors
              if (value[prevValueBreakIndex] === '#') {
                return;
              }

              // If no prev break was found, this value starts at 0
              const valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1;

              const nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), char => {
                return [' ', ',', ')', '/'].includes(char);
              });

              // If no next break was found, this value ends at the end of the string
              const valueWithZeroEnd =
              nextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart;

              const valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd);
              const parsedValue = valueParser.unit(valueWithZero);

              if (!parsedValue || parsedValue && !parsedValue.unit) {
                return;
              }

              if (parsedValue.unit.toLowerCase() === 'fr') {
                return;
              }

              // Add the indexes to ignorableIndexes so the same value will not
              // be checked multiple times.
              _.range(valueWithZeroStart, valueWithZeroEnd).forEach(i => ignorableIndexes[i] = true);

              // Only pay attention if the value parses to 0
              // and units with lengths
              if (
              parseFloat(valueWithZero) !== 0 ||
              !keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase()))
              {
                return;
              }

              if (context.fix) {
                fixPositions.unshift({
                  startIndex: valueWithZeroStart,
                  length: valueWithZeroEnd - valueWithZeroStart });


                return;
              }

              report({
                message: messages.rejected,
                node,
                index: valueWithZeroEnd - parsedValue.unit.length,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              fixPositions.forEach(fixPosition => {
                if (node.type === 'atrule') {
                  // Use `-1` for `@` character before each at rule
                  const realIndex =
                  fixPosition.startIndex - node.name.length - node.raws.afterName.length - 1;

                  node.params = replaceZero(node.params, realIndex, fixPosition.length);
                } else {
                  const realIndex = fixPosition.startIndex - node.prop.length - node.raws.between.length;

                  node.value = replaceZero(node.value, realIndex, fixPosition.length);
                }
              });
            }
          }
        };
      }

      function replaceZero(input, startIndex, length) {
        const stringStart = input.slice(0, startIndex);
        const stringEnd = input.slice(startIndex + length);

        return `${stringStart}0${stringEnd}`;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/beforeBlockString": 417, "../../utils/blurComments": 419, "../../utils/hasBlock": 437, "../../utils/isCustomProperty": 455, "../../utils/isLessVariable": 462, "../../utils/isMathFunction": 464, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120, "style-search": 166 }], 295: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'linebreaks';

      const messages = ruleMessages(ruleName, {
        expected: linebreak => `Expected linebreak to be ${linebreak}` });


      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual,
            possible: ['unix', 'windows'] });


          if (!validOptions) {
            return;
          }

          const shouldHaveCR = actual === 'windows';

          if (context.fix) {
            const propertiesToUpdate = ['selector', 'raws.before', 'raws.after', 'value', 'text'];

            root.walk(node => {
              propertiesToUpdate.forEach(property => {
                const fixedData = fixData(_.get(node, property), shouldHaveCR);

                _.set(node, property, fixedData);
              });
            });

            root.raws.after = fixData(root.raws.after, shouldHaveCR);
          } else {
            const lines = root.source.input.css.split('\n');

            for (let i = 0; i < lines.length; i++) {
              let line = lines[i];

              if (i < lines.length - 1 && !line.includes('\r')) {
                line += '\n';
              }

              if (hasError(line, shouldHaveCR)) {
                const lineNum = i + 1;
                const colNum = line.length;

                reportNewlineError(shouldHaveCR, lineNum, colNum, actual, result);
              }
            }
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function hasError(dataToCheck, shouldHaveCR) {
            const hasNewlineToVerify = /[\r\n]/.test(dataToCheck);
            const hasCR = hasNewlineToVerify ? /\r/.test(dataToCheck) : false;

            return hasNewlineToVerify && hasCR !== shouldHaveCR;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function fixData(data, shouldHaveCR) {
            if (data) {
              // TODO: Issue #4985
              // eslint-disable-next-line no-shadow
              let result = data.replace(/\r/g, '');

              if (shouldHaveCR) {
                result = result.replace(/\n/g, '\r\n');
              }

              return result;
            }

            return data;
          }

          function createReportNode(line, column) {
            // Creating a node manually helps us to point to empty lines.
            return postcss.rule({
              source: {
                start: {
                  line,
                  column } } });



          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function reportNewlineError(shouldHaveCR, lineNum, colNum, actual, result) {
            const reportNode = createReportNode(lineNum, colNum);

            report({
              message: messages.expected(actual),
              node: reportNode,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss": 137 }], 296: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function rule(max, options, context) {
        let emptyLines = 0;
        let lastIndex = -1;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: _.isNumber },

          {
            actual: options,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(options, 'ignore', 'comments');
          const getChars = _.partial(replaceEmptyLines, max);

          /**
           * 1. walk nodes & replace enterchar
           * 2. deal with special case.
           */
          if (context.fix) {
            root.walk(node => {
              if (node.type === 'comment') {
                // for inline comments
                if (node.raws.inline) {
                  node.raws.before = getChars(node.raws.before);
                }

                if (!ignoreComments) {
                  node.raws.left = getChars(node.raws.left);
                  node.raws.right = getChars(node.raws.right);
                }
              } else {
                if (node.raws.before) {
                  node.raws.before = getChars(node.raws.before);
                }

                if (node.raws.after) {
                  node.raws.after = getChars(node.raws.after);
                }
              }
            });

            // first node
            const firstNodeRawsBefore = _.get(root, 'first.raws.before');
            // root raws
            const rootRawsAfter = _.get(root, 'raws.after');

            // not document node
            if (_.get(root, 'document.constructor.name') !== 'Document') {
              if (firstNodeRawsBefore) {
                _.set(root, 'first.raws.before', getChars(firstNodeRawsBefore, true));
              }

              if (rootRawsAfter) {
                // when max setted 0, should be treated as 1 in this situation.
                _.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter, true));
              }
            } else if (rootRawsAfter) {
              // `css in js` or `html`
              _.set(root, 'raws.after', replaceEmptyLines(max === 0 ? 1 : max, rootRawsAfter));
            }

            return;
          }

          emptyLines = 0;
          lastIndex = -1;
          const rootString = root.toString();

          styleSearch(
          {
            source: rootString,
            target: /\r\n/.test(rootString) ? '\r\n' : '\n',
            comments: ignoreComments ? 'skip' : 'check' },

          match => {
            checkMatch(rootString, match.startIndex, match.endIndex, root);
          });


          function checkMatch(source, matchStartIndex, matchEndIndex, node) {
            const eof = matchEndIndex === source.length;
            let violation = false;

            // Additional check for beginning of file
            if (!matchStartIndex || lastIndex === matchStartIndex) {
              emptyLines++;
            } else {
              emptyLines = 0;
            }

            lastIndex = matchEndIndex;

            if (emptyLines > max) violation = true;

            if (!eof && !violation) return;

            if (violation) {
              report({
                message: messages.expected(max),
                node,
                index: matchStartIndex,
                result,
                ruleName });

            }

            // Additional check for end of file
            if (eof && max) {
              emptyLines++;

              if (emptyLines > max && isEofNode(result.root, node)) {
                report({
                  message: messages.expected(max),
                  node,
                  index: matchEndIndex,
                  result,
                  ruleName });

              }
            }
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function replaceEmptyLines(max, str, isSpecialCase = false) {
            const repeatTimes = isSpecialCase ? max : max + 1;

            if (repeatTimes === 0 || typeof str !== 'string') {
              return '';
            }

            const emptyLFLines = '\n'.repeat(repeatTimes);
            const emptyCRLFLines = '\r\n'.repeat(repeatTimes);

            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            let result;

            if (/(\r\n)+/g.test(str)) {
              result = str.replace(/(\r\n)+/g, $1 => {
                if ($1.length / 2 > repeatTimes) {
                  return emptyCRLFLines;
                }

                return $1;
              });
            } else {
              result = str.replace(/(\n)+/g, $1 => {
                if ($1.length > repeatTimes) {
                  return emptyLFLines;
                }

                return $1;
              });
            }

            return result;
          }
        };
      }

      /**
       * Checks whether the given node is the last node of file.
       * @param {Document|null} document the document node with `postcss-html` and `postcss-jsx`.
       * @param {Root} root the root node of css
       */
      function isEofNode(document, root) {
        if (!document || document.constructor.name !== 'Document') {
          return true;
        }

        // In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.
        let after;

        if (root === document.last) {
          after = _.get(document, 'raws.afterEnd');
        } else {
          const rootIndex = document.index(root);

          after = _.get(document.nodes[rootIndex + 1], 'raws.beforeStart');
        }

        return !String(after).trim();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "style-search": 166 }], 297: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const execall = require('execall');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'max-line-length';
      const EXCLUDED_PATTERNS = [
      /url\(\s*(\S.*\S)\s*\)/gi, // allow tab, whitespace in url content
      /@import\s+(['"].*['"])/gi];


      const messages = ruleMessages(ruleName, {
        expected: (max) =>
        `Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}` });


      function rule(maxLength, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: maxLength,
            possible: _.isNumber },

          {
            actual: options,
            possible: {
              ignore: ['non-comments', 'comments'],
              ignorePattern: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreNonComments = optionsMatches(options, 'ignore', 'non-comments');
          const ignoreComments = optionsMatches(options, 'ignore', 'comments');
          const rootString = context.fix ? root.toString() : root.source.input.css;
          // Array of skipped sub strings, i.e `url(...)`, `@import "..."`
          let skippedSubStrings = [];
          let skippedSubStringsIndex = 0;

          EXCLUDED_PATTERNS.forEach((pattern) =>
          execall(pattern, rootString).forEach(match => {
            const startOfSubString =
            match.index + match.match.indexOf(_.get(match, 'subMatches[0]', ''));

            return skippedSubStrings.push([
            startOfSubString,
            startOfSubString + _.get(match, 'subMatches[0].length', 0)]);

          }));


          skippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]);

          // Check first line
          checkNewline(rootString, { endIndex: 0 }, root);
          // Check subsequent lines
          styleSearch({ source: rootString, target: ['\n'], comments: 'check' }, (match) =>
          checkNewline(rootString, match, root));


          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function complain(index, root) {
            report({
              index,
              result,
              ruleName,
              message: messages.expected(maxLength),
              node: root });

          }

          function tryToPopSubString(start, end) {
            const [startSubString, endSubString] = skippedSubStrings[skippedSubStringsIndex];

            // Excluded substring does not presented in current line
            if (end < startSubString) {
              return 0;
            }

            // Compute excluded substring size regarding to current line indexes
            const excluded = Math.min(end, endSubString) - Math.max(start, startSubString);

            // Current substring is out of range for next lines
            if (endSubString <= end) {
              skippedSubStringsIndex++;
            }

            return excluded;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkNewline(rootString, match, root) {
            let nextNewlineIndex = rootString.indexOf('\n', match.endIndex);

            if (rootString[nextNewlineIndex - 1] === '\r') {
              nextNewlineIndex -= 1;
            }

            // Accommodate last line
            if (nextNewlineIndex === -1) {
              nextNewlineIndex = rootString.length;
            }

            const rawLineLength = nextNewlineIndex - match.endIndex;
            const excludedLength = skippedSubStrings[skippedSubStringsIndex] ?
            tryToPopSubString(match.endIndex, nextNewlineIndex) :
            0;
            const lineText = rootString.slice(match.endIndex, nextNewlineIndex);

            // Case sensitive ignorePattern match
            if (optionsMatches(options, 'ignorePattern', lineText)) {
              return;
            }

            // If the line's length is less than or equal to the specified
            // max, ignore it ... So anything below is liable to be complained about.
            // **Note that the length of any url arguments or import urls
            // are excluded from the calculation.**
            if (rawLineLength - excludedLength <= maxLength) {
              return;
            }

            const complaintIndex = nextNewlineIndex - 1;

            if (ignoreComments) {
              if (match.insideComment) {
                return;
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars === '/*' || nextTwoChars === '//') {
                return;
              }
            }

            if (ignoreNonComments) {
              if (match.insideComment) {
                return complain(complaintIndex, root);
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars !== '/*' && nextTwoChars !== '//') {
                return;
              }

              return complain(complaintIndex, root);
            }

            // If there are no spaces besides initial (indent) spaces, ignore it
            const lineString = rootString.slice(match.endIndex, nextNewlineIndex);

            if (!lineString.replace(/^\s+/, '').includes(' ')) {
              return;
            }

            return complain(complaintIndex, root);
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "execall": 7, "lodash": 68, "style-search": 166 }], 298: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parser = require('postcss-selector-parser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'max-nesting-depth';

      const messages = ruleMessages(ruleName, {
        expected: depth => `Expected nesting depth to be no more than ${depth}` });


      function rule(max, options) {
        const isIgnoreAtRule = (node) =>
        node.type === 'atrule' && optionsMatches(options, 'ignoreAtRules', node.name);

        return (root, result) => {
          validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: [_.isNumber] },

          {
            optional: true,
            actual: options,
            possible: {
              ignore: ['blockless-at-rules', 'pseudo-classes'],
              ignoreAtRules: [_.isString, _.isRegExp] } });




          root.walkRules(checkStatement);
          root.walkAtRules(checkStatement);

          function checkStatement(statement) {
            if (isIgnoreAtRule(statement)) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            if (statement.selector && !isStandardSyntaxRule(statement)) {
              return;
            }

            const depth = nestingDepth(statement);

            if (depth > max) {
              report({
                ruleName,
                result,
                node: statement,
                message: messages.expected(max) });

            }
          }
        };

        function nestingDepth(node, level = 0) {
          const parent = node.parent;

          if (isIgnoreAtRule(parent)) {
            return 0;
          }

          // The nesting depth level's computation has finished
          // when this function, recursively called, receives
          // a node that is not nested -- a direct child of the
          // root node
          if (parent.type === 'root' || parent.type === 'atrule' && parent.parent.type === 'root') {
            return level;
          }

          function containsPseudoClassesOnly(selector) {
            const normalized = parser().processSync(selector, { lossless: false });
            const selectors = normalized.split(',');

            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            return selectors.every(selector => selector.startsWith('&:') && selector[2] !== ':');
          }

          if (
          optionsMatches(options, 'ignore', 'blockless-at-rules') &&
          node.type === 'atrule' &&
          node.every(child => child.type !== 'decl') ||
          optionsMatches(options, 'ignore', 'pseudo-classes') &&
          node.type === 'rule' &&
          containsPseudoClassesOnly(node.selector))
          {
            return nestingDepth(parent, level);
          }

          // Unless any of the conditions above apply, we want to
          // add 1 to the nesting depth level and then check the parent,
          // continuing to add and move up the hierarchy
          // until we hit the root node
          return nestingDepth(parent, level + 1);
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 437, "../../utils/isStandardSyntaxRule": 478, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-selector-parser": 90 }], 299: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((colonIndices, atRule) => {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              colonIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeColon = params.slice(0, index + 1);
                const afterColon = params.slice(index + 1);

                if (expectation === 'always') {
                  params = beforeColon + afterColon.replace(/^\s*/, ' ');
                } else if (expectation === 'never') {
                  params = beforeColon + afterColon.replace(/^\s*/, '');
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaFeatureColonSpaceChecker": 316 }], 300: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((colonIndices, atRule) => {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              colonIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeColon = params.slice(0, index);
                const afterColon = params.slice(index);

                if (expectation === 'always') {
                  params = beforeColon.replace(/\s*$/, ' ') + afterColon;
                } else if (expectation === 'never') {
                  params = beforeColon.replace(/\s*$/, '') + afterColon;
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaFeatureColonSpaceChecker": 316 }], 301: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (matchesStringOrRegExp(value, list)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 302: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'media-feature-name-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (!matchesStringOrRegExp(value, list)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 303: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            let hasComments = _.get(atRule, 'raws.params.raw');
            const mediaRule = hasComments ? hasComments : atRule.params;

            mediaParser(mediaRule).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              const expectedFeatureName =
              expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();

              if (value === expectedFeatureName) {
                return;
              }

              if (context.fix) {
                if (hasComments) {
                  hasComments =
                  hasComments.slice(0, sourceIndex) +
                  expectedFeatureName +
                  hasComments.slice(sourceIndex + expectedFeatureName.length);
                  _.set(atRule, 'raws.params.raw', hasComments);
                } else {
                  atRule.params =
                  atRule.params.slice(0, sourceIndex) +
                  expectedFeatureName +
                  atRule.params.slice(sourceIndex + expectedFeatureName.length);
                }

                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.expected(value, expectedFeatureName),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 304: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (!matchesStringOrRegExp(value, list)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 305: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'media-feature-name-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: mediaFeatureName => `Unexpected unknown media feature name "${mediaFeatureName}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreMediaFeatureNames: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (optionsMatches(options, 'ignoreMediaFeatureNames', value)) {
                return;
              }

              if (vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 306: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'media-feature-name-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (name, value) => `Unexpected value "${value}" for name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature-expression$/i, node => {
              const mediaFeatureRangeContext = isRangeContextMediaFeature(node.parent.value);

              // Ignore boolean
              if (!node.value.includes(':') && !mediaFeatureRangeContext) {
                return;
              }

              const mediaFeatureNode = _.find(node.nodes, { type: 'media-feature' });

              let mediaFeatureName;
              let values = [];

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                mediaFeatureName = parsedRangeContext.name.value;
                values = parsedRangeContext.values;
              } else {
                mediaFeatureName = mediaFeatureNode.value;
                values.push(_.find(node.nodes, { type: 'value' }));
              }

              for (let i = 0; i < values.length; i++) {
                const valueNode = values[i];
                const value = valueNode.value;
                const unprefixedMediaFeatureName = vendor.unprefixed(mediaFeatureName);

                const allowedValues = _.find(list, (v, featureName) =>
                matchesStringOrRegExp(unprefixedMediaFeatureName, featureName));


                if (allowedValues === undefined) {
                  return;
                }

                if (matchesStringOrRegExp(value, allowedValues)) {
                  return;
                }

                report({
                  index: atRuleParamIndex(atRule) + valueNode.sourceIndex,
                  message: messages.rejected(mediaFeatureName, value),
                  node: atRule,
                  ruleName,
                  result });

              }
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isRangeContextMediaFeature": 467, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 307: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'media-feature-name-value-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: (name, value) => `Unexpected value "${value}" for name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isObject] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'media-feature-name-value-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature-expression$/i, node => {
              const mediaFeatureRangeContext = isRangeContextMediaFeature(node.parent.value);

              // Ignore boolean
              if (!node.value.includes(':') && !mediaFeatureRangeContext) {
                return;
              }

              const mediaFeatureNode = _.find(node.nodes, { type: 'media-feature' });

              let mediaFeatureName;
              let values = [];

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                mediaFeatureName = parsedRangeContext.name.value;
                values = parsedRangeContext.values;
              } else {
                mediaFeatureName = mediaFeatureNode.value;
                values.push(_.find(node.nodes, { type: 'value' }));
              }

              for (let i = 0; i < values.length; i++) {
                const valueNode = values[i];
                const value = valueNode.value;
                const unprefixedMediaFeatureName = vendor.unprefixed(mediaFeatureName);

                const allowedValues = _.find(list, (v, featureName) =>
                matchesStringOrRegExp(unprefixedMediaFeatureName, featureName));


                if (allowedValues === undefined) {
                  return;
                }

                if (matchesStringOrRegExp(value, allowedValues)) {
                  return;
                }

                report({
                  index: atRuleParamIndex(atRule) + valueNode.sourceIndex,
                  message: messages.rejected(mediaFeatureName, value),
                  node: atRule,
                  ruleName,
                  result });

              }
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isRangeContextMediaFeature": 467, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 308: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'media-feature-name-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (matchesStringOrRegExp(value, list)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/isCustomMediaQuery": 454, "../../utils/isRangeContextMediaFeature": 467, "../../utils/isStandardSyntaxMediaFeatureName": 476, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../rangeContextNodeParser": 337, "lodash": 68, "postcss-media-query-parser": 83 }], 309: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'media-feature-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            // If there are comments in the params, the complete string
            // will be at atRule.raws.params.raw
            const params = _.get(atRule, 'raws.params.raw', atRule.params);
            const indexBoost = atRuleParamIndex(atRule);
            const violations = [];

            const parsedParams = valueParser(params).walk(node => {
              if (node.type === 'function') {
                const len = valueParser.stringify(node).length;

                if (expectation === 'never') {
                  if (/[ \t]/.test(node.before)) {
                    if (context.fix) node.before = '';

                    violations.push({
                      message: messages.rejectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (/[ \t]/.test(node.after)) {
                    if (context.fix) node.after = '';

                    violations.push({
                      message: messages.rejectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                } else if (expectation === 'always') {
                  if (node.before === '') {
                    if (context.fix) node.before = ' ';

                    violations.push({
                      message: messages.expectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (node.after === '') {
                    if (context.fix) node.after = ' ';

                    violations.push({
                      message: messages.expectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                }
              }
            });

            if (violations.length) {
              if (context.fix) {
                atRule.params = parsedParams.toString();

                return;
              }

              violations.forEach(err => {
                report({
                  message: err.message,
                  node: atRule,
                  index: err.index,
                  result,
                  ruleName });

              });
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 310: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after range operator',
        rejectedAfter: () => 'Unexpected whitespace after range operator' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            const fixOperatorIndices = [];
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkAfterOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              fixOperatorIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeOperator = params.slice(0, index + 1);
                const afterOperator = params.slice(index + 1);

                if (expectation === 'always') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, ' ');
                } else if (expectation === 'never') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, '');
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          function checkAfterOperator(match, params, node, fix) {
            const endIndex = match.startIndex + match.target.length - 1;

            checker.after({
              source: params,
              index: endIndex,
              err: m => {
                if (fix) {
                  fix(endIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: endIndex + atRuleParamIndex(node) + 1,
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../findMediaOperator": 260 }], 311: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before range operator',
        rejectedBefore: () => 'Unexpected whitespace before range operator' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            const fixOperatorIndices = [];
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkBeforeOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              fixOperatorIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeOperator = params.slice(0, index);
                const afterOperator = params.slice(index);

                if (expectation === 'always') {
                  params = beforeOperator.replace(/\s*$/, ' ') + afterOperator;
                } else if (expectation === 'never') {
                  params = beforeOperator.replace(/\s*$/, '') + afterOperator;
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          function checkBeforeOperator(match, params, node, fix) {
            // The extra `+ 1` is because the match itself contains
            // the character before the operator
            checker.before({
              source: params,
              index: match.startIndex,
              err: m => {
                if (fix) {
                  fix(match.startIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: match.startIndex - 1 + atRuleParamIndex(node),
                  result,
                  ruleName });

              } });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../findMediaOperator": 260 }], 312: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Only check for the newline after the comma, while allowing
          // arbitrary indentation after the newline
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            allowTrailingComments: expectation.startsWith('always'),
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, atRule) => {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (expectation.startsWith('always')) {
                  if (/^\s*\r?\n/.test(afterComma)) {
                    params = beforeComma + afterComma.replace(/^[^\S\r\n]*/, '');
                  } else {
                    params = beforeComma + context.newline + afterComma;
                  }
                } else if (expectation.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaQueryListCommaWhitespaceChecker": 317 }], 313: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      function rule(expectation) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaQueryListCommaWhitespaceChecker": 317 }], 314: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, atRule) => {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (expectation.startsWith('always')) {
                  params = beforeComma + afterComma.replace(/^\s*/, ' ');
                } else if (expectation.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaQueryListCommaWhitespaceChecker": 317 }], 315: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, atRule) => {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeComma = params.slice(0, index);
                const afterComma = params.slice(index);

                if (expectation.startsWith('always')) {
                  params = beforeComma.replace(/\s*$/, ' ') + afterComma;
                } else if (expectation.startsWith('never')) {
                  params = beforeComma.replace(/\s*$/, '') + afterComma;
                }
              });

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../mediaQueryListCommaWhitespaceChecker": 317 }], 316: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ':' }, match => {
            checkColon(params, match.startIndex, atRule);
          });
        });

        function checkColon(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              const colonIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, colonIndex)) {
                return;
              }

              report({
                message: m,
                node,
                index: colonIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 416, "../utils/report": 498, "style-search": 166 }], 317: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ',' }, match => {
            let index = match.startIndex;

            if (opts.allowTrailingComments) {
              // if there is a comment on the same line at after the comma, check the space after the comment.
              let execResult;

              while (execResult = /^[^\S\r\n]*\/\*([\s\S]*?)\*\//.exec(params.slice(index + 1))) {
                index += execResult[0].length;
              }

              if (execResult = /^([^\S\r\n]*\/\/([\s\S]*?))\r?\n/.exec(params.slice(index + 1))) {
                index += execResult[1].length;
              }
            }

            checkComma(params, index, atRule);
          });
        });

        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              const commaIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, commaIndex)) {
                return;
              }

              report({
                message: m,
                node,
                index: commaIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 416, "../utils/report": 498, "style-search": 166 }], 318: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isCustomPropertySet = require('../../utils/isCustomPropertySet');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const specificity = require('specificity');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-descending-specificity';

      const messages = ruleMessages(ruleName, {
        rejected: (b, a) => `Expected selector "${b}" to come before selector "${a}"` });


      function rule(on, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: on },

          {
            optional: true,
            actual: options,
            possible: {
              ignore: ['selectors-within-list'] } });




          if (!validOptions) {
            return;
          }

          const selectorContextLookup = nodeContextLookup();

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            // Ignore custom property set `--foo: {};`
            if (isCustomPropertySet(rule)) {
              return;
            }

            // Ignore nested property `foo: {};`
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            // Ignores selectors within list of selectors
            if (optionsMatches(options, 'ignore', 'selectors-within-list') && rule.selectors.length > 1) {
              return;
            }

            const comparisonContext = selectorContextLookup.getContext(rule, findAtRuleContext(rule));

            rule.selectors.forEach(selector => {
              const trimSelector = selector.trim();

              // Ignore `.selector, { }`
              if (trimSelector === '') {
                return;
              }

              // The edge-case of duplicate selectors will act acceptably
              const index = rule.selector.indexOf(trimSelector);

              // Resolve any nested selectors before checking
              resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, rule, s => {
                  if (!isStandardSyntaxSelector(resolvedSelector)) {
                    return;
                  }

                  checkSelector(s, rule, index, comparisonContext);
                });
              });
            });
          });

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkSelector(selectorNode, rule, sourceIndex, comparisonContext) {
            const selector = selectorNode.toString();
            const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode);
            const selectorSpecificity = specificity.calculate(selector)[0].specificityArray;
            const entry = { selector, specificity: selectorSpecificity };

            if (!comparisonContext.has(referenceSelectorNode)) {
              comparisonContext.set(referenceSelectorNode, [entry]);

              return;
            }

            const priorComparableSelectors = comparisonContext.get(referenceSelectorNode);

            priorComparableSelectors.forEach(priorEntry => {
              if (specificity.compare(selectorSpecificity, priorEntry.specificity) === -1) {
                report({
                  ruleName,
                  result,
                  node: rule,
                  message: messages.rejected(selector, priorEntry.selector),
                  index: sourceIndex });

              }
            });

            priorComparableSelectors.push(entry);
          }
        };
      }

      function lastCompoundSelectorWithoutPseudoClasses(selectorNode) {
        const nodesAfterLastCombinator = _.last(
        selectorNode.nodes[0].split(node => {
          return node.type === 'combinator';
        }));


        const nodesWithoutPseudoClasses = nodesAfterLastCombinator.
        filter(node => {
          return node.type !== 'pseudo' || keywordSets.pseudoElements.has(node.value.replace(/:/g, ''));
        }).
        join('');

        return nodesWithoutPseudoClasses.toString();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/findAtRuleContext": 428, "../../utils/isCustomPropertySet": 456, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/nodeContextLookup": 489, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87, "specificity": 165 }], 319: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const mediaParser = require('postcss-media-query-parser').default;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'no-duplicate-at-import-rules';

      const messages = ruleMessages(ruleName, {
        rejected: atImport => `Unexpected duplicate @import rule ${atImport}` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          const imports = {};

          root.walkAtRules(/^import$/i, atRule => {
            const params = valueParser(atRule.params).nodes;

            if (!params.length) {
              return;
            }

            // extract uri from url() if exists
            const uri =
            params[0].type === 'function' && params[0].value === 'url' ?
            params[0].nodes[0].value :
            params[0].value;
            // extract media queries if any
            const media = mediaParser(valueParser.stringify(params.slice(1))).
            nodes.map(n => n.value.replace(/\s/g, '')).
            filter(n => n.length);

            const isDuplicate = media.length ?
            imports[uri] && media.some(q => imports[uri].includes(q)) :
            imports[uri];

            if (isDuplicate) {
              report({
                message: messages.rejected(uri),
                node: atRule,
                result,
                ruleName });


              return;
            }

            if (!imports[uri]) imports[uri] = [];

            imports[uri] = imports[uri].concat(media);
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-media-query-parser": 83, "postcss-value-parser": 120 }], 320: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const normalizeSelector = require('normalize-selector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-duplicate-selectors';

      const messages = ruleMessages(ruleName, {
        rejected: (selector, firstDuplicateLine) =>
        `Unexpected duplicate selector "${selector}", first used at line ${firstDuplicateLine}` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              disallowInList: _.isBoolean },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldDisallowDuplicateInList = _.get(options, 'disallowInList');

          // The top level of this map will be rule sources.
          // Each source maps to another map, which maps rule parents to a set of selectors.
          // This ensures that selectors are only checked against selectors
          // from other rules that share the same parent and the same source.
          const selectorContextLookup = nodeContextLookup();

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (isKeyframeRule(rule)) {
              return;
            }

            const contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule));
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            const resolvedSelectors = rule.selectors.reduce((result, selector) => {
              return _.union(result, resolvedNestedSelector(selector, rule));
            }, []);

            const normalizedSelectorList = resolvedSelectors.map(normalizeSelector);

            // Sort the selectors list so that the order of the constituents
            // doesn't matter
            const sortedSelectorList = normalizedSelectorList.slice().sort().join(',');

            const selectorLine = rule.source.start.line;

            // Complain if the same selector list occurs twice

            let previousDuplicatePosition;
            // When `disallowInList` is true, we must parse `sortedSelectorList` into
            // list items.
            let selectorListParsed = [];

            if (shouldDisallowDuplicateInList) {
              parseSelector(sortedSelectorList, result, rule, selectors => {
                selectors.each(s => {
                  const selector = String(s);

                  selectorListParsed.push(selector);

                  if (contextSelectorSet.get(selector)) {
                    previousDuplicatePosition = contextSelectorSet.get(selector);
                  }
                });
              });
            } else {
              previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);
            }

            if (previousDuplicatePosition) {
              // If the selector isn't nested we can use its raw value; otherwise,
              // we have to approximate something for the message -- which is close enough
              const isNestedSelector = resolvedSelectors.join(',') !== rule.selectors.join(',');
              const selectorForMessage = isNestedSelector ? resolvedSelectors.join(', ') : rule.selector;

              return report({
                result,
                ruleName,
                node: rule,
                message: messages.rejected(selectorForMessage, previousDuplicatePosition) });

            }

            const presentedSelectors = new Set();
            const reportedSelectors = new Set();

            // Or complain if one selector list contains the same selector more than once
            rule.selectors.forEach(selector => {
              const normalized = normalizeSelector(selector);

              if (presentedSelectors.has(normalized)) {
                if (reportedSelectors.has(normalized)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  node: rule,
                  message: messages.rejected(selector, selectorLine) });

                reportedSelectors.add(normalized);
              } else {
                presentedSelectors.add(normalized);
              }
            });

            if (shouldDisallowDuplicateInList) {
              for (let selector of selectorListParsed) {
                // [selectorLine] will not really be accurate for multi-line
                // selectors, such as "bar" in "foo,\nbar {}".
                contextSelectorSet.set(selector, selectorLine);
              }
            } else {
              contextSelectorSet.set(sortedSelectorList, selectorLine);
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/findAtRuleContext": 428, "../../utils/isKeyframeRule": 460, "../../utils/nodeContextLookup": 489, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "normalize-selector": 72, "postcss-resolve-nested-selector": 87 }], 321: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-first-line';
      const noEmptyFirstLineTest = /^\s*[\r\n]/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty line' });


      function rule(actual, _, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions || root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;

          if (!rootString.trim()) {
            return;
          }

          if (noEmptyFirstLineTest.test(rootString)) {
            if (context.fix) {
              root.nodes[0].raws.before = root.first.raws.before.trimStart();

              return;
            }

            report({
              message: messages.rejected,
              node: root,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 322: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-source';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty source' });


      function rule(actual, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;

          if (rootString.trim()) {
            return;
          }

          report({
            message: messages.rejected,
            node: root,
            result,
            ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 323: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-eol-whitespace';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected whitespace at end of line' });


      const whitespacesToReject = new Set([' ', '\t']);

      function fixString(str) {
        return str.replace(/[ \t]+$/, '');
      }

      function findErrorStartIndex(
      lastEOLIndex,
      string,
      { ignoreEmptyLines, isRootFirst } = {
        ignoreEmptyLines: false,
        isRootFirst: false })

      {
        const eolWhitespaceIndex = lastEOLIndex - 1;

        // If the character before newline is not whitespace, ignore
        if (!whitespacesToReject.has(string[eolWhitespaceIndex])) {
          return -1;
        }

        if (ignoreEmptyLines) {
          // If there is only whitespace between the previous newline and
          // this newline, ignore
          const beforeNewlineIndex = string.lastIndexOf('\n', eolWhitespaceIndex);

          if (beforeNewlineIndex >= 0 || isRootFirst) {
            const line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);

            if (isOnlyWhitespace(line)) {
              return -1;
            }
          }
        }

        return eolWhitespaceIndex;
      }

      function rule(on, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: on },

          {
            optional: true,
            actual: options,
            possible: {
              ignore: ['empty-lines'] } });




          if (!validOptions) {
            return;
          }

          const ignoreEmptyLines = optionsMatches(options, 'ignore', 'empty-lines');

          if (context.fix) {
            fix(root);
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;
          const reportFromIndex = index => {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          };

          eachEolWhitespace(rootString, reportFromIndex, true);

          const errorIndex = findErrorStartIndex(rootString.length, rootString, {
            ignoreEmptyLines,
            isRootFirst: true });


          if (errorIndex > -1) {
            reportFromIndex(errorIndex);
          }

          /**
           * Iterate each whitespace at the end of each line of the given string.
           * @param {string} string the source code string
           * @param {Function} callback callback the whitespace index at the end of each line.
           * @param {boolean} isRootFirst set `true` if the given string is the first token of the root.
           * @returns {void}
           */
          function eachEolWhitespace(string, callback, isRootFirst) {
            styleSearch(
            {
              source: string,
              target: ['\n', '\r'],
              comments: 'check' },

            match => {
              // TODO: Issue #4985
              // eslint-disable-next-line no-shadow
              const errorIndex = findErrorStartIndex(match.startIndex, string, {
                ignoreEmptyLines,
                isRootFirst });


              if (errorIndex > -1) {
                callback(errorIndex);
              }
            });

          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function fix(root) {
            let isRootFirst = true;

            root.walk(node => {
              fixText(
              node.raws.before,
              fixed => {
                node.raws.before = fixed;
              },
              isRootFirst);

              isRootFirst = false;

              // AtRule
              fixText(node.raws.afterName, fixed => {
                node.raws.afterName = fixed;
              });

              if (node.raws.params) {
                fixText(node.raws.params.raw, fixed => {
                  node.raws.params.raw = fixed;
                });
              } else {
                fixText(node.params, fixed => {
                  node.params = fixed;
                });
              }

              // Rule
              if (node.raws.selector) {
                fixText(node.raws.selector.raw, fixed => {
                  node.raws.selector.raw = fixed;
                });
              } else {
                fixText(node.selector, fixed => {
                  node.selector = fixed;
                });
              }

              // AtRule or Rule or Decl
              fixText(node.raws.between, fixed => {
                node.raws.between = fixed;
              });

              // Decl
              if (node.raws.value) {
                fixText(node.raws.value.raw, fixed => {
                  node.raws.value.raw = fixed;
                });
              } else {
                fixText(node.value, fixed => {
                  node.value = fixed;
                });
              }

              // Comment
              fixText(node.raws.left, fixed => {
                node.raws.left = fixed;
              });

              if (node.raws.inline) {
                node.raws.right = fixString(node.raws.right);
              } else {
                fixText(node.raws.right, fixed => {
                  node.raws.right = fixed;
                });
              }

              fixText(node.text, fixed => {
                node.text = fixed;
              });

              fixText(node.raws.after, fixed => {
                node.raws.after = fixed;
              });
            });

            fixText(
            root.raws.after,
            fixed => {
              root.raws.after = fixed;
            },
            isRootFirst);


            if (typeof root.raws.after === 'string') {
              const lastEOL = Math.max(
              root.raws.after.lastIndexOf('\n'),
              root.raws.after.lastIndexOf('\r'));


              if (lastEOL !== root.raws.after.length - 1) {
                root.raws.after =
                root.raws.after.slice(0, lastEOL + 1) + fixString(root.raws.after.slice(lastEOL + 1));
              }
            }
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function fixText(value, fix, isRootFirst) {
            if (!value) {
              return;
            }

            let fixed = '';
            let lastIndex = 0;

            eachEolWhitespace(
            value,
            index => {
              const newlineIndex = index + 1;

              fixed += fixString(value.slice(lastIndex, newlineIndex));
              lastIndex = newlineIndex;
            },
            isRootFirst);


            if (lastIndex) {
              fixed += value.slice(lastIndex);
              fix(fixed);
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isOnlyWhitespace": 466, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 324: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomPropertySet = require('../../utils/isCustomPropertySet');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-extra-semicolons';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected extra semicolon' });


      function getOffsetByNode(node) {
        if (node.parent && node.parent.document) {
          return 0;
        }

        const string = node.root().source.input.css;
        const nodeColumn = node.source.start.column;
        const nodeLine = node.source.start.line;
        let line = 1;
        let column = 1;
        let index = 0;

        for (let i = 0; i < string.length; i++) {
          if (column === nodeColumn && nodeLine === line) {
            index = i;
            break;
          }

          if (string[i] === '\n') {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }

        return index;
      }

      function rule(actual, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          const rawAfterRoot = root.raws.after;

          if (rawAfterRoot && rawAfterRoot.trim().length !== 0) {
            const fixSemiIndices = [];

            styleSearch({ source: rawAfterRoot, target: ';' }, match => {
              if (context.fix) {
                fixSemiIndices.push(match.startIndex);

                return;
              }

              complain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);
            });

            // fix
            if (fixSemiIndices.length) {
              root.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);
            }
          }

          root.walk(node => {
            if (node.type === 'atrule' && !isStandardSyntaxAtRule(node)) {
              return;
            }

            if (node.type === 'rule' && !isCustomPropertySet(node) && !isStandardSyntaxRule(node)) {
              return;
            }

            let rawBeforeNode = node.raws.before;

            if (rawBeforeNode && rawBeforeNode.trim().length !== 0) {
              let allowedSemi = 0;

              const next = node.next();

              // Ignore semicolon before comment if next node is custom properties sets or comment
              if (
              node.type === 'comment' &&
              next &&
              isCustomPropertySet(next) &&
              node.parent.index(next) > 0)
              {
                allowedSemi = 1;
              }

              const prev = node.prev();

              let rawBeforeIndexStart = 0;

              // Adding previous node string to custom properties set if previous node is comment
              if (
              isCustomPropertySet(node) &&
              node.parent.index(node) > 0 &&
              prev &&
              prev.type === 'comment')
              {
                rawBeforeNode = prev.toString() + rawBeforeNode;
                allowedSemi = 0;
                rawBeforeIndexStart = prev.toString().length;
              }

              const fixSemiIndices = [];

              styleSearch({ source: rawBeforeNode, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex - rawBeforeIndexStart);

                  return;
                }

                complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.before = removeIndices(node.raws.before, fixSemiIndices);
              }
            }

            const rawAfterNode = node.raws.after;

            if (rawAfterNode && rawAfterNode.trim().length !== 0) {
              /**
               * If the last child is a Less mixin followed by more than one semicolon,
               * node.raws.after will be populated with that semicolon.
               * Since we ignore Less mixins, exit here
               */
              if (
              node.last &&
              node.last.type === 'atrule' &&
              !isCustomPropertySet(node.last) &&
              !isStandardSyntaxAtRule(node.last))
              {
                return;
              }

              const fixSemiIndices = [];

              styleSearch({ source: rawAfterNode, target: ';' }, match => {
                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                1 -
                rawAfterNode.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.after = removeIndices(rawAfterNode, fixSemiIndices);
              }
            }

            const rawOwnSemicolon = node.raws.ownSemicolon;

            if (rawOwnSemicolon) {
              let allowedSemi = 0;

              if (isCustomPropertySet(node)) {
                allowedSemi = 1;
              }

              const fixSemiIndices = [];

              styleSearch({ source: rawOwnSemicolon, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                rawOwnSemicolon.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);
              }
            }
          });

          function complain(index) {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          }

          function removeIndices(str, indices) {
            indices.reverse().forEach(index => {
              str = str.slice(0, index) + str.slice(index + 1);
            });

            return str;
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomPropertySet": 456, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/isStandardSyntaxRule": 478, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 325: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-invalid-double-slash-comments';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected double-slash CSS comment' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.startsWith('//')) {
              report({
                message: messages.rejected,
                node: decl,
                result,
                ruleName });

            }
          });
          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            rule.selectors.forEach(selector => {
              if (selector.startsWith('//')) {
                report({
                  message: messages.rejected,
                  node: rule,
                  result,
                  ruleName });

              }
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 326: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-missing-end-of-source-newline';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing end-of-source newline' });


      function rule(primary, _, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { primary });

          if (!validOptions) {
            return;
          }

          if (root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;

          if (!rootString.trim() || rootString.endsWith('\n')) {
            return;
          }

          // Fix
          if (context.fix) {
            root.raws.after = context.newline;

            return;
          }

          report({
            message: messages.rejected,
            node: root,
            index: rootString.length - 1,
            result,
            ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 327: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findAnimationName = require('../../utils/findAnimationName');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-unknown-animations';

      const messages = ruleMessages(ruleName, {
        rejected: animationName => `Unexpected unknown animation name "${animationName}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          const declaredAnimations = new Set();

          root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule => {
            declaredAnimations.add(atRule.params);
          });

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'animation' || decl.prop.toLowerCase() === 'animation-name') {
              const animationNames = findAnimationName(decl.value);

              if (animationNames.length === 0) {
                return;
              }

              animationNames.forEach(animationNameNode => {
                if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {
                  return;
                }

                if (declaredAnimations.has(animationNameNode.value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(animationNameNode.value),
                  node: decl,
                  index: declarationValueIndex(decl) + animationNameNode.sourceIndex });

              });
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/findAnimationName": 427, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 328: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-leading-zero';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a leading zero',
        rejected: 'Unexpected leading zero' });


      function rule(expectation, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            const neverFixPositions = [];
            const alwaysFixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              // Check leading zero
              if (expectation === 'always') {
                const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value);

                if (match === null) {
                  return;
                }

                // The regexp above consists of 2 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-.5" as an input
                // for regex. And we need the index of ".5".
                const capturingGroupIndex = match[0].length - match[1].length;

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  alwaysFixPositions.unshift({
                    index });


                  return;
                }

                complain(messages.expected, node, getIndex(node) + index);
              }

              if (expectation === 'never') {
                const match = /(?:\D|^)(0+)(\.\d+)/.exec(valueNode.value);

                if (match === null) {
                  return;
                }

                // The regexp above consists of 3 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-00.5"
                // as an input for regex. And we need the index of "00".
                const capturingGroupIndex = match[0].length - (match[1].length + match[2].length);

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  neverFixPositions.unshift({
                    startIndex: index,
                    // match[1].length is the length of our matched zero(s)
                    endIndex: index + match[1].length });


                  return;
                }

                complain(messages.rejected, node, getIndex(node) + index);
              }
            });

            if (alwaysFixPositions.length) {
              alwaysFixPositions.forEach(fixPosition => {
                const index = fixPosition.index;

                if (node.type === 'atrule') {
                  node.params = addLeadingZero(node.params, index);
                } else {
                  node.value = addLeadingZero(node.value, index);
                }
              });
            }

            if (neverFixPositions.length) {
              neverFixPositions.forEach(fixPosition => {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeLeadingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeLeadingZeros(node.value, startIndex, endIndex);
                }
              });
            }
          }

          function complain(message, node, index) {
            report({
              result,
              ruleName,
              message,
              node,
              index });

          }
        };
      }

      function addLeadingZero(input, index) {
        // eslint-disable-next-line prefer-template
        return input.slice(0, index) + '0' + input.slice(index);
      }

      function removeLeadingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 329: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const _ = require('lodash');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-max-precision';

      const messages = ruleMessages(ruleName, {
        expected: (number, precision) => `Expected "${number}" to be "${number.toFixed(precision)}"` });


      function rule(precision, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: precision,
            possible: [_.isNumber] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreUnits: [_.isString, _.isRegExp] } });




          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              const unit = getUnitFromValueNode(valueNode);

              if (optionsMatches(options, 'ignoreUnits', unit)) {
                return;
              }

              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\d*\.(\d+)/.exec(valueNode.value);

              if (match === null) {
                return;
              }

              if (match[1].length <= precision) {
                return;
              }

              report({
                result,
                ruleName,
                node,
                index: getIndex(node) + valueNode.sourceIndex + match.index,
                message: messages.expected(parseFloat(match[0]), precision) });

            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 330: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-no-trailing-zeros';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected trailing zero(s)' });


      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            const fixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\.(\d*?)(0+)(?:\D|$)/.exec(valueNode.value);

              // match[1] is any numbers between the decimal and our trailing zero, could be empty
              // match[2] is our trailing zero(s)
              if (match === null) {
                return;
              }

              // our index is:
              //  the index of our valueNode +
              //  the index of our match +
              //  1 for our decimal +
              //  the length of our potential non-zero number match (match[1])
              const index = valueNode.sourceIndex + match.index + 1 + match[1].length;

              // our startIndex is identical to our index except when we have only
              // trailing zeros after our decimal. in that case we don't need the decimal
              // either so we move our index back by 1.
              const startIndex = match[1].length > 0 ? index : index - 1;

              // our end index is our original index + the length of our trailing zeros
              const endIndex = index + match[2].length;

              if (context.fix) {
                fixPositions.unshift({
                  startIndex,
                  endIndex });


                return;
              }

              report({
                message: messages.rejected,
                node,
                // this is the index of the _first_ trailing zero
                index: getIndex(node) + index,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              fixPositions.forEach(fixPosition => {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeTrailingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeTrailingZeros(node.value, startIndex, endIndex);
                }
              });
            }
          }
        };
      }

      function removeTrailingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 331: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'property-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 332: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'property-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'property-disallowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 333: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'property-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            const expectedProp = expectation === 'lower' ? prop.toLowerCase() : prop.toUpperCase();

            if (prop === expectedProp) {
              return;
            }

            if (context.fix) {
              decl.prop = expectedProp;

              return;
            }

            report({
              message: messages.expected(prop, expectedProp),
              node: decl,
              ruleName,
              result });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 334: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'property-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 335: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const properties = require('known-css-properties').all;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'property-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected unknown property "${property}"` });


      function rule(actual, options) {
        const allValidProperties = new Set(properties);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreProperties: [_.isString, _.isRegExp],
              checkPrefixed: _.isBoolean,
              ignoreSelectors: [_.isString, _.isRegExp],
              ignoreAtRules: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldCheckPrefixed = _.get(options, 'checkPrefixed');

          root.walkDecls(checkStatement);

          function checkStatement(decl) {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!shouldCheckPrefixed && vendor.prefix(prop)) {
              return;
            }

            if (optionsMatches(options, 'ignoreProperties', prop)) {
              return;
            }

            const { selector } = decl.parent;

            if (selector && optionsMatches(options, 'ignoreSelectors', selector)) {
              return;
            }

            let node = decl.parent;

            while (node && node.type !== 'root') {
              const { type, name } = node;

              if (type === 'atrule' && optionsMatches(options, 'ignoreAtRules', name)) {
                return;
              }

              node = node.parent;
            }

            if (allValidProperties.has(prop.toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxDeclaration": 473, "../../utils/isStandardSyntaxProperty": 477, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "known-css-properties": 17, "lodash": 68 }], 336: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'property-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'property-allowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isCustomProperty": 455, "../../utils/isStandardSyntaxProperty": 477, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 337: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const rangeOperators = ['>=', '<=', '>', '<', '='];
      const styleSearch = require('style-search');

      function getRangeContextOperators(node) {
        const operators = [];

        styleSearch({ source: node.value, target: rangeOperators }, match => {
          const before = node[match.startIndex - 1];

          if (before === '>' || before === '<') {
            return;
          }

          operators.push(match.target);
        });

        // Sorting helps when using the operators to split
        // E.g. for "(10em < width <= 50em)" this returns ["<=", "<"]
        return operators.sort((a, b) => b.length - a.length);
      }

      function getRangeContextName(parsedNode) {
        // When the node is like "(10em < width < 50em)"
        // The parsedNode is ["10em", "width", "50em"] - the name is always in the second position
        if (parsedNode.length === 3) {
          return parsedNode[1];
        }

        // When the node is like "(width > 10em)" or "(10em < width)"
        // Regex is needed because the name can either be in the first or second position
        return parsedNode.find(value => value.match(/^(?!--)\D+/) || value.match(/^(--).+/));
      }

      module.exports = function (node) {
        const nodeValue = node.value;

        const operators = getRangeContextOperators(node);

        // Remove spaces and parentheses and split by the operators
        const parsedMedia = nodeValue.replace(/[()\s]/g, '').split(new RegExp(operators.join('|')));

        const name = getRangeContextName(parsedMedia);
        const nameObj = {
          value: name,
          sourceIndex: node.sourceIndex + nodeValue.indexOf(name) };


        const values = parsedMedia.
        filter(parsedValue => parsedValue !== name).
        map(value => {
          return {
            value,
            sourceIndex: node.sourceIndex + nodeValue.indexOf(value) };

        });

        return {
          name: nameObj,
          values };

      };

    }, { "style-search": 166 }], 338: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterSingleLineComment = require('../../utils/isAfterSingleLineComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before rule',
        rejected: 'Unexpected empty line before rule' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never', 'always-multi-line', 'never-multi-line'] },

          {
            actual: options,
            possible: {
              ignore: ['after-comment', 'first-nested', 'inside-block'],
              except: [
              'after-rule',
              'after-single-line-comment',
              'first-nested',
              'inside-block-and-after-rule',
              'inside-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            // Ignore the first node
            if (isFirstNodeOfRoot(rule)) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (
            optionsMatches(options, 'ignore', 'after-comment') &&
            rule.prev() &&
            rule.prev().type === 'comment')
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(rule)) {
              return;
            }

            const isNested = rule.parent.type !== 'root';

            // Optionally ignore the expectation if inside a block
            if (optionsMatches(options, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Ignore if the expectation is for multiple and the rule is single-line
            if (expectation.includes('multi-line') && isSingleLineString(rule.toString())) {
              return;
            }

            let expectEmptyLineBefore = Boolean(expectation.includes('always'));

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(options, 'except', 'first-nested') && isFirstNested(rule) ||
            optionsMatches(options, 'except', 'after-rule') && isAfterRule(rule) ||
            optionsMatches(options, 'except', 'inside-block-and-after-rule') &&
            isNested &&
            isAfterRule(rule) ||
            optionsMatches(options, 'except', 'after-single-line-comment') &&
            isAfterSingleLineComment(rule) ||
            optionsMatches(options, 'except', 'inside-block') && isNested)
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(rule.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(rule, context.newline);
              } else {
                removeEmptyLinesBefore(rule, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: rule,
              result,
              ruleName });

          });
        };
      }

      // TODO: Issue #4985
      // eslint-disable-next-line no-shadow
      function isAfterRule(rule) {
        const prevNode = getPreviousNonSharedLineCommentNode(rule);

        return prevNode && prevNode.type === 'rule';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 415, "../../utils/getPreviousNonSharedLineCommentNode": 434, "../../utils/hasEmptyLine": 439, "../../utils/isAfterSingleLineComment": 446, "../../utils/isFirstNested": 458, "../../utils/isFirstNodeOfRoot": 459, "../../utils/isSingleLineString": 470, "../../utils/isStandardSyntaxRule": 478, "../../utils/optionsMatches": 490, "../../utils/removeEmptyLinesBefore": 497, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 339: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-brackets-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "["',
        rejectedOpening: 'Unexpected whitespace after "["',
        expectedClosing: 'Expected single space before "]"',
        rejectedClosing: 'Unexpected whitespace before "]"' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[')) {
              return;
            }

            const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

            let hasFixed;
            const fixedSelector = parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeSelectorString = attributeNode.toString();

                styleSearch({ source: attributeSelectorString, target: '[' }, match => {
                  const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex + 1;

                  if (nextCharIsSpace && expectation === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.rejectedOpening, index);
                  }

                  if (!nextCharIsSpace && expectation === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.expectedOpening, index);
                  }
                });

                styleSearch({ source: attributeSelectorString, target: ']' }, match => {
                  const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex - 1;

                  if (prevCharIsSpace && expectation === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.rejectedClosing, index);
                  }

                  if (!prevCharIsSpace && expectation === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.expectedClosing, index);
                  }
                });
              });
            });

            if (hasFixed) {
              if (!rule.raws.selector) {
                rule.selector = fixedSelector;
              } else {
                rule.raws.selector.raw = fixedSelector;
              }
            }

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: rule });

            }
          });
        };

        function fixBefore(attributeNode) {
          const rawAttrBefore = _.get(attributeNode, 'raws.spaces.attribute.before');
          const { attrBefore, setAttrBefore } = rawAttrBefore ?
          {
            attrBefore: rawAttrBefore,
            setAttrBefore(fixed) {
              attributeNode.raws.spaces.attribute.before = fixed;
            } } :

          {
            attrBefore: _.get(attributeNode, 'spaces.attribute.before', ''),
            setAttrBefore(fixed) {
              _.set(attributeNode, 'spaces.attribute.before', fixed);
            } };


          if (expectation === 'always') {
            setAttrBefore(attrBefore.replace(/^\s*/, ' '));
          } else if (expectation === 'never') {
            setAttrBefore(attrBefore.replace(/^\s*/, ''));
          }
        }

        function fixAfter(attributeNode) {
          let key;

          if (attributeNode.operator) {
            if (attributeNode.insensitive) {
              key = 'insensitive';
            } else {
              key = 'value';
            }
          } else {
            key = 'attribute';
          }

          const rawAfter = _.get(attributeNode, `raws.spaces.${key}.after`);
          const { after, setAfter } = rawAfter ?
          {
            after: rawAfter,
            setAfter(fixed) {
              attributeNode.raws.spaces[key].after = fixed;
            } } :

          {
            after: _.get(attributeNode, `spaces.${key}.after`, ''),
            setAfter(fixed) {
              _.set(attributeNode, `spaces.${key}.after`, fixed);
            } };


          if (expectation === 'always') {
            setAfter(after.replace(/\s*$/, ' '));
          } else if (expectation === 'never') {
            setAfter(after.replace(/\s*$/, ''));
          }
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "style-search": 166 }], 340: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected name "${name}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeName = attributeNode.qualifiedAttribute;

                if (!matchesStringOrRegExp(attributeName, list)) {
                  return;
                }

                report({
                  message: messages.rejected(attributeName),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('attribute'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 341: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-operator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: rule,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 342: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-operator-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-attribute-operator-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && !list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: rule,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 343: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-operator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && !list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: rule,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 344: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: operator => `Expected single space after "${operator}"`,
        rejectedAfter: operator => `Unexpected whitespace after "${operator}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const checker = whitespaceChecker('space', expectation, messages);
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            checkBeforeOperator: false,
            fix: context.fix ?
            attributeNode => {
              const { operatorAfter, setOperatorAfter } = (() => {
                const rawOperator = _.get(attributeNode, 'raws.operator');

                if (rawOperator) {
                  // TODO: Issue #4985
                  // eslint-disable-next-line no-shadow
                  const operatorAfter = rawOperator.slice(attributeNode.operator.length);

                  return {
                    operatorAfter,
                    setOperatorAfter(fixed) {
                      delete attributeNode.raws.operator;
                      _.set(attributeNode, 'raws.spaces.operator.after', fixed);
                    } };

                }

                const rawOperatorAfter = _.get(attributeNode, 'raws.spaces.operator.after');

                if (rawOperatorAfter) {
                  return {
                    operatorAfter: rawOperatorAfter,
                    setOperatorAfter(fixed) {
                      attributeNode.raws.spaces.operator.after = fixed;
                    } };

                }

                return {
                  operatorAfter: _.get(attributeNode, 'spaces.operator.after', ''),
                  setOperatorAfter(fixed) {
                    _.set(attributeNode, 'spaces.operator.after', fixed);
                  } };

              })();

              if (expectation === 'always') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (expectation === 'never') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ''));

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorAttributeOperatorSpaceChecker": 389, "lodash": 68 }], 345: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}"`,
        rejectedBefore: operator => `Unexpected whitespace before "${operator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            checkBeforeOperator: true,
            fix: context.fix ?
            attributeNode => {
              const rawAttrAfter = _.get(attributeNode, 'raws.spaces.attribute.after');
              const { attrAfter, setAttrAfter } = rawAttrAfter ?
              {
                attrAfter: rawAttrAfter,
                setAttrAfter(fixed) {
                  attributeNode.raws.spaces.attribute.after = fixed;
                } } :

              {
                attrAfter: _.get(attributeNode, 'spaces.attribute.after', ''),
                setAttrAfter(fixed) {
                  _.set(attributeNode, 'spaces.attribute.after', fixed);
                } };


              if (expectation === 'always') {
                setAttrAfter(attrAfter.replace(/\s*$/, ' '));

                return true;
              }

              if (expectation === 'never') {
                setAttrAfter(attrAfter.replace(/\s*$/, ''));

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorAttributeOperatorSpaceChecker": 389, "lodash": 68 }], 346: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-operator-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-attribute-operator-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: rule,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 347: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-quotes';

      const messages = ruleMessages(ruleName, {
        expected: value => `Expected quotes around "${value}"`,
        rejected: value => `Unexpected quotes around "${value}"` });


      function rule(expectation) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.operator) {
                  return;
                }

                if (!attributeNode.quoted && expectation === 'always') {
                  complain(
                  messages.expected(attributeNode.value),
                  attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                }

                if (attributeNode.quoted && expectation === 'never') {
                  complain(
                  messages.rejected(attributeNode.value),
                  attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                }
              });
            });

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: rule });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 348: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolveNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-class-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected class selector ".${selectorValue}" to match pattern "${pattern}"` });


      function rule(pattern, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: pattern,
            possible: [_.isRegExp, _.isString] },

          {
            actual: options,
            possible: {
              resolveNestedSelectors: _.isBoolean },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldResolveNestedSelectors = _.get(options, 'resolveNestedSelectors');
          const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            const selector = rule.selector;
            const selectors = rule.selectors;

            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            // Only bother resolving selectors that have an interpolating &
            if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {
              // TODO: Issue #4985
              // eslint-disable-next-line no-shadow
              resolveNestedSelector(selector, rule).forEach(selector => {
                if (!isStandardSyntaxSelector(selector)) {
                  return;
                }

                parseSelector(selector, result, rule, s => checkSelector(s, rule));
              });
            } else {
              parseSelector(selector, result, rule, s => checkSelector(s, rule));
            }
          });

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkSelector(fullSelector, rule) {
            fullSelector.walkClasses(classNode => {
              const value = classNode.value;
              const sourceIndex = classNode.sourceIndex;

              if (normalizedPattern.test(value)) {
                return;
              }

              report({
                result,
                ruleName,
                message: messages.expected(value, pattern),
                node: rule,
                index: sourceIndex });

            });
          }
        };
      }

      // An "interpolating ampersand" means an "&" used to interpolate
      // within another simple selector, rather than an "&" that
      // stands on its own as a simple selector
      function hasInterpolatingAmpersand(selector) {
        for (let i = 0, l = selector.length; i < l; i++) {
          if (selector[i] !== '&') {
            continue;
          }

          if (selector[i - 1] !== undefined && !isCombinator(selector[i - 1])) {
            return true;
          }

          if (selector[i + 1] !== undefined && !isCombinator(selector[i + 1])) {
            return true;
          }
        }

        return false;
      }

      function isCombinator(x) {
        return /[\s+>~]/.test(x);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isKeyframeSelector": 461, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87 }], 349: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-combinator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: rule,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 472, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 350: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-combinator-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-combinator-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (!list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: rule,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 472, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 351: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-combinator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (!list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: rule,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 472, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 352: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: combinator => `Expected single space after "${combinator}"`,
        rejectedAfter: combinator => `Unexpected whitespace after "${combinator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            locationType: 'after',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (expectation === 'always') {
                combinator.spaces.after = ' ';

                return true;
              }

              if (expectation === 'never') {
                combinator.spaces.after = '';

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorCombinatorSpaceChecker": 390 }], 353: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: combinator => `Expected single space before "${combinator}"`,
        rejectedBefore: combinator => `Unexpected whitespace before "${combinator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            locationType: 'before',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (expectation === 'always') {
                combinator.spaces.before = ' ';

                return true;
              }

              if (expectation === 'never') {
                combinator.spaces.before = '';

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorCombinatorSpaceChecker": 390 }], 354: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-combinator-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-combinator-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: rule,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 472, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 355: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-descendant-combinator-no-non-space';

      const messages = ruleMessages(ruleName, {
        rejected: nonSpaceCharacter => `Unexpected "${nonSpaceCharacter}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            let hasFixed = false;
            const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

            // Return early for selectors containing comments
            // TODO: renable when parser and stylelint are compatible
            if (selector.includes('/*')) return;

            const fixedSelector = parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (combinatorNode.value !== ' ') {
                  return;
                }

                const value = combinatorNode.toString();

                if (
                value.includes('  ') ||
                value.includes('\t') ||
                value.includes('\n') ||
                value.includes('\r'))
                {
                  if (context.fix && /^\s+$/.test(value)) {
                    hasFixed = true;
                    combinatorNode.raws.value = ' ';
                    combinatorNode.rawSpaceBefore = combinatorNode.rawSpaceBefore.replace(/^\s+/, '');
                    combinatorNode.rawSpaceAfter = combinatorNode.rawSpaceAfter.replace(/\s+$/, '');

                    return;
                  }

                  report({
                    result,
                    ruleName,
                    message: messages.rejected(value),
                    node: rule,
                    index: combinatorNode.sourceIndex });

                }
              });
            });

            if (hasFixed) {
              if (!rule.raws.selector) {
                rule.selector = fixedSelector;
              } else {
                rule.raws.selector.raw = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 356: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-id-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected ID selector "#${selectorValue}" to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            parseSelector(selector, result, rule, fullSelector => {
              fullSelector.walk(selectorNode => {
                if (selectorNode.type !== 'id') {
                  return;
                }

                const value = selectorNode.value;
                const sourceIndex = selectorNode.sourceIndex;

                if (normalizedPattern.test(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.expected(value, pattern),
                  node: rule,
                  index: sourceIndex });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 357: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            // Get raw selector so we can allow end-of-line comments, e.g.
            // a, /* comment */
            // b {}
            const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

            const fixIndices = [];

            styleSearch(
            {
              source: selector,
              target: ',',
              functionArguments: 'skip' },

            match => {
              const nextChars = selector.substr(match.endIndex, selector.length - match.endIndex);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^\s+\/\//.test(nextChars)) {
                return;
              }

              // If there are spaces and then a comment begins, look for the newline
              const indextoCheckAfter = /^\s+\/\*/.test(nextChars) ?
              selector.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;

              checker.afterOneOnly({
                source: selector,
                index: indextoCheckAfter,
                err: m => {
                  if (context.fix) {
                    fixIndices.push(indextoCheckAfter + 1);

                    return;
                  }

                  report({
                    message: m,
                    node: rule,
                    index: match.startIndex,
                    result,
                    ruleName });

                } });

            });


            if (fixIndices.length) {
              let fixedSelector = selector;

              fixIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeSelector = fixedSelector.slice(0, index);
                let afterSelector = fixedSelector.slice(index);

                if (expectation.startsWith('always')) {
                  afterSelector = context.newline + afterSelector;
                } else if (expectation.startsWith('never-multi-line')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                fixedSelector = beforeSelector + afterSelector;
              });

              if (rule.raws.selector) {
                rule.raws.selector.raw = fixedSelector;
              } else {
                rule.selector = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "style-search": 166 }], 358: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, ruleNode) => {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (expectation.startsWith('always')) {
                  const spaceIndex = beforeSelector.search(/\s+$/);

                  if (spaceIndex >= 0) {
                    beforeSelector =
                    beforeSelector.slice(0, spaceIndex) +
                    context.newline +
                    beforeSelector.slice(spaceIndex);
                  } else {
                    beforeSelector += context.newline;
                  }
                } else if (expectation === 'never-multi-line') {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              });

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorListCommaWhitespaceChecker": 391 }], 359: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, ruleNode) => {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const beforeSelector = selector.slice(0, index + 1);
                let afterSelector = selector.slice(index + 1);

                if (expectation.startsWith('always')) {
                  afterSelector = afterSelector.replace(/^\s*/, ' ');
                } else if (expectation.startsWith('never')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                selector = beforeSelector + afterSelector;
              });

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorListCommaWhitespaceChecker": 391 }], 360: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, ruleNode) => {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (expectation.includes('always')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, ' ');
                } else if (expectation.includes('never')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              });

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../selectorListCommaWhitespaceChecker": 391 }], 361: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-attribute';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} attribute ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] },


          {
            actual: options,
            possible: {
              ignoreAttributes: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type !== 'attribute') {
                // Not an attribute node -> ignore
                return total;
              }

              if (optionsMatches(options, 'ignoreAttributes', childNode.attribute)) {
                // it's an attribute that is supposed to be ignored
                return total;
              }

              return total += 1;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isStandardSyntaxRule": 478, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87 }], 362: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${max === 1 ? 'class' : 'classes'}` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              return total += childNode.type === 'class' ? 1 : 0;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87 }], 363: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-combinators';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${
        max === 1 ? 'combinator' : 'combinators'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              return total += childNode.type === 'combinator' ? 1 : 0;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87 }], 364: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-compound-selectors';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} compound ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max > 0;
            }] });



          if (!validOptions) {
            return;
          }

          // Finds actual selectors in selectorNode object and checks them
          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkSelector(selectorNode, rule) {
            let compoundCount = 1;

            selectorNode.each(childNode => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, rule);
              }

              // Compound selectors are separated by combinators, so increase count when meeting one
              if (childNode.type === 'combinator') {
                compoundCount++;
              }
            });

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && compoundCount > max) {
              report({
                ruleName,
                result,
                node: rule,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            // Using `rule.selectors` gets us each selector if there is a comma separated set
            rule.selectors.forEach(selector => {
              resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {
                // Process each resolved selector with `checkSelector` via postcss-selector-parser
                parseSelector(resolvedSelector, result, rule, s => checkSelector(s, rule));
              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87 }], 365: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function rule(max, options, context) {
        const maxAdjacentNewlines = max + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: _.isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

            if (context.fix) {
              const newSelectorString = selector.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              if (rule.raws.selector) {
                rule.raws.selector.raw = newSelectorString;
              } else {
                rule.selector = newSelectorString;
              }
            } else if (
            violatedLFNewLinesRegex.test(selector) ||
            violatedCRLFNewLinesRegex.test(selector))
            {
              report({
                message: messages.expected(max),
                node: rule,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 366: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-id';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ID ${max === 1 ? 'selector' : 'selectors'}` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] },


          {
            actual: options,
            possible: {
              ignoreContextFunctionalPseudoClasses: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes that are not part of ignored functional pseudo-classes
              if (
              childNode.type === 'selector' ||
              isContextFunctionalPseudoClass(childNode) &&
              !isIgnoredContextFunctionalPseudoClass(childNode, options))
              {
                checkSelector(childNode, ruleNode);
              }

              return total += childNode.type === 'id' ? 1 : 0;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function isIgnoredContextFunctionalPseudoClass(node, options) {
            return (
              node.type === 'pseudo' &&
              optionsMatches(options, 'ignoreContextFunctionalPseudoClasses', node.value));

          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isStandardSyntaxRule": 478, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87 }], 367: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-pseudo-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} pseudo-${max === 1 ? 'class' : 'classes'}` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              // Exclude pseudo elements from the count
              if (
              childNode.type === 'pseudo' && (
              childNode.value.includes('::') ||
              keywordSets.levelOneAndTwoPseudoElements.has(childNode.value.toLowerCase().slice(1))))
              {
                return total;
              }

              if (childNode.type === 'pseudo') {
                return total += 1;
              }

              return total;
            }, 0);

            if (count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, rule, selectorTree => {
                  checkSelector(selectorTree, ruleNode);
                });
              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87 }], 368: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const specificity = require('specificity');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-specificity';

      const messages = ruleMessages(ruleName, {
        // TODO: Issue #4985
        // eslint-disable-next-line no-shadow
        expected: (selector, specificity) =>
        `Expected "${selector}" to have a specificity no more than "${specificity}"` });


      // Return an array representation of zero specificity. We need a new array each time so that it can mutated
      const zeroSpecificity = () => [0, 0, 0, 0];

      // Calculate the sum of given array of specificity arrays
      const specificitySum = specificities => {
        const sum = zeroSpecificity();

        specificities.forEach(specificityArray => {
          specificityArray.forEach((value, i) => {
            sum[i] += value;
          });
        });

        return sum;
      };

      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              // Check that the max specificity is in the form "a,b,c"
              return /^\d+,\d+,\d+$/.test(max);
            }] },


          {
            actual: options,
            possible: {
              ignoreSelectors: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value)
          const simpleSpecificity = selector => {
            if (optionsMatches(options, 'ignoreSelectors', selector)) {
              return zeroSpecificity();
            }

            return specificity.calculate(selector)[0].specificityArray;
          };

          // Calculate the the specificity of the most specific direct child
          const maxChildSpecificity = (node) =>
          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          node.reduce((max, child) => {
            const childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define

            return specificity.compare(childSpecificity, max) === 1 ? childSpecificity : max;
          }, zeroSpecificity());

          // Calculate the specificity of a pseudo selector including own value and children
          const pseudoSpecificity = node => {
            // `node.toString()` includes children which should be processed separately,
            // so use `node.value` instead
            const ownValue = node.value;
            const ownSpecificity =
            ownValue === ':not' || ownValue === ':matches' ?
            // :not and :matches don't add specificity themselves, but their children do
            zeroSpecificity() :
            simpleSpecificity(ownValue);

            return specificitySum([ownSpecificity, maxChildSpecificity(node)]);
          };

          const shouldSkipPseudoClassArgument = node => {
            // postcss-selector-parser includes the arguments to nth-child() functions
            // as "tags", so we need to ignore them ourselves.
            // The fake-tag's "parent" is actually a selector node, whose parent
            // should be the :nth-child pseudo node.
            const parentNode = node.parent.parent;

            if (parentNode && parentNode.value) {
              const parentNodeValue = parentNode.value;
              const normalisedParentNode = parentNodeValue.toLowerCase().replace(/:+/, '');

              return (
                parentNode.type === 'pseudo' && (
                keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentNode) ||
                keywordSets.linguisticPseudoClasses.has(normalisedParentNode)));

            }

            return false;
          };

          // Calculate the specificity of a node parsed by `postcss-selector-parser`
          const nodeSpecificity = node => {
            if (shouldSkipPseudoClassArgument(node)) {
              return zeroSpecificity();
            }

            switch (node.type) {
              case 'attribute':
              case 'class':
              case 'id':
              case 'tag':
                return simpleSpecificity(node.toString());
              case 'pseudo':
                return pseudoSpecificity(node);
              case 'selector':
                // Calculate the sum of all the direct children
                return specificitySum(node.map(nodeSpecificity));
              default:
                return zeroSpecificity();}

          };

          const maxSpecificityArray = `0,${max}`.split(',').map(parseFloat);

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            // Using rule.selectors gets us each selector in the eventuality we have a comma separated set
            rule.selectors.forEach(selector => {
              resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {
                try {
                  // Skip non-standard syntax selectors
                  if (!isStandardSyntaxSelector(resolvedSelector)) {
                    return;
                  }

                  parseSelector(resolvedSelector, result, rule, selectorTree => {
                    // Check if the selector specificity exceeds the allowed maximum
                    if (
                    specificity.compare(maxChildSpecificity(selectorTree), maxSpecificityArray) === 1)
                    {
                      report({
                        ruleName,
                        result,
                        node: rule,
                        message: messages.expected(resolvedSelector, max),
                        word: selector });

                    }
                  });
                } catch (e) {
                  result.warn('Cannot parse selector', {
                    node: rule,
                    stylelintType: 'parseError' });

                }
              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87, "specificity": 165 }], 369: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-type';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} type ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            possible(max) {
              return typeof max === 'number' && max >= 0;
            } },

          {
            actual: options,
            possible: {
              ignore: ['descendant', 'child', 'compounded', 'next-sibling'],
              ignoreTypes: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreDescendant = optionsMatches(options, 'ignore', 'descendant');
          const ignoreChild = optionsMatches(options, 'ignore', 'child');
          const ignoreCompounded = optionsMatches(options, 'ignore', 'compounded');
          const ignoreNextSibling = optionsMatches(options, 'ignore', 'next-sibling');

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (optionsMatches(options, 'ignoreTypes', childNode.value)) {
                return total;
              }

              if (ignoreDescendant && hasDescendantCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreChild && hasChildCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreCompounded && hasCompoundSelector(childNode)) {
                return total;
              }

              if (ignoreNextSibling && hasNextSiblingCombinator(childNode)) {
                return total;
              }

              if (childNode.type === 'tag' && !isStandardSyntaxTypeSelector(childNode)) {
                return total;
              }

              return total + (childNode.type === 'tag');
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            ruleNode.selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                if (!isStandardSyntaxSelector(resolvedSelector)) {
                  return;
                }

                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      function hasDescendantCombinatorBefore(node) {
        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(isDescendantCombinator);
      }

      function hasChildCombinatorBefore(node) {
        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(isChildCombinator);
      }

      function hasCompoundSelector(node) {
        if (node.prev() && !isCombinator(node.prev())) {
          return true;
        }

        return node.next() && !isCombinator(node.next());
      }

      function hasNextSiblingCombinator(node) {
        return node.prev() && isNextSiblingCombinator(node.prev());
      }

      function isCombinator(node) {
        if (!node) return false;

        return _.get(node, 'type') === 'combinator';
      }

      function isDescendantCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && isOnlyWhitespace(node.value);
      }

      function isChildCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && node.value === '>';
      }

      function isNextSiblingCombinator(node) {
        return isCombinator(node) && node.value === '+';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 450, "../../utils/isKeyframeSelector": 461, "../../utils/isOnlyWhitespace": 466, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/isStandardSyntaxTypeSelector": 480, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-resolve-nested-selector": 87 }], 370: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const selectorParser = require('postcss-selector-parser');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-universal';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} universal ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: [
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            function (max) {
              return typeof max === 'number' && max >= 0;
            }] });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              // All logical combinations will be resolved as nested selector in `postcss-resolve-nested-selector`
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              return total += childNode.type === 'universal' ? 1 : 0;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selectors = [];

            selectorParser().
            astSync(ruleNode.selector).
            walk(node => {
              if (node.type === 'selector') {
                selectors.push(String(node).trim());
              }
            });

            selectors.forEach(selector => {
              resolvedNestedSelector(selector, ruleNode).forEach(resolvedSelector => {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87, "postcss-selector-parser": 90 }], 371: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-nested-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selector, pattern) =>
        `Expected nested selector "${selector}" to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [_.isRegExp, _.isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern;

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (rule.parent.type !== 'rule') {
              return;
            }

            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (normalizedPattern.test(selector)) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.expected(selector, pattern),
              node: rule });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 372: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-no-qualifying-type';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected qualifying type selector' });


      const selectorCharacters = ['#', '.', '['];

      function isSelectorCharacters(value) {
        return selectorCharacters.some(char => value.includes(char));
      }

      function getRightNodes(node) {
        const result = [];
        let rightNode = node;

        while (rightNode = rightNode.next()) {
          if (rightNode.type === 'combinator') {
            break;
          }

          if (rightNode.type !== 'id' && rightNode.type !== 'class' && rightNode.type !== 'attribute') {
            continue;
          }

          result.push(rightNode);
        }

        return result;
      }

      function rule(enabled, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: enabled,
            possible: [true, false] },

          {
            actual: options,
            possible: {
              ignore: ['attribute', 'class', 'id'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (isKeyframeRule(rule)) {
              return;
            }

            if (!isSelectorCharacters(rule.selector)) {
              return;
            }

            function checkSelector(selectorAST) {
              selectorAST.walkTags(selector => {
                const selectorParent = selector.parent;

                if (selectorParent.nodes.length === 1) {
                  return;
                }

                const selectorNodes = getRightNodes(selector);
                const index = selector.sourceIndex;

                selectorNodes.forEach(selectorNode => {
                  if (selectorNode.type === 'id' && !optionsMatches(options, 'ignore', 'id')) {
                    complain(index);
                  }

                  if (selectorNode.type === 'class' && !optionsMatches(options, 'ignore', 'class')) {
                    complain(index);
                  }

                  if (
                  selectorNode.type === 'attribute' &&
                  !optionsMatches(options, 'ignore', 'attribute'))
                  {
                    complain(index);
                  }
                });
              });
            }

            resolvedNestedSelector(rule.selector, rule).forEach(resolvedSelector => {
              if (!isStandardSyntaxSelector(resolvedSelector)) {
                return;
              }

              parseSelector(resolvedSelector, result, rule, checkSelector);
            });

            function complain(index) {
              report({
                ruleName,
                result,
                node: rule,
                message: messages.rejected,
                index });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isKeyframeRule": 460, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-resolve-nested-selector": 87 }], 373: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-class-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 374: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-class-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-pseudo-class-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements

                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 375: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            const fixedSelector = parseSelector(
            rule.raws.selector ? rule.raws.selector.raw : rule.selector,
            result,
            rule,
            selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudo = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudo)) {
                  return;
                }

                if (
                pseudo.includes('::') ||
                keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudo =
                expectation === 'lower' ? pseudo.toLowerCase() : pseudo.toUpperCase();

                if (pseudo === expectedPseudo) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudo;

                  return;
                }

                report({
                  message: messages.expected(pseudo, expectedPseudo),
                  node: rule,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });


            if (context.fix) {
              if (rule.raws.selector) {
                rule.raws.selector.raw = fixedSelector;
              } else {
                rule.selector = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 376: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-class-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements

                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 377: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomSelector = require('../../utils/isCustomSelector');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-class-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-class selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignorePseudoClasses: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function check(selector, result, node) {
            parseSelector(selector, result, node, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                if (isCustomSelector(value)) {
                  return;
                }

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                if (optionsMatches(options, 'ignorePseudoClasses', pseudoNode.value.slice(1))) {
                  return;
                }

                let index = null;
                const name = value.slice(1).toLowerCase();

                if (node.type === 'atrule' && node.name === 'page') {
                  if (keywordSets.atRulePagePseudoClasses.has(name)) {
                    return;
                  }

                  index = atRuleParamIndex(node) + pseudoNode.sourceIndex;
                } else {
                  if (
                  vendor.prefix(name) ||
                  keywordSets.pseudoClasses.has(name) ||
                  keywordSets.pseudoElements.has(name))
                  {
                    return;
                  }

                  let prevPseudoElement = pseudoNode;

                  do {
                    prevPseudoElement = prevPseudoElement.prev();

                    if (prevPseudoElement && prevPseudoElement.value.slice(0, 2) === '::') {
                      break;
                    }
                  } while (prevPseudoElement);

                  if (prevPseudoElement) {
                    const prevPseudoElementValue = vendor.unprefixed(
                    prevPseudoElement.value.toLowerCase().slice(2));


                    if (
                    keywordSets.webkitProprietaryPseudoElements.has(prevPseudoElementValue) &&
                    keywordSets.webkitProprietaryPseudoClasses.has(name))
                    {
                      return;
                    }
                  }

                  index = pseudoNode.sourceIndex;
                }

                report({
                  message: messages.rejected(value),
                  node,
                  index,
                  ruleName,
                  result });

              });
            });
          }

          root.walk(node => {
            let selector = null;

            if (node.type === 'rule') {
              if (!isStandardSyntaxRule(node)) {
                return;
              }

              selector = node.selector;
            } else if (node.type === 'atrule' && node.name === 'page' && node.params) {
              if (!isStandardSyntaxAtRule(node)) {
                return;
              }

              selector = node.params;
            }

            // Return if selector empty, it is meaning node type is not a rule or a at-rule

            if (!selector) {
              return;
            }

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            check(selector, result, node);
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/atRuleParamIndex": 416, "../../utils/isCustomSelector": 457, "../../utils/isStandardSyntaxAtRule": 471, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 378: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('(')) {
              return;
            }

            let hasFixed = false;
            const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;
            const fixedSelector = parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                if (!pseudoNode.length) {
                  return;
                }

                const paramString = pseudoNode.map(String).join(',');
                const nextCharIsSpace = paramString.startsWith(' ');
                const openIndex =
                pseudoNode.sourceIndex + stringifyProperty(pseudoNode, 'value').length + 1;

                if (nextCharIsSpace && expectation === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, '');
                  } else {
                    complain(messages.rejectedOpening, openIndex);
                  }
                }

                if (!nextCharIsSpace && expectation === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedOpening, openIndex);
                  }
                }

                const prevCharIsSpace = paramString.endsWith(' ');
                const closeIndex = openIndex + paramString.length - 1;

                if (prevCharIsSpace && expectation === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, '');
                  } else {
                    complain(messages.rejectedClosing, closeIndex);
                  }
                }

                if (!prevCharIsSpace && expectation === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedClosing, closeIndex);
                  }
                }
              });
            });

            if (hasFixed) {
              if (!rule.raws.selector) {
                rule.selector = fixedSelector;
              } else {
                rule.raws.selector.raw = fixedSelector;
              }
            }

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: rule });

            }
          });
        };
      }

      function setFirstNodeSpaceBefore(node, value) {
        const target = node.first;

        if (target.type === 'selector') {
          setFirstNodeSpaceBefore(target, value);
        } else {
          target.spaces.before = value;
        }
      }

      function setLastNodeSpaceAfter(node, value) {
        const target = node.last;

        if (target.type === 'selector') {
          setLastNodeSpaceAfter(target, value);
        } else {
          target.spaces.after = value;
        }
      }

      function stringifyProperty(node, propName) {
        return node.raws && node.raws[propName] || node[propName];
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 379: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-class-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-pseudo-class-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 380: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-element-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 381: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-element-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-pseudo-element-disallowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 382: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const transformSelector = require('../../utils/transformSelector');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes(':')) {
              return;
            }

            transformSelector(result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudoElement = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudoElement)) {
                  return;
                }

                if (
                !pseudoElement.includes('::') &&
                !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudoElement =
                expectation === 'lower' ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase();

                if (pseudoElement === expectedPseudoElement) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudoElement;

                  return;
                }

                report({
                  message: messages.expected(pseudoElement, expectedPseudoElement),
                  node: rule,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/transformSelector": 500, "../../utils/validateOptions": 503 }], 383: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-colon-notation';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} colon pseudo-element notation` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['single', 'double'] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            // get out early if no pseudo elements or classes
            if (!selector.includes(':')) {
              return;
            }

            const fixPositions = [];

            // match only level 1 and 2 pseudo elements
            const pseudoElementsWithColons = Array.from(keywordSets.levelOneAndTwoPseudoElements).map(
            x => `:${x}`);


            styleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, match => {
              const prevCharIsColon = selector[match.startIndex - 1] === ':';

              if (expectation === 'single' && !prevCharIsColon) {
                return;
              }

              if (expectation === 'double' && prevCharIsColon) {
                return;
              }

              if (context.fix) {
                fixPositions.unshift({ rule, startIndex: match.startIndex });

                return;
              }

              report({
                message: messages.expected(expectation),
                node: rule,
                index: match.startIndex,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              // If expecting : then we found :: so remove one of the colons
              // If expecting :: then we found : so add one extra colon
              const expectedSingle = expectation === 'single';
              const offset = expectedSingle ? 1 : 0;
              const extraColon = expectedSingle ? '' : ':';

              fixPositions.forEach(fixPosition => {
                rule.selector =
                rule.selector.substring(0, fixPosition.startIndex - offset) +
                extraColon +
                rule.selector.substring(fixPosition.startIndex);
              });
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxRule": 478, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "style-search": 166 }], 384: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-element-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 385: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-element-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-element selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignorePseudoElements: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                // Ignore pseudo-classes
                if (value.slice(0, 2) !== '::') {
                  return;
                }

                if (optionsMatches(options, 'ignorePseudoElements', pseudoNode.value.slice(2))) {
                  return;
                }

                const name = value.slice(2);

                if (vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {
                  return;
                }

                report({
                  message: messages.rejected(value),
                  node: rule,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxSelector": 479, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 386: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'selector-pseudo-element-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [_.isString, _.isRegExp] });


          if (!validOptions) {
            return;
          }

          result.warn(
          `'${ruleName}' has been deprecated. Instead use 'selector-pseudo-element-allowed-list'.`,
          {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });



          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            const selector = rule.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: rule,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 478, "../../utils/matchesStringOrRegExp": 487, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68 }], 387: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-type-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['lower', 'upper'] },

          {
            actual: options,
            possible: {
              ignoreTypes: [_.isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            let hasComments = _.get(rule, 'raws.selector.raw');
            const selector = hasComments ? hasComments : rule.selector;
            const selectors = rule.selectors;

            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, rule, selectorAST => {
              selectorAST.walkTags(tag => {
                if (!isStandardSyntaxTypeSelector(tag)) {
                  return;
                }

                if (optionsMatches(options, 'ignoreTypes', tag.value)) {
                  return;
                }

                const sourceIndex = tag.sourceIndex;
                const value = tag.value;

                const expectedValue = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();

                if (value === expectedValue) {
                  return;
                }

                if (context.fix) {
                  if (hasComments) {
                    hasComments =
                    hasComments.slice(0, sourceIndex) +
                    expectedValue +
                    hasComments.slice(sourceIndex + value.length);
                    _.set(rule, 'raws.selector.raw', hasComments);
                  } else {
                    rule.selector =
                    rule.selector.slice(0, sourceIndex) +
                    expectedValue +
                    rule.selector.slice(sourceIndex + value.length);
                  }

                  return;
                }

                report({
                  message: messages.expected(value, expectedValue),
                  node: rule,
                  index: sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isKeyframeSelector": 461, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxTypeSelector": 480, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 388: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const htmlTags = require('html-tags');
      const isCustomElement = require('../../utils/isCustomElement');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const keywordSets = require('../../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const svgTags = require('svg-tags');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-type-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown type selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignore: ['custom-elements', 'default-namespace'],
              ignoreNamespaces: [_.isString, _.isRegExp],
              ignoreTypes: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          root.walkRules(rule => {
            const selector = rule.selector;
            const selectors = rule.selectors;

            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, rule, selectorTree => {
              selectorTree.walkTags(tagNode => {
                if (!isStandardSyntaxTypeSelector(tagNode)) {
                  return;
                }

                if (
                optionsMatches(options, 'ignore', 'custom-elements') &&
                isCustomElement(tagNode.value))
                {
                  return;
                }

                if (
                optionsMatches(options, 'ignore', 'default-namespace') &&
                !(typeof tagNode.namespace === 'string'))
                {
                  return;
                }

                if (optionsMatches(options, 'ignoreNamespaces', tagNode.namespace)) {
                  return;
                }

                if (optionsMatches(options, 'ignoreTypes', tagNode.value)) {
                  return;
                }

                const tagName = tagNode.value;
                const tagNameLowerCase = tagName.toLowerCase();

                if (
                htmlTags.includes(tagNameLowerCase) ||
                // SVG tags are case-sensitive
                svgTags.includes(tagName) ||
                keywordSets.nonStandardHtmlTags.has(tagNameLowerCase) ||
                mathMLTags.includes(tagNameLowerCase))
                {
                  return;
                }

                report({
                  message: messages.rejected(tagName),
                  node: rule,
                  index: tagNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/isCustomElement": 453, "../../utils/isKeyframeSelector": 461, "../../utils/isStandardSyntaxRule": 478, "../../utils/isStandardSyntaxTypeSelector": 480, "../../utils/optionsMatches": 490, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "html-tags": 10, "lodash": 68, "mathml-tag-names": 71, "svg-tags": 514 }], 389: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (options) {
        options.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
            return;
          }

          let hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, options.result, rule, selectorTree => {
            selectorTree.walkAttributes(attributeNode => {
              const operator = attributeNode.operator;

              if (!operator) {
                return;
              }

              const attributeNodeString = attributeNode.toString();

              styleSearch({ source: attributeNodeString, target: operator }, match => {
                const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;

                checkOperator(attributeNodeString, index, rule, attributeNode, operator);
              });
            });
          });

          if (hasFixed) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }

          function checkOperator(source, index, node, attributeNode, operator) {
            options.locationChecker({
              source,
              index,
              err: m => {
                if (options.fix && options.fix(attributeNode)) {
                  hasFixed = true;

                  return;
                }

                report({
                  message: m.replace(
                  options.checkBeforeOperator ? operator[0] : operator[operator.length - 1],
                  operator),

                  node,
                  index: attributeNode.sourceIndex + index,
                  result: options.result,
                  ruleName: options.checkedRuleName });

              } });

          }
        });
      };

    }, { "../utils/isStandardSyntaxRule": 478, "../utils/parseSelector": 493, "../utils/report": 498, "style-search": 166 }], 390: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxCombinator = require('../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');

      module.exports = function (opts) {
        let hasFixed;

        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, opts.result, rule, selectorTree => {
            selectorTree.walkCombinators(node => {
              // Ignore non-standard combinators
              if (!isStandardSyntaxCombinator(node)) {
                return;
              }

              // Ignore spaced descendant combinator
              if (/\s/.test(node.value)) {
                return;
              }

              // Check the exist of node in prev of the combinator.
              // in case some that aren't the first begin with combinators (nesting syntax)
              if (opts.locationType === 'before' && !node.prev()) {
                return;
              }

              const parentParentNode = node.parent && node.parent.parent;

              // Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`
              if (parentParentNode && parentParentNode.type === 'pseudo') {
                return;
              }

              const sourceIndex = node.sourceIndex;
              const index =
              node.value.length > 1 && opts.locationType === 'before' ?
              sourceIndex :
              sourceIndex + node.value.length - 1;

              check(selector, node, index, rule, sourceIndex);
            });
          });

          if (hasFixed) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }
        });

        function check(source, combinator, index, node, sourceIndex) {
          opts.locationChecker({
            source,
            index,
            errTarget: combinator.value,
            err: m => {
              if (opts.fix && opts.fix(combinator)) {
                hasFixed = true;

                return;
              }

              report({
                message: m,
                node,
                index: sourceIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxCombinator": 472, "../utils/isStandardSyntaxRule": 478, "../utils/parseSelector": 493, "../utils/report": 498 }], 391: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          styleSearch(
          {
            source: selector,
            target: ',',
            functionArguments: 'skip' },

          match => {
            checkDelimiter(selector, match.startIndex, rule);
          });

        });

        function checkDelimiter(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message: m,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxRule": 478, "../utils/report": 498, "style-search": 166 }], 392: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'shorthand-property-no-redundant-values';

      const messages = ruleMessages(ruleName, {
        rejected: (unexpected, expected) =>
        `Unexpected longhand value '${unexpected}' instead of '${expected}'` });


      const propertiesWithShorthandNotation = new Set([
      'margin',
      'padding',
      'border-color',
      'border-radius',
      'border-style',
      'border-width',
      'grid-gap']);


      const ignoredCharacters = ['+', '*', '/', '(', ')', '$', '@', '--', 'var('];

      function hasIgnoredCharacters(value) {
        return ignoredCharacters.some(char => value.includes(char));
      }

      function isShorthandProperty(property) {
        return propertiesWithShorthandNotation.has(property);
      }

      function canCondense(top, right, bottom, left) {
        const lowerTop = top.toLowerCase();
        const lowerRight = right.toLowerCase();
        const lowerBottom = bottom && bottom.toLowerCase();
        const lowerLeft = left && left.toLowerCase();

        if (canCondenseToOneValue(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top];
        }

        if (canCondenseToTwoValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right];
        }

        if (canCondenseToThreeValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right, bottom];
        }

        return [top, right, bottom, left];
      }

      function canCondenseToOneValue(top, right, bottom, left) {
        if (top !== right) {
          return false;
        }

        return top === bottom && (bottom === left || !left) || !bottom && !left;
      }

      function canCondenseToTwoValues(top, right, bottom, left) {
        return top === bottom && right === left || top === bottom && !left && top !== right;
      }

      function canCondenseToThreeValues(top, right, bottom, left) {
        return right === left;
      }

      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
              return;
            }

            const prop = decl.prop;
            const value = decl.value;

            const normalizedProp = vendor.unprefixed(prop.toLowerCase());

            if (hasIgnoredCharacters(value) || !isShorthandProperty(normalizedProp)) {
              return;
            }

            const valuesToShorthand = [];

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'word') {
                return;
              }

              valuesToShorthand.push(valueParser.stringify(valueNode));
            });

            if (valuesToShorthand.length <= 1 || valuesToShorthand.length > 4) {
              return;
            }

            const shortestForm = canCondense(...valuesToShorthand);
            // TODO: Issue #4985
            // eslint-disable-next-line no-shadow
            const shortestFormString = shortestForm.filter(value => value).join(' ');
            const valuesFormString = valuesToShorthand.join(' ');

            if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
              return;
            }

            if (context.fix) {
              decl.value = decl.value.replace(value, shortestFormString);
            } else {
              report({
                message: messages.rejected(value, shortestFormString),
                node: decl,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxDeclaration": 473, "../../utils/isStandardSyntaxProperty": 477, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "postcss-value-parser": 120 }], 393: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'string-no-newline';
      const reNewLine = /(\r?\n)/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected newline in string' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkRule(rule) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(rule.selector)) {
              return;
            }

            if (!isStandardSyntaxSelector(rule.selector)) {
              return;
            }

            parseSelector(rule.selector, result, rule, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                if (!reNewLine.test(attributeNode.value)) {
                  return;
                }

                const openIndex = [
                // length of our attribute
                attributeNode.attribute,
                // length of our operator , ie '='
                attributeNode.operator,
                // length of the contents before newline
                RegExp.leftContext].
                reduce(
                (index, str) => index + str.length,
                // index of the start of our attribute node in our source
                attributeNode.sourceIndex);


                report({
                  message: messages.rejected,
                  node: rule,
                  index: openIndex,
                  result,
                  ruleName });

              });
            });
          }

          function checkDeclOrAtRule(node, value, getIndex) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(value)) {
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'string' || !reNewLine.test(valueNode.value)) {
                return;
              }

              const openIndex = [
              // length of the quote
              valueNode.quote,
              // length of the contents before newline
              RegExp.leftContext].
              reduce((index, str) => index + str.length, valueNode.sourceIndex);

              report({
                message: messages.rejected,
                node,
                index: getIndex(node) + openIndex,
                result,
                ruleName });

            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxSelector": 479, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 394: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'string-quotes';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} quotes` });


      const singleQuote = `'`;
      const doubleQuote = `"`;

      function rule(expectation, secondary, context) {
        const correctQuote = expectation === 'single' ? singleQuote : doubleQuote;
        const erroneousQuote = expectation === 'single' ? doubleQuote : singleQuote;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['single', 'double'] },

          {
            actual: secondary,
            possible: {
              avoidEscape: _.isBoolean },

            optional: true });



          if (!validOptions) {
            return;
          }

          const avoidEscape = _.get(secondary, 'avoidEscape', true);

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          // TODO: Issue #4985
          // eslint-disable-next-line no-shadow
          function checkRule(rule) {
            if (!isStandardSyntaxRule(rule)) {
              return;
            }

            if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
              return;
            }

            const fixPositions = [];

            parseSelector(rule.selector, result, rule, selectorTree => {
              let selectorFixed = false;

              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.quoted) {
                  return;
                }

                if (attributeNode.quoteMark === correctQuote) {
                  if (avoidEscape) {
                    const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                    const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                    if (needsOtherEscape) {
                      return;
                    }

                    if (needsCorrectEscape) {
                      if (context.fix) {
                        selectorFixed = true;
                        attributeNode.quoteMark = erroneousQuote;
                      } else {
                        report({
                          message: messages.expected(expectation === 'single' ? 'double' : expectation),
                          node: rule,
                          index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                          result,
                          ruleName });

                      }
                    }
                  }
                }

                if (attributeNode.quoteMark === erroneousQuote) {
                  if (avoidEscape) {
                    const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                    const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                    if (needsOtherEscape) {
                      if (context.fix) {
                        selectorFixed = true;
                        attributeNode.quoteMark = correctQuote;
                      } else {
                        report({
                          message: messages.expected(expectation),
                          node: rule,
                          index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                          result,
                          ruleName });

                      }

                      return;
                    }

                    if (needsCorrectEscape) {
                      return;
                    }
                  }

                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = correctQuote;
                  } else {
                    report({
                      message: messages.expected(expectation),
                      node: rule,
                      index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                      result,
                      ruleName });

                  }
                }
              });

              if (selectorFixed) {
                rule.selector = selectorTree.toString();
              }
            });

            fixPositions.forEach(fixIndex => {
              rule.selector = replaceQuote(rule.selector, fixIndex, correctQuote);
            });
          }

          function checkDeclOrAtRule(node, value, getIndex) {
            const fixPositions = [];

            // Get out quickly if there are no erroneous quotes
            if (!value.includes(erroneousQuote)) {
              return;
            }

            if (node.type === 'atrule' && node.name === 'charset') {
              // allow @charset rules to have double quotes, in spite of the configuration
              // TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {
                const needsEscape = valueNode.value.includes(correctQuote);

                if (avoidEscape && needsEscape) {
                  // don't consider this an error
                  return;
                }

                const openIndex = valueNode.sourceIndex;

                // we currently don't fix escapes
                if (context.fix && !needsEscape) {
                  const closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;

                  fixPositions.push(openIndex, closeIndex);
                } else {
                  report({
                    message: messages.expected(expectation),
                    node,
                    index: getIndex(node) + openIndex,
                    result,
                    ruleName });

                }
              }
            });

            fixPositions.forEach(fixIndex => {
              if (node.type === 'atrule') {
                node.params = replaceQuote(node.params, fixIndex, correctQuote);
              } else {
                node.value = replaceQuote(node.value, fixIndex, correctQuote);
              }
            });
          }
        };
      }

      function replaceQuote(string, index, replace) {
        return string.substring(0, index) + replace + string.substring(index + replace.length);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/isStandardSyntaxRule": 478, "../../utils/parseSelector": 493, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 395: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'time-min-milliseconds';

      const messages = ruleMessages(ruleName, {
        expected: time => `Expected a minimum of ${time} milliseconds` });


      const DELAY_PROPERTIES = ['animation-delay', 'transition-delay'];

      function rule(minimum, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: minimum,
            possible: _.isNumber },

          {
            actual: options,
            possible: {
              ignore: ['delay'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const propertyName = vendor.unprefixed(decl.prop.toLowerCase());

            if (
            keywordSets.longhandTimeProperties.has(propertyName) &&
            !isIgnoredProperty(propertyName) &&
            !isAcceptableTime(decl.value))
            {
              complain(decl);
            }

            if (keywordSets.shorthandTimeProperties.has(propertyName)) {
              const valueListList = postcss.list.comma(decl.value);

              for (const valueListString of valueListList) {
                const valueList = postcss.list.space(valueListString);

                if (optionsMatches(options, 'ignore', 'delay')) {
                  // Check only duration time values
                  const duration = getDuration(valueList);

                  if (duration && !isAcceptableTime(duration)) {
                    complain(decl, decl.value.indexOf(duration));
                  }
                } else {
                  // Check all time values
                  for (const value of valueList) {
                    if (!isAcceptableTime(value)) {
                      complain(decl, decl.value.indexOf(value));
                    }
                  }
                }
              }
            }
          });

          /**
           * Get the duration within an `animation` or `transition` shorthand property value.
           *
           * @param {Node[]} valueList
           *
           * @returns {Node}
           */
          function getDuration(valueList) {
            for (const value of valueList) {
              const parsedTime = valueParser.unit(value);

              if (!parsedTime) continue;

              // The first numeric value in an animation shorthand is the duration.
              return value;
            }
          }

          function isIgnoredProperty(propertyName) {
            if (optionsMatches(options, 'ignore', 'delay') && DELAY_PROPERTIES.includes(propertyName)) {
              return true;
            }

            return false;
          }

          function isAcceptableTime(time) {
            const parsedTime = valueParser.unit(time);

            if (!parsedTime) return true;

            if (parsedTime.number <= 0) {
              return true;
            }

            if (parsedTime.unit.toLowerCase() === 'ms' && parsedTime.number < minimum) {
              return false;
            }

            if (parsedTime.unit.toLowerCase() === 's' && parsedTime.number * 1000 < minimum) {
              return false;
            }

            return true;
          }

          function complain(decl, offset = 0) {
            report({
              result,
              ruleName,
              message: messages.expected(minimum),
              index: declarationValueIndex(decl) + offset,
              node: decl });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss": 137, "postcss-value-parser": 120 }], 396: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'unicode-bom';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected Unicode BOM',
        rejected: 'Unexpected Unicode BOM' });


      function rule(expectation) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (
          !validOptions ||
          root.source.inline ||
          root.source.lang === 'object-literal' ||
          // Ignore HTML documents
          root.document !== undefined)
          {
            return;
          }

          const { hasBOM } = root.source.input;

          if (expectation === 'always' && !hasBOM) {
            report({
              result,
              ruleName,
              message: messages.expected,
              root,
              line: 1 });

          }

          if (expectation === 'never' && hasBOM) {
            report({
              result,
              ruleName,
              message: messages.rejected,
              root,
              line: 1 });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503 }], 397: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      function rule(listInput, options) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [_.isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([_.isString, _.isRegExp]) } });




          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit || unit && list.includes(unit.toLowerCase())) {
                return;
              }

              if (options && optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {
                return;
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateObjectWithArrayProps": 502, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 398: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-blacklist';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      // a function to retrieve only the media feature name
      // could be externalized in an utils function if needed in other code
      const getMediaFeatureName = mediaFeatureNode => {
        const value = mediaFeatureNode.value.toLowerCase();

        return /((-?\w*)*)/i.exec(value)[1];
      };

      function rule(listInput, options) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [_.isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([_.isString, _.isRegExp]),
              ignoreMediaFeatureNames: validateObjectWithArrayProps([_.isString, _.isRegExp]) } });




          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'unit-disallowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          function check(node, nodeIndex, valueNode, input, option) {
            const unit = getUnitFromValueNode(valueNode);

            // There is not unit or it is not configured as a violation
            if (!unit || unit && !list.includes(unit.toLowerCase())) {
              return;
            }

            // The unit has an ignore option for the specific input
            if (optionsMatches(option, unit.toLowerCase(), input)) {
              return;
            }

            report({
              index: nodeIndex + valueNode.sourceIndex,
              message: messages.rejected(unit),
              node,
              result,
              ruleName });

          }

          function checkMedia(node, value, getIndex) {
            mediaParser(node.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const mediaName = getMediaFeatureName(mediaFeatureNode);
              const parentValue = mediaFeatureNode.parent.value;

              valueParser(value).walk(valueNode => {
                // Ignore all non-word valueNode and
                // the values not included in the parentValue string
                if (valueNode.type !== 'word' || !parentValue.includes(valueNode.value)) {
                  return;
                }

                check(
                node,
                getIndex(node),
                valueNode,
                mediaName,
                options ? options.ignoreMediaFeatureNames : {});

              });
            });
          }

          function checkDecl(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');

            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              check(node, getIndex(node), valueNode, node.prop, options ? options.ignoreProperties : {});
            });
          }

          root.walkAtRules(/^media$/i, atRule => checkMedia(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => checkDecl(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateObjectWithArrayProps": 502, "../../utils/validateOptions": 503, "lodash": 68, "postcss-media-query-parser": 83, "postcss-value-parser": 120 }], 399: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex) {
            const violations = [];

            function processValue(valueNode) {
              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return false;
              }

              const expectedUnit = expectation === 'lower' ? unit.toLowerCase() : unit.toUpperCase();

              if (unit === expectedUnit) {
                return false;
              }

              violations.push({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.expected(unit, expectedUnit) });


              return true;
            }

            const parsedValue = valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              let needFix = false;
              // TODO: Issue #4985
              // eslint-disable-next-line no-shadow
              const value = valueNode.value;

              if (valueNode.type === 'function' && value.toLowerCase() === 'url') {
                return false;
              }

              if (value.includes('*')) {
                value.split('*').some(val => {
                  return processValue(_extends({},
                  valueNode, {
                    sourceIndex: value.indexOf(val) + val.length + 1,
                    value: val }));

                });
              }

              needFix = processValue(valueNode);

              if (needFix && context.fix) {
                valueNode.value = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();
              }
            });

            if (violations.length) {
              if (context.fix) {
                if (node.name === 'media') {
                  node.params = parsedValue.toString();
                } else {
                  node.value = parsedValue.toString();
                }
              } else {
                violations.forEach(err => {
                  report({
                    index: err.index,
                    message: err.message,
                    node,
                    result,
                    ruleName });

                });
              }
            }
          }

          root.walkAtRules(atRule => {
            if (!/^media$/i.test(atRule.name) && !atRule.variable) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "postcss-value-parser": 120 }], 400: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      // a function to retrieve only the media feature name
      // could be externalized in an utils function if needed in other code
      const getMediaFeatureName = mediaFeatureNode => {
        const value = mediaFeatureNode.value.toLowerCase();

        return /((-?\w*)*)/i.exec(value)[1];
      };

      function rule(listInput, options) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [_.isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([_.isString, _.isRegExp]),
              ignoreMediaFeatureNames: validateObjectWithArrayProps([_.isString, _.isRegExp]) } });




          if (!validOptions) {
            return;
          }

          function check(node, nodeIndex, valueNode, input, option) {
            const unit = getUnitFromValueNode(valueNode);

            // There is not unit or it is not configured as a violation
            if (!unit || unit && !list.includes(unit.toLowerCase())) {
              return;
            }

            // The unit has an ignore option for the specific input
            if (optionsMatches(option, unit.toLowerCase(), input)) {
              return;
            }

            report({
              index: nodeIndex + valueNode.sourceIndex,
              message: messages.rejected(unit),
              node,
              result,
              ruleName });

          }

          function checkMedia(node, value, getIndex) {
            mediaParser(node.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const mediaName = getMediaFeatureName(mediaFeatureNode);
              const parentValue = mediaFeatureNode.parent.value;

              valueParser(value).walk(valueNode => {
                // Ignore all non-word valueNode and
                // the values not included in the parentValue string
                if (valueNode.type !== 'word' || !parentValue.includes(valueNode.value)) {
                  return;
                }

                check(
                node,
                getIndex(node),
                valueNode,
                mediaName,
                options ? options.ignoreMediaFeatureNames : {});

              });
            });
          }

          function checkDecl(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');

            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              check(node, getIndex(node), valueNode, node.prop, options ? options.ignoreProperties : {});
            });
          }

          root.walkAtRules(/^media$/i, atRule => checkMedia(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => checkDecl(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateObjectWithArrayProps": 502, "../../utils/validateOptions": 503, "lodash": 68, "postcss-media-query-parser": 83, "postcss-value-parser": 120 }], 401: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isMap = require('../../utils/isMap');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'unit-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unknown unit "${unit}"` });


      // The map property name (in map cleared from comments and spaces) always
      // has index that being divided by 4 gives remainder equals 0
      const mapPropertyNameIndexOffset = 4;

      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreUnits: [_.isString, _.isRegExp],
              ignoreFunctions: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            const parsedValue = valueParser(value);
            const ignoredMapProperties = [];

            parsedValue.walk(valueNode => {
              // Ignore wrong units within `url` function
              // and within functions listed in the `ignoreFunctions` option
              if (
              valueNode.type === 'function' && (
              valueNode.value.toLowerCase() === 'url' ||
              optionsMatches(options, 'ignoreFunctions', valueNode.value)))
              {
                return false;
              }

              if (isMap(valueNode)) {
                // TODO: Issue #4985
                // eslint-disable-next-line no-shadow
                valueNode.nodes.forEach((node, index) => {
                  if (!(index % mapPropertyNameIndexOffset)) {
                    ignoredMapProperties.push(node.sourceIndex);
                  }
                });
              }

              if (ignoredMapProperties.includes(valueNode.sourceIndex)) {
                return;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return;
              }

              if (optionsMatches(options, 'ignoreUnits', unit)) {
                return;
              }

              if (keywordSets.units.has(unit.toLowerCase()) && unit.toLowerCase() !== 'x') {
                return;
              }

              if (unit.toLowerCase() === 'x') {
                if (
                node.type === 'atrule' &&
                node.name === 'media' &&
                node.params.toLowerCase().includes('resolution'))
                {
                  let ignoreUnit = false;

                  mediaParser(node.params).walk((mediaNode, i, mediaNodes) => {
                    if (
                    mediaNode.value.toLowerCase().includes('resolution') &&
                    _.last(mediaNodes).sourceIndex === valueNode.sourceIndex)
                    {
                      ignoreUnit = true;

                      return false;
                    }
                  });

                  if (ignoreUnit) {
                    return;
                  }
                }

                if (node.type === 'decl') {
                  if (node.prop.toLowerCase() === 'image-resolution') {
                    return;
                  }

                  if (/^(?:-webkit-)?image-set[\s(]/i.test(value)) {
                    const imageSet = parsedValue.nodes.find(
                    // TODO: Issue #4985
                    // eslint-disable-next-line no-shadow
                    node => vendor.unprefixed(node.value) === 'image-set');

                    const imageSetValueLastIndex = _.last(imageSet.nodes).sourceIndex;

                    if (imageSetValueLastIndex >= valueNode.sourceIndex) {
                      return;
                    }
                  }
                }
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(atRule => {
            if (!/^media$/i.test(atRule.name) && !atRule.variable) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/isMap": 463, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/vendor": 504, "lodash": 68, "postcss-media-query-parser": 83, "postcss-value-parser": 120 }], 402: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-whitelist';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      function rule(listInput, options) {
        const list = [].concat(listInput);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [_.isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([_.isString, _.isRegExp]) } });




          if (!validOptions) {
            return;
          }

          result.warn(`'${ruleName}' has been deprecated. Instead use 'unit-allowed-list'.`, {
            stylelintType: 'deprecation',
            stylelintReference: `https://github.com/stylelint/stylelint/blob/13.7.0/lib/rules/${ruleName}/README.md` });


          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit || unit && list.includes(unit.toLowerCase())) {
                return;
              }

              if (options && optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {
                return;
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      rule.meta = { deprecated: true };

      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 416, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/optionsMatches": 490, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateObjectWithArrayProps": 502, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 403: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isCounterIncrementCustomIdentValue = require('../../utils/isCounterIncrementCustomIdentValue');
      const isCounterResetCustomIdentValue = require('../../utils/isCounterResetCustomIdentValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const keywordSets = require('../../reference/keywordSets');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'value-keyword-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      // Operators are interpreted as "words" by the value parser, so we want to make sure to ignore them.
      const ignoredCharacters = new Set(['+', '-', '/', '*', '%']);
      const gridRowProps = new Set(['grid-row', 'grid-row-start', 'grid-row-end']);
      const gridColumnProps = new Set(['grid-column', 'grid-column-start', 'grid-column-end']);

      const mapLowercaseKeywordsToCamelCase = new Map();

      keywordSets.camelCaseKeywords.forEach(func => {
        mapLowercaseKeywordsToCamelCase.set(func.toLowerCase(), func);
      });

      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['lower', 'upper'] },

          {
            actual: options,
            possible: {
              ignoreProperties: [_.isString, _.isRegExp],
              ignoreKeywords: [_.isString, _.isRegExp],
              ignoreFunctions: [_.isString, _.isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const propLowerCase = decl.prop.toLowerCase();
            const value = decl.value;

            const parsed = valueParser(decl.raws.value ? decl.raws.value.raw : decl.value);

            let needFix = false;

            parsed.walk(node => {
              const valueLowerCase = node.value.toLowerCase();

              // Ignore system colors
              if (keywordSets.systemColors.has(valueLowerCase)) {
                return;
              }

              // Ignore keywords within `url` and `var` function
              if (
              node.type === 'function' && (
              valueLowerCase === 'url' ||
              valueLowerCase === 'var' ||
              valueLowerCase === 'counter' ||
              valueLowerCase === 'counters' ||
              valueLowerCase === 'attr'))
              {
                return false;
              }

              // ignore keywords within ignoreFunctions functions

              const ignoreFunctions = options && options.ignoreFunctions || [];

              if (
              node.type === 'function' &&
              ignoreFunctions.length > 0 &&
              matchesStringOrRegExp(valueLowerCase, ignoreFunctions))
              {
                return false;
              }

              const keyword = node.value;

              // Ignore css variables, and hex values, and math operators, and sass interpolation
              if (
              node.type !== 'word' ||
              !isStandardSyntaxValue(node.value) ||
              value.includes('#') ||
              ignoredCharacters.has(keyword) ||
              getUnitFromValueNode(node))
              {
                return;
              }

              if (
              propLowerCase === 'animation' &&
              !keywordSets.animationShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'animation-name' &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font' &&
              !keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font-family' &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'counter-increment' &&
              isCounterIncrementCustomIdentValue(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'counter-reset' && isCounterResetCustomIdentValue(valueLowerCase)) {
                return;
              }

              if (gridRowProps.has(propLowerCase) && !keywordSets.gridRowKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              gridColumnProps.has(propLowerCase) &&
              !keywordSets.gridColumnKeywords.has(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'grid-area' && !keywordSets.gridAreaKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              propLowerCase === 'list-style' &&
              !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'list-style-type' &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              const ignoreKeywords = options && options.ignoreKeywords || [];
              const ignoreProperties = options && options.ignoreProperties || [];

              if (ignoreKeywords.length > 0 && matchesStringOrRegExp(keyword, ignoreKeywords)) {
                return;
              }

              if (ignoreProperties.length > 0 && matchesStringOrRegExp(prop, ignoreProperties)) {
                return;
              }

              const keywordLowerCase = keyword.toLocaleLowerCase();
              let expectedKeyword = null;

              if (expectation === 'lower' && mapLowercaseKeywordsToCamelCase.has(keywordLowerCase)) {
                expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase);
              } else if (expectation === 'lower') {
                expectedKeyword = keyword.toLowerCase();
              } else {
                expectedKeyword = keyword.toUpperCase();
              }

              if (keyword === expectedKeyword) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedKeyword;

                return;
              }

              report({
                message: messages.expected(keyword, expectedKeyword),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              decl.value = parsed.toString();
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 186, "../../utils/declarationValueIndex": 425, "../../utils/getUnitFromValueNode": 436, "../../utils/isCounterIncrementCustomIdentValue": 451, "../../utils/isCounterResetCustomIdentValue": 452, "../../utils/isStandardSyntaxValue": 482, "../../utils/matchesStringOrRegExp": 487, "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68, "postcss-value-parser": 120 }], 404: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null,
            determineIndex: (declString, match) => {
              const nextChars = declString.substr(match.endIndex, declString.length - match.endIndex);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^[ \t]*\/\//.test(nextChars)) {
                return false;
              }

              // If there are spaces and then a comment begins, look for the newline
              return /^[ \t]*\/\*/.test(nextChars) ?
              declString.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;
            } });


          if (fixData) {
            fixData.forEach((commaIndices, decl) => {
              commaIndices.
              sort((a, b) => a - b).
              reverse().
              forEach(index => {
                const value = decl.raws.value ? decl.raws.value.raw : decl.value;
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (expectation.startsWith('always')) {
                  afterValue = context.newline + afterValue;
                } else if (expectation.startsWith('never-multi-line')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                if (decl.raws.value) {
                  decl.raws.value.raw = beforeValue + afterValue;
                } else {
                  decl.value = beforeValue + afterValue;
                }
              });
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../valueListCommaWhitespaceChecker": 409 }], 405: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      function rule(expectation) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../valueListCommaWhitespaceChecker": 409 }], 406: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, decl) => {
              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const value = decl.raws.value ? decl.raws.value.raw : decl.value;
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (expectation.startsWith('always')) {
                  afterValue = afterValue.replace(/^\s*/, ' ');
                } else if (expectation.startsWith('never')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                if (decl.raws.value) {
                  decl.raws.value.raw = beforeValue + afterValue;
                } else {
                  decl.value = beforeValue + afterValue;
                }
              });
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../valueListCommaWhitespaceChecker": 409 }], 407: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            fixData.forEach((commaIndices, decl) => {
              commaIndices.
              sort((a, b) => b - a).
              forEach(index => {
                const value = decl.raws.value ? decl.raws.value.raw : decl.value;
                const valueIndex = index - declarationValueIndex(decl);
                let beforeValue = value.slice(0, valueIndex);
                const afterValue = value.slice(valueIndex);

                if (expectation.startsWith('always')) {
                  beforeValue = beforeValue.replace(/\s*$/, ' ');
                } else if (expectation.startsWith('never')) {
                  beforeValue = beforeValue.replace(/\s*$/, '');
                }

                if (decl.raws.value) {
                  decl.raws.value.raw = beforeValue + afterValue;
                } else {
                  decl.value = beforeValue + afterValue;
                }
              });
            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 425, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "../../utils/whitespaceChecker": 505, "../valueListCommaWhitespaceChecker": 409 }], 408: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const _ = require('lodash');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'value-list-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function rule(max, options, context) {
        const maxAdjacentNewlines = max + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: _.isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            const value = decl.raws.value ? decl.raws.value.raw : decl.value;

            if (context.fix) {
              const newValueString = value.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              if (decl.raws.value) {
                decl.raws.value.raw = newValueString;
              } else {
                decl.value = newValueString;
              }
            } else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {
              report({
                message: messages.expected(max),
                node: decl,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 498, "../../utils/ruleMessages": 499, "../../utils/validateOptions": 503, "lodash": 68 }], 409: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../utils/isStandardSyntaxProperty');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
            return;
          }

          const declString = decl.toString();

          styleSearch(
          {
            source: declString,
            target: ',',
            functionArguments: 'skip' },

          match => {
            const indexToCheckAfter = opts.determineIndex ?
            opts.determineIndex(declString, match) :
            match.startIndex;

            if (indexToCheckAfter === false) {
              return;
            }

            checkComma(declString, indexToCheckAfter, decl);
          });

        });

        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message: m,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxDeclaration": 473, "../utils/isStandardSyntaxProperty": 477, "../utils/report": 498, "style-search": 166 }], 410: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const createStylelint = require('./createStylelint');
      const createStylelintResult = require('./createStylelintResult');
      /* const debug = require('debug')('stylelint:standalone'); */
      /* const fastGlob = require('fast-glob'); */
      /* const FileCache = require('./utils/FileCache'); */
      /* const filterFilePaths = require('./utils/filterFilePaths'); */
      const formatters = require('./formatters');
      /* const fs = require('fs'); */
      const getFormatterOptionsText = require('./utils/getFormatterOptionsText');
      /* const globby = require('globby'); */
      /* const hash = require('./utils/hash'); */
      /* const NoFilesFoundError = require('./utils/noFilesFoundError'); */
      const path = require('path');
      /* const pkg = require('../package.json'); */
      const prepareReturnValue = require('./prepareReturnValue');
      const { default: ignore } = require('ignore');
      const DEFAULT_IGNORE_FILENAME = '.stylelintignore';
      const FILE_NOT_FOUND_ERROR_CODE = 'ENOENT';
      const ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];
      /* const writeFileAtomic = require('write-file-atomic'); */

      /** @typedef {import('stylelint').StylelintStandaloneOptions} StylelintStandaloneOptions */
      /** @typedef {import('stylelint').StylelintStandaloneReturnValue} StylelintStandaloneReturnValue */
      /** @typedef {import('stylelint').StylelintResult} StylelintResult */
      /** @typedef {import('stylelint').Formatter} Formatter */
      /** @typedef {import('stylelint').FormatterIdentifier} FormatterIdentifier */

      /**
       * @param {StylelintStandaloneOptions} options
       * @returns {Promise<StylelintStandaloneReturnValue>}
       */
      module.exports = function (options) {
        const cacheLocation = options.cacheLocation;
        const code = options.code;
        const codeFilename = options.codeFilename;
        const config = options.config;
        const configBasedir = options.configBasedir;
        const configFile = options.configFile;
        const configOverrides = options.configOverrides;
        const customSyntax = options.customSyntax;
        const globbyOptions = options.globbyOptions;
        const files = options.files;
        const fix = options.fix;
        const formatter = options.formatter;
        const ignoreDisables = options.ignoreDisables;
        const reportNeedlessDisables = options.reportNeedlessDisables;
        const reportInvalidScopeDisables = options.reportInvalidScopeDisables;
        const reportDescriptionlessDisables = options.reportDescriptionlessDisables;
        const syntax = options.syntax;
        const allowEmptyInput = options.allowEmptyInput || false;
        const useCache = options.cache || false;
        /** @type {FileCache} */
        let fileCache;
        const startTime = Date.now();

        // The ignorer will be used to filter file paths after the glob is checked,
        // before any files are actually read
        const ignoreFilePath = options.ignorePath || DEFAULT_IGNORE_FILENAME;
        /* const absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath)
        	? ignoreFilePath
        	: path.resolve(process.cwd(), ignoreFilePath); */
        const absoluteIgnoreFilePath = ignoreFilePath;
        let ignoreText = '';

        try {
          /* ignoreText = fs.readFileSync(absoluteIgnoreFilePath, 'utf8'); */
        } catch (readError) {
          /* if (readError.code !== FILE_NOT_FOUND_ERROR_CODE) throw readError; */
        }

        const ignorePattern = options.ignorePattern || [];
        const ignorer = ignore().add(ignoreText).add(ignorePattern);

        const isValidCode = typeof code === 'string';

        if (!files && !isValidCode || files && (code || isValidCode)) {
          throw new Error('You must pass stylelint a `files` glob or a `code` string, though not both');
        }

        /** @type {Formatter} */
        let formatterFunction;

        try {
          formatterFunction = getFormatterFunction(formatter);
        } catch (error) {
          return Promise.reject(error);
        }

        const stylelint = createStylelint({
          config,
          configFile,
          configBasedir,
          configOverrides,
          ignoreDisables,
          ignorePath: ignoreFilePath,
          reportNeedlessDisables,
          reportInvalidScopeDisables,
          reportDescriptionlessDisables,
          syntax,
          customSyntax,
          fix });


        if (!files) {
          /* const absoluteCodeFilename =
          	codeFilename !== undefined && !path.isAbsolute(codeFilename)
          		? path.join(process.cwd(), codeFilename)
          		: codeFilename; */
          const absoluteCodeFilename = codeFilename;

          // if file is ignored, return nothing
          if (
          absoluteCodeFilename /* &&
          !filterFilePaths(ignorer, [path.relative(process.cwd(), absoluteCodeFilename)]).length */ &&
          false)
          {
            return Promise.resolve(prepareReturnValue([], options, formatterFunction));
          }

          return stylelint.
          _lintSource({
            code,
            codeFilename: absoluteCodeFilename }).

          then(postcssResult => {
            /* // Check for file existence
            return new Promise((resolve, reject) => {
            	if (!absoluteCodeFilename) {
            		reject();
            			return;
            	}
            		fs.stat(absoluteCodeFilename, (err) => {
            		if (err) {
            			reject();
            		} else {
            			resolve();
            		}
            	});
            })
            	 */


            return Promise.resolve().then(() => {
              return stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);
            }).
            catch(() => {
              return stylelint._createStylelintResult(postcssResult);
            });
          }).
          catch(_.partial(handleError, stylelint)).
          then(stylelintResult => {
            const postcssResult = stylelintResult._postcssResult;
            const returnValue = prepareReturnValue([stylelintResult], options, formatterFunction);

            if (options.fix && postcssResult && !postcssResult.stylelint.ignored) {
              if (!postcssResult.stylelint.disableWritingFix) {
                // If we're fixing, the output should be the fixed code
                returnValue.output = postcssResult.root.toString(postcssResult.opts.syntax);
              } else {
                // If the writing of the fix is disabled, the input code is returned as-is
                returnValue.output = code;
              }
            }

            return returnValue;
          });
        }

        /* let fileList = files;
        	if (typeof fileList === 'string') {
        	fileList = [fileList];
        }
        	fileList = fileList.map((entry) => {
        	const cwd = _.get(globbyOptions, 'cwd', process.cwd());
        	const absolutePath = !path.isAbsolute(entry) ? path.join(cwd, entry) : path.normalize(entry);
        		if (fs.existsSync(absolutePath)) {
        		// This path points to a file. Return an escaped path to avoid globbing
        		return fastGlob.escapePath(entry);
        	}
        		return entry;
        });
        	if (!options.disableDefaultIgnores) {
        	fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map((glob) => `!${glob}`));
        }
        	if (useCache) {
        	const stylelintVersion = pkg.version;
        	const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);
        		fileCache = new FileCache(cacheLocation, hashOfConfig);
        } else {
        	// No need to calculate hash here, we just want to delete cache file.
        	fileCache = new FileCache(cacheLocation);
        	// Remove cache file if cache option is disabled
        	fileCache.destroy();
        }
        	return globby(fileList, globbyOptions)
        	.then((filePaths) => {
        		// The ignorer filter needs to check paths relative to cwd
        		filePaths = filterFilePaths(
        			ignorer,
        			filePaths.map((p) => path.relative(process.cwd(), p)),
        		);
        			if (!filePaths.length) {
        			if (!allowEmptyInput) {
        				throw new NoFilesFoundError(fileList);
        			}
        				return Promise.all([]);
        		}
        			const cwd = _.get(globbyOptions, 'cwd', process.cwd());
        		let absoluteFilePaths = filePaths.map((filePath) => {
        			const absoluteFilepath = !path.isAbsolute(filePath)
        				? path.join(cwd, filePath)
        				: path.normalize(filePath);
        				return absoluteFilepath;
        		});
        			if (useCache) {
        			absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));
        		}
        			const getStylelintResults = absoluteFilePaths.map((absoluteFilepath) => {
        			debug(`Processing ${absoluteFilepath}`);
        				return stylelint
        				._lintSource({
        					filePath: absoluteFilepath,
        				})
        				.then((postcssResult) => {
        					if (postcssResult.stylelint.stylelintError && useCache) {
        						debug(`${absoluteFilepath} contains linting errors and will not be cached.`);
        						fileCache.removeEntry(absoluteFilepath);
        					}
        						
        					let fixFile = Promise.resolve();
        						if (
        						postcssResult.root &&
        						postcssResult.opts &&
        						!postcssResult.stylelint.ignored &&
        						options.fix &&
        						!postcssResult.stylelint.disableWritingFix
        					) {
        						// @ts-ignore TODO TYPES toString accepts 0 arguments
        						const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);
        							if (
        							postcssResult.root &&
        							postcssResult.root.source &&
        							// @ts-ignore TODO TYPES css is unknown property
        							postcssResult.root.source.input.css !== fixedCss
        						) {
        							fixFile = writeFileAtomic(absoluteFilepath, fixedCss);
        						}
        					}
        						return fixFile.then(() =>
        						stylelint._createStylelintResult(postcssResult, absoluteFilepath),
        					);
        				})
        				.catch((error) => {
        					// On any error, we should not cache the lint result
        					fileCache.removeEntry(absoluteFilepath);
        						return handleError(stylelint, error, absoluteFilepath);
        				});
        		});
        			return Promise.all(getStylelintResults);
        	})
        	.then((stylelintResults) => {
        		if (useCache) {
        			fileCache.reconcile();
        		}
        			const rtn = prepareReturnValue(stylelintResults, options, formatterFunction);
        			debug(`Linting complete in ${Date.now() - startTime}ms`);
        			return rtn;
        	}); */
























        return "";
      };

      /**
       * @param {FormatterIdentifier | undefined} selected
       * @returns {Formatter}
       */
      function getFormatterFunction(selected) {
        /** @type {Formatter} */
        let formatterFunction;

        if (typeof selected === 'string') {
          formatterFunction = formatters[selected];

          if (formatterFunction === undefined) {
            throw new Error(
            `You must use a valid formatter option: ${getFormatterOptionsText()} or a function`);

          }
        } else if (typeof selected === 'function') {
          formatterFunction = selected;
        } else {
          formatterFunction = formatters.json;
        }

        return formatterFunction;
      }

      /**
       * @param {import('stylelint').StylelintInternalApi} stylelint
       * @param {any} error
       * @param {string} [filePath]
       * @return {Promise<StylelintResult>}
       */
      function handleError(stylelint, error, filePath = undefined) {
        if (error.name === 'CssSyntaxError') {
          return createStylelintResult(stylelint, undefined, filePath, error);
        }

        throw error;
      }

    }, { "./createStylelint": 170, "./createStylelintResult": 171, "./formatters": 174, "./prepareReturnValue": 185, "./utils/getFormatterOptionsText": 431, "ignore": 12, "lodash": 68, "path": 74 }], 411: [function (require, module, exports) {
      'use strict';

      // Use this require pattern so that syntaxes can be bundled separately
      const importLazy = require('import-lazy')(require);

      /** @typedef {import('../getPostcssResult').Syntax} Syntax */
      /** @type {{[k: string]: Syntax}} */
      module.exports = {
        /* 'css-in-js': require('./syntax-css-in-js'), */
        /* html: require('./syntax-html'), */
        less: require('./syntax-less'),
        /* markdown: require('./syntax-markdown'), */
        /* sass: require('./syntax-sass'), */
        /* scss: require('./syntax-scss'), */
        sugarss: require('./syntax-sugarss') };


    }, { "./syntax-less": 412, "./syntax-sugarss": 413, "import-lazy": 13 }], 412: [function (require, module, exports) {
      'use strict';

      module.exports = require('postcss-less');

    }, { "postcss-less": 77 }], 413: [function (require, module, exports) {
      'use strict';

      module.exports = require('sugarss');

    }, { "sugarss": 506 }], 414: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {import('postcss').ChildNode} ChildNode */

      /**
       * Add an empty line after a node. Mutates the node.
       *
       * @param {ChildNode} node
       * @param {'\n' | '\r\n'} newline
       * @returns {ChildNode}
       */
      function addEmptyLineAfter(node, newline) {
        if (node.raws.after === undefined) {
          return node;
        }

        const after = _.last(node.raws.after.split(';')) || '';

        if (!/\r?\n/.test(after)) {
          node.raws.after += newline.repeat(2);
        } else {
          node.raws.after = node.raws.after.replace(/(\r?\n)/, `${newline}$1`);
        }

        return node;
      }

      module.exports = addEmptyLineAfter;

    }, { "lodash": 68 }], 415: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').ChildNode} ChildNode */

      /**
       * Add an empty line before a node. Mutates the node.
       *
       * @param {ChildNode} node
       * @param {'\n' | '\r\n'} newline
       * @returns {ChildNode}
       */
      function addEmptyLineBefore(node, newline) {
        if (node.raws.before === undefined) {
          return node;
        }

        if (!/\r?\n/.test(node.raws.before)) {
          node.raws.before = newline.repeat(2) + node.raws.before;
        } else {
          node.raws.before = node.raws.before.replace(/(\r?\n)/, `${newline}$1`);
        }

        return node;
      }

      module.exports = addEmptyLineBefore;

    }, {}], 416: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {number}
       */
      module.exports = function (atRule) {
        // Initial 1 is for the `@`
        let index = 1 + atRule.name.length;

        if (atRule.raws.afterName) {
          index += atRule.raws.afterName.length;
        }

        return index;
      };

    }, {}], 417: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Rule} Rule */
      /** @typedef {import('postcss').AtRule} AtRule */

      /**
       * @param {Rule | AtRule} statement
       * @param {{
       * 	noRawBefore?: boolean
       * }} options
       *
       * @returns {string}
       */
      module.exports = function (statement, options = {}) {
        let result = '';
        /** @type {Rule | undefined} */
        let rule; /*?: postcss$rule*/
        /** @type {AtRule | undefined} */
        let atRule; /*?: postcss$atRule*/

        if (statement.type === 'rule') {
          rule = statement;
        }

        if (statement.type === 'atrule') {
          atRule = statement;
        }

        if (!rule && !atRule) {
          return result;
        }

        const before = statement.raws.before || '';

        if (!options.noRawBefore) {
          result += before;
        }

        if (rule) {
          result += rule.selector;
        }

        if (atRule) {
          result += `@${atRule.name}${atRule.raws.afterName || ''}${atRule.params}`;
        }

        const between = statement.raws.between;

        if (between !== undefined) {
          result += between;
        }

        return result;
      };

    }, {}], 418: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('./beforeBlockString');
      const hasBlock = require('./hasBlock');
      const rawNodeString = require('./rawNodeString');

      /** @typedef {import('postcss').Rule} Rule */
      /** @typedef {import('postcss').AtRule} AtRule */

      /**
       * Return a CSS statement's block -- the string that starts and `{` and ends with `}`.
       *
       * If the statement has no block (e.g. `@import url(foo.css);`),
       * return false.
       *
       * @param {Rule | AtRule} statement - postcss rule or at-rule node
       * @return {string | boolean}
       */
      module.exports = function (statement) {
        if (!hasBlock(statement)) {
          return false;
        }

        return rawNodeString(statement).slice(beforeBlockString(statement).length);
      };

    }, { "./beforeBlockString": 417, "./hasBlock": 437, "./rawNodeString": 495 }], 419: [function (require, module, exports) {
      'use strict';

      /**
       * @param {string} source
       *
       * @returns {string}
       */
      module.exports = function (source, blurChar = '`') {
        return source.replace(/\/\*.*\*\//g, blurChar);
      };

    }, {}], 420: [function (require, module, exports) {
      'use strict';

      const balancedMatch = require('balanced-match');

      /**
       * Replace all of the characters that are arguments to a certain
       * CSS function with some innocuous character.
       *
       * This is useful if you need to use a RegExp to find a string
       * but want to ignore matches in certain functions (e.g. `url()`,
       * which might contain all kinds of false positives).
       *
       * For example:
       * blurFunctionArguments("abc url(abc) abc", "url") === "abc url(```) abc"
       *
       * @param {string} source
       * @param {string} functionName
       * @return {string} - The result string, with the function arguments "blurred"
       */
      module.exports = function (source, functionName, blurChar = '`') {
        const nameWithParen = `${functionName.toLowerCase()}(`;
        const lowerCaseSource = source.toLowerCase();

        if (!lowerCaseSource.includes(nameWithParen)) {
          return source;
        }

        const functionNameLength = functionName.length;

        let result = source;
        let searchStartIndex = 0;

        while (lowerCaseSource.includes(nameWithParen, searchStartIndex)) {
          const openingParenIndex =
          lowerCaseSource.indexOf(nameWithParen, searchStartIndex) + functionNameLength;
          const parensMatch = balancedMatch('(', ')', lowerCaseSource.slice(openingParenIndex));

          if (!parensMatch) {
            throw new Error(`No parens match: "${source}"`);
          }

          const closingParenIndex = parensMatch.end + openingParenIndex;
          const argumentsLength = closingParenIndex - openingParenIndex - 1;

          result =
          result.slice(0, openingParenIndex + 1) +
          blurChar.repeat(argumentsLength) +
          result.slice(closingParenIndex);
          searchStartIndex = closingParenIndex;
        }

        return result;
      };

    }, { "balanced-match": 1 }], 421: [function (require, module, exports) {
      'use strict';

      /**
       * @param {string} source
       *
       * @returns {string}
       */
      module.exports = function (source, blurChar = ' ') {
        return source.replace(/[#@{}]+/g, blurChar);
      };

    }, {}], 422: [function (require, module, exports) {
      'use strict';

      const normalizeRuleSettings = require('../normalizeRuleSettings');
      const Result = require('postcss/lib/result');
      const rules = require('../rules');

      /**
       * Useful for third-party code (e.g. plugins) to run a PostCSS Root
       * against a specific rule and do something with the warnings
       * @param {{
      		ruleName: string,
      		ruleSettings: import('stylelint').StylelintConfigRuleSettings,
      		root: import('postcss').Root,
      	}} options
       * @param {Function} callback
       * @returns {void}
       */
      module.exports = function (options, callback) {
        if (!options)
        throw new Error(
        "checkAgainstRule requires an options object with 'ruleName', 'ruleSettings', and 'root' properties");


        if (!callback) throw new Error('checkAgainstRule requires a callback');

        if (!options.ruleName) throw new Error("checkAgainstRule requires a 'ruleName' option");

        if (!Object.keys(rules).includes(options.ruleName))
        throw new Error(`Rule '${options.ruleName}' does not exist`);

        if (!options.ruleSettings) throw new Error("checkAgainstRule requires a 'ruleSettings' option");

        if (!options.root) throw new Error("checkAgainstRule requires a 'root' option");

        const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName);

        if (!settings) {
          return;
        }

        const tmpPostcssResult = new Result();

        rules[options.ruleName](settings[0], settings[1], {})(options.root, tmpPostcssResult);
        tmpPostcssResult.warnings().forEach(callback);
      };

    }, { "../normalizeRuleSettings": 183, "../rules": 291, "postcss/lib/result": 140 }], 423: [function (require, module, exports) {
      'use strict';

      /**
       * Create configurationError from text and set CLI exit code
       * @param {string} text
       * @returns {Object}
       */
      module.exports = function (text) /* Object */{
        /** @type {Error & {code?: number}} */
        const err = new Error(text);

        err.code = 78;

        return err;
      };

    }, {}], 424: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {false | { match: string, pattern: string }} ReturnValue */

      /**
       * Checks if a string contains a value. The comparison value can be a string or
       * an array of strings.
       *
       * Any strings starting and ending with `/` are ignored. Use the
       * matchesStringOrRegExp() util to match regexes.
       *
       * @param {string} input
       * @param {string | string[]} comparison
       *
       * @returns {ReturnValue}
       */
      module.exports = function containsString(input, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstString(input, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstString(input, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       *
       * @param {string} value
       * @param {string} comparison
       *
       * @returns {ReturnValue}
       */
      function testAgainstString(value, comparison) {
        if (!comparison) return false;

        if (!_.isString(comparison)) return false;

        if (comparison.startsWith('/') && comparison.endsWith('/')) {
          return false;
        }

        if (value.includes(comparison)) {
          return { match: value, pattern: comparison };
        }

        return false;
      }

    }, { "lodash": 68 }], 425: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /**
       * Get the index of a declaration's value
       *
       * @param {import('postcss').Declaration} decl
       *
       * @returns {number}
       */
      module.exports = function (decl) {
        return [
        _.get(decl, 'raws.prop.prefix'),
        _.get(decl, 'raws.prop.raw', decl.prop),
        _.get(decl, 'raws.prop.suffix'),
        _.get(decl, 'raws.between', ':'),
        _.get(decl, 'raws.value.prefix')].
        reduce((count, str) => {
          if (str) {
            return count + str.length;
          }

          return count;
        }, 0);
      };

    }, { "lodash": 68 }], 426: [function (require, module, exports) {
      'use strict';

      const { isRoot, isAtRule, isRule } = require('./typeGuards');

      /** @typedef {import('postcss').Root} Root */
      /** @typedef {import('postcss').Root} Document */
      /** @typedef {import('postcss').Node} PostcssNode */
      /** @typedef {import('postcss').ContainerBase} PostcssContainerNode */

      /**
       * @param {PostcssNode} node
       * @returns {node is PostcssContainerNode}
       */
      function isContainerNode(node) {
        return isRule(node) || isAtRule(node) || isRoot(node);
      }

      /**
       * In order to accommodate nested blocks (postcss-nested),
       * we need to run a shallow loop (instead of eachDecl() or eachRule(),
       * which loop recursively) and allow each nested block to accumulate
       * its own list of properties -- so that a property in a nested rule
       * does not conflict with the same property in the parent rule
       * executes a provided function once for each declaration block.
       *
       * @param {Root | Document} root - root element of file.
       * @param {function} cb - Function to execute for each declaration block
       *
       * @returns {void}
       */
      module.exports = function (root, cb) {
        /**
         * @param {PostcssNode} statement
         *
         * @returns {void}
         */
        function each(statement) {
          if (!isContainerNode(statement)) return;

          if (statement.nodes && statement.nodes.length) {
            /** @type {PostcssNode[]} */
            const decls = [];

            statement.nodes.forEach(node => {
              if (node.type === 'decl') {
                decls.push(node);
              }

              each(node);
            });

            if (decls.length) {
              cb(decls.forEach.bind(decls));
            }
          }
        }

        each(root);
      };

    }, { "./typeGuards": 501 }], 427: [function (require, module, exports) {
      'use strict';

      const getUnitFromValueNode = require('./getUnitFromValueNode');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isVariable = require('./isVariable');
      const keywordSets = require('../reference/keywordSets');
      const postcssValueParser = require('postcss-value-parser');

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       * Get the animation name within an `animation` shorthand property value.
       *
       * @param {string} value
       *
       * @returns {Node[]}
       */
      module.exports = function findAnimationName(value) {
        /** @type {Node[]} */
        const animationNames = [];

        const valueNodes = postcssValueParser(value);

        // Handle `inherit`, `initial` and etc
        if (
        valueNodes.nodes.length === 1 &&
        keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase()))
        {
          return [valueNodes.nodes[0]];
        }

        valueNodes.walk(valueNode => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (valueNode.type !== 'word') {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non-standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other animation parts
          if (keywordSets.animationShorthandKeywords.has(valueLowerCase)) {
            return;
          }

          // Ignore numbers with units
          const unit = getUnitFromValueNode(valueNode);

          if (unit || unit === '') {
            return;
          }

          animationNames.push(valueNode);
        });

        return animationNames;
      };

    }, { "../reference/keywordSets": 186, "./getUnitFromValueNode": 436, "./isStandardSyntaxValue": 482, "./isVariable": 485, "postcss-value-parser": 120 }], 428: [function (require, module, exports) {
      'use strict';

      /**
       * Find the at-rule in which a rule is nested.
       *
       * Returns `null` if the rule is not nested within an at-rule.
       *
       * @param {import('postcss').Rule} rule
       * @returns {null | import('postcss').AtRule}
       */
      module.exports = function findAtRuleContext(rule) {
        const parent = rule.parent;

        if (parent.type === 'root') {
          return null;
        }

        if (parent.type === 'atrule') {
          return parent;
        }

        return findAtRuleContext(parent);
      };

    }, {}], 429: [function (require, module, exports) {
      'use strict';

      const isNumbery = require('./isNumbery');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isValidFontSize = require('./isValidFontSize');
      const isVariable = require('./isVariable');
      const keywordSets = require('../reference/keywordSets');
      const postcssValueParser = require('postcss-value-parser');

      const nodeTypesToCheck = new Set(['word', 'string', 'space', 'div']);

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       *
       * @param {Node} firstNode
       * @param {Node} secondNode
       * @param {string | null} charactersBetween
       *
       * @returns {Node}
       */
      function joinValueNodes(firstNode, secondNode, charactersBetween) {
        firstNode.value = firstNode.value + charactersBetween + secondNode.value;

        return firstNode;
      }

      /**
       * Get the font-families within a `font` shorthand property value.
       *
       * @param {string} value
       * @return {object} Collection font-family nodes
       */
      module.exports = function findFontFamily(value) {
        /** @type {Node[]} */
        const fontFamilies = [];

        const valueNodes = postcssValueParser(value);

        // Handle `inherit`, `initial` and etc
        if (
        valueNodes.nodes.length === 1 &&
        keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase()))
        {
          return [valueNodes.nodes[0]];
        }

        let needMergeNodesByValue = false;
        /** @type {string | null} */
        let mergeCharacters = null;

        valueNodes.walk((valueNode, index, nodes) => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (!nodeTypesToCheck.has(valueNode.type)) {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other font parts
          if (
          keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
          !keywordSets.fontFamilyKeywords.has(valueLowerCase))
          {
            return;
          }

          // Ignore font-sizes
          if (isValidFontSize(valueNode.value)) {
            return;
          }

          // Ignore anything come after a <font-size>/, because it's a line-height
          if (
          nodes[index - 1] &&
          nodes[index - 1].value === '/' &&
          nodes[index - 2] &&
          isValidFontSize(nodes[index - 2].value))
          {
            return;
          }

          // Ignore number values
          if (isNumbery(valueLowerCase)) {
            return;
          }

          // Detect when a space or comma is dividing a list of font-families, and save the joining character.
          if (
          (valueNode.type === 'space' || valueNode.type === 'div' && valueNode.value !== ',') &&
          fontFamilies.length !== 0)
          {
            needMergeNodesByValue = true;
            mergeCharacters = valueNode.value;

            return;
          }

          if (valueNode.type === 'space' || valueNode.type === 'div') {
            return;
          }

          const fontFamily = valueNode;

          if (needMergeNodesByValue) {
            joinValueNodes(fontFamilies[fontFamilies.length - 1], valueNode, mergeCharacters);
            needMergeNodesByValue = false;
            mergeCharacters = null;
          } else {
            fontFamilies.push(fontFamily);
          }
        });

        return fontFamilies;
      };

    }, { "../reference/keywordSets": 186, "./isNumbery": 465, "./isStandardSyntaxValue": 482, "./isValidFontSize": 483, "./isVariable": 485, "postcss-value-parser": 120 }], 430: [function (require, module, exports) {
      'use strict';

      const balancedMatch = require('balanced-match');
      const styleSearch = require('style-search');

      /**
       * Search a CSS string for functions by name.
       * For every match, invoke the callback, passing the function's
       * "argument(s) string" (whatever is inside the parentheses)
       * as an argument.
       *
       * Callback will be called once for every matching function found,
       * with the function's "argument(s) string" and its starting index
       * as the arguments.
       *
       * @param {string} source
       * @param {string} functionName
       * @param {Function} callback
       */
      module.exports = function (source, functionName, callback) {
        styleSearch(
        {
          source,
          target: functionName,
          functionNames: 'check' },

        match => {
          if (source[match.endIndex] !== '(') {
            return;
          }

          const parensMatch = balancedMatch('(', ')', source.substr(match.startIndex));

          if (!parensMatch) {
            throw new Error(`No parens match: "${source}"`);
          }

          callback(parensMatch.body, match.endIndex + 1);
        });

      };

    }, { "balanced-match": 1, "style-search": 166 }], 431: [function (require, module, exports) {
      'use strict';

      const formatters = require('../formatters');

      /**
       * @param {{ useOr?: boolean }} [options={}]
       * @returns {string}
       */
      module.exports = function getFormatterOptionsText(options = {}) {
        let output = Object.keys(formatters).
        map(name => `"${name}"`).
        join(', ');

        if (options.useOr) {
          output = output.replace(/, ([a-z"]+)$/u, ' or $1');
        }

        return output;
      };

    }, { "../formatters": 174 }], 432: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node | void} node
       */
      function getNodeLine(node) {
        return _.get(node, 'source.start.line');
      }

      /**
       * @param {Node | void} node
       * @returns {Node | void}
       */
      module.exports = function getNextNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        /** @type {Node | void} */
        const nextNode = node.next();

        if (_.get(nextNode, 'type') !== 'comment') {
          return nextNode;
        }

        if (
        getNodeLine(node) === getNodeLine(nextNode) ||
        nextNode !== undefined && getNodeLine(nextNode) === getNodeLine(nextNode.next()))
        {
          return getNextNonSharedLineCommentNode(nextNode);
        }

        return nextNode;
      };

    }, { "lodash": 68 }], 433: [function (require, module, exports) {
      'use strict';

      const os = require('os');

      // This function simply provides roundabout way of getting os.EOL
      // so we can mock this for Jest tests
      function getOsEl() {
        return os.EOL;
      }

      module.exports = getOsEl;

    }, { "os": 73 }], 434: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node} node
       */
      function getNodeLine(node) {
        return _.get(node, 'source.start.line');
      }

      /**
       * @param {import('postcss').Node | void} node
       * @returns {Node | void}
       */
      module.exports = function getPreviousNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        const previousNode = node.prev();

        if (!previousNode || _.get(previousNode, 'type') !== 'comment') {
          return previousNode;
        }

        if (getNodeLine(node) === getNodeLine(previousNode)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        const previousNode2 = previousNode.prev();

        if (previousNode2 && getNodeLine(previousNode) === getNodeLine(previousNode2)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        return previousNode;
      };

    }, { "lodash": 68 }], 435: [function (require, module, exports) {
      'use strict';

      const { URL } = require('url');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {string} urlString
       */
      module.exports = function (urlString) {
        let protocol = null;

        try {
          protocol = new URL(urlString).protocol;
        } catch (err) {
          return null;
        }

        if (protocol === null || typeof protocol === 'undefined') {
          return null;
        }

        const scheme = protocol.slice(0, -1); // strip trailing `:`

        // The URL spec does not require a scheme to be followed by `//`, but checking
        // for it allows this rule to differentiate <scheme>:<hostname> urls from
        // <hostname>:<port> urls. `data:` scheme urls are an exception to this rule.
        const slashIndex = protocol.length;
        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2);
        const isSchemeLessUrl = expectedSlashes !== '//' && scheme !== 'data';

        if (isSchemeLessUrl) {
          return null;
        }

        return scheme;
      };

    }, { "url": 517 }], 436: [function (require, module, exports) {
      'use strict';

      const blurInterpolation = require('./blurInterpolation');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const valueParser = require('postcss-value-parser');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {import('postcss-value-parser').Node} node
       *
       * @returns {string | null}
       */
      module.exports = function (node) {
        if (!node || !node.value) {
          return null;
        }

        // Ignore non-word nodes
        if (node.type !== 'word') {
          return null;
        }

        // Ignore non standard syntax
        if (!isStandardSyntaxValue(node.value)) {
          return null;
        }

        // Ignore HEX
        if (node.value.startsWith('#')) {
          return null;
        }

        // Remove non standard stuff
        const value = blurInterpolation(node.value, '')
        // ignore hack unit
        .replace('\\0', '').
        replace('\\9', '');

        const parsedUnit = valueParser.unit(value);

        if (!parsedUnit) {
          return null;
        }

        return parsedUnit.unit;
      };

    }, { "./blurInterpolation": 421, "./isStandardSyntaxValue": 482, "postcss-value-parser": 120 }], 437: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an block (empty or otherwise).
       *
       * @param {import('postcss').Rule | import('postcss').AtRule} statement - postcss rule or at-rule node
       * @return {boolean} True if `statement` has a block (empty or otherwise)
       */
      module.exports = function (statement) {
        return statement.nodes !== undefined;
      };

    }, {}], 438: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an empty block.
       *
       * @param {import('postcss').Rule | import('postcss').AtRule} statement - postcss rule or at-rule node
       * @return {boolean} True if the statement has a block and it is empty
       */
      module.exports = function (statement) {
        return (
          statement.nodes !== undefined && statement.nodes.length === 0 // has block
        ); // and is empty
      };

    }, {}], 439: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string contains at least one empty line
       *
       * @param {string} string
       *
       * @returns {boolean}
       */
      module.exports = function (string) {
        if (string === '' || string === undefined) return false;

        return /\n[\r\t ]*\n/.test(string);
      };

    }, {}], 440: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a string has interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has interpolation
       */
      module.exports = function (string) {
        // SCSS or Less interpolation
        if (
        hasLessInterpolation(string) ||
        hasScssInterpolation(string) ||
        hasTplInterpolation(string) ||
        hasPsvInterpolation(string))
        {
          return true;
        }

        return false;
      };

    }, { "../utils/hasLessInterpolation": 441, "../utils/hasPsvInterpolation": 442, "../utils/hasScssInterpolation": 443, "../utils/hasTplInterpolation": 444 }], 441: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has less interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has less interpolation
       */
      module.exports = function (string) {
        return /@{.+?}/.test(string);
      };

    }, {}], 442: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has postcss-simple-vars interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /\$\(.+?\)/.test(string);
      };

    }, {}], 443: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has scss interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /#{.+?}/.test(string);
      };

    }, {}], 444: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has JS template literal interpolation or HTML-like template
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has template literal interpolation
       */
      module.exports = function (string) {
        return /{.+?}/.test(string);
      };

    }, {}], 445: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const previousNode = node.prev();

        if (!previousNode || previousNode.type !== 'comment') {
          return false;
        }

        return !isSharedLineComment(previousNode);
      };

    }, { "./isSharedLineComment": 469 }], 446: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      function isAfterSingleLineComment(node) {
        const prevNode = node.prev();

        return (
          prevNode !== undefined &&
          prevNode.type === 'comment' &&
          !isSharedLineComment(prevNode) &&
          prevNode.source &&
          prevNode.source.start &&
          prevNode.source.end &&
          prevNode.source.start.line === prevNode.source.end.line);

      }

      module.exports = isAfterSingleLineComment;

    }, { "./isSharedLineComment": 469 }], 447: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isCustomProperty = require('./isCustomProperty');
      const isStandardSyntaxDeclaration = require('./isStandardSyntaxDeclaration');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const prevNode = getPreviousNonSharedLineCommentNode(node);

        return (
          prevNode !== undefined &&
          prevNode.type === 'decl' &&
          isStandardSyntaxDeclaration(prevNode) &&
          !isCustomProperty(_.get(prevNode, 'prop', '')));

      };

    }, { "./getPreviousNonSharedLineCommentNode": 434, "./isCustomProperty": 455, "./isStandardSyntaxDeclaration": 473, "lodash": 68 }], 448: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const hasBlock = require('./hasBlock');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (atRule.type !== 'atrule') {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        if (previousNode === undefined) {
          return false;
        }

        return previousNode.type === 'atrule' && !hasBlock(previousNode) && !hasBlock(atRule);
      };

    }, { "./getPreviousNonSharedLineCommentNode": 434, "./hasBlock": 437 }], 449: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('./isBlocklessAtRuleAfterBlocklessAtRule');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (!isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        return _.get(previousNode, 'name') === atRule.name;
      };

    }, { "./getPreviousNonSharedLineCommentNode": 434, "./isBlocklessAtRuleAfterBlocklessAtRule": 448, "lodash": 68 }], 450: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a node is a context-functional pseudo-class (i.e. either a logical combination
       * or a 'aNPlusBOfSNotationPseudoClasses' / tree-structural pseudo-class)
       *
       * @param {import('postcss-selector-parser').Pseudo} node postcss-selector-parser node (of type pseudo)
       * @return {boolean} If `true`, the node is a context-functional pseudo-class
       */
      module.exports = function isContextFunctionalPseudoClass(node) {
        if (node.type === 'pseudo') {
          const normalisedParentName = node.value.toLowerCase().replace(/:+/, '');

          return (
            keywordSets.logicalCombinationsPseudoClasses.has(normalisedParentName) ||
            keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName));

        }

        return false;
      };

    }, { "../reference/keywordSets": 186 }], 451: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterIncrementKeywords.has(valueLowerCase) ||
        Number.isFinite(parseInt(valueLowerCase)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 186 }], 452: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterResetKeywords.has(valueLowerCase) ||
        Number.isFinite(parseInt(valueLowerCase)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 186 }], 453: [function (require, module, exports) {
      'use strict';

      const htmlTags = require('html-tags');
      const keywordSets = require('../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const svgTags = require('svg-tags');

      /**
       * Check whether a type selector is a custom element
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (!/^[a-z]/.test(selector)) {
          return false;
        }

        if (!selector.includes('-')) {
          return false;
        }

        const selectorLowerCase = selector.toLowerCase();

        if (selectorLowerCase !== selector) {
          return false;
        }

        if (svgTags.includes(selectorLowerCase)) {
          return false;
        }

        if (htmlTags.includes(selectorLowerCase)) {
          return false;
        }

        if (keywordSets.nonStandardHtmlTags.has(selectorLowerCase)) {
          return false;
        }

        if (mathMLTags.includes(selectorLowerCase)) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 186, "html-tags": 10, "mathml-tag-names": 71, "svg-tags": 514 }], 454: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media query is a custom
       * @param {string} mediaQuery
       * @returns {boolean}
       */
      module.exports = function (mediaQuery) {
        return mediaQuery.startsWith('--');
      };

    }, {}], 455: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is a custom one
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        return property.startsWith('--');
      };

    }, {}], 456: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const hasBlock = require('../utils/hasBlock');

      /**
       * Check whether a Node is a custom property set
       *
       * @param {import('postcss').Rule} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        const selector = _.get(node, 'raws.selector.raw', node.selector);

        return (
          node.type === 'rule' && hasBlock(node) && selector.startsWith('--') && selector.endsWith(':'));

      };

    }, { "../utils/hasBlock": 437, "lodash": 68 }], 457: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a selector is a custom one
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        return selector.startsWith(':--');
      };

    }, {}], 458: [function (require, module, exports) {
      'use strict';

      const { isComment, hasSource } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} statement
       * @returns {boolean}
       */
      module.exports = function (statement) {
        const parentNode = statement.parent;

        if (parentNode === undefined || parentNode.type === 'root') {
          return false;
        }

        if (statement === parentNode.first) {
          return true;
        }

        /*
         * Search for the statement in the parent's nodes, ignoring comment
         * nodes on the same line as the parent's opening brace.
         */

        const parentNodes = parentNode.nodes;

        if (!parentNodes) {
          return false;
        }

        const firstNode = parentNodes[0];

        if (
        !isComment(firstNode) ||
        typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n'))
        {
          return false;
        }

        if (!hasSource(firstNode) || !firstNode.source.start) {
          return false;
        }

        const openingBraceLine = firstNode.source.start.line;

        if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
          return false;
        }

        for (let i = 1; i < parentNodes.length; i++) {
          const node = parentNodes[i];

          if (node === statement) {
            return true;
          }

          if (
          !isComment(node) ||
          hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine)
          {
            return false;
          }
        }

        /* istanbul ignore next: Should always return in the loop */
        return false;
      };

    }, { "./typeGuards": 501 }], 459: [function (require, module, exports) {
      'use strict';

      const { isRoot } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        if (isRoot(node)) return false;

        const parentNode = node.parent;

        return isRoot(parentNode) && node === parentNode.first;
      };

    }, { "./typeGuards": 501 }], 460: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a rule is a keyframe one
       *
       * @param {import('postcss').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        const parent = rule.parent;

        return parent.type === 'atrule' && parent.name.toLowerCase() === 'keyframes';
      };

    }, {}], 461: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a string is a keyframe selector.
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (keywordSets.keyframeSelectorKeywords.has(selector)) {
          return true;
        }

        // Percentages
        if (/^(?:\d+\.?\d*|\d*\.?\d+)%$/.test(selector)) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 186 }], 462: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('./hasBlock');

      /**
       * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        return (
          atRule.type === 'atrule' && 'variable' in atRule && atRule.variable && !hasBlock(atRule) ||
          false);

      };

    }, { "./hasBlock": 437 }], 463: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss-value-parser').Node} ValueNode */

      /**
       * @param {ValueNode | undefined} valueNode
       * @returns {boolean}
       */
      module.exports = function (valueNode) {
        if (!valueNode) {
          return false;
        }

        if (valueNode.type !== 'function' || !valueNode.nodes || valueNode.value) {
          return false;
        }

        // It's necessary to remove comments and spaces if they are present
        const cleanNodes = valueNode.nodes.filter(
        node => node.type !== 'comment' && node.type !== 'space');


        // Map without comments and spaces will have the structure like $map (prop: value, prop2: value)
        //                                                                            
        //                                                                     0  1   2  3
        if (cleanNodes[0] && cleanNodes[0].type !== 'word' && cleanNodes[0].type !== 'string') {
          return false;
        }

        if (cleanNodes[1] && cleanNodes[1].value !== ':') {
          return false;
        }

        // There is no need to check type or value of this node since it could be anything
        if (!cleanNodes[2]) {
          return false;
        }

        if (cleanNodes[3] && cleanNodes[3].value !== ',') {
          return false;
        }

        return true;
      };

    }, {}], 464: [function (require, module, exports) {
      'use strict';

      const MATH_FUNCTIONS = require('../reference/mathFunctions');

      /**
       * Check whether a node is math function
       *
       * @param {import('postcss-value-parser').Node} node postcss-value-parser node
       * @return {boolean} If `true`, the node is math function
       */
      module.exports = function isMathFunction(node) {
        return node.type === 'function' && MATH_FUNCTIONS.includes(node.value.toLowerCase());
      };

    }, { "../reference/mathFunctions": 187 }], 465: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether it's a number or a number-like string:
       * i.e. when coerced to a number it == itself.
       *
       * @param {string | number} value
       */
      module.exports = function (value) {
        /* eslint-disable eqeqeq */
        return value.toString().trim().length !== 0 && Number(value) == value;
        /* eslint-enable eqeqeq */
      };

    }, {}], 466: [function (require, module, exports) {
      'use strict';

      const isWhitespace = require('./isWhitespace');

      /**
       * Returns a Boolean indicating whether the the input string is only whitespace.
       *
       * @param {string} input
       * @returns {boolean}
       */
      module.exports = function (input) {
        let isOnlyWhitespace = true;

        for (let i = 0, l = input.length; i < l; i++) {
          if (!isWhitespace(input[i])) {
            isOnlyWhitespace = false;
            break;
          }
        }

        return isOnlyWhitespace;
      };

    }, { "./isWhitespace": 486 }], 467: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature is a range context one
       *
       * @param {string} mediaFeature feature
       * @return {boolean} If `true`, media feature is a range context one
       */
      module.exports = function (mediaFeature) {
        return mediaFeature.includes('=') || mediaFeature.includes('<') || mediaFeature.includes('>');
      };

    }, {}], 468: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is SCSS variable
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))
        if (property.startsWith('$')) {
          return true;
        }

        // SCSS var within a namespace (e.g. namespace.$var: x)
        if (property.includes('.$')) {
          return true;
        }

        return false;
      };

    }, {}], 469: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const getNextNonSharedLineCommentNode = require('./getNextNonSharedLineCommentNode');
      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       *
       * @param {PostcssNode | void} a
       * @param {PostcssNode | void} b
       */
      function nodesShareLines(a, b) {
        return _.get(a, 'source.end.line') === _.get(b, 'source.start.line');
      }

      /**
       * @param {PostcssNode} node
       * @returns {boolean}
       */
      module.exports = function isSharedLineComment(node) {
        if (node.type !== 'comment') {
          return false;
        }

        const previousNonSharedLineCommentNode = getPreviousNonSharedLineCommentNode(node);

        if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
          return true;
        }

        const nextNonSharedLineCommentNode = getNextNonSharedLineCommentNode(node);

        if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
          return true;
        }

        const parentNode = node.parent;

        // It's a first child and located on the same line as block start
        if (
        parentNode !== undefined &&
        parentNode.type !== 'root' &&
        parentNode.index(node) === 0 &&
        node.raws.before !== undefined &&
        !node.raws.before.includes('\n'))
        {
          return true;
        }

        return false;
      };

    }, { "./getNextNonSharedLineCommentNode": 432, "./getPreviousNonSharedLineCommentNode": 434, "lodash": 68 }], 470: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string is a single line (i.e. does not contain
       * any newline characters).
       *
       * @param {string} input
       * @return {boolean}
       */
      module.exports = function (input) {
        return !/[\n\r]/.test(input);
      };

    }, {}], 471: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a at-rule is standard
       *
       * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule postcss at-rule node
       * @return {boolean} If `true`, the declaration is standard
       */
      module.exports = function (atRule) {
        // Ignore scss `@content` inside mixins
        if (!atRule.nodes && atRule.params === '') {
          return false;
        }

        // Ignore Less mixins
        if ('mixin' in atRule && atRule.mixin) {
          return false;
        }

        // Ignore Less detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`
        if (
        'variable' in atRule && atRule.variable ||
        !atRule.nodes && atRule.raws.afterName === '' && atRule.params[0] === '(')
        {
          return false;
        }

        return true;
      };

    }, {}], 472: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a combinator is standard
       *
       * @param {import('postcss-selector-parser').Combinator} node postcss-selector-parser node (of type combinator)
       * @return {boolean} If `true`, the combinator is standard
       */
      module.exports = function (node) {
        // if it's not a combinator, then it's not a standard combinator
        if (node.type !== 'combinator') {
          return false;
        }

        // Ignore reference combinators like `/deep/`
        if (node.value.startsWith('/') || node.value.endsWith('/')) {
          return false;
        }

        // ignore the combinators that are the first or last node in their container
        if (node.parent !== undefined && node.parent !== null) {
          let parent = node.parent;

          if (node === parent.first) {
            return false;
          }

          if (node === parent.last) {
            return false;
          }
        }

        return true;
      };

    }, {}], 473: [function (require, module, exports) {
      'use strict';

      const isScssVariable = require('./isScssVariable');
      const { isRoot } = require('./typeGuards');

      /**
       * @param {string} [lang]
       */
      function isStandardSyntaxLang(lang) {
        return lang && (lang === 'css' || lang === 'custom-template' || lang === 'template-literal');
      }

      /**
       * Check whether a declaration is standard
       *
       * @param {import('postcss').Declaration | import('postcss-less').Declaration} decl
       */
      module.exports = function (decl) {
        const prop = decl.prop;
        const parent = decl.parent;

        // Declarations belong in a declaration block or standard CSS source
        if (
        isRoot(parent) &&
        parent.source &&
        !isStandardSyntaxLang(
        /** @type {import('postcss').NodeSource & {lang?: string}} */parent.source.lang))

        {
          return false;
        }

        // SCSS var
        if (isScssVariable(prop)) {
          return false;
        }

        // Less var (e.g. @var: x), but exclude variable interpolation (e.g. @{var})
        if (prop[0] === '@' && prop[1] !== '{') {
          return false;
        }

        // Sass nested properties (e.g. border: { style: solid; color: red; })
        if (
        // @ts-ignore TODO TYPES selector does not exists
        parent.selector &&
        // @ts-ignore
        parent.selector[parent.selector.length - 1] === ':' &&
        // @ts-ignore
        parent.selector.substring(0, 2) !== '--')
        {
          return false;
        }

        // Less &:extend
        if ('extend' in decl && decl.extend) {
          return false;
        }

        return true;
      };

    }, { "./isScssVariable": 468, "./typeGuards": 501 }], 474: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a function is standard
       *
       * @param {import('postcss-value-parser').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        // Function nodes without names are things in parentheses like Sass lists
        if (!node.value) {
          return false;
        }

        return true;
      };

    }, {}], 475: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a math function is standard
       *
       * @param {string} mathFunction
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxMathFunction(mathFunction) {
        // SCSS variable
        if (mathFunction.includes('$')) {
          return false;
        }

        // Less variable
        if (mathFunction.includes('@')) {
          return false;
        }

        return true;
      };

    }, {}], 476: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature name is standard
       *
       * @param {string} mediaFeatureName
       * @returns {boolean}
       */
      module.exports = function (mediaFeatureName) {
        // SCSS interpolation
        if (/#{.+?}|\$.+?/.test(mediaFeatureName)) {
          return false;
        }

        return true;
      };

    }, {}], 477: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');
      const isScssVariable = require('./isScssVariable');

      /**
       * Check whether a property is standard
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var
        if (isScssVariable(property)) {
          return false;
        }

        // Less var (e.g. @var: x)
        if (property.startsWith('@')) {
          return false;
        }

        // Less append property value with space (e.g. transform+_: scale(2))
        if (property.endsWith('+') || property.endsWith('+_')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(property)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 440, "./isScssVariable": 468 }], 478: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');
      const isCustomPropertySet = require('../utils/isCustomPropertySet');
      const isStandardSyntaxSelector = require('../utils/isStandardSyntaxSelector');

      /**
       * Check whether a Node is a standard rule
       *
       * @param {import('postcss').Rule | import('postcss-less').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        if (rule.type !== 'rule') {
          return false;
        }

        // Get full selector
        const selector = _.get(rule, 'raws.selector.raw', rule.selector);

        if (!isStandardSyntaxSelector(rule.selector)) {
          return false;
        }

        // Custom property set (e.g. --custom-property-set: {})
        if (isCustomPropertySet(rule)) {
          return false;
        }

        // Called Less mixin (e.g. a { .mixin() })
        // @ts-ignore TODO TYPES support LESS and SASS types somehow
        if (rule.mixin) {
          return false;
        }

        // Less detached rulesets
        if (selector.startsWith('@') && selector.endsWith(':')) {
          return false;
        }

        // Ignore Less &:extend rule
        if ('extend' in rule && rule.extend) {
          return false;
        }

        // Ignore mixin or &:extend rule
        // https://github.com/shellscape/postcss-less/blob/master/lib/less-parser.js#L52
        // @ts-ignore TODO TYPES support LESS and SASS types somehow
        if (rule.params && rule.params[0]) {
          return false;
        }

        // Non-outputting Less mixin definition (e.g. .mixin() {})
        if (selector.endsWith(')') && !selector.includes(':')) {
          return false;
        }

        // Less guards
        if (/when\s+(not\s+)*\(/.test(selector)) {
          return false;
        }

        // Ignore Scss nested properties
        if (selector.endsWith(':')) {
          return false;
        }

        return true;
      };

    }, { "../utils/isCustomPropertySet": 456, "../utils/isStandardSyntaxSelector": 479, "lodash": 68 }], 479: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a selector is standard
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        // SCSS or Less interpolation
        if (hasInterpolation(selector)) {
          return false;
        }

        // SCSS placeholder selectors
        if (selector.startsWith('%')) {
          return false;
        }

        // Less :extend()
        if (/:extend(\(.*?\))?/.test(selector)) {
          return false;
        }

        // Less mixin with resolved nested selectors (e.g. .foo().bar or .foo(@a, @b)[bar])
        if (/\.[\w-]+\(.*\).+/i.test(selector)) {
          return false;
        }

        // ERB template tags
        if (selector.includes('<%') || selector.includes('%>')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 440 }], 480: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a type selector is standard
       *
       * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)
       * @return {boolean} If `true`, the type selector is standard
       */
      module.exports = function (node) {
        // postcss-selector-parser includes the arguments to nth-child() functions
        // as "tags", so we need to ignore them ourselves.
        // The fake-tag's "parent" is actually a selector node, whose parent
        // should be the :nth-child pseudo node.
        if (!node.parent || !node.parent.parent) {
          return false;
        }

        const _node$parent$parent = node.parent.parent;
        const parentType = _node$parent$parent.type;
        const parentValue = _node$parent$parent.value;

        if (parentValue) {
          const normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');

          if (
          parentType === 'pseudo' && (
          keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.linguisticPseudoClasses.has(normalisedParentName) ||
          keywordSets.shadowTreePseudoElements.has(normalisedParentName)))
          {
            return false;
          }
        }

        // &-bar is a nesting selector combined with a suffix
        if (node.prev() && node.prev().type === 'nesting') {
          return false;
        }

        if (node.value.startsWith('%')) {
          return false;
        }

        // Reference combinators like `/deep/`
        if (node.value.startsWith('/') && node.value.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 186 }], 481: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a URL is standard
       *
       * @param {string} url
       * @returns {boolean}
       */
      module.exports = function (url) {
        if (url.length === 0) {
          return true;
        }

        // Sass interpolation works anywhere
        if (hasScssInterpolation(url) || hasTplInterpolation(url) || hasPsvInterpolation(url)) {
          return false;
        }

        // Inside `'` and `"` work only LESS interpolation
        if (url.startsWith(`'`) && url.endsWith(`'`) || url.startsWith(`"`) && url.endsWith(`"`)) {
          if (hasLessInterpolation(url)) {
            return false;
          }

          return true;
        }

        // Less variable works only at the beginning
        // Check is less variable, allow use '@url/some/path'
        // https://github.com/less/less.js/blob/3.x/lib/less/parser/parser.js#L547
        if (url.startsWith('@') && /^@@?[\w-]+$/.test(url)) {
          return false;
        }

        // In url without quotes scss variable can be everywhere
        // But in this case it is allowed to use only specific characters
        // Also forbidden "/" at the end of url
        if (url.includes('$') && /^[$\s\w+-/*'"/]+$/.test(url) && !url.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasLessInterpolation": 441, "../utils/hasPsvInterpolation": 442, "../utils/hasScssInterpolation": 443, "../utils/hasTplInterpolation": 444 }], 482: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a value is standard
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        let normalizedValue = value;

        // Ignore operators before variables (example -$variable)
        if (/^[-+*/]/.test(value[0])) {
          normalizedValue = normalizedValue.slice(1);
        }

        // SCSS variable (example $variable)
        if (normalizedValue.startsWith('$')) {
          return false;
        }

        // SCSS namespace (example namespace.$variable)
        if (/^.+\.\$/.test(value)) {
          return false;
        }

        // Less variable
        if (normalizedValue.startsWith('@')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(normalizedValue)) {
          return false;
        }

        // WebExtension replacement keyword used by Chrome/Firefox
        // more information: https://developer.chrome.com/extensions/i18n
        // and https://github.com/stylelint/stylelint/issues/4707
        if (/__MSG_[^\s]+__/.test(value)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 440 }], 483: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');
      const valueParser = require('postcss-value-parser');

      /**
       * Check if a word is a font-size value.
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        if (!word) {
          return false;
        }

        if (keywordSets.fontSizeKeywords.has(word)) {
          return true;
        }

        const numberUnit = valueParser.unit(word);

        if (!numberUnit) {
          return false;
        }

        const unit = numberUnit.unit;

        if (unit === '%') {
          return true;
        }

        if (keywordSets.lengthUnits.has(unit.toLowerCase())) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 186, "postcss-value-parser": 120 }], 484: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a value is a valid 3, 4, 6 or 8 digit hex
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        return /^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(value);
      };

    }, {}], 485: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a word is a variable i.e var(--custom-property).
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        return word.toLowerCase().startsWith('var(');
      };

    }, {}], 486: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a character is whitespace.
       *
       * @param {string} char
       * @returns {boolean}
       */
      module.exports = function (char) {
        return [' ', '\n', '\t', '\r', '\f'].includes(char);
      };

    }, {}], 487: [function (require, module, exports) {
      'use strict';

      /**
       * Compares a string to a second value that, if it fits a certain convention,
       * is converted to a regular expression before the comparison.
       * If it doesn't fit the convention, then two strings are compared.
       *
       * Any strings starting and ending with `/` are interpreted
       * as regular expressions.
       *
       * @param {string} input
       * @param {string | RegExp | Array<string | RegExp>} comparison
       *
       * @returns {false | {match: string, pattern: (string | RegExp) }}
       */
      module.exports = function matchesStringOrRegExp(input, comparison) {
        if (!Array.isArray(input)) {
          return testAgainstStringOrRegExpOrArray(input, comparison);
        }

        for (const inputItem of input) {
          const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       * @param {string} value
       * @param {string | RegExp | Array<string | RegExp>} comparison
       */
      function testAgainstStringOrRegExpOrArray(value, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstStringOrRegExp(value, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstStringOrRegExp(value, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      }

      /**
       * @param {string} value
       * @param {string | RegExp} comparison
       */
      function testAgainstStringOrRegExp(value, comparison) {
        // If it's a RegExp, test directly
        if (comparison instanceof RegExp) {
          return comparison.test(value) ? { match: value, pattern: comparison } : false;
        }

        // Check if it's RegExp in a string
        const firstComparisonChar = comparison[0];
        const lastComparisonChar = comparison[comparison.length - 1];
        const secondToLastComparisonChar = comparison[comparison.length - 2];

        const comparisonIsRegex =
        firstComparisonChar === '/' && (
        lastComparisonChar === '/' ||
        secondToLastComparisonChar === '/' && lastComparisonChar === 'i');

        const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';

        // If so, create a new RegExp from it
        if (comparisonIsRegex) {
          const valueMatches = hasCaseInsensitiveFlag ?
          new RegExp(comparison.slice(1, -2), 'i').test(value) :
          new RegExp(comparison.slice(1, -1)).test(value);

          return valueMatches ? { match: value, pattern: comparison } : false;
        }

        // Otherwise, it's a string. Do a strict comparison
        return value === comparison ? { match: value, pattern: comparison } : false;
      }

    }, {}], 488: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       * Get the next non-comment node in a PostCSS AST
       * at or after a given node.
       *
       * @param {PostcssNode | void} startNode
       * @returns {PostcssNode | null}
       */
      module.exports = function nextNonCommentNode(startNode) {
        if (!startNode || !startNode.next) return null;

        if (startNode.type === 'comment') {
          return nextNonCommentNode(startNode.next());
        }

        return startNode;
      };

    }, {}], 489: [function (require, module, exports) {
      'use strict';

      /**
       * Create a collection of Maps that serve to contextualize a given node.
       * This is useful to ensure that you only compare nodes that share a certain
       * context.
       *
       * All nodes are initially contextualized by their input source.
       * From there, you can contextualize them however you want.
       *
       * For a usage example, see `selector-no-descending-specificity`.
       */
      module.exports = function () {
        const contextMap = new Map();

        return {
          /**
           * @param {import('postcss').Node} node
           */
          getContext(node, /** @type {any[]} */...subContexts) {
            // TODO TYPES node.source possible undefined
            const nodeSource = /** @type {import('postcss').NodeSource} */node.source.input.from;
            const baseContext = creativeGetMap(contextMap, nodeSource);

            return subContexts.reduce((result, context) => {
              return creativeGetMap(result, context);
            }, baseContext);
          } };

      };

      /**
       * TODO TYPES
       * @param {Map<any, any>} someMap
       * @param {any} someThing
       */
      function creativeGetMap(someMap, someThing) {
        if (!someMap.has(someThing)) {
          someMap.set(someThing, new Map());
        }

        return someMap.get(someThing);
      }

    }, {}], 490: [function (require, module, exports) {
      'use strict';

      const matchesStringOrRegExp = require('./matchesStringOrRegExp');

      /**
       * Check if an options object's propertyName contains a user-defined string or
       * regex that matches the passed in input.
       *
       * @param {{ [x: string]: any; }} options
       * @param {string} propertyName
       * @param {string} input
       *
       * @returns {boolean}
       */
      module.exports = function optionsMatches(options, propertyName, input) {
        return Boolean(
        options &&
        options[propertyName] &&
        typeof input === 'string' &&
        matchesStringOrRegExp(input, options[propertyName]));

      };

    }, { "./matchesStringOrRegExp": 487 }], 491: [function (require, module, exports) {
      'use strict';

      // To generate parser.js run the following command in the current directory:
      //
      // npx jison-gho parser.jison -o parser.js

      const parse = require('./parser').parse;

      /**
       * @param {string} exp
       * @returns {object}
       */
      module.exports = function parseCalcExpression(exp) {
        return parse(exp);
      };

    }, { "./parser": 492 }], 492: [function (require, module, exports) {

      // @ts-nocheck

      /* parser generated by jison 0.6.1-215 */

      /*
       * Returns a Parser object of the following structure:
       *
       *  Parser: {
       *    yy: {}     The so-called "shared state" or rather the *source* of it;
       *               the real "shared state" `yy` passed around to
       *               the rule actions, etc. is a derivative/copy of this one,
       *               not a direct reference!
       *  }
       *
       *  Parser.prototype: {
       *    yy: {},
       *    EOF: 1,
       *    TERROR: 2,
       *
       *    trace: function(errorMessage, ...),
       *
       *    JisonParserError: function(msg, hash),
       *
       *    quoteName: function(name),
       *               Helper function which can be overridden by user code later on: put suitable
       *               quotes around literal IDs in a description string.
       *
       *    originalQuoteName: function(name),
       *               The basic quoteName handler provided by JISON.
       *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
       *               at the end of the `parse()`.
       *
       *    describeSymbol: function(symbol),
       *               Return a more-or-less human-readable description of the given symbol, when
       *               available, or the symbol itself, serving as its own 'description' for lack
       *               of something better to serve up.
       *
       *               Return NULL when the symbol is unknown to the parser.
       *
       *    symbols_: {associative list: name ==> number},
       *    terminals_: {associative list: number ==> name},
       *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
       *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
       *    productions_: [...],
       *
       *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
       *
       *               The function parameters and `this` have the following value/meaning:
       *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
       *                             to store/reference the rule value `$$` and location info `@$`.
       *
       *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
       *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
       *                 data from one reduce action through to the next within a single parse run, then you
       *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
       *
       *                 `this.yy` is a direct reference to the `yy` shared state object.
       *
       *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
       *                 object at `parse()` start and are therefore available to the action code via the
       *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
       *                 the %parse-param` list.
       *
       *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
       *                             to match this rule. This is *not* the look-ahead token, but the last token
       *                             that's actually part of this rule.
       *
       *                 Formulated another way, `yytext` is the value of the token immediately preceeding
       *                 the current look-ahead token.
       *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
       *
       *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
       *
       *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
       *
       *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
       *
       *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
       *                               of an empty object when no suitable location info can be provided.
       *
       *               - `yystate` : the current parser state number, used internally for dispatching and
       *                               executing the action code chunk matching the rule currently being reduced.
       *
       *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
       *
       *                 This one comes in handy when you are going to do advanced things to the parser
       *                 stacks, all of which are accessible from your action code (see the next entries below).
       *
       *                 Also note that you can access this and other stack index values using the new double-hash
       *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
       *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
       *                 This is made available to write very advanced grammar action rules, e.g. when you want
       *                 to investigate the parse state stack in your action code, which would, for example,
       *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
       *                 to the work described here:
       *
       *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
       *                   In Journes Francophones des Languages Applicatifs.
       *
       *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
       *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631640.
       *
       *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
       *
       *                 This one comes in handy when you are going to do advanced things to the parser
       *                 stacks, all of which are accessible from your action code (see the next entries below).
       *
       *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
       *                             constructs.
       *
       *               - `yylstack`: reference to the parser token location stack. Also accessed via
       *                             the `@1` etc. constructs.
       *
       *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
       *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
       *                             action code did not provide a suitable location info object when such a
       *                             slot was filled!
       *
       *               - `yystack` : reference to the parser token id stack. Also accessed via the
       *                             `#1` etc. constructs.
       *
       *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
       *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
       *                 want access this array for your own purposes, such as error analysis as mentioned above!
       *
       *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
       *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
       *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
       *                 *reduced*.
       *
       *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
       *                             *states* such as the one in `yystate`, which are used to represent
       *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
       *                             what can I say? If you access this one, you're clearly doing wicked things
       *
       *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
       *                             grammar definition file.
       *
       *    table: [...],
       *               State transition table
       *               ----------------------
       *
       *               index levels are:
       *               - `state`  --> hash table
       *               - `symbol` --> action (number or array)
       *
       *                 If the `action` is an array, these are the elements' meaning:
       *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
       *                 - index [1]: GOTO `state`
       *
       *                 If the `action` is a number, it is the GOTO `state`
       *
       *    defaultActions: {...},
       *
       *    parseError: function(str, hash, ExceptionClass),
       *    yyError: function(str, ...),
       *    yyRecovering: function(),
       *    yyErrOk: function(),
       *    yyClearIn: function(),
       *
       *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
       *               Helper function **which will be set up during the first invocation of the `parse()` method**.
       *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
       *               See it's use in this parser kernel in many places; example usage:
       *
       *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
       *                                     parser.collect_expected_token_set(state), true);
       *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
       *
       *    originalParseError: function(str, hash, ExceptionClass),
       *               The basic `parseError` handler provided by JISON.
       *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
       *               at the end of the `parse()`.
       *
       *    options: { ... parser %options ... },
       *
       *    parse: function(input[, args...]),
       *               Parse the given `input` and return the parsed value (or `true` when none was provided by
       *               the root action, in which case the parser is acting as a *matcher*).
       *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
       *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
       *
       *               WARNING:
       *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
       *               any attributes already added to `yy` by the jison run-time;
       *               when such a collision is detected an exception is thrown to prevent the generated run-time
       *               from silently accepting this confusing and potentially hazardous situation!
       *
       *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
       *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
       *               object and any collision with those will be reported by the lexer via a thrown exception.
       *
       *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
       *               Helper function **which will be set up during the first invocation of the `parse()` method**.
       *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
       *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
       *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
       *               the internal parser gets properly garbage collected under these particular circumstances.
       *
       *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
       *               Helper function **which will be set up during the first invocation of the `parse()` method**.
       *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
       *
       *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
       *               this function will attempt to obtain a suitable location marker by inspecting the location stack
       *               backwards.
       *
       *               For more info see the documentation comment further below, immediately above this function's
       *               implementation.
       *
       *    lexer: {
       *        yy: {...},           A reference to the so-called "shared state" `yy` once
       *                             received via a call to the `.setInput(input, yy)` lexer API.
       *        EOF: 1,
       *        ERROR: 2,
       *        JisonLexerError: function(msg, hash),
       *        parseError: function(str, hash, ExceptionClass),
       *        setInput: function(input, [yy]),
       *        input: function(),
       *        unput: function(str),
       *        more: function(),
       *        reject: function(),
       *        less: function(n),
       *        pastInput: function(n),
       *        upcomingInput: function(n),
       *        showPosition: function(),
       *        test_match: function(regex_match_array, rule_index, ...),
       *        next: function(...),
       *        lex: function(...),
       *        begin: function(condition),
       *        pushState: function(condition),
       *        popState: function(),
       *        topState: function(),
       *        _currentRules: function(),
       *        stateStackSize: function(),
       *        cleanupAfterLex: function()
       *
       *        options: { ... lexer %options ... },
       *
       *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
       *        rules: [...],
       *        conditions: {associative list: name ==> set},
       *    }
       *  }
       *
       *
       *  token location info (@$, _$, etc.): {
       *    first_line: n,
       *    last_line: n,
       *    first_column: n,
       *    last_column: n,
       *    range: [start_number, end_number]
       *               (where the numbers are indexes into the input string, zero-based)
       *  }
       *
       * ---
       *
       * The `parseError` function receives a 'hash' object with these members for lexer and
       * parser errors:
       *
       *  {
       *    text:        (matched text)
       *    token:       (the produced terminal token, if any)
       *    token_id:    (the produced terminal token numeric ID, if any)
       *    line:        (yylineno)
       *    loc:         (yylloc)
       *  }
       *
       * parser (grammar) errors will also provide these additional members:
       *
       *  {
       *    expected:    (array describing the set of expected tokens;
       *                  may be UNDEFINED when we cannot easily produce such a set)
       *    state:       (integer (or array when the table includes grammar collisions);
       *                  represents the current internal state of the parser kernel.
       *                  can, for example, be used to pass to the `collect_expected_token_set()`
       *                  API to obtain the expected token set)
       *    action:      (integer; represents the current internal action which will be executed)
       *    new_state:   (integer; represents the next/planned internal state, once the current
       *                  action has executed)
       *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
       *                  available for this particular error)
       *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
       *                  for instance, for advanced error analysis and reporting)
       *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
       *                  for instance, for advanced error analysis and reporting)
       *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
       *                  for instance, for advanced error analysis and reporting)
       *    yy:          (object: the current parser internal "shared state" `yy`
       *                  as is also available in the rule actions; this can be used,
       *                  for instance, for advanced error analysis and reporting)
       *    lexer:       (reference to the current lexer instance used by the parser)
       *    parser:      (reference to the current parser instance)
       *  }
       *
       * while `this` will reference the current parser instance.
       *
       * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
       * instance, while these additional `hash` fields will also be provided:
       *
       *  {
       *    lexer:       (reference to the current lexer instance which reported the error)
       *  }
       *
       * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
       * from either the parser or lexer, `this` will still reference the related *parser*
       * instance, while these additional `hash` fields will also be provided:
       *
       *  {
       *    exception:   (reference to the exception thrown)
       *  }
       *
       * Please do note that in the latter situation, the `expected` field will be omitted as
       * this type of failure is assumed not to be due to *parse errors* but rather due to user
       * action code in either parser or lexer failing unexpectedly.
       *
       * ---
       *
       * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
       * These options are available:
       *
       * ### options which are global for all parser instances
       *
       *  Parser.pre_parse: function(yy)
       *                 optional: you can specify a pre_parse() function in the chunk following
       *                 the grammar, i.e. after the last `%%`.
       *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
       *                 optional: you can specify a post_parse() function in the chunk following
       *                 the grammar, i.e. after the last `%%`. When it does not return any value,
       *                 the parser will return the original `retval`.
       *
       * ### options which can be set up per parser instance
       *
       *  yy: {
       *      pre_parse:  function(yy)
       *                 optional: is invoked before the parse cycle starts (and before the first
       *                 invocation of `lex()`) but immediately after the invocation of
       *                 `parser.pre_parse()`).
       *      post_parse: function(yy, retval, parseInfo) { return retval; }
       *                 optional: is invoked when the parse terminates due to success ('accept')
       *                 or failure (even when exceptions are thrown).
       *                 `retval` contains the return value to be produced by `Parser.parse()`;
       *                 this function can override the return value by returning another.
       *                 When it does not return any value, the parser will return the original
       *                 `retval`.
       *                 This function is invoked immediately before `parser.post_parse()`.
       *
       *      parseError: function(str, hash, ExceptionClass)
       *                 optional: overrides the default `parseError` function.
       *      quoteName: function(name),
       *                 optional: overrides the default `quoteName` function.
       *  }
       *
       *  parser.lexer.options: {
       *      pre_lex:  function()
       *                 optional: is invoked before the lexer is invoked to produce another token.
       *                 `this` refers to the Lexer object.
       *      post_lex: function(token) { return token; }
       *                 optional: is invoked when the lexer has produced a token `token`;
       *                 this function can override the returned token value by returning another.
       *                 When it does not return any (truthy) value, the lexer will return
       *                 the original `token`.
       *                 `this` refers to the Lexer object.
       *
       *      ranges: boolean
       *                 optional: `true` ==> token location info will include a .range[] member.
       *      flex: boolean
       *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
       *                 exhaustively to find the longest match.
       *      backtrack_lexer: boolean
       *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
       *                 the lexer terminates the scan when a token is returned by the action code.
       *      xregexp: boolean
       *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
       *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
       *                 rule regexes have been written as standard JavaScript RegExp expressions.
       *  }
       */



      var parser = function () {


        // See also:
        // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
        // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
        // with userland code which might access the derived class in a 'classic' way.
        function JisonParserError(msg, hash) {
          Object.defineProperty(this, 'name', {
            enumerable: false,
            writable: false,
            value: 'JisonParserError' });


          if (msg == null) msg = '???';

          Object.defineProperty(this, 'message', {
            enumerable: false,
            writable: true,
            value: msg });


          this.hash = hash;

          var stacktrace;
          if (hash && hash.exception instanceof Error) {
            var ex2 = hash.exception;
            this.message = ex2.message || msg;
            stacktrace = ex2.stack;
          }
          if (!stacktrace) {
            if (Error.hasOwnProperty('captureStackTrace')) {// V8/Chrome engine
              Error.captureStackTrace(this, this.constructor);
            } else {
              stacktrace = new Error(msg).stack;
            }
          }
          if (stacktrace) {
            Object.defineProperty(this, 'stack', {
              enumerable: false,
              writable: false,
              value: stacktrace });

          }
        }

        if (typeof Object.setPrototypeOf === 'function') {
          Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
        } else {
          JisonParserError.prototype = Object.create(Error.prototype);
        }
        JisonParserError.prototype.constructor = JisonParserError;
        JisonParserError.prototype.name = 'JisonParserError';




        // helper: reconstruct the productions[] table
        function bp(s) {
          var rv = [];
          var p = s.pop;
          var r = s.rule;
          for (var i = 0, l = p.length; i < l; i++) {
            rv.push([
            p[i],
            r[i]]);

          }
          return rv;
        }



        // helper: reconstruct the defaultActions[] table
        function bda(s) {
          var rv = {};
          var d = s.idx;
          var g = s.goto;
          for (var i = 0, l = d.length; i < l; i++) {
            var j = d[i];
            rv[j] = g[i];
          }
          return rv;
        }



        // helper: reconstruct the 'goto' table
        function bt(s) {
          var rv = [];
          var d = s.len;
          var y = s.symbol;
          var t = s.type;
          var a = s.state;
          var m = s.mode;
          var g = s.goto;
          for (var i = 0, l = d.length; i < l; i++) {
            var n = d[i];
            var q = {};
            for (var j = 0; j < n; j++) {
              var z = y.shift();
              switch (t.shift()) {
                case 2:
                  q[z] = [
                  m.shift(),
                  g.shift()];

                  break;

                case 0:
                  q[z] = a.shift();
                  break;

                default:
                  // type === 1: accept
                  q[z] = [
                  3];}


            }
            rv.push(q);
          }
          return rv;
        }



        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
          a = a || 0;
          for (var i = 0; i < l; i++) {
            this.push(c);
            c += a;
          }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
          i = this.length - i;
          for (l += i; i < l; i++) {
            this.push(this[i]);
          }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
          var rv = [];
          for (var i = 0, l = a.length; i < l; i++) {
            var e = a[i];
            // Is this entry a helper function?
            if (typeof e === 'function') {
              i++;
              e.apply(rv, a[i]);
            } else {
              rv.push(e);
            }
          }
          return rv;
        }


        var parser = {
          // Code Generator Information Report
          // ---------------------------------
          //
          // Options:
          //
          //   default action mode: ............. ["classic","merge"]
          //   test-compile action mode: ........ "parser:*,lexer:*"
          //   try..catch: ...................... true
          //   default resolve on conflict: ..... true
          //   on-demand look-ahead: ............ false
          //   error recovery token skip maximum: 3
          //   yyerror in parse actions is: ..... NOT recoverable,
          //   yyerror in lexer actions and other non-fatal lexer are:
          //   .................................. NOT recoverable,
          //   debug grammar/output: ............ false
          //   has partial LR conflict upgrade:   true
          //   rudimentary token-stack support:   false
          //   parser table compression mode: ... 2
          //   export debug tables: ............. false
          //   export *all* tables: ............. false
          //   module type: ..................... commonjs
          //   parser engine type: .............. lalr
          //   output main() in the module: ..... true
          //   has user-specified main(): ....... false
          //   has user-specified require()/import modules for main():
          //   .................................. false
          //   number of expected conflicts: .... 0
          //
          //
          // Parser Analysis flags:
          //
          //   no significant actions (parser is a language matcher only):
          //   .................................. false
          //   uses yyleng: ..................... false
          //   uses yylineno: ................... false
          //   uses yytext: ..................... false
          //   uses yylloc: ..................... false
          //   uses ParseError API: ............. false
          //   uses YYERROR: .................... false
          //   uses YYRECOVERING: ............... false
          //   uses YYERROK: .................... false
          //   uses YYCLEARIN: .................. false
          //   tracks rule values: .............. true
          //   assigns rule values: ............. true
          //   uses location tracking: .......... true
          //   assigns location: ................ true
          //   uses yystack: .................... false
          //   uses yysstack: ................... false
          //   uses yysp: ....................... true
          //   uses yyrulelength: ............... false
          //   uses yyMergeLocationInfo API: .... true
          //   has error recovery: .............. false
          //   has error reporting: ............. false
          //
          // --------- END OF REPORT -----------

          trace: function no_op_trace() {},
          JisonParserError: JisonParserError,
          yy: {},
          options: {
            type: "lalr",
            hasPartialLrUpgradeOnConflict: true,
            errorRecoveryTokenDiscardCount: 3,
            caseInsensitive: true },

          symbols_: {
            "$accept": 0,
            "$end": 1,
            "ADD": 6,
            "ANGLE": 13,
            "CALC": 3,
            "DIV": 9,
            "EOF": 1,
            "FREQ": 15,
            "FUNCTION": 11,
            "LENGTH": 12,
            "LPAREN": 4,
            "MUL": 8,
            "NUMBER": 10,
            "PERCENTAGE": 17,
            "RES": 16,
            "RPAREN": 5,
            "SUB": 7,
            "TIME": 14,
            "UNKNOWN": 18,
            "css_value": 23,
            "error": 2,
            "expression": 19,
            "function": 22,
            "math_expression": 20,
            "value": 21 },

          terminals_: {
            1: "EOF",
            2: "error",
            3: "CALC",
            4: "LPAREN",
            5: "RPAREN",
            6: "ADD",
            7: "SUB",
            8: "MUL",
            9: "DIV",
            10: "NUMBER",
            11: "FUNCTION",
            12: "LENGTH",
            13: "ANGLE",
            14: "TIME",
            15: "FREQ",
            16: "RES",
            17: "PERCENTAGE",
            18: "UNKNOWN" },

          TERROR: 2,
          EOF: 1,

          // internals: defined here so the object *structure* doesn't get modified by parse() et al,
          // thus helping JIT compilers like Chrome V8.
          originalQuoteName: null,
          originalParseError: null,
          cleanupAfterParse: null,
          constructParseErrorInfo: null,
          yyMergeLocationInfo: null,

          __reentrant_call_depth: 0, // INTERNAL USE ONLY
          __error_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
          __error_recovery_infos: [], // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

          // APIs which will be set up depending on user action code analysis:
          //yyRecovering: 0,
          //yyErrOk: 0,
          //yyClearIn: 0,

          // Helper APIs
          // -----------

          // Helper function which can be overridden by user code later on: put suitable quotes around
          // literal IDs in a description string.
          quoteName: function parser_quoteName(id_str) {
            return '"' + id_str + '"';
          },

          // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
          //
          // Return NULL when the symbol is unknown to the parser.
          getSymbolName: function parser_getSymbolName(symbol) {
            if (this.terminals_[symbol]) {
              return this.terminals_[symbol];
            }

            // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
            //
            // An example of this may be where a rule's action code contains a call like this:
            //
            //      parser.getSymbolName(#$)
            //
            // to obtain a human-readable name of the current grammar rule.
            var s = this.symbols_;
            for (var key in s) {
              if (s[key] === symbol) {
                return key;
              }
            }
            return null;
          },

          // Return a more-or-less human-readable description of the given symbol, when available,
          // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
          //
          // Return NULL when the symbol is unknown to the parser.
          describeSymbol: function parser_describeSymbol(symbol) {
            if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
              return this.terminal_descriptions_[symbol];
            } else
            if (symbol === this.EOF) {
              return 'end of input';
            }
            var id = this.getSymbolName(symbol);
            if (id) {
              return this.quoteName(id);
            }
            return null;
          },

          // Produce a (more or less) human-readable list of expected tokens at the point of failure.
          //
          // The produced list may contain token or token set descriptions instead of the tokens
          // themselves to help turning this output into something that easier to read by humans
          // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
          // expected terminals and nonterminals is produced.
          //
          // The returned list (array) will not contain any duplicate entries.
          collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
            var TERROR = this.TERROR;
            var tokenset = [];
            var check = {};
            // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
            // If so, use that one instead of the less palatable token set.
            if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
              return [
              this.state_descriptions_[state]];

            }
            for (var p in this.table[state]) {
              p = +p;
              if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                  tokenset.push(d);
                  check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
              }
            }
            return tokenset;
          },
          productions_: bp({
            pop: u([
            19,
            s,
            [20, 11],
            21,
            22,
            s,
            [23, 7]]),

            rule: u([
            2,
            4,
            s,
            [3, 4],
            2,
            2,
            3,
            s,
            [1, 12]]) }),


          performAction: function parser__PerformAction(yyloc, yystate /* action[1] */, yysp, yyvstack, yylstack) {

            /* this == yyval */

            // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
            var yy = this.yy;
            var yyparser = yy.parser;
            var yylexer = yy.lexer;



            switch (yystate) {
              case 0:
                /*! Production::    $accept : expression $end */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yylstack[yysp - 1];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,LT,LA,-,-)
                break;

              case 1:
                /*! Production::    expression : math_expression EOF */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-):
                this.$ = yyvstack[yysp - 1];
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,LT,LA,-,-)


                return yyvstack[yysp - 1];
                break;

              case 2:
                /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */

                // default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 3, yysp);
                // END of default action (generated by JISON mode classic/merge :: 4,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                this.$.source.start = { index: yylstack[yysp - 3].range[0] };
                this.$.source.end = { index: yylstack[yysp].range[1] };
                break;

              case 3:
              /*! Production::    math_expression : math_expression ADD math_expression */
              case 4:
              /*! Production::    math_expression : math_expression SUB math_expression */
              case 5:
              /*! Production::    math_expression : math_expression MUL math_expression */
              case 6:
                /*! Production::    math_expression : math_expression DIV math_expression */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = {
                  type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp],
                  source: {
                    start: yyvstack[yysp - 2].source.start, end: yyvstack[yysp].source.end,
                    operator: { start: { index: yylstack[yysp - 1].range[0] }, end: { index: yylstack[yysp - 1].range[1] } } } };


                break;

              case 7:
                /*! Production::    math_expression : SUB math_expression */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {
                  throw new Error('Unexpected spaces was found between sign and value');
                }
                if (typeof yyvstack[yysp].value !== 'number') {
                  throw new Error('Unexpected sign');
                }
                if (yyvstack[yysp].sign) {
                  throw new Error('Unexpected continuous sign');
                }
                this.$ = yyvstack[yysp];
                this.$.sign = '-';
                this.$.value = -yyvstack[yysp].value;
                this.$.source.start.index = yylstack[yysp - 1].range[0];
                break;

              case 8:
                /*! Production::    math_expression : ADD math_expression */

                // default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 1, yysp);
                // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,VU,-,LT,LA,-,-)


                if (yylstack[yysp - 1].range[1] !== yyvstack[yysp].source.start.index) {
                  throw new Error('Unexpected spaces was found between sign and value');
                }
                if (typeof yyvstack[yysp].value !== 'number') {
                  throw new Error('Unexpected sign');
                }
                if (yyvstack[yysp].sign) {
                  throw new Error('Unexpected continuous sign');
                }
                this.$ = yyvstack[yysp];
                this.$.sign = '+';
                this.$.source.start.index = yylstack[yysp - 1].range[0];
                break;

              case 9:
                /*! Production::    math_expression : LPAREN math_expression RPAREN */

                // default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yyparser.yyMergeLocationInfo(yysp - 2, yysp);
                // END of default action (generated by JISON mode classic/merge :: 3,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp - 1];
                this.$.source.start = { index: yylstack[yysp - 2].range[0] };
                this.$.source.end = { index: yylstack[yysp].range[1] };
                break;

              case 10:
              /*! Production::    math_expression : function */
              case 11:
              /*! Production::    math_expression : css_value */
              case 12:
                /*! Production::    math_expression : value */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = yyvstack[yysp];
                break;

              case 13:
                /*! Production::    value : NUMBER */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]), source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 14:
                /*! Production::    function : FUNCTION */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'Function', value: yyvstack[yysp], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 15:
                /*! Production::    css_value : LENGTH */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 16:
                /*! Production::    css_value : ANGLE */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 17:
                /*! Production::    css_value : TIME */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 18:
                /*! Production::    css_value : FREQ */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 19:
                /*! Production::    css_value : RES */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/i.exec(yyvstack[yysp])[0], source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 20:
                /*! Production::    css_value : PERCENTAGE */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%', source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;

              case 21:
                /*! Production::    css_value : UNKNOWN */

                // default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-):
                this._$ = yylstack[yysp];
                // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,VU,-,LT,LA,-,-)


                this.$ = { type: 'UnknownValue', value: yyvstack[yysp], unit: '', source: { start: { index: yylstack[yysp].range[0] }, end: { index: yylstack[yysp].range[1] } } };
                break;}


          },
          table: bt({
            len: u([
            18,
            1,
            5,
            1,
            s,
            [17, 3],
            s,
            [0, 13],
            s,
            [17, 5],
            0,
            0,
            5,
            6,
            6,
            c,
            [5, 3],
            0,
            0]),

            symbol: u([
            3,
            4,
            6,
            7,
            s,
            [10, 14, 1],
            1,
            1,
            s,
            [6, 4, 1],
            4,
            c,
            [25, 13],
            c,
            [24, 4],
            c,
            [17, 119],
            s,
            [5, 5, 1],
            1,
            c,
            [6, 11],
            c,
            [5, 5]]),

            type: u([
            s,
            [2, 13],
            s,
            [0, 5],
            1,
            s,
            [2, 19],
            s,
            [0, 4],
            c,
            [17, 132],
            s,
            [2, 9]]),

            state: u([
            1,
            2,
            9,
            7,
            8,
            25,
            c,
            [4, 3],
            26,
            c,
            [4, 3],
            27,
            c,
            [4, 3],
            28,
            c,
            [4, 3],
            29,
            c,
            [4, 3],
            30,
            c,
            [4, 3],
            31,
            c,
            [4, 3],
            32,
            c,
            [4, 3]]),

            mode: u([
            s,
            [1, 128],
            s,
            [2, 4],
            c,
            [6, 8],
            s,
            [1, 5]]),

            goto: u([
            3,
            6,
            5,
            4,
            18,
            s,
            [10, 8, 1],
            s,
            [19, 6, 1],
            c,
            [19, 13],
            c,
            [13, 91],
            33,
            c,
            [110, 4],
            s,
            [3, 4],
            22,
            23,
            s,
            [4, 4],
            22,
            23,
            34,
            c,
            [17, 4]]) }),


          defaultActions: bda({
            idx: u([
            s,
            [7, 13, 1],
            25,
            26,
            30,
            31,
            33,
            34]),

            goto: u([
            10,
            11,
            12,
            s,
            [14, 8, 1],
            13,
            1,
            7,
            8,
            5,
            6,
            9,
            2]) }),


          parseError: function parseError(str, hash, ExceptionClass) {
            if (hash.recoverable) {
              if (typeof this.trace === 'function') {
                this.trace(str);
              }
              hash.destroy(); // destroy... well, *almost*!
            } else {
              if (typeof this.trace === 'function') {
                this.trace(str);
              }
              if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
              }
              throw new ExceptionClass(str, hash);
            }
          },
          parse: function parse(input) {
            var self = this;
            var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)
            var sstack = new Array(128); // state stack: stores states (column storage)

            var vstack = new Array(128); // semantic value stack
            var lstack = new Array(128); // location stack
            var table = this.table;
            var sp = 0; // 'stack pointer': index into the stacks
            var yyloc;




            var symbol = 0;



            var TERROR = this.TERROR;
            var EOF = this.EOF;
            var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;
            var NO_ACTION = [0, 35 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

            var lexer;
            if (this.__lexer__) {
              lexer = this.__lexer__;
            } else {
              lexer = this.__lexer__ = Object.create(this.lexer);
            }

            var sharedState_yy = {
              parseError: undefined,
              quoteName: undefined,
              lexer: undefined,
              parser: undefined,
              pre_parse: undefined,
              post_parse: undefined,
              pre_lex: undefined,
              post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
            };

            var ASSERT;
            if (typeof assert !== 'function') {
              ASSERT = function JisonAssert(cond, msg) {
                if (!cond) {
                  throw new Error('assertion failed: ' + (msg || '***'));
                }
              };
            } else {
              ASSERT = assert;
            }

            this.yyGetSharedState = function yyGetSharedState() {
              return sharedState_yy;
            };


            // shallow clone objects, straight copy of simple `src` values
            // e.g. `lexer.yytext` MAY be a complex value object,
            // rather than a simple string/value.
            function shallow_copy(src) {
              if (typeof src === 'object') {
                var dst = {};
                for (var k in src) {
                  if (Object.prototype.hasOwnProperty.call(src, k)) {
                    dst[k] = src[k];
                  }
                }
                return dst;
              }
              return src;
            }
            function shallow_copy_noclobber(dst, src) {
              for (var k in src) {
                if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                  dst[k] = src[k];
                }
              }
            }
            function copy_yylloc(loc) {
              var rv = shallow_copy(loc);
              if (rv && rv.range) {
                rv.range = rv.range.slice(0);
              }
              return rv;
            }

            // copy state
            shallow_copy_noclobber(sharedState_yy, this.yy);

            sharedState_yy.lexer = lexer;
            sharedState_yy.parser = this;






            // Does the shared state override the default `parseError` that already comes with this instance?
            if (typeof sharedState_yy.parseError === 'function') {
              this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
                if (!ExceptionClass) {
                  ExceptionClass = this.JisonParserError;
                }
                return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
              };
            } else {
              this.parseError = this.originalParseError;
            }

            // Does the shared state override the default `quoteName` that already comes with this instance?
            if (typeof sharedState_yy.quoteName === 'function') {
              this.quoteName = function quoteNameAlt(id_str) {
                return sharedState_yy.quoteName.call(this, id_str);
              };
            } else {
              this.quoteName = this.originalQuoteName;
            }

            // set up the cleanup function; make it an API so that external code can re-use this one in case of
            // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
            // case this parse() API method doesn't come with a `finally { ... }` block any more!
            //
            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
            //       or else your `sharedState`, etc. references will be *wrong*!
            this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
              var rv;

              if (invoke_post_methods) {
                var hash;

                if (sharedState_yy.post_parse || this.post_parse) {
                  // create an error hash info instance: we re-use this API in a **non-error situation**
                  // as this one delivers all parser internals ready for access by userland code.
                  hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
                }

                if (sharedState_yy.post_parse) {
                  rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                  if (typeof rv !== 'undefined') resultValue = rv;
                }
                if (this.post_parse) {
                  rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                  if (typeof rv !== 'undefined') resultValue = rv;
                }

                // cleanup:
                if (hash && hash.destroy) {
                  hash.destroy();
                }
              }

              if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.

              // clean up the lingering lexer structures as well:
              if (lexer.cleanupAfterLex) {
                lexer.cleanupAfterLex(do_not_nuke_errorinfos);
              }

              // prevent lingering circular references from causing memory leaks:
              if (sharedState_yy) {
                sharedState_yy.lexer = undefined;
                sharedState_yy.parser = undefined;
                if (lexer.yy === sharedState_yy) {
                  lexer.yy = undefined;
                }
              }
              sharedState_yy = undefined;
              this.parseError = this.originalParseError;
              this.quoteName = this.originalQuoteName;

              // nuke the vstack[] array at least as that one will still reference obsoleted user values.
              // To be safe, we nuke the other internal stack columns as well...
              stack.length = 0; // fastest way to nuke an array without overly bothering the GC
              sstack.length = 0;
              lstack.length = 0;
              vstack.length = 0;
              sp = 0;

              // nuke the error hash info instances created during this run.
              // Userland code must COPY any data/references
              // in the error hash instance(s) it is more permanently interested in.
              if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                  var el = this.__error_infos[i];
                  if (el && typeof el.destroy === 'function') {
                    el.destroy();
                  }
                }
                this.__error_infos.length = 0;


              }

              return resultValue;
            };

            // merge yylloc info into a new yylloc instance.
            //
            // `first_index` and `last_index` MAY be UNDEFINED/NULL or these are indexes into the `lstack[]` location stack array.
            //
            // `first_yylloc` and `last_yylloc` MAY be UNDEFINED/NULL or explicit (custom or regular) `yylloc` instances, in which
            // case these override the corresponding first/last indexes.
            //
            // `dont_look_back` is an optional flag (default: FALSE), which instructs this merge operation NOT to search
            // through the parse location stack for a location, which would otherwise be used to construct the new (epsilon!)
            // yylloc info.
            //
            // Note: epsilon rule's yylloc situation is detected by passing both `first_index` and `first_yylloc` as UNDEFINED/NULL.
            this.yyMergeLocationInfo = function parser_yyMergeLocationInfo(first_index, last_index, first_yylloc, last_yylloc, dont_look_back) {
              var i1 = first_index | 0,
              i2 = last_index | 0;
              var l1 = first_yylloc,
              l2 = last_yylloc;
              var rv;

              // rules:
              // - first/last yylloc entries override first/last indexes

              if (!l1) {
                if (first_index != null) {
                  for (var i = i1; i <= i2; i++) {
                    l1 = lstack[i];
                    if (l1) {
                      break;
                    }
                  }
                }
              }

              if (!l2) {
                if (last_index != null) {
                  for (var i = i2; i >= i1; i--) {
                    l2 = lstack[i];
                    if (l2) {
                      break;
                    }
                  }
                }
              }

              // - detect if an epsilon rule is being processed and act accordingly:
              if (!l1 && first_index == null) {
                // epsilon rule span merger. With optional look-ahead in l2.
                if (!dont_look_back) {
                  for (var i = (i1 || sp) - 1; i >= 0; i--) {
                    l1 = lstack[i];
                    if (l1) {
                      break;
                    }
                  }
                }
                if (!l1) {
                  if (!l2) {
                    // when we still don't have any valid yylloc info, we're looking at an epsilon rule
                    // without look-ahead and no preceding terms and/or `dont_look_back` set:
                    // in that case we ca do nothing but return NULL/UNDEFINED:
                    return undefined;
                  } else {
                    // shallow-copy L2: after all, we MAY be looking
                    // at unconventional yylloc info objects...
                    rv = shallow_copy(l2);
                    if (rv.range) {
                      // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                      rv.range = rv.range.slice(0);
                    }
                    return rv;
                  }
                } else {
                  // shallow-copy L1, then adjust first col/row 1 column past the end.
                  rv = shallow_copy(l1);
                  rv.first_line = rv.last_line;
                  rv.first_column = rv.last_column;
                  if (rv.range) {
                    // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                    rv.range = rv.range.slice(0);
                    rv.range[0] = rv.range[1];
                  }

                  if (l2) {
                    // shallow-mixin L2, then adjust last col/row accordingly.
                    shallow_copy_noclobber(rv, l2);
                    rv.last_line = l2.last_line;
                    rv.last_column = l2.last_column;
                    if (rv.range && l2.range) {
                      rv.range[1] = l2.range[1];
                    }
                  }
                  return rv;
                }
              }

              if (!l1) {
                l1 = l2;
                l2 = null;
              }
              if (!l1) {
                return undefined;
              }

              // shallow-copy L1|L2, before we try to adjust the yylloc values: after all, we MAY be looking
              // at unconventional yylloc info objects...
              rv = shallow_copy(l1);

              // first_line: ...,
              // first_column: ...,
              // last_line: ...,
              // last_column: ...,
              if (rv.range) {
                // shallow copy the yylloc ranges info to prevent us from modifying the original arguments' entries:
                rv.range = rv.range.slice(0);
              }

              if (l2) {
                shallow_copy_noclobber(rv, l2);
                rv.last_line = l2.last_line;
                rv.last_column = l2.last_column;
                if (rv.range && l2.range) {
                  rv.range[1] = l2.range[1];
                }
              }

              return rv;
            };

            // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
            //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
            this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
              var pei = {
                errStr: msg,
                exception: ex,
                text: lexer.match,
                value: lexer.yytext,
                token: this.describeSymbol(symbol) || symbol,
                token_id: symbol,
                line: lexer.yylineno,
                loc: copy_yylloc(lexer.yylloc),
                expected: expected,
                recoverable: recoverable,
                state: state,
                action: action,
                new_state: newState,
                symbol_stack: stack,
                state_stack: sstack,
                value_stack: vstack,
                location_stack: lstack,
                stack_pointer: sp,
                yy: sharedState_yy,
                lexer: lexer,
                parser: this,

                // and make sure the error info doesn't stay due to potential
                // ref cycle via userland code manipulations.
                // These would otherwise all be memory leak opportunities!
                //
                // Note that only array and object references are nuked as those
                // constitute the set of elements which can produce a cyclic ref.
                // The rest of the members is kept intact as they are harmless.
                destroy: function destructParseErrorInfo() {
                  // remove cyclic references added to error info:
                  // info.yy = null;
                  // info.lexer = null;
                  // info.value = null;
                  // info.value_stack = null;
                  // ...
                  var rec = !!this.recoverable;
                  for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                      this[key] = undefined;
                    }
                  }
                  this.recoverable = rec;
                } };

              // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
              this.__error_infos.push(pei);
              return pei;
            };













            function getNonTerminalFromCode(symbol) {
              var tokenName = self.getSymbolName(symbol);
              if (!tokenName) {
                tokenName = symbol;
              }
              return tokenName;
            }


            function stdLex() {
              var token = lexer.lex();
              // if token isn't its numeric value, convert
              if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
              }

              return token || EOF;
            }

            function fastLex() {
              var token = lexer.fastLex();
              // if token isn't its numeric value, convert
              if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
              }

              return token || EOF;
            }

            var lex = stdLex;


            var state, action, r, t;
            var yyval = {
              $: true,
              _$: undefined,
              yy: sharedState_yy };

            var p;
            var yyrulelen;
            var this_production;
            var newState;
            var retval = false;


            try {
              this.__reentrant_call_depth++;

              lexer.setInput(input, sharedState_yy);

              // NOTE: we *assume* no lexer pre/post handlers are set up *after*
              // this initial `setInput()` call: hence we can now check and decide
              // whether we'll go with the standard, slower, lex() API or the
              // `fast_lex()` one:
              if (typeof lexer.canIUse === 'function') {
                var lexerInfo = lexer.canIUse();
                if (lexerInfo.fastLex && typeof fastLex === 'function') {
                  lex = fastLex;
                }
              }

              yyloc = lexer.yylloc;
              lstack[sp] = yyloc;
              vstack[sp] = null;
              sstack[sp] = 0;
              stack[sp] = 0;
              ++sp;





              if (this.pre_parse) {
                this.pre_parse.call(this, sharedState_yy);
              }
              if (sharedState_yy.pre_parse) {
                sharedState_yy.pre_parse.call(this, sharedState_yy);
              }

              newState = sstack[sp - 1];
              for (;;) {
                // retrieve state number from top of stack
                state = newState; // sstack[sp - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                  action = 2;
                  newState = this.defaultActions[state];
                } else {
                  // The single `==` condition below covers both these `===` comparisons in a single
                  // operation:
                  //
                  //     if (symbol === null || typeof symbol === 'undefined') ...
                  if (!symbol) {
                    symbol = lex();
                  }
                  // read action for current state and first input
                  t = table[state] && table[state][symbol] || NO_ACTION;
                  newState = t[1];
                  action = t[0];











                  // handle parse error
                  if (!action) {
                    var errStr;
                    var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                      errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                      errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                      errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                      errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                      errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                      retval = r;
                    }
                    break;
                  }


                }










                switch (action) {
                  // catch misc. parse failures:
                  default:
                    // this shouldn't happen, unless resolve defaults are off
                    if (action instanceof Array) {
                      p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                      r = this.parseError(p.errStr, p, this.JisonParserError);
                      if (typeof r !== 'undefined') {
                        retval = r;
                      }
                      break;
                    }
                    // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                    // or a buggy LUT (LookUp Table):
                    p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                      retval = r;
                    }
                    break;

                  // shift:
                  case 1:
                    stack[sp] = symbol;
                    vstack[sp] = lexer.yytext;
                    lstack[sp] = copy_yylloc(lexer.yylloc);
                    sstack[sp] = newState; // push state

                    ++sp;
                    symbol = 0;




                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:



                    yyloc = lexer.yylloc;
                    continue;

                  // reduce:
                  case 2:



                    this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                    yyrulelen = this_production[1];










                    r = this.performAction.call(yyval, yyloc, newState, sp - 1, vstack, lstack);

                    if (typeof r !== 'undefined') {
                      retval = r;
                      break;
                    }

                    // pop off stack
                    sp -= yyrulelen;

                    // don't overwrite the `symbol` variable: use a local var to speed things up:
                    var ntsymbol = this_production[0]; // push nonterminal (reduce)
                    stack[sp] = ntsymbol;
                    vstack[sp] = yyval.$;
                    lstack[sp] = yyval._$;
                    // goto new state = table[STATE][NONTERMINAL]
                    newState = table[sstack[sp - 1]][ntsymbol];
                    sstack[sp] = newState;
                    ++sp;









                    continue;

                  // accept:
                  case 3:
                    if (sp !== -2) {
                      retval = true;
                      // Return the `$accept` rule's `$$` result, if available.
                      //
                      // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                      // default, action):
                      //
                      //     $accept: <startSymbol> $end
                      //                  %{ $$ = $1; @$ = @1; %}
                      //
                      // which, combined with the parse kernel's `$accept` state behaviour coded below,
                      // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                      // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                      //
                      // In code:
                      //
                      //                  %{
                      //                      @$ = @1;            // if location tracking support is included
                      //                      if (typeof $1 !== 'undefined')
                      //                          return $1;
                      //                      else
                      //                          return true;           // the default parse result if the rule actions don't produce anything
                      //                  %}
                      sp--;
                      if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                      }
                    }
                    break;}


                // break out of loop: we accept or fail with error
                break;
              }
            } catch (ex) {
              // report exceptions through the parseError callback too, but keep the exception intact
              // if it is a known parser or lexer error which has been thrown by parseError() already:
              if (ex instanceof this.JisonParserError) {
                throw ex;
              } else
              if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
                throw ex;
              }

              p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
              retval = false;
              r = this.parseError(p.errStr, p, this.JisonParserError);
              if (typeof r !== 'undefined') {
                retval = r;
              }
            } finally {
              retval = this.cleanupAfterParse(retval, true, true);
              this.__reentrant_call_depth--;
            } // /finally

            return retval;
          } };

        parser.originalParseError = parser.parseError;
        parser.originalQuoteName = parser.quoteName;
        /* lexer generated by jison-lex 0.6.1-215 */

        /*
         * Returns a Lexer object of the following structure:
         *
         *  Lexer: {
         *    yy: {}     The so-called "shared state" or rather the *source* of it;
         *               the real "shared state" `yy` passed around to
         *               the rule actions, etc. is a direct reference!
         *
         *               This "shared context" object was passed to the lexer by way of
         *               the `lexer.setInput(str, yy)` API before you may use it.
         *
         *               This "shared context" object is passed to the lexer action code in `performAction()`
         *               so userland code in the lexer actions may communicate with the outside world
         *               and/or other lexer rules' actions in more or less complex ways.
         *
         *  }
         *
         *  Lexer.prototype: {
         *    EOF: 1,
         *    ERROR: 2,
         *
         *    yy:        The overall "shared context" object reference.
         *
         *    JisonLexerError: function(msg, hash),
         *
         *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
         *
         *               The function parameters and `this` have the following value/meaning:
         *               - `this`    : reference to the `lexer` instance.
         *                               `yy_` is an alias for `this` lexer instance reference used internally.
         *
         *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
         *                             by way of the `lexer.setInput(str, yy)` API before.
         *
         *                             Note:
         *                             The extra arguments you specified in the `%parse-param` statement in your
         *                             **parser** grammar definition file are passed to the lexer via this object
         *                             reference as member variables.
         *
         *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
         *
         *               - `YY_START`: the current lexer "start condition" state.
         *
         *    parseError: function(str, hash, ExceptionClass),
         *
         *    constructLexErrorInfo: function(error_message, is_recoverable),
         *               Helper function.
         *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
         *               See it's use in this lexer kernel in many places; example usage:
         *
         *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
         *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
         *
         *    options: { ... lexer %options ... },
         *
         *    lex: function(),
         *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
         *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
         *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
         *
         *               WARNING:
         *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
         *               any attributes already added to `yy` by the **parser** or the jison run-time;
         *               when such a collision is detected an exception is thrown to prevent the generated run-time
         *               from silently accepting this confusing and potentially hazardous situation!
         *
         *    cleanupAfterLex: function(do_not_nuke_errorinfos),
         *               Helper function.
         *
         *               This helper API is invoked when the **parse process** has completed: it is the responsibility
         *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired.
         *
         *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
         *
         *    setInput: function(input, [yy]),
         *
         *
         *    input: function(),
         *
         *
         *    unput: function(str),
         *
         *
         *    more: function(),
         *
         *
         *    reject: function(),
         *
         *
         *    less: function(n),
         *
         *
         *    pastInput: function(n),
         *
         *
         *    upcomingInput: function(n),
         *
         *
         *    showPosition: function(),
         *
         *
         *    test_match: function(regex_match_array, rule_index),
         *
         *
         *    next: function(),
         *
         *
         *    begin: function(condition),
         *
         *
         *    pushState: function(condition),
         *
         *
         *    popState: function(),
         *
         *
         *    topState: function(),
         *
         *
         *    _currentRules: function(),
         *
         *
         *    stateStackSize: function(),
         *
         *
         *    performAction: function(yy, yy_, yyrulenumber, YY_START),
         *
         *
         *    rules: [...],
         *
         *
         *    conditions: {associative list: name ==> set},
         *  }
         *
         *
         *  token location info (`yylloc`): {
         *    first_line: n,
         *    last_line: n,
         *    first_column: n,
         *    last_column: n,
         *    range: [start_number, end_number]
         *               (where the numbers are indexes into the input string, zero-based)
         *  }
         *
         * ---
         *
         * The `parseError` function receives a 'hash' object with these members for lexer errors:
         *
         *  {
         *    text:        (matched text)
         *    token:       (the produced terminal token, if any)
         *    token_id:    (the produced terminal token numeric ID, if any)
         *    line:        (yylineno)
         *    loc:         (yylloc)
         *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
         *                  available for this particular error)
         *    yy:          (object: the current parser internal "shared state" `yy`
         *                  as is also available in the rule actions; this can be used,
         *                  for instance, for advanced error analysis and reporting)
         *    lexer:       (reference to the current lexer instance used by the parser)
         *  }
         *
         * while `this` will reference the current lexer instance.
         *
         * When `parseError` is invoked by the lexer, the default implementation will
         * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
         * it will try to invoke `yy.parseError()` instead. When that callback is also not
         * provided, a `JisonLexerError` exception will be thrown containing the error
         * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
         *
         * Note that the lexer's `JisonLexerError` error class is passed via the
         * `ExceptionClass` argument, which is invoked to construct the exception
         * instance to be thrown, so technically `parseError` will throw the object
         * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
         *
         * ---
         *
         * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
         * These options are available:
         *
         * (Options are permanent.)
         *
         *  yy: {
         *      parseError: function(str, hash, ExceptionClass)
         *                 optional: overrides the default `parseError` function.
         *  }
         *
         *  lexer.options: {
         *      pre_lex:  function()
         *                 optional: is invoked before the lexer is invoked to produce another token.
         *                 `this` refers to the Lexer object.
         *      post_lex: function(token) { return token; }
         *                 optional: is invoked when the lexer has produced a token `token`;
         *                 this function can override the returned token value by returning another.
         *                 When it does not return any (truthy) value, the lexer will return
         *                 the original `token`.
         *                 `this` refers to the Lexer object.
         *
         * WARNING: the next set of options are not meant to be changed. They echo the abilities of
         * the lexer as per when it was compiled!
         *
         *      ranges: boolean
         *                 optional: `true` ==> token location info will include a .range[] member.
         *      flex: boolean
         *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
         *                 exhaustively to find the longest match.
         *      backtrack_lexer: boolean
         *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
         *                 the lexer terminates the scan when a token is returned by the action code.
         *      xregexp: boolean
         *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
         *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
         *                 rule regexes have been written as standard JavaScript RegExp expressions.
         *  }
         */


        var lexer = function () {
          /**
           * See also:
           * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
           * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
           * with userland code which might access the derived class in a 'classic' way.
           *
           * @public
           * @constructor
           * @nocollapse
           */
          function JisonLexerError(msg, hash) {
            Object.defineProperty(this, 'name', {
              enumerable: false,
              writable: false,
              value: 'JisonLexerError' });


            if (msg == null)
            msg = '???';

            Object.defineProperty(this, 'message', {
              enumerable: false,
              writable: true,
              value: msg });


            this.hash = hash;
            var stacktrace;

            if (hash && hash.exception instanceof Error) {
              var ex2 = hash.exception;
              this.message = ex2.message || msg;
              stacktrace = ex2.stack;
            }

            if (!stacktrace) {
              if (Error.hasOwnProperty('captureStackTrace')) {
                // V8
                Error.captureStackTrace(this, this.constructor);
              } else {
                stacktrace = new Error(msg).stack;
              }
            }

            if (stacktrace) {
              Object.defineProperty(this, 'stack', {
                enumerable: false,
                writable: false,
                value: stacktrace });

            }
          }

          if (typeof Object.setPrototypeOf === 'function') {
            Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
          } else {
            JisonLexerError.prototype = Object.create(Error.prototype);
          }

          JisonLexerError.prototype.constructor = JisonLexerError;
          JisonLexerError.prototype.name = 'JisonLexerError';

          var lexer = {

            // Code Generator Information Report
            // ---------------------------------
            //
            // Options:
            //
            //   backtracking: .................... false
            //   location.ranges: ................. false
            //   location line+column tracking: ... true
            //
            //
            // Forwarded Parser Analysis flags:
            //
            //   uses yyleng: ..................... false
            //   uses yylineno: ................... false
            //   uses yytext: ..................... false
            //   uses yylloc: ..................... false
            //   uses lexer values: ............... true / true
            //   location tracking: ............... true
            //   location assignment: ............. true
            //
            //
            // Lexer Analysis flags:
            //
            //   uses yyleng: ..................... ???
            //   uses yylineno: ................... ???
            //   uses yytext: ..................... ???
            //   uses yylloc: ..................... ???
            //   uses ParseError API: ............. ???
            //   uses yyerror: .................... ???
            //   uses location tracking & editing:  ???
            //   uses more() API: ................. ???
            //   uses unput() API: ................ ???
            //   uses reject() API: ............... ???
            //   uses less() API: ................. ???
            //   uses display APIs pastInput(), upcomingInput(), showPosition():
            //        ............................. ???
            //   uses describeYYLLOC() API: ....... ???
            //
            // --------- END OF REPORT -----------

            EOF: 1,
            ERROR: 2,

            // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

            // options: {},                             /// <-- injected by the code generator

            // yy: ...,                                 /// <-- injected by setInput()

            __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state

            __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup
            __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use
            done: false, /// INTERNAL USE ONLY
            _backtrack: false, /// INTERNAL USE ONLY
            _input: '', /// INTERNAL USE ONLY
            _more: false, /// INTERNAL USE ONLY
            _signaled_error_token: false, /// INTERNAL USE ONLY
            conditionStack: [], /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`
            match: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!
            matched: '', /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far
            matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt
            yytext: '', /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.
            offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far
            yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)
            yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located
            yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction

            /**
             * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
             *
             * @public
             * @this {RegExpLexer}
             */
            constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
              msg = '' + msg;

              // heuristic to determine if the error message already contains a (partial) source code dump
              // as produced by either `showPosition()` or `prettyPrintRange()`:
              if (show_input_position == undefined) {
                show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
              }

              if (this.yylloc && show_input_position) {
                if (typeof this.prettyPrintRange === 'function') {
                  var pretty_src = this.prettyPrintRange(this.yylloc);

                  if (!/\n\s*$/.test(msg)) {
                    msg += '\n';
                  }

                  msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
                } else if (typeof this.showPosition === 'function') {
                  var pos_str = this.showPosition();

                  if (pos_str) {
                    if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
                      msg += '\n' + pos_str;
                    } else {
                      msg += pos_str;
                    }
                  }
                }
              }

              /** @constructor */
              var pei = {
                errStr: msg,
                recoverable: !!recoverable,
                text: this.match, // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                yy: this.yy,
                lexer: this,

                /**
                 * and make sure the error info doesn't stay due to potential
                 * ref cycle via userland code manipulations.
                 * These would otherwise all be memory leak opportunities!
                 *
                 * Note that only array and object references are nuked as those
                 * constitute the set of elements which can produce a cyclic ref.
                 * The rest of the members is kept intact as they are harmless.
                 *
                 * @public
                 * @this {LexErrorInfo}
                 */
                destroy: function destructLexErrorInfo() {
                  // remove cyclic references added to error info:
                  // info.yy = null;
                  // info.lexer = null;
                  // ...
                  var rec = !!this.recoverable;

                  for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                      this[key] = undefined;
                    }
                  }

                  this.recoverable = rec;
                } };


              // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
              this.__error_infos.push(pei);

              return pei;
            },

            /**
             * handler which is invoked when a lexer error occurs.
             *
             * @public
             * @this {RegExpLexer}
             */
            parseError: function lexer_parseError(str, hash, ExceptionClass) {
              if (!ExceptionClass) {
                ExceptionClass = this.JisonLexerError;
              }

              if (this.yy) {
                if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
                  return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                } else if (typeof this.yy.parseError === 'function') {
                  return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
                }
              }

              throw new ExceptionClass(str, hash);
            },

            /**
             * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
             *
             * @public
             * @this {RegExpLexer}
             */
            yyerror: function yyError(str /*, ...args */) {
              var lineno_msg = '';

              if (this.yylloc) {
                lineno_msg = ' on line ' + (this.yylineno + 1);
              }

              var p = this.constructLexErrorInfo(
              'Lexical error' + lineno_msg + ': ' + str,
              this.options.lexerErrorsAreRecoverable);


              // Add any extra args to the hash under the name `extra_error_attributes`:
              var args = Array.prototype.slice.call(arguments, 1);

              if (args.length) {
                p.extra_error_attributes = args;
              }

              return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
            },

            /**
             * final cleanup function for when we have completed lexing the input;
             * make it an API so that external code can use this one once userland
             * code has decided it's time to destroy any lingering lexer error
             * hash object instances and the like: this function helps to clean
             * up these constructs, which *may* carry cyclic references which would
             * otherwise prevent the instances from being properly and timely
             * garbage-collected, i.e. this function helps prevent memory leaks!
             *
             * @public
             * @this {RegExpLexer}
             */
            cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
              // prevent lingering circular references from causing memory leaks:
              this.setInput('', {});

              // nuke the error hash info instances created during this run.
              // Userland code must COPY any data/references
              // in the error hash instance(s) it is more permanently interested in.
              if (!do_not_nuke_errorinfos) {
                for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                  var el = this.__error_infos[i];

                  if (el && typeof el.destroy === 'function') {
                    el.destroy();
                  }
                }

                this.__error_infos.length = 0;
              }

              return this;
            },

            /**
             * clear the lexer token context; intended for internal use only
             *
             * @public
             * @this {RegExpLexer}
             */
            clear: function lexer_clear() {
              this.yytext = '';
              this.yyleng = 0;
              this.match = '';

              // - DO NOT reset `this.matched`
              this.matches = false;

              this._more = false;
              this._backtrack = false;
              var col = this.yylloc ? this.yylloc.last_column : 0;

              this.yylloc = {
                first_line: this.yylineno + 1,
                first_column: col,
                last_line: this.yylineno + 1,
                last_column: col,
                range: [this.offset, this.offset] };

            },

            /**
             * resets the lexer, sets new input
             *
             * @public
             * @this {RegExpLexer}
             */
            setInput: function lexer_setInput(input, yy) {
              this.yy = yy || this.yy || {};

              // also check if we've fully initialized the lexer instance,
              // including expansion work to be done to go from a loaded
              // lexer to a usable lexer:
              if (!this.__decompressed) {
                // step 1: decompress the regex list:
                var rules = this.rules;

                for (var i = 0, len = rules.length; i < len; i++) {
                  var rule_re = rules[i];

                  // compression: is the RE an xref to another RE slot in the rules[] table?
                  if (typeof rule_re === 'number') {
                    rules[i] = rules[rule_re];
                  }
                }

                // step 2: unfold the conditions[] set to make these ready for use:
                var conditions = this.conditions;

                for (var k in conditions) {
                  var spec = conditions[k];
                  var rule_ids = spec.rules;
                  var len = rule_ids.length;
                  var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple!
                  var rule_new_ids = new Array(len + 1);

                  for (var i = 0; i < len; i++) {
                    var idx = rule_ids[i];
                    var rule_re = rules[idx];
                    rule_regexes[i + 1] = rule_re;
                    rule_new_ids[i + 1] = idx;
                  }

                  spec.rules = rule_new_ids;
                  spec.__rule_regexes = rule_regexes;
                  spec.__rule_count = len;
                }

                this.__decompressed = true;
              }

              this._input = input || '';
              this.clear();
              this._signaled_error_token = false;
              this.done = false;
              this.yylineno = 0;
              this.matched = '';
              this.conditionStack = ['INITIAL'];
              this.__currentRuleSet__ = null;

              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0] };


              this.offset = 0;
              return this;
            },

            /**
             * edit the remaining input via user-specified callback.
             * This can be used to forward-adjust the input-to-parse,
             * e.g. inserting macro expansions and alike in the
             * input which has yet to be lexed.
             * The behaviour of this API contrasts the `unput()` et al
             * APIs as those act on the *consumed* input, while this
             * one allows one to manipulate the future, without impacting
             * the current `yyloc` cursor location or any history.
             *
             * Use this API to help implement C-preprocessor-like
             * `#include` statements, etc.
             *
             * The provided callback must be synchronous and is
             * expected to return the edited input (string).
             *
             * The `cpsArg` argument value is passed to the callback
             * as-is.
             *
             * `callback` interface:
             * `function callback(input, cpsArg)`
             *
             * - `input` will carry the remaining-input-to-lex string
             *   from the lexer.
             * - `cpsArg` is `cpsArg` passed into this API.
             *
             * The `this` reference for the callback will be set to
             * reference this lexer instance so that userland code
             * in the callback can easily and quickly access any lexer
             * API.
             *
             * When the callback returns a non-string-type falsey value,
             * we assume the callback did not edit the input and we
             * will using the input as-is.
             *
             * When the callback returns a non-string-type value, it
             * is converted to a string for lexing via the `"" + retval`
             * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html
             * -- that way any returned object's `toValue()` and `toString()`
             * methods will be invoked in a proper/desirable order.)
             *
             * @public
             * @this {RegExpLexer}
             */
            editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
              var rv = callback.call(this, this._input, cpsArg);

              if (typeof rv !== 'string') {
                if (rv) {
                  this._input = '' + rv;
                }
                // else: keep `this._input` as is.
              } else {
                this._input = rv;
              }

              return this;
            },

            /**
             * consumes and returns one char from the input
             *
             * @public
             * @this {RegExpLexer}
             */
            input: function lexer_input() {
              if (!this._input) {
                //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
                return null;
              }

              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;

              // Count the linenumber up when we hit the LF (or a stand-alone CR).
              // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
              // and we advance immediately past the LF as well, returning both together as if
              // it was all a single 'character' only.
              var slice_len = 1;

              var lines = false;

              if (ch === '\n') {
                lines = true;
              } else if (ch === '\r') {
                lines = true;
                var ch2 = this._input[1];

                if (ch2 === '\n') {
                  slice_len++;
                  ch += ch2;
                  this.yytext += ch2;
                  this.yyleng++;
                  this.offset++;
                  this.match += ch2;
                  this.matched += ch2;
                  this.yylloc.range[1]++;
                }
              }

              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
                this.yylloc.last_column = 0;
              } else {
                this.yylloc.last_column++;
              }

              this.yylloc.range[1]++;
              this._input = this._input.slice(slice_len);
              return ch;
            },

            /**
             * unshifts one char (or an entire string) into the input
             *
             * @public
             * @this {RegExpLexer}
             */
            unput: function lexer_unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len);
              this.yyleng = this.yytext.length;
              this.offset -= len;
              this.match = this.match.substr(0, this.match.length - len);
              this.matched = this.matched.substr(0, this.matched.length - len);

              if (lines.length > 1) {
                this.yylineno -= lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;

                // Get last entirely matched line into the `pre_lines[]` array's
                // last index slot; we don't mind when other previously
                // matched lines end up in the array too.
                var pre = this.match;

                var pre_lines = pre.split(/(?:\r\n?|\n)/g);

                if (pre_lines.length === 1) {
                  pre = this.matched;
                  pre_lines = pre.split(/(?:\r\n?|\n)/g);
                }

                this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
              } else {
                this.yylloc.last_column -= len;
              }

              this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
              this.done = false;
              return this;
            },

            /**
             * cache matched text and append it on next action
             *
             * @public
             * @this {RegExpLexer}
             */
            more: function lexer_more() {
              this._more = true;
              return this;
            },

            /**
             * signal the lexer that this rule fails to match the input, so the
             * next matching rule (regex) should be tested instead.
             *
             * @public
             * @this {RegExpLexer}
             */
            reject: function lexer_reject() {
              if (this.options.backtrack_lexer) {
                this._backtrack = true;
              } else {
                // when the `parseError()` call returns, we MUST ensure that the error is registered.
                // We accomplish this by signaling an 'error' token to be produced for the current
                // `.lex()` run.
                var lineno_msg = '';

                if (this.yylloc) {
                  lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo(
                'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
                false);


                this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
              }

              return this;
            },

            /**
             * retain first n characters of the match
             *
             * @public
             * @this {RegExpLexer}
             */
            less: function lexer_less(n) {
              return this.unput(this.match.slice(n));
            },

            /**
             * return (part of the) already matched input, i.e. for error
             * messages.
             *
             * Limit the returned string length to `maxSize` (default: 20).
             *
             * Limit the returned string to the `maxLines` number of lines of
             * input (default: 1).
             *
             * Negative limit values equal *unlimited*.
             *
             * @public
             * @this {RegExpLexer}
             */
            pastInput: function lexer_pastInput(maxSize, maxLines) {
              var past = this.matched.substring(0, this.matched.length - this.match.length);

              if (maxSize < 0)
              maxSize = past.length;else
              if (!maxSize)
              maxSize = 20;

              if (maxLines < 0)
              maxLines = past.length; // can't ever have more input lines than this!
              else if (!maxLines)
                maxLines = 1;

              // `substr` anticipation: treat \r\n as a single character and take a little
              // more than necessary so that we can still properly check against maxSize
              // after we've transformed and limited the newLines in here:
              past = past.substr(-maxSize * 2 - 2);

              // now that we have a significantly reduced string to process, transform the newlines
              // and chop them, then limit them:
              var a = past.replace(/\r\n|\r/g, '\n').split('\n');

              a = a.slice(-maxLines);
              past = a.join('\n');

              // When, after limiting to maxLines, we still have too much to return,
              // do add an ellipsis prefix...
              if (past.length > maxSize) {
                past = '...' + past.substr(-maxSize);
              }

              return past;
            },

            /**
             * return (part of the) upcoming input, i.e. for error messages.
             *
             * Limit the returned string length to `maxSize` (default: 20).
             *
             * Limit the returned string to the `maxLines` number of lines of input (default: 1).
             *
             * Negative limit values equal *unlimited*.
             *
             * > ### NOTE ###
             * >
             * > *"upcoming input"* is defined as the whole of the both
             * > the *currently lexed* input, together with any remaining input
             * > following that. *"currently lexed"* input is the input
             * > already recognized by the lexer but not yet returned with
             * > the lexer token. This happens when you are invoking this API
             * > from inside any lexer rule action code block.
             * >
             *
             * @public
             * @this {RegExpLexer}
             */
            upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
              var next = this.match;

              if (maxSize < 0)
              maxSize = next.length + this._input.length;else
              if (!maxSize)
              maxSize = 20;

              if (maxLines < 0)
              maxLines = maxSize; // can't ever have more input lines than this!
              else if (!maxLines)
                maxLines = 1;

              // `substring` anticipation: treat \r\n as a single character and take a little
              // more than necessary so that we can still properly check against maxSize
              // after we've transformed and limited the newLines in here:
              if (next.length < maxSize * 2 + 2) {
                next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8
              }

              // now that we have a significantly reduced string to process, transform the newlines
              // and chop them, then limit them:
              var a = next.replace(/\r\n|\r/g, '\n').split('\n');

              a = a.slice(0, maxLines);
              next = a.join('\n');

              // When, after limiting to maxLines, we still have too much to return,
              // do add an ellipsis postfix...
              if (next.length > maxSize) {
                next = next.substring(0, maxSize) + '...';
              }

              return next;
            },

            /**
             * return a string which displays the character position where the
             * lexing error occurred, i.e. for error messages
             *
             * @public
             * @this {RegExpLexer}
             */
            showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
              var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
            },

            /**
             * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
             * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
             * it MAY be NULL) and you MUST have a valid location info object anyway:
             * then we take the given context of the `preceding` and `following` locations, IFF those are available,
             * and reconstruct the `actual` location info from those.
             * If this fails, the heuristic is to take the `current` location, IFF available.
             * If this fails as well, we assume the sought location is at/around the current lexer position
             * and then produce that one as a response. DO NOTE that these heuristic/derived location info
             * values MAY be inaccurate!
             *
             * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
             * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
             *
             * @public
             * @this {RegExpLexer}
             */
            deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
              var loc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0,
                range: [0, 0] };


              if (actual) {
                loc.first_line = actual.first_line | 0;
                loc.last_line = actual.last_line | 0;
                loc.first_column = actual.first_column | 0;
                loc.last_column = actual.last_column | 0;

                if (actual.range) {
                  loc.range[0] = actual.range[0] | 0;
                  loc.range[1] = actual.range[1] | 0;
                }
              }

              if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
                // plan B: heuristic using preceding and following:
                if (loc.first_line <= 0 && preceding) {
                  loc.first_line = preceding.last_line | 0;
                  loc.first_column = preceding.last_column | 0;

                  if (preceding.range) {
                    loc.range[0] = actual.range[1] | 0;
                  }
                }

                if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
                  loc.last_line = following.first_line | 0;
                  loc.last_column = following.first_column | 0;

                  if (following.range) {
                    loc.range[1] = actual.range[0] | 0;
                  }
                }

                // plan C?: see if the 'current' location is useful/sane too:
                if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
                  loc.first_line = current.first_line | 0;
                  loc.first_column = current.first_column | 0;

                  if (current.range) {
                    loc.range[0] = current.range[0] | 0;
                  }
                }

                if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
                  loc.last_line = current.last_line | 0;
                  loc.last_column = current.last_column | 0;

                  if (current.range) {
                    loc.range[1] = current.range[1] | 0;
                  }
                }
              }

              // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
              // or plan D heuristics to produce a 'sensible' last_line value:
              if (loc.last_line <= 0) {
                if (loc.first_line <= 0) {
                  loc.first_line = this.yylloc.first_line;
                  loc.last_line = this.yylloc.last_line;
                  loc.first_column = this.yylloc.first_column;
                  loc.last_column = this.yylloc.last_column;
                  loc.range[0] = this.yylloc.range[0];
                  loc.range[1] = this.yylloc.range[1];
                } else {
                  loc.last_line = this.yylloc.last_line;
                  loc.last_column = this.yylloc.last_column;
                  loc.range[1] = this.yylloc.range[1];
                }
              }

              if (loc.first_line <= 0) {
                loc.first_line = loc.last_line;
                loc.first_column = 0; // loc.last_column;
                loc.range[1] = loc.range[0];
              }

              if (loc.first_column < 0) {
                loc.first_column = 0;
              }

              if (loc.last_column < 0) {
                loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
              }

              return loc;
            },

            /**
             * return a string which displays the lines & columns of input which are referenced
             * by the given location info range, plus a few lines of context.
             *
             * This function pretty-prints the indicated section of the input, with line numbers
             * and everything!
             *
             * This function is very useful to provide highly readable error reports, while
             * the location range may be specified in various flexible ways:
             *
             * - `loc` is the location info object which references the area which should be
             *   displayed and 'marked up': these lines & columns of text are marked up by `^`
             *   characters below each character in the entire input range.
             *
             * - `context_loc` is the *optional* location info object which instructs this
             *   pretty-printer how much *leading* context should be displayed alongside
             *   the area referenced by `loc`. This can help provide context for the displayed
             *   error, etc.
             *
             *   When this location info is not provided, a default context of 3 lines is
             *   used.
             *
             * - `context_loc2` is another *optional* location info object, which serves
             *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
             *   context lines to display in the pretty-print output.
             *
             *   When this location info is not provided, a default context of 1 line only is
             *   used.
             *
             * Special Notes:
             *
             * - when the `loc`-indicated range is very large (about 5 lines or more), then
             *   only the first and last few lines of this block are printed while a
             *   `...continued...` message will be printed between them.
             *
             *   This serves the purpose of not printing a huge amount of text when the `loc`
             *   range happens to be huge: this way a manageable & readable output results
             *   for arbitrary large ranges.
             *
             * - this function can display lines of input which whave not yet been lexed.
             *   `prettyPrintRange()` can access the entire input!
             *
             * @public
             * @this {RegExpLexer}
             */
            prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
              loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
              const CONTEXT = 3;
              const CONTEXT_TAIL = 1;
              const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
              var input = this.matched + this._input;
              var lines = input.split('\n');
              var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
              var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
              var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
              var ws_prefix = new Array(lineno_display_width).join(' ');
              var nonempty_line_indexes = [];

              var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
                var lno = index + l0;
                var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
                var rv = lno_pfx + ': ' + line;
                var errpfx = new Array(lineno_display_width + 1).join('^');
                var offset = 2 + 1;
                var len = 0;

                if (lno === loc.first_line) {
                  offset += loc.first_column;

                  len = Math.max(
                  2,
                  (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);

                } else if (lno === loc.last_line) {
                  len = Math.max(2, loc.last_column + 1);
                } else if (lno > loc.first_line && lno < loc.last_line) {
                  len = Math.max(2, line.length + 1);
                }

                if (len) {
                  var lead = new Array(offset).join('.');
                  var mark = new Array(len).join('^');
                  rv += '\n' + errpfx + lead + mark;

                  if (line.trim().length > 0) {
                    nonempty_line_indexes.push(index);
                  }
                }

                rv = rv.replace(/\t/g, ' ');
                return rv;
              });

              // now make sure we don't print an overly large amount of error area: limit it
              // to the top and bottom line count:
              if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
                var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
                var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
                var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
                intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
                rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
              }

              return rv.join('\n');
            },

            /**
             * helper function, used to produce a human readable description as a string, given
             * the input `yylloc` location object.
             *
             * Set `display_range_too` to TRUE to include the string character index position(s)
             * in the description if the `yylloc.range` is available.
             *
             * @public
             * @this {RegExpLexer}
             */
            describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
              var l1 = yylloc.first_line;
              var l2 = yylloc.last_line;
              var c1 = yylloc.first_column;
              var c2 = yylloc.last_column;
              var dl = l2 - l1;
              var dc = c2 - c1;
              var rv;

              if (dl === 0) {
                rv = 'line ' + l1 + ', ';

                if (dc <= 1) {
                  rv += 'column ' + c1;
                } else {
                  rv += 'columns ' + c1 + ' .. ' + c2;
                }
              } else {
                rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
              }

              if (yylloc.range && display_range_too) {
                var r1 = yylloc.range[0];
                var r2 = yylloc.range[1] - 1;

                if (r2 <= r1) {
                  rv += ' {String Offset: ' + r1 + '}';
                } else {
                  rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
                }
              }

              return rv;
            },

            /**
             * test the lexed token: return FALSE when not a match, otherwise return token.
             *
             * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
             * contains the actually matched text string.
             *
             * Also move the input cursor forward and update the match collectors:
             *
             * - `yytext`
             * - `yyleng`
             * - `match`
             * - `matches`
             * - `yylloc`
             * - `offset`
             *
             * @public
             * @this {RegExpLexer}
             */
            test_match: function lexer_test_match(match, indexed_rule) {
              var token, lines, backup, match_str, match_str_len;

              if (this.options.backtrack_lexer) {
                // save context
                backup = {
                  yylineno: this.yylineno,

                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylloc.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column,
                    range: this.yylloc.range.slice(0) },


                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,

                  //_signaled_error_token: this._signaled_error_token,
                  yy: this.yy,

                  conditionStack: this.conditionStack.slice(0),
                  done: this.done };

              }

              match_str = match[0];
              match_str_len = match_str.length;

              // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
              lines = match_str.split(/(?:\r\n?|\n)/g);

              if (lines.length > 1) {
                this.yylineno += lines.length - 1;
                this.yylloc.last_line = this.yylineno + 1;
                this.yylloc.last_column = lines[lines.length - 1].length;
              } else {
                this.yylloc.last_column += match_str_len;
              }

              // }
              this.yytext += match_str;

              this.match += match_str;
              this.matched += match_str;
              this.matches = match;
              this.yyleng = this.yytext.length;
              this.yylloc.range[1] += match_str_len;

              // previous lex rules MAY have invoked the `more()` API rather than producing a token:
              // those rules will already have moved this `offset` forward matching their match lengths,
              // hence we must only add our own match length now:
              this.offset += match_str_len;

              this._more = false;
              this._backtrack = false;
              this._input = this._input.slice(match_str_len);

              // calling this method:
              //
              //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
              token = this.performAction.call(
              this,
              this.yy,
              indexed_rule,
              this.conditionStack[this.conditionStack.length - 1] /* = YY_START */);


              // otherwise, when the action codes are all simple return token statements:
              //token = this.simpleCaseActionClusters[indexed_rule];

              if (this.done && this._input) {
                this.done = false;
              }

              if (token) {
                return token;
              } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                  this[k] = backup[k];
                }

                this.__currentRuleSet__ = null;
                return false; // rule action called reject() implying the next rule should be tested instead.
              } else if (this._signaled_error_token) {
                // produce one 'error' token as `.parseError()` in `reject()`
                // did not guarantee a failure signal by throwing an exception!
                token = this._signaled_error_token;

                this._signaled_error_token = false;
                return token;
              }

              return false;
            },

            /**
             * return next match in input
             *
             * @public
             * @this {RegExpLexer}
             */
            next: function lexer_next() {
              if (this.done) {
                this.clear();
                return this.EOF;
              }

              if (!this._input) {
                this.done = true;
              }

              var token, match, tempMatch, index;

              if (!this._more) {
                this.clear();
              }

              var spec = this.__currentRuleSet__;

              if (!spec) {
                // Update the ruleset cache as we apparently encountered a state change or just started lexing.
                // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
                // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
                // speed up those activities a tiny bit.
                spec = this.__currentRuleSet__ = this._currentRules();

                // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
                // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
                if (!spec || !spec.rules) {
                  var lineno_msg = '';

                  if (this.options.trackPosition) {
                    lineno_msg = ' on line ' + (this.yylineno + 1);
                  }

                  var p = this.constructLexErrorInfo(
                  'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
                  false);


                  // produce one 'error' token until this situation has been resolved, most probably by parse termination!
                  return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
                }
              }

              var rule_ids = spec.rules;
              var regexes = spec.__rule_regexes;
              var len = spec.__rule_count;

              // Note: the arrays are 1-based, while `len` itself is a valid index,
              // hence the non-standard less-or-equal check in the next loop condition!
              for (var i = 1; i <= len; i++) {
                tempMatch = this._input.match(regexes[i]);

                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;

                  if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rule_ids[i]);

                    if (token !== false) {
                      return token;
                    } else if (this._backtrack) {
                      match = undefined;
                      continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                      // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                      return false;
                    }
                  } else if (!this.options.flex) {
                    break;
                  }
                }
              }

              if (match) {
                token = this.test_match(match, rule_ids[index]);

                if (token !== false) {
                  return token;
                }

                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }

              if (!this._input) {
                this.done = true;
                this.clear();
                return this.EOF;
              } else {
                var lineno_msg = '';

                if (this.options.trackPosition) {
                  lineno_msg = ' on line ' + (this.yylineno + 1);
                }

                var p = this.constructLexErrorInfo(
                'Lexical error' + lineno_msg + ': Unrecognized text.',
                this.options.lexerErrorsAreRecoverable);


                var pendingInput = this._input;
                var activeCondition = this.topState();
                var conditionStackDepth = this.conditionStack.length;
                token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

                if (token === this.ERROR) {
                  // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
                  // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
                  // has not consumed/modified any pending input or changed state in the error handler:
                  if (!this.matches && // and make sure the input has been modified/consumed ...
                  pendingInput === this._input && // ...or the lexer state has been modified significantly enough
                  // to merit a non-consuming error handling action right now.
                  activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                    this.input();
                  }
                }

                return token;
              }
            },

            /**
             * return next match that has a token
             *
             * @public
             * @this {RegExpLexer}
             */
            lex: function lexer_lex() {
              var r;

              // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
              if (typeof this.pre_lex === 'function') {
                r = this.pre_lex.call(this, 0);
              }

              if (typeof this.options.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.pre_lex.call(this, r) || r;
              }

              if (this.yy && typeof this.yy.pre_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.pre_lex.call(this, r) || r;
              }

              while (!r) {
                r = this.next();
              }

              if (this.yy && typeof this.yy.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.yy.post_lex.call(this, r) || r;
              }

              if (typeof this.options.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.options.post_lex.call(this, r) || r;
              }

              if (typeof this.post_lex === 'function') {
                // (also account for a userdef function which does not return any value: keep the token as is)
                r = this.post_lex.call(this, r) || r;
              }

              return r;
            },

            /**
             * return next match that has a token. Identical to the `lex()` API but does not invoke any of the
             * `pre_lex()` nor any of the `post_lex()` callbacks.
             *
             * @public
             * @this {RegExpLexer}
             */
            fastLex: function lexer_fastLex() {
              var r;

              while (!r) {
                r = this.next();
              }

              return r;
            },

            /**
             * return info about the lexer state that can help a parser or other lexer API user to use the
             * most efficient means available. This API is provided to aid run-time performance for larger
             * systems which employ this lexer.
             *
             * @public
             * @this {RegExpLexer}
             */
            canIUse: function lexer_canIUse() {
              var rv = {
                fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function' };


              return rv;
            },

            /**
             * backwards compatible alias for `pushState()`;
             * the latter is symmetrical with `popState()` and we advise to use
             * those APIs in any modern lexer code, rather than `begin()`.
             *
             * @public
             * @this {RegExpLexer}
             */
            begin: function lexer_begin(condition) {
              return this.pushState(condition);
            },

            /**
             * activates a new lexer condition state (pushes the new lexer
             * condition state onto the condition stack)
             *
             * @public
             * @this {RegExpLexer}
             */
            pushState: function lexer_pushState(condition) {
              this.conditionStack.push(condition);
              this.__currentRuleSet__ = null;
              return this;
            },

            /**
             * pop the previously active lexer condition state off the condition
             * stack
             *
             * @public
             * @this {RegExpLexer}
             */
            popState: function lexer_popState() {
              var n = this.conditionStack.length - 1;

              if (n > 0) {
                this.__currentRuleSet__ = null;
                return this.conditionStack.pop();
              } else {
                return this.conditionStack[0];
              }
            },

            /**
             * return the currently active lexer condition state; when an index
             * argument is provided it produces the N-th previous condition state,
             * if available
             *
             * @public
             * @this {RegExpLexer}
             */
            topState: function lexer_topState(n) {
              n = this.conditionStack.length - 1 - Math.abs(n || 0);

              if (n >= 0) {
                return this.conditionStack[n];
              } else {
                return 'INITIAL';
              }
            },

            /**
             * (internal) determine the lexer rule set which is active for the
             * currently active lexer condition state
             *
             * @public
             * @this {RegExpLexer}
             */
            _currentRules: function lexer__currentRules() {
              if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
              } else {
                return this.conditions['INITIAL'];
              }
            },

            /**
             * return the number of states currently on the stack
             *
             * @public
             * @this {RegExpLexer}
             */
            stateStackSize: function lexer_stateStackSize() {
              return this.conditionStack.length;
            },

            options: {
              trackPosition: true,
              caseInsensitive: true },


            JisonLexerError: JisonLexerError,

            performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
              var yy_ = this;
              var YYSTATE = YY_START;

              switch (yyrulenumber) {
                case 0:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       \s+ */
                  /* skip whitespace */
                  break;

                case 7:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)em\b */
                  return 12; // em

                  break;

                case 8:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ex\b */
                  return 12; // ex

                  break;

                case 9:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ch\b */
                  return 12; // ch

                  break;

                case 10:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)rem\b */
                  return 12; // rem

                  break;

                case 11:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vw\b */
                  return 12; // vw

                  break;

                case 12:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vh\b */
                  return 12; // vh

                  break;

                case 13:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vmin\b */
                  return 12; // vmin

                  break;

                case 14:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vmax\b */
                  return 12; // vmax

                  break;

                case 15:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)vm\b */
                  return 12; // vm (non-standard name)

                  break;

                case 16:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)px\b */
                  return 12; // px

                  break;

                case 17:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)mm\b */
                  return 12; // mm

                  break;

                case 18:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)cm\b */
                  return 12; // cm

                  break;

                case 19:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)in\b */
                  return 12; // in

                  break;

                case 20:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)pt\b */
                  return 12; // pt

                  break;

                case 21:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)pc\b */
                  return 12; // pc

                  break;

                case 22:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)Q\b */
                  return 12; // Q

                  break;

                case 23:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)fr\b */
                  return 12; // fr

                  break;

                case 24:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)deg\b */
                  return 13; // deg

                  break;

                case 25:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)grad\b */
                  return 13; // grad

                  break;

                case 26:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)turn\b */
                  return 13; // turn

                  break;

                case 27:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)rad\b */
                  return 13; // rad

                  break;

                case 28:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)s\b */
                  return 14; // s

                  break;

                case 29:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)ms\b */
                  return 14; // ms

                  break;

                case 30:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)Hz\b */
                  return 15; // Hz

                  break;

                case 31:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)kHz\b */
                  return 15; // kHz

                  break;

                case 32:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dpi\b */
                  return 16; // dpi

                  break;

                case 33:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dpcm\b */
                  return 16; // dpcm

                  break;

                case 34:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)dppx\b */
                  return 16; // dppm

                  break;

                case 39:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       #\{([\s\S]*?)\} */
                  return 18; // scss variable

                  break;

                case 40:
                  /*! Conditions:: INITIAL */
                  /*! Rule::       @\{([\s\S]*?)\} */
                  return 18; // less variable

                  break;

                default:
                  return this.simpleCaseActionClusters[yyrulenumber];}

            },

            simpleCaseActionClusters: {
              /*! Conditions:: INITIAL */
              /*! Rule::       (-(webkit|moz)-)?calc\b */
              1: 3,

              /*! Conditions:: INITIAL */
              /*! Rule::       [a-z][a-z0-9-]*\s*\((?:(?:"(?:\\.|[^\"\\])*"|'(?:\\.|[^\'\\])*')|\([^)]*\)|[^\(\)]*)*\) */
              2: 11,

              /*! Conditions:: INITIAL */
              /*! Rule::       \* */
              3: 8,

              /*! Conditions:: INITIAL */
              /*! Rule::       \/ */
              4: 9,

              /*! Conditions:: INITIAL */
              /*! Rule::       \+ */
              5: 6,

              /*! Conditions:: INITIAL */
              /*! Rule::       - */
              6: 7,

              /*! Conditions:: INITIAL */
              /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)% */
              35: 17,

              /*! Conditions:: INITIAL */
              /*! Rule::       ([0-9]+(\.[0-9]+)?|\.[0-9]+)\b */
              36: 10,

              /*! Conditions:: INITIAL */
              /*! Rule::       \( */
              37: 4,

              /*! Conditions:: INITIAL */
              /*! Rule::       \) */
              38: 5,

              /*! Conditions:: INITIAL */
              /*! Rule::       \S[^\s()*\/+-]* */
              41: 18,

              /*! Conditions:: INITIAL */
              /*! Rule::       $ */
              42: 1 },


            rules: [
            /*  0: */ /^(?:\s+)/i,
            /*  1: */ /^(?:(-(webkit|moz)-)?calc\b)/i,
            /*  2: */ /^(?:[a-z][\d\-a-z]*\s*\((?:(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')|\([^)]*\)|[^()]*)*\))/i,
            /*  3: */ /^(?:\*)/i,
            /*  4: */ /^(?:\/)/i,
            /*  5: */ /^(?:\+)/i,
            /*  6: */ /^(?:-)/i,
            /*  7: */ /^(?:(\d+(\.\d+)?|\.\d+)em\b)/i,
            /*  8: */ /^(?:(\d+(\.\d+)?|\.\d+)ex\b)/i,
            /*  9: */ /^(?:(\d+(\.\d+)?|\.\d+)ch\b)/i,
            /* 10: */ /^(?:(\d+(\.\d+)?|\.\d+)rem\b)/i,
            /* 11: */ /^(?:(\d+(\.\d+)?|\.\d+)vw\b)/i,
            /* 12: */ /^(?:(\d+(\.\d+)?|\.\d+)vh\b)/i,
            /* 13: */ /^(?:(\d+(\.\d+)?|\.\d+)vmin\b)/i,
            /* 14: */ /^(?:(\d+(\.\d+)?|\.\d+)vmax\b)/i,
            /* 15: */ /^(?:(\d+(\.\d+)?|\.\d+)vm\b)/i,
            /* 16: */ /^(?:(\d+(\.\d+)?|\.\d+)px\b)/i,
            /* 17: */ /^(?:(\d+(\.\d+)?|\.\d+)mm\b)/i,
            /* 18: */ /^(?:(\d+(\.\d+)?|\.\d+)cm\b)/i,
            /* 19: */ /^(?:(\d+(\.\d+)?|\.\d+)in\b)/i,
            /* 20: */ /^(?:(\d+(\.\d+)?|\.\d+)pt\b)/i,
            /* 21: */ /^(?:(\d+(\.\d+)?|\.\d+)pc\b)/i,
            /* 22: */ /^(?:(\d+(\.\d+)?|\.\d+)Q\b)/i,
            /* 23: */ /^(?:(\d+(\.\d+)?|\.\d+)fr\b)/i,
            /* 24: */ /^(?:(\d+(\.\d+)?|\.\d+)deg\b)/i,
            /* 25: */ /^(?:(\d+(\.\d+)?|\.\d+)grad\b)/i,
            /* 26: */ /^(?:(\d+(\.\d+)?|\.\d+)turn\b)/i,
            /* 27: */ /^(?:(\d+(\.\d+)?|\.\d+)rad\b)/i,
            /* 28: */ /^(?:(\d+(\.\d+)?|\.\d+)s\b)/i,
            /* 29: */ /^(?:(\d+(\.\d+)?|\.\d+)ms\b)/i,
            /* 30: */ /^(?:(\d+(\.\d+)?|\.\d+)Hz\b)/i,
            /* 31: */ /^(?:(\d+(\.\d+)?|\.\d+)kHz\b)/i,
            /* 32: */ /^(?:(\d+(\.\d+)?|\.\d+)dpi\b)/i,
            /* 33: */ /^(?:(\d+(\.\d+)?|\.\d+)dpcm\b)/i,
            /* 34: */ /^(?:(\d+(\.\d+)?|\.\d+)dppx\b)/i,
            /* 35: */ /^(?:(\d+(\.\d+)?|\.\d+)%)/i,
            /* 36: */ /^(?:(\d+(\.\d+)?|\.\d+)\b)/i,
            /* 37: */ /^(?:\()/i,
            /* 38: */ /^(?:\))/i,
            /* 39: */ /^(?:#\{([\s\S]*?)\})/i,
            /* 40: */ /^(?:@\{([\s\S]*?)\})/i,
            /* 41: */ /^(?:\S[^\s()*\/+-]*)/i,
            /* 42: */ /^(?:$)/i],


            conditions: {
              'INITIAL': {
                rules: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42],


                inclusive: true } } };




          return lexer;
        }();
        parser.lexer = lexer;



        function Parser() {
          this.yy = {};
        }
        Parser.prototype = parser;
        parser.Parser = Parser;

        return new Parser();
      }();




      if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
        exports.parser = parser;
        exports.Parser = parser.Parser;
        exports.parse = function () {
          return parser.parse.apply(parser, arguments);
        };

      }

    }, {}], 493: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {string} selector
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Node} node
       * @param {Function} cb
       */
      module.exports = function parseSelector(selector, result, node, cb) {
        try {
          // @ts-ignore TODO TYPES wrong postcss-selector-parser types
          return selectorParser(cb).processSync(selector);
        } catch (e) {
          result.warn('Cannot parse selector', { node, stylelintType: 'parseError' });
        }
      };

    }, { "postcss-selector-parser": 90 }], 494: [function (require, module, exports) {
      'use strict';

      /**
       * If `map` already has the given `key`, returns its value. Otherwise, calls
       * `callback`, adds the result to `map` at `key`, and then returns it.
       *
       * @template K
       * @template V
       * @param {Map<K, V>} map
       * @param {K} key
       * @param {() => V} callback
       * @returns {V}
       */
      module.exports = function (map, key, callback) {
        if (map.has(key)) return (/** @type {V} */map.get(key));

        const value = callback();

        map.set(key, value);

        return value;
      };

    }, {}], 495: [function (require, module, exports) {
      'use strict';

      /**
       * Stringify PostCSS node including its raw "before" string.
       *
       * @param {import('postcss').Node} node
       *
       * @returns {string}
       */
      module.exports = function (node) {
        let result = '';

        if (node.raws.before) {
          result += node.raws.before;
        }

        result += node.toString();

        return result;
      };

    }, {}], 496: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @param {import('postcss').Node} node
       * @param {'\n' | '\r\n'} newline
       */
      function removeEmptyLinesAfter(node, newline) {
        node.raws.after = node.raws.after ? node.raws.after.replace(/(\r?\n\s*\r?\n)+/g, newline) : '';

        return node;
      }

      module.exports = removeEmptyLinesAfter;

    }, {}], 497: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @param {import('postcss').Node} node
       * @param {'\n' | '\r\n'} newline
       */
      function removeEmptyLinesBefore(node, newline) {
        node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\r?\n)+/g, newline) : '';

        return node;
      }

      module.exports = removeEmptyLinesBefore;

    }, {}], 498: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /** @typedef {{
        ruleName: string,
        result: import('stylelint').PostcssResult,
        message: string,
        node: import('postcss').Node & {
          positionBy(opts: { index?: number, word?: string }): { line: number, column: number }
        },
        index?: number,
        word?: string,
        line?: number
      }} Violation */

      /**
       * Report a violation.
       *
       * This function accounts for `disabledRanges` attached to the result.
       * That is, if the reported violation is within a disabledRange,
       * it is ignored. Otherwise, it is attached to the result as a
       * postcss warning.
       *
       * It also accounts for the rule's severity.
       *
       * You *must* pass *either* a node or a line number.
       * @param {Violation} violation
       */
      module.exports = function (violation) {
        const ruleName = violation.ruleName;
        const result = violation.result;
        const message = violation.message;
        const line = violation.line;
        const node = violation.node;
        const index = violation.index;
        const word = violation.word;

        result.stylelint = result.stylelint || {
          ruleSeverities: {},
          customMessages: {} };


        // In quiet mode, mere warnings are ignored
        if (result.stylelint.quiet && result.stylelint.ruleSeverities[ruleName] !== 'error') {
          return;
        }

        // If a line is not passed, use the node.positionBy method to get the
        // line number that the complaint pertains to
        const startLine = line || node.positionBy({ index }).line;

        if (
        result.stylelint.disabledRanges && (
        !result.stylelint.ignoreDisables || result.stylelint.reportNeedlessDisables))
        {
          const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all;

          for (const range of ranges) {
            if (
            // If the violation is within a disabledRange,
            // and that disabledRange's rules include this one,
            // do not register a warning
            range.start <= startLine && (
            range.end === undefined || range.end >= startLine) && (
            !range.rules || range.rules.includes(ruleName)))
            {
              if (result.stylelint.reportNeedlessDisables) {
                // Collect disabled warnings
                // Used to report `needlessDisables` in subsequent processing.
                const disabledWarnings =
                result.stylelint.disabledWarnings || (result.stylelint.disabledWarnings = []);

                disabledWarnings.push({
                  rule: ruleName,
                  line: startLine });


                if (!result.stylelint.ignoreDisables) {
                  return;
                }

                break;
              } else {
                return;
              }
            }
          }
        }

        /** @type {string} */
        const severity = _.get(result.stylelint, ['ruleSeverities', ruleName], 'ignore');

        if (!result.stylelint.stylelintError && severity === 'error') {
          result.stylelint.stylelintError = true;
        }

        /** @type {import('stylelint').StylelintWarningOptions} */
        const warningProperties = {
          severity,
          rule: ruleName };


        if (node) {
          warningProperties.node = node;
        }

        if (index) {
          warningProperties.index = index;
        }

        if (word) {
          warningProperties.word = word;
        }

        const warningMessage = _.get(result.stylelint, ['customMessages', ruleName], message);

        result.warn(warningMessage, warningProperties);
      };

    }, { "lodash": 68 }], 499: [function (require, module, exports) {
      'use strict';

      /**
       * Given an object of violation messages, return another
       * that provides the same messages postfixed with the rule
       * that has been violated.
       *
       * @param {string} ruleName
       * @param {{[k: string]: string|Function}} messages - Object whose keys are message identifiers
       *   and values are either message strings or functions that return message strings
       * @return {{[k: string]: string|Function}} New message object, whose messages will be marked with the rule name
       */
      module.exports = function (ruleName, messages) {
        return Object.keys(messages).reduce(
        /**
         * @param {{[k: string]: string|Function}} newMessages
         * @param {string} messageId
         * @return {{[k: string]: string|Function}}
         */
        (newMessages, messageId) => {
          const messageText = messages[messageId];

          if (typeof messageText === 'string') {
            newMessages[messageId] = `${messageText} (${ruleName})`;
          } else {
            newMessages[messageId] = ( /** @type {any[]} */...args) => {
              return `${messageText(...args)} (${ruleName})`;
            };
          }

          return newMessages;
        },
        {});

      };

    }, {}], 500: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Node} node
       * @param {Function} cb
       */
      module.exports = function (result, node, cb) {
        try {
          // @ts-ignore TODO TYPES wrong postcss-selector-parser definitions
          return selectorParser(cb).processSync(node, { updateSelector: true });
        } catch (e) {
          result.warn('Cannot parse selector', { node, stylelintType: 'parseError' });
        }
      };

    }, { "postcss-selector-parser": 90 }], 501: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */
      /** @typedef {import('postcss').Node} NodeSource */

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Root}
       */
      module.exports.isRoot = function isRoot(node) {
        return node.type === 'root';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Rule}
       */
      module.exports.isRule = function isRule(node) {
        return node.type === 'rule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').AtRule}
       */
      module.exports.isAtRule = function isAtRule(node) {
        return node.type === 'atrule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Comment}
       */
      module.exports.isComment = function isComment(node) {
        return node.type === 'comment';
      };

      /**
       * @param {Node} node
       * @returns {node is (Node & {source: NodeSource})}
       */
      module.exports.hasSource = function hasSource(node) {
        return Boolean(node.source);
      };

    }, {}], 502: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      /**
       * @template T
       * @typedef {(i: T) => boolean} Validator
       */

      /**
       * Check whether the variable is an object and all it's properties are arrays of string values:
       *
       * ignoreProperties = {
       *   value1: ["item11", "item12", "item13"],
       *   value2: ["item21", "item22", "item23"],
       *   value3: ["item31", "item32", "item33"],
       * }
       * @template T
       * @param {Validator<T>|Validator<T>[]} validator
       * @returns {(value: {[k: any]: T|T[]}) => boolean}
       */
      module.exports = validator => value => {
        if (!_.isPlainObject(value)) {
          return false;
        }

        // TODO: Issue #4985
        // eslint-disable-next-line no-shadow
        return Object.values(value).every(value => {
          if (!Array.isArray(value)) {
            return false;
          }

          // Make sure the array items are strings
          return value.every(item => {
            if (Array.isArray(validator)) {
              return validator.some(v => v(item));
            }

            return validator(item);
          });
        });
      };

    }, { "lodash": 68 }], 503: [function (require, module, exports) {
      'use strict';

      const _ = require('lodash');

      const ignoredOptions = ['severity', 'message', 'reportDisables'];

      /** @typedef {{possible: any, actual: any, optional: boolean}} Options */

      /**
       * Validate a rule's options.
       *
       * See existing rules for examples.
       *
       * @param {import('stylelint').PostcssResult} result - postcss result
       * @param {string} ruleName
       * @param {...Options} optionDescriptions - Each optionDescription can
       *   have the following properties:
       *   	- `actual` (required): the actual passed option value or object.
       *   	- `possible` (required): a schema representation of what values are
       *      valid for those options. `possible` should be an object if the
       *      options are an object, with corresponding keys; if the options are not an
       *      object, `possible` isn't, either. All `possible` value representations
       *      should be **arrays of either values or functions**. Values are === checked
       *      against `actual`. Functions are fed `actual` as an argument and their
       *      return value is interpreted: truthy = valid, falsy = invalid.
       *    - `optional` (optional): If this is `true`, `actual` can be undefined.
       * @return {boolean} Whether or not the options are valid (true = valid)
       */

      module.exports = function (result, ruleName, ...optionDescriptions) {
        let noErrors = true;

        optionDescriptions.forEach(optionDescription => {
          validate(optionDescription, ruleName, complain);
        });

        /**
         * @param {string} message
         */
        function complain(message) {
          noErrors = false;
          result.warn(message, {
            stylelintType: 'invalidOption' });

          _.set(result, 'stylelint.stylelintError', true);
        }

        return noErrors;
      };

      /**
       * @param {Options} opts
       * @param {string} ruleName
       * @param {(s: string) => void} complain
       */
      function validate(opts, ruleName, complain) {
        const possible = opts.possible;
        const actual = opts.actual;
        const optional = opts.optional;

        if (actual === null || _.isEqual(actual, [null])) {
          return;
        }

        const nothingPossible =
        possible === undefined || Array.isArray(possible) && possible.length === 0;

        if (nothingPossible && actual === true) {
          return;
        }

        if (actual === undefined) {
          if (nothingPossible || optional) {
            return;
          }

          complain(`Expected option value for rule "${ruleName}"`);

          return;
        }

        if (nothingPossible) {
          if (optional) {
            complain(
            `Incorrect configuration for rule "${ruleName}". Rule should have "possible" values for options validation`);


            return;
          }

          complain(`Unexpected option value "${String(actual)}" for rule "${ruleName}"`);

          return;
        }

        // If `possible` is a function ...
        if (_.isFunction(possible)) {
          if (!possible(actual)) {
            complain(`Invalid option "${JSON.stringify(actual)}" for rule ${ruleName}`);
          }

          return;
        }

        // If `possible` is an array instead of an object ...
        if (!_.isPlainObject(possible)) {
          [].concat(actual).forEach(a => {
            if (isValid(possible, a)) {
              return;
            }

            complain(`Invalid option value "${String(a)}" for rule "${ruleName}"`);
          });

          return;
        }

        // If actual is NOT an object ...
        if (typeof actual !== 'object') {
          complain(
          `Invalid option value ${JSON.stringify(actual)} for rule "${ruleName}": should be an object`);


          return;
        }

        Object.keys(actual).forEach(optionName => {
          if (ignoredOptions.includes(optionName)) {
            return;
          }

          if (!possible[optionName]) {
            complain(`Invalid option name "${optionName}" for rule "${ruleName}"`);

            return;
          }

          const actualOptionValue = actual[optionName];

          [].concat(actualOptionValue).forEach(a => {
            if (isValid(possible[optionName], a)) {
              return;
            }

            complain(`Invalid value "${a}" for option "${optionName}" of rule "${ruleName}"`);
          });
        });
      }

      /**
       * @param {any|Function} possible
       * @param {any} actual
       * @returns {boolean}
       */
      function isValid(possible, actual) {
        const possibleList = /** @type {Array<any|Function>} */[].concat(possible);

        for (let i = 0, l = possibleList.length; i < l; i++) {
          const possibility = possibleList[i];

          if (typeof possibility === 'function' && possibility(actual)) {
            return true;
          }

          if (actual === possibility) {
            return true;
          }
        }

        return false;
      }

    }, { "lodash": 68 }], 504: [function (require, module, exports) {
      'use strict';

      /**
       * Contains helpers for working with vendor prefixes.
       *
       * Copied from https://github.com/postcss/postcss/commit/777c55b5d2a10605313a4972888f4f32005f5ac2
       *
       * @namespace vendor
       */
      module.exports = {
        /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} vendor prefix or empty string
         *
         * @example
         * vendor.prefix('-moz-tab-size') //=> '-moz-'
         * vendor.prefix('tab-size')      //=> ''
         */
        prefix(prop) {
          let match = prop.match(/^(-\w+-)/);

          if (match) {
            return match[0];
          }

          return '';
        },

        /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} String name without vendor prefixes.
         *
         * @example
         * vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */
        unprefixed(prop) {
          return prop.replace(/^-\w+-/, '');
        } };


    }, {}], 505: [function (require, module, exports) {
      'use strict';

      const configurationError = require('./configurationError');
      const isSingleLineString = require('./isSingleLineString');
      const isWhitespace = require('./isWhitespace');

      /**
       * @typedef {object} Messages
       * @property {function} [expectedBefore]
       * @property {function} [rejectedBefore]
       * @property {function} [expectedAfter]
       * @property {function} [rejectedAfter]
       * @property {function} [expectedBeforeSingleLine]
       * @property {function} [rejectedBeforeSingleLine]
       * @property {function} [expectedBeforeMultiLine]
       * @property {function} [rejectedBeforeMultiLine]
       * @property {function} [expectedAfterSingleLine]
       * @property {function} [rejectedAfterSingleLine]
       * @property {function} [expectedAfterMultiLine]
       * @property {function} [rejectedAfterMultiLine]
       */

      /**
       * @typedef {object} WhitespaceCheckerArgs
       * @property {string} source - The source string
       * @property {number} index - The index of the character to check before
       * @property {function} err - If a violation is found, this callback
       *   will be invoked with the relevant warning message.
       *   Typically this callback will report() the violation.
       * @property {function} errTarget - If a violation is found, this string
       *   will be sent to the relevant warning message.
       * @property {string} [lineCheckStr] - Single- and multi-line checkers
       *   will use this string to determine whether they should proceed,
       *   i.e. if this string is one line only, single-line checkers will check,
       *   multi-line checkers will ignore.
       *   If none is passed, they will use `source`.
       * @property {boolean} [onlyOneChar=false] - Only check *one* character before.
       *   By default, "always-*" checks will look for the `targetWhitespace` one
       *   before and then ensure there is no whitespace two before. This option
       *   bypasses that second check.
       * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation
       *   between the `targetWhitespace` (almost definitely a newline) and the `index`.
       *   With this option, the checker will see if a newline *begins* the whitespace before
       *   the `index`.
       */

      /**
       * @callback WhitespaceChecker
       * @param {WhitespaceCheckerArgs} args
       */

      /**
       * Create a whitespaceChecker, which exposes the following functions:
       * - `before()`
       * - `beforeAllowingIndentation()`
       * - `after()`
       * - `afterOneOnly()`
       *
       * @param {"space" | "newline"} targetWhitespace - This is a keyword instead
       *   of the actual character (e.g. " ") in order to accommodate
       *   different styles of newline ("\n" vs "\r\n")
       * @param { "always" | "never" | "always-single-line" | "always-multi-line" | "never-single-line" | "never-multi-line" } expectation
       * @param {Messages} messages - An object of message functions;
       *   calling `before*()` or `after*()` and the `expectation` that is passed
       *   determines which message functions are required
       *
       * @returns {object} The checker, with its exposed checking functions
       */
      module.exports = function (targetWhitespace, expectation, messages) {
        // Keep track of active arguments in order to avoid passing
        // too much stuff around, making signatures long and confusing.
        // This variable gets reset anytime a checking function is called.
        /**
         * @type {{
        		source?: any,
        		index?: any,
        		err: any,
        		errTarget: any,
        		onlyOneChar: any,
        		allowIndentation?: any,
        	}}
        */
        let activeArgs;

        /**
         * Check for whitespace *before* a character.
         * @type {WhitespaceChecker}
         */
        function before({
          source,
          index,
          err,
          errTarget,
          lineCheckStr,
          onlyOneChar = false,
          allowIndentation = false })
        {
          activeArgs = {
            source,
            index,
            err,
            errTarget,
            onlyOneChar,
            allowIndentation };


          switch (expectation) {
            case 'always':
              expectBefore();
              break;
            case 'never':
              rejectBefore();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * Check for whitespace *after* a character.
         * @type {WhitespaceChecker}
         */
        function after({ source, index, err, errTarget, lineCheckStr, onlyOneChar = false }) {
          activeArgs = { source, index, err, errTarget, onlyOneChar };

          switch (expectation) {
            case 'always':
              expectAfter();
              break;
            case 'never':
              rejectAfter();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * @param {WhitespaceCheckerArgs} obj
         */
        function beforeAllowingIndentation(obj) {
          before(_extends({}, obj, { allowIndentation: true }));
        }

        /**
         * @param {Function} [messageFunc]
         */
        function expectBefore(messageFunc = messages.expectedBefore) {
          if (activeArgs.allowIndentation) {
            expectBeforeAllowingIndentation(messageFunc);

            return;
          }

          const _activeArgs = activeArgs;
          const source = _activeArgs.source;
          const index = _activeArgs.index;

          const oneCharBefore = source[index - 1];
          const twoCharsBefore = source[index - 2];

          if (!isValue(oneCharBefore)) {
            return;
          }

          if (targetWhitespace === 'space' && oneCharBefore === ' ') {
            if (activeArgs.onlyOneChar || !isWhitespace(twoCharsBefore)) {
              return;
            }
          }

          const msgFunc = assertFunction(messageFunc);

          activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));
        }

        /**
         * @param {Function} [messageFunc]
         */
        function expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {
          const _activeArgs2 = activeArgs;
          const source = _activeArgs2.source;
          const index = _activeArgs2.index;
          const err = _activeArgs2.err;

          const expectedChar = function () {
            if (targetWhitespace === 'newline') {
              return '\n';
            }
          }();
          let i = index - 1;

          while (source[i] !== expectedChar) {
            if (source[i] === '\t' || source[i] === ' ') {
              i--;
              continue;
            }

            const msgFunc = assertFunction(messageFunc);

            err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));

            return;
          }
        }

        /**
         * @param {Function} [messageFunc]
         */
        function rejectBefore(messageFunc = messages.rejectedBefore) {
          const _activeArgs3 = activeArgs;
          const source = _activeArgs3.source;
          const index = _activeArgs3.index;

          const oneCharBefore = source[index - 1];

          if (isValue(oneCharBefore) && isWhitespace(oneCharBefore)) {
            const msgFunc = assertFunction(messageFunc);

            activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));
          }
        }

        /**
         * @param {WhitespaceCheckerArgs} obj
         */
        function afterOneOnly(obj) {
          after(_extends({}, obj, { onlyOneChar: true }));
        }

        /**
         * @param {Function} [messageFunc]
         */
        function expectAfter(messageFunc = messages.expectedAfter) {
          const _activeArgs4 = activeArgs;
          const source = _activeArgs4.source;
          const index = _activeArgs4.index;

          const oneCharAfter = source[index + 1];
          const twoCharsAfter = source[index + 2];

          if (!isValue(oneCharAfter)) {
            return;
          }

          if (targetWhitespace === 'newline') {
            // If index is followed by a Windows CR-LF ...
            if (oneCharAfter === '\r' && twoCharsAfter === '\n') {
              if (activeArgs.onlyOneChar || !isWhitespace(source[index + 3])) {
                return;
              }
            }

            // If index is followed by a Unix LF ...
            if (oneCharAfter === '\n') {
              if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {
                return;
              }
            }
          }

          if (targetWhitespace === 'space' && oneCharAfter === ' ') {
            if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {
              return;
            }
          }

          const msgFunc = assertFunction(messageFunc);

          activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));
        }

        /**
         * @param {Function} [messageFunc]
         */
        function rejectAfter(messageFunc = messages.rejectedAfter) {
          const _activeArgs5 = activeArgs;
          const source = _activeArgs5.source;
          const index = _activeArgs5.index;

          const oneCharAfter = source[index + 1];

          if (isValue(oneCharAfter) && isWhitespace(oneCharAfter)) {
            const msgFunc = assertFunction(messageFunc);

            activeArgs.err(msgFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]));
          }
        }

        return {
          before,
          beforeAllowingIndentation,
          after,
          afterOneOnly };

      };

      /**
       * @param {any} x
       */
      function isValue(x) {
        return x !== undefined && x !== null;
      }

      /**
       * @param {unknown} x
       */
      function assertFunction(x) {
        if (typeof x === 'function') {
          return x;
        }

        throw new Error(`\`${x}\` must be a function`);
      }

    }, { "./configurationError": 423, "./isSingleLineString": 470, "./isWhitespace": 486 }], 506: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;

      var _stringify = require('./stringify');

      var _stringify2 = _interopRequireDefault(_stringify);

      var _parse = require('./parse');

      var _parse2 = _interopRequireDefault(_parse);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      exports.default = { stringify: _stringify2.default, parse: _parse2.default };
      module.exports = exports['default'];

    }, { "./parse": 508, "./stringify": 512 }], 507: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;
      exports.default = liner;
      function liner(tokens) {
        var line = [];
        var result = [line];
        var brackets = 0;
        for (var _iterator = tokens, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var token = _ref;

          line.push(token);
          if (token[0] === '(') {
            brackets += 1;
          } else if (token[0] === ')') {
            brackets -= 1;
          } else if (token[0] === 'newline' && brackets === 0) {
            line = [];
            result.push(line);
          }
        }
        return result;
      }
      module.exports = exports['default'];

    }, {}], 508: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;
      exports.default = parse;

      var _input = require('postcss/lib/input');

      var _input2 = _interopRequireDefault(_input);

      var _preprocess = require('./preprocess');

      var _preprocess2 = _interopRequireDefault(_preprocess);

      var _tokenize = require('./tokenize');

      var _tokenize2 = _interopRequireDefault(_tokenize);

      var _parser = require('./parser');

      var _parser2 = _interopRequireDefault(_parser);

      var _liner = require('./liner');

      var _liner2 = _interopRequireDefault(_liner);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function parse(source, opts) {
        var input = new _input2.default(source, opts);

        var parser = new _parser2.default(input);
        parser.tokens = (0, _tokenize2.default)(input);
        parser.parts = (0, _preprocess2.default)(input, (0, _liner2.default)(parser.tokens));
        parser.loop();

        return parser.root;
      }
      module.exports = exports['default'];

    }, { "./liner": 507, "./parser": 509, "./preprocess": 510, "./tokenize": 513, "postcss/lib/input": 130 }], 509: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;

      var _declaration = require('postcss/lib/declaration');

      var _declaration2 = _interopRequireDefault(_declaration);

      var _comment = require('postcss/lib/comment');

      var _comment2 = _interopRequireDefault(_comment);

      var _atRule = require('postcss/lib/at-rule');

      var _atRule2 = _interopRequireDefault(_atRule);

      var _rule = require('postcss/lib/rule');

      var _rule2 = _interopRequireDefault(_rule);

      var _root = require('postcss/lib/root');

      var _root2 = _interopRequireDefault(_root);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}

      var Parser = function () {
        function Parser(input) {
          _classCallCheck(this, Parser);

          this.input = input;

          this.pos = 0;
          this.root = new _root2.default();
          this.current = this.root;
          this.spaces = '';

          this.extraIndent = false;
          this.prevIndent = undefined;
          this.step = undefined;

          this.root.source = { input: input, start: { line: 1, column: 1 } };
        }

        Parser.prototype.loop = function loop() {
          var part = void 0;
          while (this.pos < this.parts.length) {
            part = this.parts[this.pos];

            if (part.comment) {
              this.comment(part);
            } else if (part.atrule) {
              this.atrule(part);
            } else if (part.colon) {
              var next = this.nextNonComment(this.pos);

              if (next.end || next.atrule) {
                this.decl(part);
              } else {
                var moreIndent = next.indent.length > part.indent.length;
                if (!moreIndent) {
                  this.decl(part);
                } else if (moreIndent && next.colon) {
                  this.rule(part);
                } else if (moreIndent && !next.colon) {
                  this.decl(part);
                }
              }
            } else if (part.end) {
              this.root.raws.after = part.before;
            } else {
              this.rule(part);
            }

            this.pos += 1;
          }

          for (var i = this.tokens.length - 1; i >= 0; i--) {
            if (this.tokens[i].length > 3) {
              var last = this.tokens[i];
              this.root.source.end = {
                line: last[4] || last[2],
                column: last[5] || last[3] };

              break;
            }
          }
        };

        Parser.prototype.comment = function comment(part) {
          var token = part.tokens[0];
          var node = new _comment2.default();
          this.init(node, part);
          node.source.end = { line: token[4], column: token[5] };
          this.commentText(node, token);
        };

        Parser.prototype.atrule = function atrule(part) {
          var atword = part.tokens[0];
          var params = part.tokens.slice(1);

          var node = new _atRule2.default();
          node.name = atword[1].slice(1);
          this.init(node, part);

          if (node.name === '') this.unnamedAtrule(atword);

          while (!part.end && part.lastComma) {
            this.pos += 1;
            part = this.parts[this.pos];
            params.push(['space', part.before + part.indent]);
            params = params.concat(part.tokens);
          }

          node.raws.afterName = this.firstSpaces(params);
          this.keepTrailingSpace(node, params);
          this.checkSemicolon(params);
          this.checkCurly(params);
          this.raw(node, 'params', params, atword);
        };

        Parser.prototype.decl = function decl(part) {
          var node = new _declaration2.default();
          this.init(node, part);

          var between = '';
          var colon = 0;
          var value = [];
          var prop = '';
          for (var i = 0; i < part.tokens.length; i++) {
            var token = part.tokens[i];
            if (token[0] === ':') {
              between += token[1];
              colon = token;
              value = part.tokens.slice(i + 1);
              break;
            } else if (token[0] === 'comment' || token[0] === 'space') {
              between += token[1];
            } else if (between !== '') {
              this.badProp(token);
            } else {
              prop += token[1];
            }
          }

          if (prop === '') this.unnamedDecl(part.tokens[0]);
          node.prop = prop;

          var next = this.parts[this.pos + 1];

          while (!next.end && !next.atrule && !next.colon && next.indent.length > part.indent.length) {
            value.push(['space', next.before + next.indent]);
            value = value.concat(next.tokens);
            this.pos += 1;
            next = this.parts[this.pos + 1];
          }

          var last = value[value.length - 1];
          if (last && last[0] === 'comment') {
            value.pop();
            var comment = new _comment2.default();
            this.current.push(comment);
            comment.source = {
              input: this.input,
              start: { line: last[2], column: last[3] },
              end: { line: last[4], column: last[5] } };

            var prev = value[value.length - 1];
            if (prev && prev[0] === 'space') {
              value.pop();
              comment.raws.before = prev[1];
            }
            this.commentText(comment, last);
          }

          for (var _i = value.length - 1; _i > 0; _i--) {
            var t = value[_i][0];
            if (t === 'word' && value[_i][1] === '!important') {
              node.important = true;
              if (_i > 0 && value[_i - 1][0] === 'space') {
                node.raws.important = value[_i - 1][1] + '!important';
                value.splice(_i - 1, 2);
              } else {
                node.raws.important = '!important';
                value.splice(_i, 1);
              }
              break;
            } else if (t !== 'space' && t !== 'newline' && t !== 'comment') {
              break;
            }
          }

          node.raws.between = between + this.firstSpaces(value);
          this.checkSemicolon(value);
          this.raw(node, 'value', value, colon);
        };

        Parser.prototype.rule = function rule(part) {
          var node = new _rule2.default();
          this.init(node, part);

          var selector = part.tokens;
          var next = this.parts[this.pos + 1];

          while (!next.end && next.indent.length === part.indent.length) {
            selector.push(['space', next.before + next.indent]);
            selector = selector.concat(next.tokens);
            this.pos += 1;
            next = this.parts[this.pos + 1];
          }

          this.keepTrailingSpace(node, selector);
          this.checkCurly(selector);
          this.raw(node, 'selector', selector);
        };

        /* Helpers */

        Parser.prototype.indent = function indent(part) {
          var indent = part.indent.length;
          var isPrev = typeof this.prevIndent !== 'undefined';

          if (!isPrev && indent) this.indentedFirstLine(part);

          if (!this.step && indent) {
            this.step = indent;
            this.root.raws.indent = part.indent;
          }

          if (isPrev && this.prevIndent !== indent) {
            var diff = indent - this.prevIndent;
            if (diff > 0) {
              if (diff !== this.step) {
                this.wrongIndent(this.prevIndent + this.step, indent, part);
              } else if (this.current.last.push) {
                this.current = this.current.last;
              } else {
                this.extraIndent = '';
                for (var i = 0; i < diff; i++) {
                  this.extraIndent += ' ';
                }
              }
            } else if (diff % this.step !== 0) {
              var m = indent + diff % this.step;
              this.wrongIndent(m + ' or ' + (m + this.step), indent, part);
            } else {
              for (var _i2 = 0; _i2 < -diff / this.step; _i2++) {
                this.current = this.current.parent;
              }
            }
          }

          this.prevIndent = indent;
        };

        Parser.prototype.init = function init(node, part) {
          this.indent(part);

          if (!this.current.nodes) this.current.nodes = [];
          this.current.push(node);

          node.raws.before = part.before + part.indent;
          if (this.extraIndent) {
            node.raws.extraIndent = this.extraIndent;
            this.extraIndent = false;
          }
          node.source = {
            start: { line: part.tokens[0][2], column: part.tokens[0][3] },
            input: this.input };

        };

        Parser.prototype.checkCurly = function checkCurly(tokens) {
          for (var _iterator = tokens, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i3 >= _iterator.length) break;
              _ref = _iterator[_i3++];
            } else {
              _i3 = _iterator.next();
              if (_i3.done) break;
              _ref = _i3.value;
            }

            var token = _ref;

            if (token[0] === '{') {
              this.error('Unnecessary curly bracket', token[2], token[3]);
            }
          }
        };

        Parser.prototype.checkSemicolon = function checkSemicolon(tokens) {
          for (var _iterator2 = tokens, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i4 >= _iterator2.length) break;
              _ref2 = _iterator2[_i4++];
            } else {
              _i4 = _iterator2.next();
              if (_i4.done) break;
              _ref2 = _i4.value;
            }

            var token = _ref2;

            if (token[0] === ';') {
              this.error('Unnecessary semicolon', token[2], token[3]);
            }
          }
        };

        Parser.prototype.keepTrailingSpace = function keepTrailingSpace(node, tokens) {
          var lastSpace = tokens[tokens.length - 1];
          if (lastSpace && lastSpace[0] === 'space') {
            tokens.pop();
            node.raws.sssBetween = lastSpace[1];
          }
        };

        Parser.prototype.firstSpaces = function firstSpaces(tokens) {
          var result = '';
          for (var i = 0; i < tokens.length; i++) {
            if (tokens[i][0] === 'space' || tokens[i][0] === 'newline') {
              result += tokens.shift()[1];
              i -= 1;
            } else {
              break;
            }
          }
          return result;
        };

        Parser.prototype.raw = function raw(node, prop, tokens, altLast) {
          var token = void 0,
          type = void 0;
          var length = tokens.length;
          var value = '';
          var clean = true;
          for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
              clean = false;
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            var sss = tokens.reduce(function (all, i) {
              return all + i[1];
            }, '');
            var raw = tokens.reduce(function (all, i) {
              if (i[0] === 'comment' && i[6] === 'inline') {
                return all + '/* ' + i[1].slice(2).trim() + ' */';
              } else {
                return all + i[1];
              }
            }, '');
            node.raws[prop] = { value: value, raw: raw };
            if (sss !== raw) node.raws[prop].sss = sss;
          }
          node[prop] = value;

          var last = void 0;
          for (var _i5 = tokens.length - 1; _i5 >= 0; _i5--) {
            if (tokens[_i5].length > 2) {
              last = tokens[_i5];
              break;
            }
          }
          if (!last) last = altLast;

          node.source.end = {
            line: last[4] || last[2],
            column: last[5] || last[3] };

        };

        Parser.prototype.nextNonComment = function nextNonComment(pos) {
          var next = pos;
          var part = void 0;
          while (next < this.parts.length) {
            next += 1;
            part = this.parts[next];
            if (part.end || !part.comment) break;
          }
          return part;
        };

        Parser.prototype.commentText = function commentText(node, token) {
          var text = token[1];
          if (token[6] === 'inline') {
            node.raws.inline = true;
            text = text.slice(2);
          } else {
            text = text.slice(2, -2);
          }

          var match = text.match(/^(\s*)([^]*[^\s])(\s*)\n?$/);
          if (match) {
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.inlineRight = match[3];
          } else {
            node.text = '';
            node.raws.left = '';
            node.raws.inlineRight = '';
          }
        };

        // Errors

        Parser.prototype.error = function error(msg, line, column) {
          throw this.input.error(msg, line, column);
        };

        Parser.prototype.unnamedAtrule = function unnamedAtrule(token) {
          this.error('At-rule without name', token[2], token[3]);
        };

        Parser.prototype.unnamedDecl = function unnamedDecl(token) {
          this.error('Declaration without name', token[2], token[3]);
        };

        Parser.prototype.indentedFirstLine = function indentedFirstLine(part) {
          this.error('First line should not have indent', part.number, 1);
        };

        Parser.prototype.wrongIndent = function wrongIndent(expected, real, part) {
          var msg = 'Expected ' + expected + ' indent, but get ' + real;
          this.error(msg, part.number, 1);
        };

        Parser.prototype.badProp = function badProp(token) {
          this.error('Unexpected separator in property', token[2], token[3]);
        };

        return Parser;
      }();

      exports.default = Parser;
      module.exports = exports['default'];

    }, { "postcss/lib/at-rule": 125, "postcss/lib/comment": 126, "postcss/lib/declaration": 129, "postcss/lib/root": 141, "postcss/lib/rule": 142 }], 510: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;
      exports.default = preprocess;
      function indentError(input, l, p) {
        throw input.error('Mixed tabs and spaces are not allowed', l, p + 1);
      }

      function preprocess(input, lines) {
        var indentType = void 0;
        var prevNumber = 0;
        var parts = lines.map(function (line) {
          var lastComma = false;
          var comment = false;
          var number = prevNumber + 1;
          var atrule = false;
          var indent = '';
          var tokens = [];
          var colon = false;

          if (line.length > 0) {
            if (line[0][0] === 'space') {
              indent = line[0][1];
              tokens = line.slice(1);
            } else {
              indent = '';
              tokens = line;
            }

            if (!indentType && indent.length) {
              indentType = indent[0] === ' ' ? 'space' : 'tab';
            }
            if (indentType === 'space') {
              if (indent.indexOf('\t') !== -1) {
                indentError(input, number, indent.indexOf('\t'));
              }
            } else if (indentType === 'tab') {
              if (indent.indexOf(' ') !== -1) {
                indentError(input, number, indent.indexOf(' '));
              }
            }

            if (tokens.length) {
              for (var i = tokens.length - 1; i >= 0; i--) {
                var type = tokens[i][0];
                if (type === ',') {
                  lastComma = true;
                  break;
                } else if (type === 'space') {
                  continue;
                } else if (type === 'comment') {
                  continue;
                } else if (type === 'newline') {
                  continue;
                } else {
                  break;
                }
              }
              comment = tokens[0][0] === 'comment';
              atrule = tokens[0][0] === 'at-word';

              var brackets = 0;
              for (var _i = 0; _i < tokens.length - 1; _i++) {
                var _type = tokens[_i][0];
                var next = tokens[_i + 1][0];
                if (_type === '(') {
                  brackets += 1;
                } else if (_type === ')') {
                  brackets -= 1;
                } else if (_type === ':' && brackets === 0 && (next === 'space' || next === 'newline')) {
                  colon = true;
                }
              }
            }

            var last = tokens[tokens.length - 1];
            if (last && last[0] === 'newline') prevNumber = last[2];
          }

          return {
            number: number,
            indent: indent,
            colon: colon,
            tokens: tokens,
            atrule: atrule,
            comment: comment,
            lastComma: lastComma,
            before: '' };

        });

        parts = parts.reduceRight(function (all, i) {
          if (!i.tokens.length || i.tokens.every(function (j) {
            return j[0] === 'newline';
          })) {
            var prev = all[0];
            var before = i.indent + i.tokens.map(function (j) {
              return j[1];
            }).join('');
            prev.before = before + prev.before;
          } else {
            all.unshift(i);
          }
          return all;
        }, [{ end: true, before: '' }]);

        parts.forEach(function (part, i) {
          if (i === 0) return;

          var prev = parts[i - 1];
          var last = prev.tokens[prev.tokens.length - 1];
          if (last && last[0] === 'newline') {
            part.before = last[1] + part.before;
            prev.tokens.pop();
          }
        });

        return parts;
      }
      module.exports = exports['default'];

    }, {}], 511: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;

      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}

      var defaultRaw = {
        colon: ': ',
        indent: '  ',
        commentLeft: ' ',
        commentRight: ' ' };


      var Stringifier = function () {
        function Stringifier(builder) {
          _classCallCheck(this, Stringifier);

          this.builder = builder;
        }

        Stringifier.prototype.stringify = function stringify(node, semicolon) {
          this[node.type](node, semicolon);
        };

        Stringifier.prototype.root = function root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        };

        Stringifier.prototype.comment = function comment(node) {
          var left = defaultRaw.commentLeft;
          var right = defaultRaw.commentRight;
          if (this.has(node.raws.left)) left = node.raws.left;

          if (node.raws.inline) {
            if (this.has(node.raws.inlineRight)) {
              right = node.raws.inlineRight;
            } else {
              right = '';
            }
            if (node.raws.extraIndent) {
              this.builder(node.raws.extraIndent);
            }
            this.builder('//' + left + node.text + right, node);
          } else {
            if (this.has(node.raws.right)) right = node.raws.right;
            this.builder('/*' + left + node.text + right + '*/', node);
          }
        };

        Stringifier.prototype.decl = function decl(node) {
          var between = node.raws.between || defaultRaw.colon;
          var string = node.prop + between + this.rawValue(node, 'value');

          if (node.important) {
            string += node.raws.important || ' !important';
          }

          this.builder(string, node);
        };

        Stringifier.prototype.rule = function rule(node) {
          this.block(node, this.rawValue(node, 'selector'));
        };

        Stringifier.prototype.atrule = function atrule(node) {
          var name = '@' + node.name;
          var params = node.params ? this.rawValue(node, 'params') : '';

          if (this.has(node.raws.afterName)) {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          this.block(node, name + params);
        };

        Stringifier.prototype.body = function body(node) {
          var indent = node.root().raws.indent || defaultRaw.indent;

          for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            var before = child.raws.before.replace(/[^\n]*$/, '') + this.indent(node, indent);
            if (child.type === 'comment' && child.raws.before.indexOf('\n') === -1) {
              before = child.raws.before;
            }
            if (before) this.builder(before);
            this.stringify(child);
          }
        };

        Stringifier.prototype.block = function block(node, start) {
          var between = node.raws.sssBetween || '';
          this.builder(start + between, node, 'start');
          if (this.has(node.nodes)) this.body(node);
        };

        Stringifier.prototype.indent = function indent(node, step) {
          var result = '';
          while (node.parent) {
            result += step;
            node = node.parent;
          }
          return result;
        };

        Stringifier.prototype.has = function has(value) {
          return typeof value !== 'undefined';
        };

        Stringifier.prototype.rawValue = function rawValue(node, prop) {
          var value = node[prop];
          var raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.sss || raw.raw;
          } else {
            return value;
          }
        };

        return Stringifier;
      }();

      exports.default = Stringifier;
      module.exports = exports['default'];

    }, {}], 512: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;
      exports.default = stringify;

      var _stringifier = require('./stringifier');

      var _stringifier2 = _interopRequireDefault(_stringifier);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function stringify(node, builder) {
        var str = new _stringifier2.default(builder);
        str.stringify(node);
      }
      module.exports = exports['default'];

    }, { "./stringifier": 511 }], 513: [function (require, module, exports) {
      'use strict';

      exports.__esModule = true;
      exports.default = tokenize;
      var SINGLE_QUOTE = 39;
      var DOUBLE_QUOTE = 34;
      var BACKSLASH = 92;
      var SLASH = 47;
      var NEWLINE = 10;
      var SPACE = 32;
      var FEED = 12;
      var TAB = 9;
      var CR = 13;
      var OPEN_PARENTHESES = 40;
      var CLOSE_PARENTHESES = 41;
      var OPEN_CURLY = 123;
      var CLOSE_CURLY = 125;
      var SEMICOLON = 59;
      var ASTERICK = 42;
      var COLON = 58;
      var AT = 64;
      var COMMA = 44;

      var RE_AT_END = /[ \n\t\r\f{()'"\\;/]/g;
      var RE_NEW_LINE = /[\r\f\n]/g;
      var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\,]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\\/("'\n]/;

      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();

        var code = void 0,
        next = void 0,
        quote = void 0,
        lines = void 0,
        last = void 0,
        content = void 0,
        escape = void 0,
        nextLine = void 0,
        nextOffset = void 0,
        escaped = void 0,
        escapePos = void 0,
        prev = void 0,
        n = void 0;

        var length = css.length;
        var offset = -1;
        var line = 1;
        var pos = 0;

        function unclosed(what) {
          throw input.error('Unclosed ' + what, line, pos - offset);
        }

        while (pos < length) {
          code = css.charCodeAt(pos);

          if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
            offset = pos;
            line += 1;
          }

          switch (code) {
            case CR:
              if (css.charCodeAt(pos + 1) === NEWLINE) {
                offset = pos;
                line += 1;
                pos += 1;
                tokens.push(['newline', '\r\n', line - 1]);
              } else {
                tokens.push(['newline', '\r', line - 1]);
              }
              break;

            case FEED:
            case NEWLINE:
              tokens.push(['newline', css.slice(pos, pos + 1), line - 1]);
              break;

            case SPACE:
            case TAB:
              next = pos;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === SPACE || code === TAB);

              tokens.push(['space', css.slice(pos, next)]);
              pos = next - 1;
              break;

            case OPEN_CURLY:
              tokens.push(['{', '{', line, pos - offset]);
              break;

            case CLOSE_CURLY:
              tokens.push(['}', '}', line, pos - offset]);
              break;

            case COLON:
              tokens.push([':', ':', line, pos - offset]);
              break;

            case SEMICOLON:
              tokens.push([';', ';', line, pos - offset]);
              break;

            case COMMA:
              tokens.push([',', ',', line, pos - offset]);
              break;

            case OPEN_PARENTHESES:
              prev = tokens.length ? tokens[tokens.length - 1][1] : '';
              n = css.charCodeAt(pos + 1);
              if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(')', next + 1);
                  if (next === -1) unclosed('bracket');
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);

                tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
              } else {
                next = css.indexOf(')', pos + 1);
                content = css.slice(pos, next + 1);

                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  tokens.push(['(', '(', line, pos - offset]);
                } else {
                  tokens.push(['brackets', content, line, pos - offset, line, next - offset]);
                  pos = next;
                }
              }

              break;

            case CLOSE_PARENTHESES:
              tokens.push([')', ')', line, pos - offset]);
              break;

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:
              quote = code === SINGLE_QUOTE ? '\'' : '"';
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) unclosed('quote');
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              content = css.slice(pos, next + 1);
              lines = content.split('\n');
              last = lines.length - 1;

              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }

              tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);

              offset = nextOffset;
              line = nextLine;
              pos = next;
              break;

            case AT:
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css);
              if (RE_AT_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
              pos = next;
              break;

            case BACKSLASH:
              next = pos;
              escape = true;

              nextLine = line;

              while (css.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape = !escape;
              }
              code = css.charCodeAt(next + 1);
              if (escape) {
                if (code === CR && css.charCodeAt(next + 2) === NEWLINE) {
                  next += 2;
                  nextLine += 1;
                  nextOffset = next;
                } else if (code === CR || code === NEWLINE || code === FEED) {
                  next += 1;
                  nextLine += 1;
                  nextOffset = next;
                } else {
                  next += 1;
                }
              }
              tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
              if (nextLine !== line) {
                line = nextLine;
                offset = nextOffset;
              }
              pos = next;
              break;

            default:
              n = css.charCodeAt(pos + 1);

              if (code === SLASH && n === ASTERICK) {
                next = css.indexOf('*/', pos + 2) + 1;
                if (next === 0) unclosed('comment');

                content = css.slice(pos, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);

                offset = nextOffset;
                line = nextLine;
                pos = next;
              } else if (code === SLASH && n === SLASH) {
                RE_NEW_LINE.lastIndex = pos + 1;
                RE_NEW_LINE.test(css);
                if (RE_NEW_LINE.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_NEW_LINE.lastIndex - 2;
                }

                content = css.slice(pos, next + 1);

                tokens.push(['comment', content, line, pos - offset, line, next - offset, 'inline']);

                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }

                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);
                pos = next;
              }

              break;}


          pos++;
        }

        return tokens;
      }
      module.exports = exports['default'];

    }, {}], 514: [function (require, module, exports) {
      module.exports = require('./svg-tags.json');
    }, { "./svg-tags.json": 515 }], 515: [function (require, module, exports) {
      module.exports = [
      "a",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern"];

    }, {}], 516: [function (require, module, exports) {
      "use strict";

      function unique_pred(list, compare) {
        var ptr = 1,
        len = list.length,
        a = list[0],b = list[0];
        for (var i = 1; i < len; ++i) {
          b = a;
          a = list[i];
          if (compare(a, b)) {
            if (i === ptr) {
              ptr++;
              continue;
            }
            list[ptr++] = a;
          }
        }
        list.length = ptr;
        return list;
      }

      function unique_eq(list) {
        var ptr = 1,
        len = list.length,
        a = list[0],b = list[0];
        for (var i = 1; i < len; ++i, b = a) {
          b = a;
          a = list[i];
          if (a !== b) {
            if (i === ptr) {
              ptr++;
              continue;
            }
            list[ptr++] = a;
          }
        }
        list.length = ptr;
        return list;
      }

      function unique(list, compare, sorted) {
        if (list.length === 0) {
          return list;
        }
        if (compare) {
          if (!sorted) {
            list.sort(compare);
          }
          return unique_pred(list, compare);
        }
        if (!sorted) {
          list.sort();
        }
        return unique_eq(list);
      }

      module.exports = unique;

    }, {}], 517: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var punycode = require('punycode');
      var util = require('./util');

      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;

      exports.Url = Url;

      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }

      // Reference: RFC 3986, RFC 1808, RFC 2396

      // define these here so at least they only have to be
      // compiled once on the first module load.
      var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

      // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true },

      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true },

      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true },

      querystring = require('querystring');

      function urlParse(url, parseQueryString, slashesDenoteHost) {
        if (url && util.isObject(url) && url instanceof Url) return url;

        var u = new Url();
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
      }

      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
        if (!util.isString(url)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }

        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'),
        splitter =
        queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);

        var rest = url;

        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();

        if (!slashesDenoteHost && url.split('#').length === 1) {
          // Try fast path regexp
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = '';
              this.query = {};
            }
            return this;
          }
        }

        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }

        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === '//';
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }

        if (!hostlessProtocol[proto] && (
        slashes || proto && !slashedProtocol[proto])) {

          // there's a hostname.
          // the first instance of /, ?, ;, or # ends the host.
          //
          // If there is an @ in the hostname, then non-host chars *are* allowed
          // to the left of the last @ sign, unless some host-ending character
          // comes *before* the @-sign.
          // URLs are obnoxious.
          //
          // ex:
          // http://a@b@c/ => user:a@b host:c
          // http://a@b?@c => user:a host:c path:/?@c

          // v0.12 TODO(isaacs): This is not quite how Chrome does things.
          // Review our test case against browsers more comprehensively.

          // find the first instance of any hostEndingChars
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
          }

          // at this point, either we have an explicit point where the
          // auth portion cannot go past, or the last @ char is the decider.
          var auth, atSign;
          if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
          } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
          }

          // Now we have a portion which is definitely the auth.
          // Pull that off.
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }

          // the host is the remaining to the left of the first non-host char
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
          }
          // if we still have not hit it, then the entire thing is a host.
          if (hostEnd === -1)
          hostEnd = rest.length;

          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);

          // pull out port.
          this.parseHost();

          // we've indicated that there is a hostname,
          // so even if it's empty, it has to be present.
          this.hostname = this.hostname || '';

          // if hostname begins with [ and ends with ]
          // assume that it's an IPv6 address.
          var ipv6Hostname = this.hostname[0] === '[' &&
          this.hostname[this.hostname.length - 1] === ']';

          // validate a little.
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part) continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = '';
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    // we replace non-ASCII char with a temporary placeholder
                    // we need this to make sure size of hostname is not
                    // broken by replacing non-ASCII by nothing
                    newpart += 'x';
                  } else {
                    newpart += part[j];
                  }
                }
                // we test again with ASCII char only
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = '/' + notHost.join('.') + rest;
                  }
                  this.hostname = validParts.join('.');
                  break;
                }
              }
            }
          }

          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
          } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
          }

          if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
          }

          var p = this.port ? ':' + this.port : '';
          var h = this.hostname || '';
          this.host = h + p;
          this.href += this.host;

          // strip [ and ] from the hostname
          // the host field still retains them, though
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
              rest = '/' + rest;
            }
          }
        }

        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!unsafeProtocol[lowerProto]) {

          // First, make 100% sure that any "autoEscape" chars get
          // escaped, even if encodeURIComponent doesn't think they
          // need to be.
          for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1)
            continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }


        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
          // got a fragment string.
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          // no query string, but parseQueryString still requested
          this.search = '';
          this.query = {};
        }
        if (rest) this.pathname = rest;
        if (slashedProtocol[lowerProto] &&
        this.hostname && !this.pathname) {
          this.pathname = '/';
        }

        //to support http.request
        if (this.pathname || this.search) {
          var p = this.pathname || '';
          var s = this.search || '';
          this.path = p + s;
        }

        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
      };

      // format a parsed object into a url string
      function urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (util.isString(obj)) obj = urlParse(obj);
        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
        return obj.format();
      }

      Url.prototype.format = function () {
        var auth = this.auth || '';
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ':');
          auth += '@';
        }

        var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(':') === -1 ?
          this.hostname :
          '[' + this.hostname + ']');
          if (this.port) {
            host += ':' + this.port;
          }
        }

        if (this.query &&
        util.isObject(this.query) &&
        Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }

        var search = this.search || query && '?' + query || '';

        if (protocol && protocol.substr(-1) !== ':') protocol += ':';

        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
        (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = '//' + (host || '');
          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
        } else if (!host) {
          host = '';
        }

        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
        if (search && search.charAt(0) !== '?') search = '?' + search;

        pathname = pathname.replace(/[?#]/g, function (match) {
          return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');

        return protocol + host + pathname + search + hash;
      };

      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }

      Url.prototype.resolve = function (relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };

      function urlResolveObject(source, relative) {
        if (!source) return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }

      Url.prototype.resolveObject = function (relative) {
        if (util.isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }

        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }

        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;

        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
          result.href = result.format();
          return result;
        }

        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
          // take everything except the protocol from relative
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
          }

          //urlParse appends trailing / to urls like http://www.example.com
          if (slashedProtocol[result.protocol] &&
          result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
          }

          result.href = result.format();
          return result;
        }

        if (relative.protocol && relative.protocol !== result.protocol) {
          // if it's a known url protocol, then changing
          // the protocol does weird things
          // first, if it's not file:, then we MUST have a host,
          // and if there was a path
          // to begin with, then we MUST have a path.
          // if it is file:, then the host is dropped,
          // because that's known to be hostless.
          // anything else is assumed to be absolute.
          if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
              var k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }

          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = '';
            if (!relative.hostname) relative.hostname = '';
            if (relPath[0] !== '') relPath.unshift('');
            if (relPath.length < 2) relPath.unshift('');
            result.pathname = relPath.join('/');
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || '';
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          // to support http.request
          if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }

        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs =
        relative.host ||
        relative.pathname && relative.pathname.charAt(0) === '/',

        mustEndAbs = isRelAbs || isSourceAbs ||
        result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
          result.hostname = '';
          result.port = null;
          if (result.host) {
            if (srcPath[0] === '') srcPath[0] = result.host;else
            srcPath.unshift(result.host);
          }
          result.host = '';
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === '') relPath[0] = relative.host;else
              relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }

        if (isRelAbs) {
          // it's absolute.
          result.host = relative.host || relative.host === '' ?
          relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === '' ?
          relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
          // fall through to the dot-handling below.
        } else if (relPath.length) {
          // it's relative
          // throw away the existing file, and take the new path instead.
          if (!srcPath) srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util.isNullOrUndefined(relative.search)) {
          // just pull out the search.
          // like href='?foo'.
          // Put this after the other two cases because it simplifies the booleans
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
            result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          //to support http.request
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (
            result.search ? result.search : '');
          }
          result.href = result.format();
          return result;
        }

        if (!srcPath.length) {
          // no path at all.  easy.
          // we've already handled the other stuff above.
          result.pathname = null;
          //to support http.request
          if (result.search) {
            result.path = '/' + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }

        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash =
        (result.host || relative.host || srcPath.length > 1) && (
        last === '.' || last === '..') || last === '';

        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === '.') {
            srcPath.splice(i, 1);
          } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }

        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift('..');
          }
        }

        if (mustEndAbs && srcPath[0] !== '' && (
        !srcPath[0] || srcPath[0].charAt(0) !== '/')) {
          srcPath.unshift('');
        }

        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
          srcPath.push('');
        }

        var isAbsolute = srcPath[0] === '' ||
        srcPath[0] && srcPath[0].charAt(0) === '/';

        // put the host back
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? '' :
          srcPath.length ? srcPath.shift() : '';
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }

        mustEndAbs = mustEndAbs || result.host && srcPath.length;

        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift('');
        }

        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join('/');
        }

        //to support request.http
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (
          result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };

      Url.prototype.parseHost = function () {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ':') {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host) this.hostname = host;
      };

    }, { "./util": 518, "punycode": 161, "querystring": 164 }], 518: [function (require, module, exports) {
      'use strict';

      module.exports = {
        isString: function (arg) {
          return typeof arg === 'string';
        },
        isObject: function (arg) {
          return typeof arg === 'object' && arg !== null;
        },
        isNull: function (arg) {
          return arg === null;
        },
        isNullOrUndefined: function (arg) {
          return arg == null;
        } };


    }, {}], 519: [function (require, module, exports) {
      (function (global) {(function () {

          /**
           * Module exports.
           */

          module.exports = deprecate;

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }

            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
          }

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], "stylelint": [function (require, module, exports) {
      'use strict';

      const checkAgainstRule = require('./utils/checkAgainstRule');
      const createPlugin = require('./createPlugin');
      const createStylelint = require('./createStylelint');
      const formatters = require('./formatters');
      const postcssPlugin = require('./postcssPlugin');
      const report = require('./utils/report');
      const ruleMessages = require('./utils/ruleMessages');
      const rules = require('./rules');
      const standalone = require('./standalone');
      const validateOptions = require('./utils/validateOptions');

      /**
       * TODO TYPES change any to appropriated options
       * @type {import('postcss').Plugin<any> & Partial<import('stylelint').StylelintPublicAPI>}
       */
      const api = postcssPlugin;

      api.utils = {
        report,
        ruleMessages,
        validateOptions,
        checkAgainstRule };


      api.lint = standalone;
      api.rules = rules;
      api.formatters = formatters;
      api.createPlugin = createPlugin;
      api.createLinter = createStylelint;

      module.exports = api;

    }, { "./createPlugin": 169, "./createStylelint": 170, "./formatters": 174, "./postcssPlugin": 184, "./rules": 291, "./standalone": 410, "./utils/checkAgainstRule": 422, "./utils/report": 498, "./utils/ruleMessages": 499, "./utils/validateOptions": 503 }] }, {}, [])("stylelint");
});})();