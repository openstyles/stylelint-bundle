/*!= Stylelint v14.2.0 bundle =*/
/* See https://github.com/openstyles/stylelint-bundle */
;(()=>{"use strict";function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function _extends() {_extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};return _extends.apply(this, arguments);}(function (f) {if (typeof exports === "object" && typeof module !== "undefined") {module.exports = f();} else if (typeof define === "function" && define.amd) {define([], f);} else {var g;if (typeof window !== "undefined") {g = window;} else if (typeof global !== "undefined") {g = global;} else if (typeof self !== "undefined") {g = self;} else {g = this;}g.stylelint = f();}})(function () {var define, module, exports;return function () {function r(e, n, t) {function o(i, f) {if (!n[i]) {if (!e[i]) {var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;}var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {var n = e[i][1][r];return o(n || r);}, p, p.exports, r, e, n, t);}return n[i].exports;}for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);return o;}return r;}()({ 1: [function (require, module, exports) {

      /**
       * Array#filter.
       *
       * @param {Array} arr
       * @param {Function} fn
       * @param {Object=} self
       * @return {Array}
       * @throw TypeError
       */

      module.exports = function (arr, fn, self) {
        if (arr.filter) return arr.filter(fn, self);
        if (void 0 === arr || null === arr) throw new TypeError();
        if ('function' != typeof fn) throw new TypeError();
        var ret = [];
        for (var i = 0; i < arr.length; i++) {
          if (!hasOwn.call(arr, i)) continue;
          var val = arr[i];
          if (fn.call(self, val, i, arr)) ret.push(val);
        }
        return ret;
      };

      var hasOwn = Object.prototype.hasOwnProperty;

    }, {}], 2: [function (require, module, exports) {
      (function (global) {(function () {
          'use strict';

          var filter = require('array-filter');

          module.exports = function availableTypedArrays() {
            return filter([
            'BigInt64Array',
            'BigUint64Array',
            'Float32Array',
            'Float64Array',
            'Int16Array',
            'Int32Array',
            'Int8Array',
            'Uint16Array',
            'Uint32Array',
            'Uint8Array',
            'Uint8ClampedArray'],
            function (typedArray) {
              return typeof global[typedArray] === 'function';
            });
          };

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "array-filter": 1 }], 3: [function (require, module, exports) {
      'use strict';

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;

      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;

        var placeHoldersLen = validLen === len ?
        0 :
        4 - validLen % 4;

        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];

        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ?
        validLen - 4 :
        validLen;

        var i;
        for (i = 0; i < len; i += 4) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 18 |
          revLookup[b64.charCodeAt(i + 1)] << 12 |
          revLookup[b64.charCodeAt(i + 2)] << 6 |
          revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 2) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 2 |
          revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 1) {
          tmp =
          revLookup[b64.charCodeAt(i)] << 10 |
          revLookup[b64.charCodeAt(i + 1)] << 4 |
          revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp =
          (uint8[i] << 16 & 0xFF0000) + (
          uint8[i + 1] << 8 & 0xFF00) + (
          uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(
          lookup[tmp >> 2] +
          lookup[tmp << 4 & 0x3F] +
          '==');

        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(
          lookup[tmp >> 10] +
          lookup[tmp >> 4 & 0x3F] +
          lookup[tmp << 2 & 0x3F] +
          '=');

        }

        return parts.join('');
      }

    }, {}], 4: [function (require, module, exports) {

    }, {}], 5: [function (require, module, exports) {
      arguments[4][4][0].apply(exports, arguments);
    }, { "dup": 4 }], 6: [function (require, module, exports) {
      (function (Buffer) {(function () {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          /* eslint-disable no-proto */

          'use strict';

          var base64 = require('base64-js');
          var ieee754 = require('ieee754');

          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;

          var K_MAX_LENGTH = 0x7fffffff;
          exports.kMaxLength = K_MAX_LENGTH;

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Print warning and recommend using `buffer` v4.x which has an Object
           *               implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * We report that the browser does not support typed arrays if the are not subclassable
           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
           * for __proto__ and has a buggy typed array implementation.
           */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
          typeof console.error === 'function') {
            console.error(
            'This browser lacks typed array (Uint8Array) support which is required by ' +
            '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');

          }

          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {return 42;} };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }

          Object.defineProperty(Buffer.prototype, 'parent', {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.buffer;
            } });


          Object.defineProperty(Buffer.prototype, 'offset', {
            enumerable: true,
            get: function () {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.byteOffset;
            } });


          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new TypeError(
                'The "string" argument must be of type string. Received type number');

              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }

          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          if (typeof Symbol !== 'undefined' && Symbol.species != null &&
          Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false });

          }

          Buffer.poolSize = 8192; // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === 'string') {
              return fromString(value, encodingOrOffset);
            }

            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }

            if (value == null) {
              throw TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
              'or Array-like Object. Received type ' + typeof value);

            }

            if (isInstance(value, ArrayBuffer) ||
            value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }

            if (typeof value === 'number') {
              throw new TypeError(
              'The "value" argument must not be of type number. Received type number');

            }

            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }

            var b = fromObject(value);
            if (b) return b;

            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === 'function') {
              return Buffer.from(
              value[Symbol.toPrimitive]('string'), encodingOrOffset, length);

            }

            throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + typeof value);

          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }

          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ?
              createBuffer(size).fill(fill, encoding) :
              createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding);
          };

          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size);
          };

          function fromString(string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }

            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);

            var actual = buf.write(string, encoding);

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual);
            }

            return buf;
          }

          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }

          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }

            var buf;
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);

              if (buf.length === 0) {
                return buf;
              }

              obj.copy(buf, 0, 0, len);
              return buf;
            }

            if (obj.length !== undefined) {
              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }

            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }

          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
              'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
            }
            return length | 0;
          }

          function SlowBuffer(length) {
            if (+length != length) {// eslint-disable-line eqeqeq
              length = 0;
            }
            return Buffer.alloc(+length);
          }

          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true &&
            b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
          };

          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');

            }

            if (a === b) return 0;

            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;}

          };

          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            if (list.length === 0) {
              return Buffer.alloc(0);
            }

            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }

            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== 'string') {
              throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
              'Received type ' + typeof string);

            }

            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;

            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;}

            }
          }
          Buffer.byteLength = byteLength;

          function slowToString(encoding, start, end) {
            var loweredCase = false;

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0;
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return '';
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return '';
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return '';
            }

            if (!encoding) encoding = 'utf8';

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);

                case 'ascii':
                  return asciiSlice(this, start, end);

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);

                case 'base64':
                  return base64Slice(this, start, end);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;}

            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true;

          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };

          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };

          Buffer.prototype.toLocaleString = Buffer.prototype.toString;

          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };

          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
            if (this.length > max) str += ' ... ';
            return '<Buffer ' + str + '>';
          };

          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. ' +
              'Received type ' + typeof target);

            }

            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }

            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;

            if (this === target) return 0;

            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);

            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1;

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }
            byteOffset = +byteOffset; // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;else
              byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;else
              return -1;
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }

            throw new TypeError('val must be string, number or Buffer');
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }

            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }

            return -1;
          }

          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };

          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }

            var strLen = string.length;

            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }

          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported');

            }

            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;

            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }

            if (!encoding) encoding = 'utf8';

            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);

                case 'ascii':
                  return asciiWrite(this, string, offset, length);

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;}

            }
          };

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0) };

          };

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];

            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 :
              firstByte > 0xDF ? 3 :
              firstByte > 0xBF ? 2 :
              1;

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }}

              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));

            }
            return res;
          }

          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }
            return ret;
          }

          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }

          function hexSlice(buf, start, end) {
            var len = buf.length;

            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;

            var out = '';
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;

            var newBuf = this.subarray(start, end);
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };

          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }

          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            return val;
          };

          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }

            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }

            return val;
          };

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };

          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return (this[offset] |
            this[offset + 1] << 8 |
            this[offset + 2] << 16) +
            this[offset + 3] * 0x1000000;
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] * 0x1000000 + (
            this[offset + 1] << 16 |
            this[offset + 2] << 8 |
            this[offset + 3]);
          };

          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);

            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;

            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

            return val;
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] |
            this[offset + 1] << 8 |
            this[offset + 2] << 16 |
            this[offset + 3] << 24;
          };

          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);

            return this[offset] << 24 |
            this[offset + 1] << 16 |
            this[offset + 2] << 8 |
            this[offset + 3];
          };

          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };

          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };

          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };

          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);

              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
            if (end < 0) throw new RangeError('sourceEnd out of bounds');

            // Are we oob?
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;

            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart);

            }

            return len;
          };

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === 'utf8' && code < 128 ||
                encoding === 'latin1') {
                  // Fast path: If `val` fits into a single byte, use that numeric value.
                  val = code;
                }
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }

            if (end <= start) {
              return this;
            }

            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;

            if (!val) val = 0;

            var i;
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ?
              val :
              Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val +
                '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }

            return this;
          };

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

          function base64clean(str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split('=')[0];
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }

          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);

              // is surrogate component
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  }

                  // valid lead
                  leadSurrogate = codePoint;

                  continue;
                }

                // 2 leads in a row
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                }

                // valid surrogate pair
                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }

              leadSurrogate = null;

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(
                codePoint >> 0x6 | 0xC0,
                codePoint & 0x3F | 0x80);

              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(
                codePoint >> 0xC | 0xE0,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80);

              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(
                codePoint >> 0x12 | 0xF0,
                codePoint >> 0xC & 0x3F | 0x80,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80);

              } else {
                throw new Error('Invalid code point');
              }
            }

            return bytes;
          }

          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }
            return byteArray;
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;

              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }

            return byteArray;
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }

          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
          // the `instanceof` check but they should be treated as of that type.
          // See: https://github.com/feross/buffer/issues/166
          function isInstance(obj, type) {
            return obj instanceof type ||
            obj != null && obj.constructor != null && obj.constructor.name != null &&
            obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }

        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "base64-js": 3, "buffer": 6, "ieee754": 29 }], 7: [function (require, module, exports) {
      'use strict';

      var GetIntrinsic = require('get-intrinsic');

      var callBind = require('./');

      var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };

    }, { "./": 8, "get-intrinsic": 23 }], 8: [function (require, module, exports) {
      'use strict';

      var bind = require('function-bind');
      var GetIntrinsic = require('get-intrinsic');

      var $apply = GetIntrinsic('%Function.prototype.apply%');
      var $call = GetIntrinsic('%Function.prototype.call%');
      var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

      var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

      if ($defineProperty) {
        try {
          $defineProperty({}, 'a', { value: 1 });
        } catch (e) {
          // IE 8 has a broken defineProperty
          $defineProperty = null;
        }
      }

      module.exports = function callBind() {
        return $reflectApply(bind, $call, arguments);
      };

      var applyBind = function applyBind() {
        return $reflectApply(bind, $apply, arguments);
      };

      if ($defineProperty) {
        $defineProperty(module.exports, 'apply', { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }

    }, { "function-bind": 22, "get-intrinsic": 23 }], 9: [function (require, module, exports) {
      'use strict';
      const isRegexp = require('is-regexp');

      const flagMap = {
        global: 'g',
        ignoreCase: 'i',
        multiline: 'm',
        dotAll: 's',
        sticky: 'y',
        unicode: 'u' };


      module.exports = (regexp, options = {}) => {
        if (!isRegexp(regexp)) {
          throw new TypeError('Expected a RegExp instance');
        }

        const flags = Object.keys(flagMap).map((flag) =>
        (typeof options[flag] === 'boolean' ? options[flag] : regexp[flag]) ? flagMap[flag] : '').
        join('');

        const clonedRegexp = new RegExp(options.source || regexp.source, flags);

        clonedRegexp.lastIndex = typeof options.lastIndex === 'number' ?
        options.lastIndex :
        regexp.lastIndex;

        return clonedRegexp;
      };

    }, { "is-regexp": 36 }], 10: [function (require, module, exports) {
      Object.defineProperty(exports, "__esModule", { value: !0 });var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },t = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},n = function (r, t, n) {return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;},e = function (r, t, n) {return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;},u = function (r) {return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;},o = function (r) {return { r: e(r.r, 0, 255), g: e(r.g, 0, 255), b: e(r.b, 0, 255), a: e(r.a) };},a = function (r) {return { r: n(r.r), g: n(r.g), b: n(r.b), a: n(r.a, 3) };},s = /^#([0-9a-f]{3,8})$/i,i = function (r) {var t = r.toString(16);return t.length < 2 ? "0" + t : t;},h = function (r) {var t = r.r,n = r.g,e = r.b,u = r.a,o = Math.max(t, n, e),a = o - Math.min(t, n, e),s = a ? o === t ? (n - e) / a : o === n ? 2 + (e - t) / a : 4 + (t - n) / a : 0;return { h: 60 * (s < 0 ? s + 6 : s), s: o ? a / o * 100 : 0, v: o / 255 * 100, a: u };},b = function (r) {var t = r.h,n = r.s,e = r.v,u = r.a;t = t / 360 * 6, n /= 100, e /= 100;var o = Math.floor(t),a = e * (1 - n),s = e * (1 - (t - o) * n),i = e * (1 - (1 - t + o) * n),h = o % 6;return { r: 255 * [e, s, a, a, i, e][h], g: 255 * [i, e, e, s, a, a][h], b: 255 * [a, a, i, e, e, s][h], a: u };},d = function (r) {return { h: u(r.h), s: e(r.s, 0, 100), l: e(r.l, 0, 100), a: e(r.a) };},g = function (r) {return { h: n(r.h), s: n(r.s), l: n(r.l), a: n(r.a, 3) };},f = function (r) {return b((n = (t = r).s, { h: t.h, s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0, v: e + n, a: t.a }));var t, n, e;},p = function (r) {return { h: (t = h(r)).h, s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0, l: u / 2, a: t.a };var t, n, e, u;},l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y = { string: [[function (r) {var t = s.exec(r);return t ? (r = t[1]).length <= 4 ? { r: parseInt(r[0] + r[0], 16), g: parseInt(r[1] + r[1], 16), b: parseInt(r[2] + r[2], 16), a: 4 === r.length ? n(parseInt(r[3] + r[3], 16) / 255, 2) : 1 } : 6 === r.length || 8 === r.length ? { r: parseInt(r.substr(0, 2), 16), g: parseInt(r.substr(2, 2), 16), b: parseInt(r.substr(4, 2), 16), a: 8 === r.length ? n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1 } : null : null;}, "hex"], [function (r) {var t = v.exec(r) || m.exec(r);return t ? t[2] !== t[4] || t[4] !== t[6] ? null : o({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;}, "rgb"], [function (t) {var n = l.exec(t) || c.exec(t);if (!n) return null;var e,u,o = d({ h: (e = n[1], u = n[2], void 0 === u && (u = "deg"), Number(e) * (r[u] || 1)), s: Number(n[3]), l: Number(n[4]), a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1) });return f(o);}, "hsl"]], object: [[function (r) {var n = r.r,e = r.g,u = r.b,a = r.a,s = void 0 === a ? 1 : a;return t(n) && t(e) && t(u) ? o({ r: Number(n), g: Number(e), b: Number(u), a: Number(s) }) : null;}, "rgb"], [function (r) {var n = r.h,e = r.s,u = r.l,o = r.a,a = void 0 === o ? 1 : o;if (!t(n) || !t(e) || !t(u)) return null;var s = d({ h: Number(n), s: Number(e), l: Number(u), a: Number(a) });return f(s);}, "hsl"], [function (r) {var n = r.h,o = r.s,a = r.v,s = r.a,i = void 0 === s ? 1 : s;if (!t(n) || !t(o) || !t(a)) return null;var h = function (r) {return { h: u(r.h), s: e(r.s, 0, 100), v: e(r.v, 0, 100), a: e(r.a) };}({ h: Number(n), s: Number(o), v: Number(a), a: Number(i) });return b(h);}, "hsv"]] },N = function (r, t) {for (var n = 0; n < t.length; n++) {var e = t[n][0](r);if (e) return [e, t[n][1]];}return [null, void 0];},x = function (r) {return "string" == typeof r ? N(r.trim(), y.string) : "object" == typeof r && null !== r ? N(r, y.object) : [null, void 0];},M = function (r, t) {var n = p(r);return { h: n.h, s: e(n.s + 100 * t, 0, 100), l: n.l, a: n.a };},I = function (r) {return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;},H = function (r, t) {var n = p(r);return { h: n.h, s: n.s, l: e(n.l + 100 * t, 0, 100), a: n.a };},$ = function () {function r(r) {this.parsed = x(r)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };}return r.prototype.isValid = function () {return null !== this.parsed;}, r.prototype.brightness = function () {return n(I(this.rgba), 2);}, r.prototype.isDark = function () {return I(this.rgba) < .5;}, r.prototype.isLight = function () {return I(this.rgba) >= .5;}, r.prototype.toHex = function () {return r = a(this.rgba), t = r.r, e = r.g, u = r.b, s = (o = r.a) < 1 ? i(n(255 * o)) : "", "#" + i(t) + i(e) + i(u) + s;var r, t, e, u, o, s;}, r.prototype.toRgb = function () {return a(this.rgba);}, r.prototype.toRgbString = function () {return r = a(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? "rgba(" + t + ", " + n + ", " + e + ", " + u + ")" : "rgb(" + t + ", " + n + ", " + e + ")";var r, t, n, e, u;}, r.prototype.toHsl = function () {return g(p(this.rgba));}, r.prototype.toHslString = function () {return r = g(p(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? "hsla(" + t + ", " + n + "%, " + e + "%, " + u + ")" : "hsl(" + t + ", " + n + "%, " + e + "%)";var r, t, n, e, u;}, r.prototype.toHsv = function () {return r = h(this.rgba), { h: n(r.h), s: n(r.s), v: n(r.v), a: n(r.a, 3) };var r;}, r.prototype.invert = function () {return j({ r: 255 - (r = this.rgba).r, g: 255 - r.g, b: 255 - r.b, a: r.a });var r;}, r.prototype.saturate = function (r) {return void 0 === r && (r = .1), j(M(this.rgba, r));}, r.prototype.desaturate = function (r) {return void 0 === r && (r = .1), j(M(this.rgba, -r));}, r.prototype.grayscale = function () {return j(M(this.rgba, -1));}, r.prototype.lighten = function (r) {return void 0 === r && (r = .1), j(H(this.rgba, r));}, r.prototype.darken = function (r) {return void 0 === r && (r = .1), j(H(this.rgba, -r));}, r.prototype.rotate = function (r) {return void 0 === r && (r = 15), this.hue(this.hue() + r);}, r.prototype.alpha = function (r) {return "number" == typeof r ? j({ r: (t = this.rgba).r, g: t.g, b: t.b, a: r }) : n(this.rgba.a, 3);var t;}, r.prototype.hue = function (r) {var t = p(this.rgba);return "number" == typeof r ? j({ h: r, s: t.s, l: t.l, a: t.a }) : n(t.h);}, r.prototype.isEqual = function (r) {return this.toHex() === j(r).toHex();}, r;}(),j = function (r) {return r instanceof $ ? r : new $(r);},w = [];exports.Colord = $, exports.colord = j, exports.extend = function (r) {r.forEach(function (r) {w.indexOf(r) < 0 && (r($, y), w.push(r));});}, exports.getFormat = function (r) {return x(r)[1];}, exports.random = function () {return new $({ r: 255 * Math.random(), g: 255 * Math.random(), b: 255 * Math.random() });};

    }, {}], 11: [function (require, module, exports) {
      var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },n = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},t = function (r, n, t) {return void 0 === n && (n = 0), void 0 === t && (t = Math.pow(10, n)), Math.round(t * r) / t + 0;},u = function (r, n, t) {return void 0 === n && (n = 0), void 0 === t && (t = 1), r > t ? t : r > n ? r : n;},a = function (r) {return { h: (n = r.h, (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360), w: u(r.w, 0, 100), b: u(r.b, 0, 100), a: u(r.a) };var n;},e = function (r) {return { h: t(r.h), w: t(r.w), b: t(r.b), a: t(r.a, 3) };},o = function (r) {return { h: function (r) {var n = r.r,t = r.g,u = r.b,a = r.a,e = Math.max(n, t, u),o = e - Math.min(n, t, u),b = o ? e === n ? (t - u) / o : e === t ? 2 + (u - n) / o : 4 + (n - t) / o : 0;return { h: 60 * (b < 0 ? b + 6 : b), s: e ? o / e * 100 : 0, v: e / 255 * 100, a: a };}(r).h, w: Math.min(r.r, r.g, r.b) / 255 * 100, b: 100 - Math.max(r.r, r.g, r.b) / 255 * 100, a: r.a };},b = function (r) {return function (r) {var n = r.h,t = r.s,u = r.v,a = r.a;n = n / 360 * 6, t /= 100, u /= 100;var e = Math.floor(n),o = u * (1 - t),b = u * (1 - (n - e) * t),i = u * (1 - (1 - n + e) * t),h = e % 6;return { r: 255 * [u, b, o, o, i, u][h], g: 255 * [i, u, u, b, o, o][h], b: 255 * [o, o, i, u, u, b][h], a: a };}({ h: r.h, s: 100 === r.b ? 0 : 100 - r.w / (100 - r.b) * 100, v: 100 - r.b, a: r.a });},i = function (r) {var t = r.h,u = r.w,e = r.b,o = r.a,i = void 0 === o ? 1 : o;if (!n(t) || !n(u) || !n(e)) return null;var h = a({ h: Number(t), w: Number(u), b: Number(e), a: Number(i) });return b(h);},h = /^hwb\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,d = function (n) {var t = h.exec(n);if (!t) return null;var u,e,o = a({ h: (u = t[1], e = t[2], void 0 === e && (e = "deg"), Number(u) * (r[e] || 1)), w: Number(t[3]), b: Number(t[4]), a: void 0 === t[5] ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });return b(o);};module.exports = function (r, n) {r.prototype.toHwb = function () {return e(o(this.rgba));}, r.prototype.toHwbString = function () {return r = e(o(this.rgba)), n = r.h, t = r.w, u = r.b, (a = r.a) < 1 ? "hwb(" + n + " " + t + "% " + u + "% / " + a + ")" : "hwb(" + n + " " + t + "% " + u + "%)";var r, n, t, u, a;}, n.string.push([d, "hwb"]), n.object.push([i, "hwb"]);};

    }, {}], 12: [function (require, module, exports) {
      var a = function (a) {return "string" == typeof a ? a.length > 0 : "number" == typeof a;},t = function (a, t, o) {return void 0 === t && (t = 0), void 0 === o && (o = Math.pow(10, t)), Math.round(o * a) / o + 0;},o = function (a, t, o) {return void 0 === t && (t = 0), void 0 === o && (o = 1), a > o ? o : a > t ? a : t;},r = function (a) {var t = a / 255;return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);},h = function (a) {return 255 * (a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a);},n = 96.422,p = 100,M = 82.521,u = function (a) {var t,r,n = { x: .9555766 * (t = a).x + -.0230393 * t.y + .0631636 * t.z, y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z, z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z };return r = { r: h(.032404542 * n.x - .015371385 * n.y - .004985314 * n.z), g: h(-.00969266 * n.x + .018760108 * n.y + 41556e-8 * n.z), b: h(556434e-9 * n.x - .002040259 * n.y + .010572252 * n.z), a: a.a }, { r: o(r.r, 0, 255), g: o(r.g, 0, 255), b: o(r.b, 0, 255), a: o(r.a) };},e = function (a) {var t = r(a.r),h = r(a.g),u = r(a.b);return function (a) {return { x: o(a.x, 0, n), y: o(a.y, 0, p), z: o(a.z, 0, M), a: o(a.a) };}(function (a) {return { x: 1.0478112 * a.x + .0228866 * a.y + -.050127 * a.z, y: .0295424 * a.x + .9904844 * a.y + -.0170491 * a.z, z: -.0092345 * a.x + .0150436 * a.y + .7521316 * a.z, a: a.a };}({ x: 100 * (.4124564 * t + .3575761 * h + .1804375 * u), y: 100 * (.2126729 * t + .7151522 * h + .072175 * u), z: 100 * (.0193339 * t + .119192 * h + .9503041 * u), a: a.a }));},w = 216 / 24389,b = 24389 / 27,i = function (t) {var r = t.l,h = t.a,n = t.b,p = t.alpha,M = void 0 === p ? 1 : p;if (!a(r) || !a(h) || !a(n)) return null;var u = function (a) {return { l: o(a.l, 0, 400), a: a.a, b: a.b, alpha: o(a.alpha) };}({ l: Number(r), a: Number(h), b: Number(n), alpha: Number(M) });return l(u);},l = function (a) {var t = (a.l + 16) / 116,o = a.a / 500 + t,r = t - a.b / 200;return u({ x: (Math.pow(o, 3) > w ? Math.pow(o, 3) : (116 * o - 16) / b) * n, y: (a.l > 8 ? Math.pow((a.l + 16) / 116, 3) : a.l / b) * p, z: (Math.pow(r, 3) > w ? Math.pow(r, 3) : (116 * r - 16) / b) * M, a: a.alpha });};module.exports = function (a, r) {a.prototype.toLab = function () {return o = e(this.rgba), h = o.y / p, u = o.z / M, r = (r = o.x / n) > w ? Math.cbrt(r) : (b * r + 16) / 116, a = { l: 116 * (h = h > w ? Math.cbrt(h) : (b * h + 16) / 116) - 16, a: 500 * (r - h), b: 200 * (h - (u = u > w ? Math.cbrt(u) : (b * u + 16) / 116)), alpha: o.a }, { l: t(a.l, 2), a: t(a.a, 2), b: t(a.b, 2), alpha: t(a.alpha, 3) };var a, o, r, h, u;}, a.prototype.delta = function (r) {void 0 === r && (r = "#FFF");var h = r instanceof a ? r : new a(r),n = function (a, t) {var o = a.l,r = a.a,h = a.b,n = t.l,p = t.a,M = t.b,u = 180 / Math.PI,e = Math.PI / 180,w = Math.pow(Math.pow(r, 2) + Math.pow(h, 2), .5),b = Math.pow(Math.pow(p, 2) + Math.pow(M, 2), .5),i = (o + n) / 2,l = Math.pow((w + b) / 2, 7),c = .5 * (1 - Math.pow(l / (l + Math.pow(25, 7)), .5)),f = r * (1 + c),y = p * (1 + c),v = Math.pow(Math.pow(f, 2) + Math.pow(h, 2), .5),x = Math.pow(Math.pow(y, 2) + Math.pow(M, 2), .5),z = (v + x) / 2,s = 0 === f && 0 === h ? 0 : Math.atan2(h, f) * u,d = 0 === y && 0 === M ? 0 : Math.atan2(M, y) * u;s < 0 && (s += 360), d < 0 && (d += 360);var g = d - s,m = Math.abs(d - s);m > 180 && d <= s ? g += 360 : m > 180 && d > s && (g -= 360);var N = s + d;m <= 180 ? N /= 2 : N = (s + d < 360 ? N + 360 : N - 360) / 2;var F = 1 - .17 * Math.cos(e * (N - 30)) + .24 * Math.cos(2 * e * N) + .32 * Math.cos(e * (3 * N + 6)) - .2 * Math.cos(e * (4 * N - 63)),L = n - o,I = x - v,P = 2 * Math.sin(e * g / 2) * Math.pow(v * x, .5),j = 1 + .015 * Math.pow(i - 50, 2) / Math.pow(20 + Math.pow(i - 50, 2), .5),k = 1 + .045 * z,q = 1 + .015 * z * F,A = 30 * Math.exp(-1 * Math.pow((N - 275) / 25, 2)),B = -2 * Math.pow(l / (l + Math.pow(25, 7)), .5) * Math.sin(2 * e * A);return Math.pow(Math.pow(L / 1 / j, 2) + Math.pow(I / 1 / k, 2) + Math.pow(P / 1 / q, 2) + B * I * P / (1 * k * 1 * q), .5);}(this.toLab(), h.toLab()) / 100;return o(t(n, 3));}, r.object.push([i, "lab"]);};

    }, {}], 13: [function (require, module, exports) {
      var r = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) },t = function (r) {return "string" == typeof r ? r.length > 0 : "number" == typeof r;},a = function (r, t, a) {return void 0 === t && (t = 0), void 0 === a && (a = Math.pow(10, t)), Math.round(a * r) / a + 0;},n = function (r, t, a) {return void 0 === t && (t = 0), void 0 === a && (a = 1), r > a ? a : r > t ? r : t;},u = function (r) {var t = r / 255;return t < .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);},h = function (r) {return 255 * (r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r);},o = 96.422,e = 100,c = 82.521,i = function (r) {var t,a,u = { x: .9555766 * (t = r).x + -.0230393 * t.y + .0631636 * t.z, y: -.0282895 * t.x + 1.0099416 * t.y + .0210077 * t.z, z: .0122982 * t.x + -.020483 * t.y + 1.3299098 * t.z };return a = { r: h(.032404542 * u.x - .015371385 * u.y - .004985314 * u.z), g: h(-.00969266 * u.x + .018760108 * u.y + 41556e-8 * u.z), b: h(556434e-9 * u.x - .002040259 * u.y + .010572252 * u.z), a: r.a }, { r: n(a.r, 0, 255), g: n(a.g, 0, 255), b: n(a.b, 0, 255), a: n(a.a) };},l = function (r) {var t = u(r.r),a = u(r.g),h = u(r.b);return function (r) {return { x: n(r.x, 0, o), y: n(r.y, 0, e), z: n(r.z, 0, c), a: n(r.a) };}(function (r) {return { x: 1.0478112 * r.x + .0228866 * r.y + -.050127 * r.z, y: .0295424 * r.x + .9904844 * r.y + -.0170491 * r.z, z: -.0092345 * r.x + .0150436 * r.y + .7521316 * r.z, a: r.a };}({ x: 100 * (.4124564 * t + .3575761 * a + .1804375 * h), y: 100 * (.2126729 * t + .7151522 * a + .072175 * h), z: 100 * (.0193339 * t + .119192 * a + .9503041 * h), a: r.a }));},b = 216 / 24389,d = 24389 / 27,f = function (r) {return { l: n(r.l, 0, 100), c: r.c, h: (t = r.h, (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360), a: r.a };var t;},p = function (r) {return { l: a(r.l, 2), c: a(r.c, 2), h: a(r.h, 2), a: a(r.a, 3) };},v = function (r) {var a = r.l,n = r.c,u = r.h,h = r.a,o = void 0 === h ? 1 : h;if (!t(a) || !t(n) || !t(u)) return null;var e = f({ l: Number(a), c: Number(n), h: Number(u), a: Number(o) });return M(e);},y = function (r) {var t = function (r) {var t = l(r),a = t.x / o,n = t.y / e,u = t.z / c;return a = a > b ? Math.cbrt(a) : (d * a + 16) / 116, { l: 116 * (n = n > b ? Math.cbrt(n) : (d * n + 16) / 116) - 16, a: 500 * (a - n), b: 200 * (n - (u = u > b ? Math.cbrt(u) : (d * u + 16) / 116)), alpha: t.a };}(r),n = a(t.a, 3),u = a(t.b, 3),h = Math.atan2(u, n) / Math.PI * 180;return { l: t.l, c: Math.sqrt(n * n + u * u), h: h < 0 ? h + 360 : h, a: t.alpha };},M = function (r) {return t = { l: r.l, a: r.c * Math.cos(r.h * Math.PI / 180), b: r.c * Math.sin(r.h * Math.PI / 180), alpha: r.a }, n = t.a / 500 + (a = (t.l + 16) / 116), u = a - t.b / 200, i({ x: (Math.pow(n, 3) > b ? Math.pow(n, 3) : (116 * n - 16) / d) * o, y: (t.l > 8 ? Math.pow((t.l + 16) / 116, 3) : t.l / d) * e, z: (Math.pow(u, 3) > b ? Math.pow(u, 3) : (116 * u - 16) / d) * c, a: t.alpha });var t, a, n, u;},x = /^lch\(\s*([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,s = function (t) {var a = x.exec(t);if (!a) return null;var n,u,h = f({ l: Number(a[1]), c: Number(a[2]), h: (n = a[3], u = a[4], void 0 === u && (u = "deg"), Number(n) * (r[u] || 1)), a: void 0 === a[5] ? 1 : Number(a[5]) / (a[6] ? 100 : 1) });return M(h);};module.exports = function (r, t) {r.prototype.toLch = function () {return p(y(this.rgba));}, r.prototype.toLchString = function () {return r = p(y(this.rgba)), t = r.l, a = r.c, n = r.h, (u = r.a) < 1 ? "lch(" + t + "% " + a + " " + n + " / " + u + ")" : "lch(" + t + "% " + a + " " + n + ")";var r, t, a, n, u;}, t.string.push([s, "lch"]), t.object.push([v, "lch"]);};

    }, {}], 14: [function (require, module, exports) {
      module.exports = function (e, f) {var a = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" },r = {};for (var d in a) r[a[d]] = d;var l = {};e.prototype.toName = function (f) {if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";var d,i,o = r[this.toHex()];if (o) return o;if (null == f ? void 0 : f.closest) {var n = this.toRgb(),t = 1 / 0,b = "black";if (!l.length) for (var c in a) l[c] = new e(a[c]).toRgb();for (var g in a) {var u = (d = n, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));u < t && (t = u, b = g);}return b;}};f.string.push([function (f) {var r = f.toLowerCase(),d = "transparent" === r ? "#0000" : a[r];return d ? new e(d).toRgb() : null;}, "name"]);};

    }, {}], 15: [function (require, module, exports) {
      /*! https://mths.be/cssesc v3.0.0 by @mathias */
      'use strict';

      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var merge = function merge(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        for (var key in defaults) {
          // `if (defaults.hasOwnProperty(key) {  }` is not needed here, since
          // only recognized option names are used.
          result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
        }
        return result;
      };

      var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
      var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
      var regexAlwaysEscape = /['"\\]/;
      var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

      // https://mathiasbynens.be/notes/css-escapes#css
      var cssesc = function cssesc(string, options) {
        options = merge(options, cssesc.options);
        if (options.quotes != 'single' && options.quotes != 'double') {
          options.quotes = 'single';
        }
        var quote = options.quotes == 'double' ? '"' : '\'';
        var isIdentifier = options.isIdentifier;

        var firstChar = string.charAt(0);
        var output = '';
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var character = string.charAt(counter++);
          var codePoint = character.charCodeAt();
          var value = void 0;
          // If its not a printable ASCII character
          if (codePoint < 0x20 || codePoint > 0x7E) {
            if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
              // Its a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // next character is low surrogate
                codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
              } else {
                // Its an unmatched surrogate; only append this code unit, in case
                // the next code unit is the high surrogate of a surrogate pair.
                counter--;
              }
            }
            value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
          } else {
            if (options.escapeEverything) {
              if (regexAnySingleEscape.test(character)) {
                value = '\\' + character;
              } else {
                value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
              }
            } else if (/[\t\n\f\r\x0B]/.test(character)) {
              value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
            } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
              value = '\\' + character;
            } else {
              value = character;
            }
          }
          output += value;
        }

        if (isIdentifier) {
          if (/^-[-\d]/.test(output)) {
            output = '\\-' + output.slice(1);
          } else if (/\d/.test(firstChar)) {
            output = '\\3' + firstChar + ' ' + output.slice(1);
          }
        }

        // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
        // since theyre redundant. Note that this is only possible if the escape
        // sequence isnt preceded by an odd number of backslashes.
        output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
          if ($1 && $1.length % 2) {
            // Its not safe to remove the space, so dont.
            return $0;
          }
          // Strip the space.
          return ($1 || '') + $2;
        });

        if (!isIdentifier && options.wrap) {
          return quote + output + quote;
        }
        return output;
      };

      // Expose default options (so they can be overridden globally).
      cssesc.options = {
        'escapeEverything': false,
        'isIdentifier': false,
        'quotes': 'single',
        'wrap': false };


      cssesc.version = '3.0.0';

      module.exports = cssesc;

    }, {}], 16: [function (require, module, exports) {
      'use strict';

      /* globals
      	AggregateError,
      	Atomics,
      	FinalizationRegistry,
      	SharedArrayBuffer,
      	WeakRef,
      */

      var undefined;

      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;

      // eslint-disable-next-line consistent-return
      var getEvalledConstructor = function (expressionSyntax) {
        try {
          // eslint-disable-next-line no-new-func
          return Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
        } catch (e) {}
      };

      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, '');
        } catch (e) {
          $gOPD = null; // this is IE 8, which has a broken gOPD
        }
      }

      var throwTypeError = function () {throw new $TypeError();};
      var ThrowTypeError = $gOPD ?
      function () {
        try {
          // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
          arguments.callee; // IE 8 does not throw here
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() :
      throwTypeError;

      var hasSymbols = require('has-symbols')();

      var getProto = Object.getPrototypeOf || function (x) {return x.__proto__;}; // eslint-disable-line no-proto

      var asyncGenFunction = getEvalledConstructor('async function* () {}');
      var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined;
      var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined;

      var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

      var INTRINSICS = {
        '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
        '%Array%': Array,
        '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
        '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
        '%AsyncFromSyncIteratorPrototype%': undefined,
        '%AsyncFunction%': getEvalledConstructor('async function () {}'),
        '%AsyncGenerator%': asyncGenFunctionPrototype,
        '%AsyncGeneratorFunction%': asyncGenFunction,
        '%AsyncIteratorPrototype%': asyncGenPrototype ? getProto(asyncGenPrototype) : undefined,
        '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
        '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
        '%Boolean%': Boolean,
        '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
        '%Date%': Date,
        '%decodeURI%': decodeURI,
        '%decodeURIComponent%': decodeURIComponent,
        '%encodeURI%': encodeURI,
        '%encodeURIComponent%': encodeURIComponent,
        '%Error%': Error,
        '%eval%': eval, // eslint-disable-line no-eval
        '%EvalError%': EvalError,
        '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
        '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
        '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
        '%Function%': $Function,
        '%GeneratorFunction%': getEvalledConstructor('function* () {}'),
        '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
        '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
        '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
        '%isFinite%': isFinite,
        '%isNaN%': isNaN,
        '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
        '%JSON%': typeof JSON === 'object' ? JSON : undefined,
        '%Map%': typeof Map === 'undefined' ? undefined : Map,
        '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
        '%Math%': Math,
        '%Number%': Number,
        '%Object%': Object,
        '%parseFloat%': parseFloat,
        '%parseInt%': parseInt,
        '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
        '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
        '%RangeError%': RangeError,
        '%ReferenceError%': ReferenceError,
        '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
        '%RegExp%': RegExp,
        '%Set%': typeof Set === 'undefined' ? undefined : Set,
        '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
        '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
        '%String%': String,
        '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
        '%Symbol%': hasSymbols ? Symbol : undefined,
        '%SyntaxError%': $SyntaxError,
        '%ThrowTypeError%': ThrowTypeError,
        '%TypedArray%': TypedArray,
        '%TypeError%': $TypeError,
        '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
        '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
        '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
        '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
        '%URIError%': URIError,
        '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
        '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
        '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet };


      var LEGACY_ALIASES = {
        '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
        '%ArrayPrototype%': ['Array', 'prototype'],
        '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
        '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
        '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
        '%ArrayProto_values%': ['Array', 'prototype', 'values'],
        '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
        '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
        '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
        '%BooleanPrototype%': ['Boolean', 'prototype'],
        '%DataViewPrototype%': ['DataView', 'prototype'],
        '%DatePrototype%': ['Date', 'prototype'],
        '%ErrorPrototype%': ['Error', 'prototype'],
        '%EvalErrorPrototype%': ['EvalError', 'prototype'],
        '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
        '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
        '%FunctionPrototype%': ['Function', 'prototype'],
        '%Generator%': ['GeneratorFunction', 'prototype'],
        '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
        '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
        '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
        '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
        '%JSONParse%': ['JSON', 'parse'],
        '%JSONStringify%': ['JSON', 'stringify'],
        '%MapPrototype%': ['Map', 'prototype'],
        '%NumberPrototype%': ['Number', 'prototype'],
        '%ObjectPrototype%': ['Object', 'prototype'],
        '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
        '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
        '%PromisePrototype%': ['Promise', 'prototype'],
        '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
        '%Promise_all%': ['Promise', 'all'],
        '%Promise_reject%': ['Promise', 'reject'],
        '%Promise_resolve%': ['Promise', 'resolve'],
        '%RangeErrorPrototype%': ['RangeError', 'prototype'],
        '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
        '%RegExpPrototype%': ['RegExp', 'prototype'],
        '%SetPrototype%': ['Set', 'prototype'],
        '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
        '%StringPrototype%': ['String', 'prototype'],
        '%SymbolPrototype%': ['Symbol', 'prototype'],
        '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
        '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
        '%TypeErrorPrototype%': ['TypeError', 'prototype'],
        '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
        '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
        '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
        '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
        '%URIErrorPrototype%': ['URIError', 'prototype'],
        '%WeakMapPrototype%': ['WeakMap', 'prototype'],
        '%WeakSetPrototype%': ['WeakSet', 'prototype'] };


      var bind = require('function-bind');
      var hasOwn = require('has');
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);

      /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
      var stringToPath = function stringToPath(string) {
        var result = [];
        $replace(string, rePropName, function (match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
        });
        return result;
      };
      /* end adaptation */

      var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = '%' + alias[0] + '%';
        }

        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
          }

          return {
            alias: alias,
            name: intrinsicName,
            value: value };

        }

        throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
      };

      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== 'string' || name.length === 0) {
          throw new $TypeError('intrinsic name must be a non-empty string');
        }
        if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }

        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

        var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;

        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }

        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
          }

          intrinsicBaseName += '.' + part;
          intrinsicRealName = '%' + intrinsicBaseName + '%';

          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;

              if (!allowMissing && !(part in value)) {
                throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
              }
              // By convention, when a data property is converted to an accessor
              // property to emulate a data property that does not suffer from
              // the override mistake, that accessor's getter is marked with
              // an `originalValue` property. Here, when we detect this, we
              // uphold the illusion by pretending to see that original data
              // property, i.e., returning the value rather than the getter
              // itself.
              if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }

            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };

    }, { "function-bind": 22, "has": 26, "has-symbols": 24 }], 17: [function (require, module, exports) {
      'use strict';

      var GetIntrinsic = require('../GetIntrinsic');

      var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
      if ($gOPD) {
        try {
          $gOPD([], 'length');
        } catch (e) {
          // IE 8 has a broken gOPD
          $gOPD = null;
        }
      }

      module.exports = $gOPD;

    }, { "../GetIntrinsic": 16 }], 18: [function (require, module, exports) {
      'use strict';
      const cloneRegexp = require('clone-regexp');

      module.exports = (regexp, string) => {
        let match;
        const matches = [];
        const clonedRegexp = cloneRegexp(regexp, { lastIndex: 0 });
        const isGlobal = clonedRegexp.global;

        // eslint-disable-next-line no-cond-assign
        while (match = clonedRegexp.exec(string)) {
          matches.push({
            match: match[0],
            subMatches: match.slice(1),
            index: match.index });


          if (!isGlobal) {
            break;
          }
        }

        return matches;
      };

    }, { "clone-regexp": 9 }], 19: [function (require, module, exports) {
      "use strict";
      const peq = new Uint32Array(0x10000);
      const myers_32 = (a, b) => {
        const n = a.length;
        const m = b.length;
        const lst = 1 << n - 1;
        let pv = -1;
        let mv = 0;
        let sc = n;
        let i = n;
        while (i--) {
          peq[a.charCodeAt(i)] |= 1 << i;
        }
        for (i = 0; i < m; i++) {
          let eq = peq[b.charCodeAt(i)];
          const xv = eq | mv;
          eq |= (eq & pv) + pv ^ pv;
          mv |= ~(eq | pv);
          pv &= eq;
          if (mv & lst) {
            sc++;
          }
          if (pv & lst) {
            sc--;
          }
          mv = mv << 1 | 1;
          pv = pv << 1 | ~(xv | mv);
          mv &= xv;
        }
        i = n;
        while (i--) {
          peq[a.charCodeAt(i)] = 0;
        }
        return sc;
      };

      const myers_x = (a, b) => {
        const n = a.length;
        const m = b.length;
        const mhc = [];
        const phc = [];
        const hsize = Math.ceil(n / 32);
        const vsize = Math.ceil(m / 32);
        let score = m;
        for (let i = 0; i < hsize; i++) {
          phc[i] = -1;
          mhc[i] = 0;
        }
        let j = 0;
        for (; j < vsize - 1; j++) {
          let mv = 0;
          let pv = -1;
          const start = j * 32;
          const end = Math.min(32, m) + start;
          for (let k = start; k < end; k++) {
            peq[b.charCodeAt(k)] |= 1 << k;
          }
          score = m;
          for (let i = 0; i < n; i++) {
            const eq = peq[a.charCodeAt(i)];
            const pb = phc[i / 32 | 0] >>> i & 1;
            const mb = mhc[i / 32 | 0] >>> i & 1;
            const xv = eq | mv;
            const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
            let ph = mv | ~(xh | pv);
            let mh = pv & xh;
            if (ph >>> 31 ^ pb) {
              phc[i / 32 | 0] ^= 1 << i;
            }
            if (mh >>> 31 ^ mb) {
              mhc[i / 32 | 0] ^= 1 << i;
            }
            ph = ph << 1 | pb;
            mh = mh << 1 | mb;
            pv = mh | ~(xv | ph);
            mv = ph & xv;
          }
          for (let k = start; k < end; k++) {
            peq[b.charCodeAt(k)] = 0;
          }
        }
        let mv = 0;
        let pv = -1;
        const start = j * 32;
        const end = Math.min(32, m - start) + start;
        for (let k = start; k < end; k++) {
          peq[b.charCodeAt(k)] |= 1 << k;
        }
        score = m;
        for (let i = 0; i < n; i++) {
          const eq = peq[a.charCodeAt(i)];
          const pb = phc[i / 32 | 0] >>> i & 1;
          const mb = mhc[i / 32 | 0] >>> i & 1;
          const xv = eq | mv;
          const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
          let ph = mv | ~(xh | pv);
          let mh = pv & xh;
          score += ph >>> m - 1 & 1;
          score -= mh >>> m - 1 & 1;
          if (ph >>> 31 ^ pb) {
            phc[i / 32 | 0] ^= 1 << i;
          }
          if (mh >>> 31 ^ mb) {
            mhc[i / 32 | 0] ^= 1 << i;
          }
          ph = ph << 1 | pb;
          mh = mh << 1 | mb;
          pv = mh | ~(xv | ph);
          mv = ph & xv;
        }
        for (let k = start; k < end; k++) {
          peq[b.charCodeAt(k)] = 0;
        }
        return score;
      };

      const distance = (a, b) => {
        if (a.length > b.length) {
          const tmp = b;
          b = a;
          a = tmp;
        }
        if (a.length === 0) {
          return b.length;
        }
        if (a.length <= 32) {
          return myers_32(a, b);
        }
        return myers_x(a, b);
      };

      const closest = (str, arr) => {
        let min_distance = Infinity;
        let min_index = 0;
        for (let i = 0; i < arr.length; i++) {
          const dist = distance(str, arr[i]);
          if (dist < min_distance) {
            min_distance = dist;
            min_index = i;
          }
        }
        return arr[min_index];
      };

      module.exports = {
        closest, distance };


    }, {}], 20: [function (require, module, exports) {

      var hasOwn = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;

      module.exports = function forEach(obj, fn, ctx) {
        if (toString.call(fn) !== '[object Function]') {
          throw new TypeError('iterator must be a function');
        }
        var l = obj.length;
        if (l === +l) {
          for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
          }
        } else {
          for (var k in obj) {
            if (hasOwn.call(obj, k)) {
              fn.call(ctx, obj[k], k, obj);
            }
          }
        }
      };


    }, {}], 21: [function (require, module, exports) {
      'use strict';

      /* eslint no-invalid-this: 1 */

      var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = '[object Function]';

      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);

        var bound;
        var binder = function () {
          if (this instanceof bound) {
            var result = target.apply(
            this,
            args.concat(slice.call(arguments)));

            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
            that,
            args.concat(slice.call(arguments)));

          }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push('$' + i);
        }

        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }

        return bound;
      };

    }, {}], 22: [function (require, module, exports) {
      'use strict';

      var implementation = require('./implementation');

      module.exports = Function.prototype.bind || implementation;

    }, { "./implementation": 21 }], 23: [function (require, module, exports) {
      'use strict';

      /* globals
      	AggregateError,
      	Atomics,
      	FinalizationRegistry,
      	SharedArrayBuffer,
      	WeakRef,
      */

      var undefined;

      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;

      // eslint-disable-next-line consistent-return
      var getEvalledConstructor = function (expressionSyntax) {
        try {
          // eslint-disable-next-line no-new-func
          return Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
        } catch (e) {}
      };

      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, '');
        } catch (e) {
          $gOPD = null; // this is IE 8, which has a broken gOPD
        }
      }

      var throwTypeError = function () {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ?
      function () {
        try {
          // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
          arguments.callee; // IE 8 does not throw here
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() :
      throwTypeError;

      var hasSymbols = require('has-symbols')();

      var getProto = Object.getPrototypeOf || function (x) {return x.__proto__;}; // eslint-disable-line no-proto

      var asyncGenFunction = getEvalledConstructor('async function* () {}');
      var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined;
      var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined;

      var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

      var INTRINSICS = {
        '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
        '%Array%': Array,
        '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
        '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
        '%AsyncFromSyncIteratorPrototype%': undefined,
        '%AsyncFunction%': getEvalledConstructor('async function () {}'),
        '%AsyncGenerator%': asyncGenFunctionPrototype,
        '%AsyncGeneratorFunction%': asyncGenFunction,
        '%AsyncIteratorPrototype%': asyncGenPrototype ? getProto(asyncGenPrototype) : undefined,
        '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
        '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
        '%Boolean%': Boolean,
        '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
        '%Date%': Date,
        '%decodeURI%': decodeURI,
        '%decodeURIComponent%': decodeURIComponent,
        '%encodeURI%': encodeURI,
        '%encodeURIComponent%': encodeURIComponent,
        '%Error%': Error,
        '%eval%': eval, // eslint-disable-line no-eval
        '%EvalError%': EvalError,
        '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
        '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
        '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
        '%Function%': $Function,
        '%GeneratorFunction%': getEvalledConstructor('function* () {}'),
        '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
        '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
        '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
        '%isFinite%': isFinite,
        '%isNaN%': isNaN,
        '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
        '%JSON%': typeof JSON === 'object' ? JSON : undefined,
        '%Map%': typeof Map === 'undefined' ? undefined : Map,
        '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
        '%Math%': Math,
        '%Number%': Number,
        '%Object%': Object,
        '%parseFloat%': parseFloat,
        '%parseInt%': parseInt,
        '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
        '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
        '%RangeError%': RangeError,
        '%ReferenceError%': ReferenceError,
        '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
        '%RegExp%': RegExp,
        '%Set%': typeof Set === 'undefined' ? undefined : Set,
        '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
        '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
        '%String%': String,
        '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
        '%Symbol%': hasSymbols ? Symbol : undefined,
        '%SyntaxError%': $SyntaxError,
        '%ThrowTypeError%': ThrowTypeError,
        '%TypedArray%': TypedArray,
        '%TypeError%': $TypeError,
        '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
        '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
        '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
        '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
        '%URIError%': URIError,
        '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
        '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
        '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet };


      var LEGACY_ALIASES = {
        '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
        '%ArrayPrototype%': ['Array', 'prototype'],
        '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
        '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
        '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
        '%ArrayProto_values%': ['Array', 'prototype', 'values'],
        '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
        '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
        '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
        '%BooleanPrototype%': ['Boolean', 'prototype'],
        '%DataViewPrototype%': ['DataView', 'prototype'],
        '%DatePrototype%': ['Date', 'prototype'],
        '%ErrorPrototype%': ['Error', 'prototype'],
        '%EvalErrorPrototype%': ['EvalError', 'prototype'],
        '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
        '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
        '%FunctionPrototype%': ['Function', 'prototype'],
        '%Generator%': ['GeneratorFunction', 'prototype'],
        '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
        '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
        '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
        '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
        '%JSONParse%': ['JSON', 'parse'],
        '%JSONStringify%': ['JSON', 'stringify'],
        '%MapPrototype%': ['Map', 'prototype'],
        '%NumberPrototype%': ['Number', 'prototype'],
        '%ObjectPrototype%': ['Object', 'prototype'],
        '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
        '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
        '%PromisePrototype%': ['Promise', 'prototype'],
        '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
        '%Promise_all%': ['Promise', 'all'],
        '%Promise_reject%': ['Promise', 'reject'],
        '%Promise_resolve%': ['Promise', 'resolve'],
        '%RangeErrorPrototype%': ['RangeError', 'prototype'],
        '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
        '%RegExpPrototype%': ['RegExp', 'prototype'],
        '%SetPrototype%': ['Set', 'prototype'],
        '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
        '%StringPrototype%': ['String', 'prototype'],
        '%SymbolPrototype%': ['Symbol', 'prototype'],
        '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
        '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
        '%TypeErrorPrototype%': ['TypeError', 'prototype'],
        '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
        '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
        '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
        '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
        '%URIErrorPrototype%': ['URIError', 'prototype'],
        '%WeakMapPrototype%': ['WeakMap', 'prototype'],
        '%WeakSetPrototype%': ['WeakSet', 'prototype'] };


      var bind = require('function-bind');
      var hasOwn = require('has');
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);

      /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
      var stringToPath = function stringToPath(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === '%' && last !== '%') {
          throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
        } else if (last === '%' && first !== '%') {
          throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
        }
        var result = [];
        $replace(string, rePropName, function (match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
        });
        return result;
      };
      /* end adaptation */

      var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = '%' + alias[0] + '%';
        }

        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
          }

          return {
            alias: alias,
            name: intrinsicName,
            value: value };

        }

        throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
      };

      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== 'string' || name.length === 0) {
          throw new $TypeError('intrinsic name must be a non-empty string');
        }
        if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }

        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

        var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;

        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }

        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if (
          (
          first === '"' || first === "'" || first === '`' ||
          last === '"' || last === "'" || last === '`') &&

          first !== last)
          {
            throw new $SyntaxError('property names with quotes must have matching quotes');
          }
          if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
          }

          intrinsicBaseName += '.' + part;
          intrinsicRealName = '%' + intrinsicBaseName + '%';

          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
              }
              return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;

              // By convention, when a data property is converted to an accessor
              // property to emulate a data property that does not suffer from
              // the override mistake, that accessor's getter is marked with
              // an `originalValue` property. Here, when we detect this, we
              // uphold the illusion by pretending to see that original data
              // property, i.e., returning the value rather than the getter
              // itself.
              if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }

            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };

    }, { "function-bind": 22, "has": 26, "has-symbols": 24 }], 24: [function (require, module, exports) {
      (function (global) {(function () {
          'use strict';

          var origSymbol = global.Symbol;
          var hasSymbolSham = require('./shams');

          module.exports = function hasNativeSymbols() {
            if (typeof origSymbol !== 'function') {return false;}
            if (typeof Symbol !== 'function') {return false;}
            if (typeof origSymbol('foo') !== 'symbol') {return false;}
            if (typeof Symbol('bar') !== 'symbol') {return false;}

            return hasSymbolSham();
          };

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./shams": 25 }], 25: [function (require, module, exports) {
      'use strict';

      /* eslint complexity: [2, 18], max-statements: [2, 33] */
      module.exports = function hasSymbols() {
        if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {return false;}
        if (typeof Symbol.iterator === 'symbol') {return true;}

        var obj = {};
        var sym = Symbol('test');
        var symObj = Object(sym);
        if (typeof sym === 'string') {return false;}

        if (Object.prototype.toString.call(sym) !== '[object Symbol]') {return false;}
        if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {return false;}

        // temp disabled per https://github.com/ljharb/object.assign/issues/17
        // if (sym instanceof Symbol) { return false; }
        // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
        // if (!(symObj instanceof Symbol)) { return false; }

        // if (typeof Symbol.prototype.toString !== 'function') { return false; }
        // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {return false;} // eslint-disable-line no-restricted-syntax
        if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {return false;}

        if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {return false;}

        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {return false;}

        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {return false;}

        if (typeof Object.getOwnPropertyDescriptor === 'function') {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {return false;}
        }

        return true;
      };

    }, {}], 26: [function (require, module, exports) {
      'use strict';

      var bind = require('function-bind');

      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

    }, { "function-bind": 22 }], 27: [function (require, module, exports) {
      module.exports = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "math",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "slot",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"];


    }, {}], 28: [function (require, module, exports) {
      'use strict';
      module.exports = require('./html-tags.json');

    }, { "./html-tags.json": 27 }], 29: [function (require, module, exports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];

        i += d;

        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
      };

    }, {}], 30: [function (require, module, exports) {
      (function (process) {(function () {
          // A simple implementation of make-array
          function makeArray(subject) {
            return Array.isArray(subject) ?
            subject :
            [subject];
          }

          const EMPTY = '';
          const SPACE = ' ';
          const ESCAPE = '\\';
          const REGEX_TEST_BLANK_LINE = /^\s+$/;
          const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
          const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
          const REGEX_SPLITALL_CRLF = /\r?\n/g;
          // /foo,
          // ./foo,
          // ../foo,
          // .
          // ..
          const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;

          const SLASH = '/';
          const KEY_IGNORE = typeof Symbol !== 'undefined' ?
          Symbol.for('node-ignore')
          /* istanbul ignore next */ :
          'node-ignore';

          const define = (object, key, value) =>
          Object.defineProperty(object, key, { value });

          const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

          const RETURN_FALSE = () => false;

          // Sanitize the range of a regular expression
          // The cases are complicated, see test cases for details
          const sanitizeRange = range => range.replace(
          REGEX_REGEXP_RANGE,
          (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ?
          match
          // Invalid range (out of order) which is ok for gitignore rules but
          //   fatal for JavaScript regular expression, so eliminate it.
          : EMPTY);


          // See fixtures #59
          const cleanRangeBackSlash = slashes => {
            const { length } = slashes;
            return slashes.slice(0, length - length % 2);
          };

          // > If the pattern ends with a slash,
          // > it is removed for the purpose of the following description,
          // > but it would only find a match with a directory.
          // > In other words, foo/ will match a directory foo and paths underneath it,
          // > but will not match a regular file or a symbolic link foo
          // >  (this is consistent with the way how pathspec works in general in Git).
          // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
          // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
          //      you could use option `mark: true` with `glob`

          // '`foo/`' should not continue with the '`..`'
          const REPLACERS = [

          // > Trailing spaces are ignored unless they are quoted with backslash ("\")
          [
          // (a\ ) -> (a )
          // (a  ) -> (a)
          // (a \ ) -> (a  )
          /\\?\s+$/,
          match => match.indexOf('\\') === 0 ?
          SPACE :
          EMPTY],


          // replace (\ ) with ' '
          [
          /\\\s/g,
          () => SPACE],


          // Escape metacharacters
          // which is written down by users but means special for regular expressions.

          // > There are 12 characters with special meanings:
          // > - the backslash \,
          // > - the caret ^,
          // > - the dollar sign $,
          // > - the period or dot .,
          // > - the vertical bar or pipe symbol |,
          // > - the question mark ?,
          // > - the asterisk or star *,
          // > - the plus sign +,
          // > - the opening parenthesis (,
          // > - the closing parenthesis ),
          // > - and the opening square bracket [,
          // > - the opening curly brace {,
          // > These special characters are often called "metacharacters".
          [
          /[\\$.|*+(){^]/g,
          match => `\\${match}`],


          [
          // > a question mark (?) matches a single character
          /(?!\\)\?/g,
          () => '[^/]'],


          // leading slash
          [

          // > A leading slash matches the beginning of the pathname.
          // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
          // A leading slash matches the beginning of the pathname
          /^\//,
          () => '^'],


          // replace special metacharacter slash after the leading slash
          [
          /\//g,
          () => '\\/'],


          [
          // > A leading "**" followed by a slash means match in all directories.
          // > For example, "**/foo" matches file or directory "foo" anywhere,
          // > the same as pattern "foo".
          // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
          // >   under directory "foo".
          // Notice that the '*'s have been replaced as '\\*'
          /^\^*\\\*\\\*\\\//,

          // '**/foo' <-> 'foo'
          () => '^(?:.*\\/)?'],


          // starting
          [
          // there will be no leading '/'
          //   (which has been replaced by section "leading slash")
          // If starts with '**', adding a '^' to the regular expression also works
          /^(?=[^^])/,
          function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this)
            // > Prior to 2.22.1
            // > If the pattern does not contain a slash /,
            // >   Git treats it as a shell glob pattern
            // Actually, if there is only a trailing slash,
            //   git also treats it as a shell glob pattern

            // After 2.22.1 (compatible but clearer)
            // > If there is a separator at the beginning or middle (or both)
            // > of the pattern, then the pattern is relative to the directory
            // > level of the particular .gitignore file itself.
            // > Otherwise the pattern may also match at any level below
            // > the .gitignore level.
            ? '(?:^|\\/)'

            // > Otherwise, Git treats the pattern as a shell glob suitable for
            // >   consumption by fnmatch(3)
            : '^';
          }],


          // two globstars
          [
          // Use lookahead assertions so that we could match more than one `'/**'`
          /\\\/\\\*\\\*(?=\\\/|$)/g,

          // Zero, one or several directories
          // should not use '*', or it will be replaced by the next replacer

          // Check if it is not the last `'/**'`
          (_, index, str) => index + 6 < str.length

          // case: /**/
          // > A slash followed by two consecutive asterisks then a slash matches
          // >   zero or more directories.
          // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
          // '/**/'
          ? '(?:\\/[^\\/]+)*'

          // case: /**
          // > A trailing `"/**"` matches everything inside.

          // #21: everything inside but it should not include the current folder
          : '\\/.+'],


          // intermediate wildcards
          [
          // Never replace escaped '*'
          // ignore rule '\*' will match the path '*'

          // 'abc.*/' -> go
          // 'abc.*'  -> skip this rule
          /(^|[^\\]+)\\\*(?=.+)/g,

          // '*.js' matches '.js'
          // '*.js' doesn't match 'abc'
          (_, p1) => `${p1}[^\\/]*`],


          [
          // unescape, revert step 3 except for back slash
          // For example, if a user escape a '\\*',
          // after step 3, the result will be '\\\\\\*'
          /\\\\\\(?=[$.|*+(){^])/g,
          () => ESCAPE],


          [
          // '\\\\' -> '\\'
          /\\\\/g,
          () => ESCAPE],


          [
          // > The range notation, e.g. [a-zA-Z],
          // > can be used to match one of the characters in a range.

          // `\` is escaped by step 3
          /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
          (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
          // '\\[bar]' -> '\\\\[bar\\]'
          ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` :
          close === ']' ?
          endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]' :
          '[]'],


          // ending
          [
          // 'js' will not match 'js.'
          // 'ab' will not match 'abc'
          /(?:[^*])$/,

          // WTF!
          // https://git-scm.com/docs/gitignore
          // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
          // which re-fixes #24, #38

          // > If there is a separator at the end of the pattern then the pattern
          // > will only match directories, otherwise the pattern can match both
          // > files and directories.

          // 'js*' will not match 'a.js'
          // 'js/' will not match 'a.js'
          // 'js' will match 'a.js' and 'a.js/'
          match => /\/$/.test(match)
          // foo/ will not match 'foo'
          ? `${match}$`
          // foo matches 'foo' and 'foo/'
          : `${match}(?=$|\\/$)`],


          // trailing wildcard
          [
          /(\^|\\\/)?\\\*$/,
          (_, p1) => {
            const prefix = p1
            // '\^':
            // '/*' does not match EMPTY
            // '/*' does not match everything

            // '\\\/':
            // 'abc/*' does not match 'abc/'
            ? `${p1}[^/]+`

            // 'a*' matches 'a'
            // 'a*' matches 'aa'
            : '[^/]*';

            return `${prefix}(?=$|\\/$)`;
          }]];



          // A simple cache, because an ignore rule only has only one certain meaning
          const regexCache = Object.create(null);

          // @param {pattern}
          const makeRegex = (pattern, ignoreCase) => {
            let source = regexCache[pattern];

            if (!source) {
              source = REPLACERS.reduce(
              (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
              pattern);

              regexCache[pattern] = source;
            }

            return ignoreCase ?
            new RegExp(source, 'i') :
            new RegExp(source);
          };

          const isString = subject => typeof subject === 'string';

          // > A blank line matches no files, so it can serve as a separator for readability.
          const checkPattern = pattern => pattern &&
          isString(pattern) &&
          !REGEX_TEST_BLANK_LINE.test(pattern)

          // > A line starting with # serves as a comment.
          && pattern.indexOf('#') !== 0;

          const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

          class IgnoreRule {
            constructor(
            origin,
            pattern,
            negative,
            regex)
            {
              this.origin = origin;
              this.pattern = pattern;
              this.negative = negative;
              this.regex = regex;
            }}


          const createRule = (pattern, ignoreCase) => {
            const origin = pattern;
            let negative = false;

            // > An optional prefix "!" which negates the pattern;
            if (pattern.indexOf('!') === 0) {
              negative = true;
              pattern = pattern.substr(1);
            }

            pattern = pattern
            // > Put a backslash ("\") in front of the first "!" for patterns that
            // >   begin with a literal "!", for example, `"\!important!.txt"`.
            .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
            // > Put a backslash ("\") in front of the first hash for patterns that
            // >   begin with a hash.
            .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');

            const regex = makeRegex(pattern, ignoreCase);

            return new IgnoreRule(
            origin,
            pattern,
            negative,
            regex);

          };

          const throwError = (message, Ctor) => {
            throw new Ctor(message);
          };

          const checkPath = (path, originalPath, doThrow) => {
            if (!isString(path)) {
              return doThrow(
              `path must be a string, but got \`${originalPath}\``,
              TypeError);

            }

            // We don't know if we should ignore EMPTY, so throw
            if (!path) {
              return doThrow(`path must not be empty`, TypeError);
            }

            // Check if it is a relative path
            if (checkPath.isNotRelative(path)) {
              const r = '`path.relative()`d';
              return doThrow(
              `path should be a ${r} string, but got "${originalPath}"`,
              RangeError);

            }

            return true;
          };

          const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

          checkPath.isNotRelative = isNotRelative;
          checkPath.convert = p => p;

          class Ignore {
            constructor({
              ignorecase = true,
              ignoreCase = ignorecase,
              allowRelativePaths = false } =
            {}) {
              define(this, KEY_IGNORE, true);

              this._rules = [];
              this._ignoreCase = ignoreCase;
              this._allowRelativePaths = allowRelativePaths;
              this._initCache();
            }

            _initCache() {
              this._ignoreCache = Object.create(null);
              this._testCache = Object.create(null);
            }

            _addPattern(pattern) {
              // #32
              if (pattern && pattern[KEY_IGNORE]) {
                this._rules = this._rules.concat(pattern._rules);
                this._added = true;
                return;
              }

              if (checkPattern(pattern)) {
                const rule = createRule(pattern, this._ignoreCase);
                this._added = true;
                this._rules.push(rule);
              }
            }

            // @param {Array<string> | string | Ignore} pattern
            add(pattern) {
              this._added = false;

              makeArray(
              isString(pattern) ?
              splitPattern(pattern) :
              pattern).
              forEach(this._addPattern, this);

              // Some rules have just added to the ignore,
              // making the behavior changed.
              if (this._added) {
                this._initCache();
              }

              return this;
            }

            // legacy
            addPattern(pattern) {
              return this.add(pattern);
            }

            //          |           ignored : unignored
            // negative |   0:0   |   0:1   |   1:0   |   1:1
            // -------- | ------- | ------- | ------- | --------
            //     0    |  TEST   |  TEST   |  SKIP   |    X
            //     1    |  TESTIF |  SKIP   |  TEST   |    X

            // - SKIP: always skip
            // - TEST: always test
            // - TESTIF: only test if checkUnignored
            // - X: that never happen

            // @param {boolean} whether should check if the path is unignored,
            //   setting `checkUnignored` to `false` could reduce additional
            //   path matching.

            // @returns {TestResult} true if a file is ignored
            _testOne(path, checkUnignored) {
              let ignored = false;
              let unignored = false;

              this._rules.forEach(rule => {
                const { negative } = rule;
                if (
                unignored === negative && ignored !== unignored ||
                negative && !ignored && !unignored && !checkUnignored)
                {
                  return;
                }

                const matched = rule.regex.test(path);

                if (matched) {
                  ignored = !negative;
                  unignored = negative;
                }
              });

              return {
                ignored,
                unignored };

            }

            // @returns {TestResult}
            _test(originalPath, cache, checkUnignored, slices) {
              const path = originalPath
              // Supports nullable path
              && checkPath.convert(originalPath);

              checkPath(
              path,
              originalPath,
              this._allowRelativePaths ?
              RETURN_FALSE :
              throwError);


              return this._t(path, cache, checkUnignored, slices);
            }

            _t(path, cache, checkUnignored, slices) {
              if (path in cache) {
                return cache[path];
              }

              if (!slices) {
                // path/to/a.js
                // ['path', 'to', 'a.js']
                slices = path.split(SLASH);
              }

              slices.pop();

              // If the path has no parent directory, just test it
              if (!slices.length) {
                return cache[path] = this._testOne(path, checkUnignored);
              }

              const parent = this._t(
              slices.join(SLASH) + SLASH,
              cache,
              checkUnignored,
              slices);


              // If the path contains a parent directory, check the parent first
              return cache[path] = parent.ignored
              // > It is not possible to re-include a file if a parent directory of
              // >   that file is excluded.
              ? parent :
              this._testOne(path, checkUnignored);
            }

            ignores(path) {
              return this._test(path, this._ignoreCache, false).ignored;
            }

            createFilter() {
              return path => !this.ignores(path);
            }

            filter(paths) {
              return makeArray(paths).filter(this.createFilter());
            }

            // @returns {TestResult}
            test(path) {
              return this._test(path, this._testCache, true);
            }}


          const factory = options => new Ignore(options);

          const isPathValid = (path) =>
          checkPath(path && checkPath.convert(path), path, RETURN_FALSE);

          factory.isPathValid = isPathValid;

          // Fixes typescript
          factory.default = factory;

          module.exports = factory;

          // Windows
          // --------------------------------------------------------------
          /* istanbul ignore if  */
          if (
          // Detect `process` so that it can run in browsers.
          typeof process !== 'undefined' && (

          process.env && process.env.IGNORE_TEST_WIN32 ||
          process.platform === 'win32'))

          {
            /* eslint no-control-regex: "off" */
            const makePosix = str => /^\\\\\?\\/.test(str) ||
            /["<>|\u0000-\u001F]+/u.test(str) ?
            str :
            str.replace(/\\/g, '/');

            checkPath.convert = makePosix;

            // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
            // 'd:\\foo'
            const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
            checkPath.isNotRelative = (path) =>
            REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) ||
            isNotRelative(path);
          }

        }).call(this);}).call(this, require('_process'));
    }, { "_process": 115 }], 31: [function (require, module, exports) {
      'use strict';
      const lazy = (importedModule, importFn, moduleId) =>
      importedModule === undefined ? importFn(moduleId) : importedModule;

      module.exports = importFn => {
        return moduleId => {
          let importedModule;

          const handler = {
            get: (target, property) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.get(importedModule, property);
            },
            apply: (target, thisArgument, argumentsList) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.apply(importedModule, thisArgument, argumentsList);
            },
            construct: (target, argumentsList) => {
              importedModule = lazy(importedModule, importFn, moduleId);
              return Reflect.construct(importedModule, argumentsList);
            } };


          // eslint-disable-next-line prefer-arrow-callback
          return new Proxy(function () {}, handler);
        };
      };

    }, {}], 32: [function (require, module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true } });


          }
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }

    }, {}], 33: [function (require, module, exports) {
      'use strict';

      var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
      var callBound = require('call-bind/callBound');

      var $toString = callBound('Object.prototype.toString');

      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === '[object Arguments]';
      };

      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        $toString(value) !== '[object Array]' &&
        $toString(value.callee) === '[object Function]';
      };

      var supportsStandardArguments = function () {
        return isStandardArguments(arguments);
      }();

      isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

    }, { "call-bind/callBound": 7 }], 34: [function (require, module, exports) {
      'use strict';

      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function () {// eslint-disable-line consistent-return
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function('return function*() {}')();
        } catch (e) {
        }
      };
      var generatorFunc = getGeneratorFunc();
      var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== 'function') {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === '[object GeneratorFunction]';
        }
        return getProto && getProto(fn) === GeneratorFunction;
      };

    }, {}], 35: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, '__esModule', { value: true });

      /*!
       * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */

      function isObject(o) {
        return Object.prototype.toString.call(o) === '[object Object]';
      }

      function isPlainObject(o) {
        var ctor, prot;

        if (isObject(o) === false) return false;

        // If has modified constructor
        ctor = o.constructor;
        if (ctor === undefined) return true;

        // If has modified prototype
        prot = ctor.prototype;
        if (isObject(prot) === false) return false;

        // If constructor does not have an Object-specific method
        if (prot.hasOwnProperty('isPrototypeOf') === false) {
          return false;
        }

        // Most likely a plain Object
        return true;
      }

      exports.isPlainObject = isPlainObject;

    }, {}], 36: [function (require, module, exports) {
      'use strict';

      module.exports = input => Object.prototype.toString.call(input) === '[object RegExp]';

    }, {}], 37: [function (require, module, exports) {
      (function (global) {(function () {
          'use strict';

          var forEach = require('foreach');
          var availableTypedArrays = require('available-typed-arrays');
          var callBound = require('call-bind/callBound');

          var $toString = callBound('Object.prototype.toString');
          var hasSymbols = require('has-symbols')();
          var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

          var typedArrays = availableTypedArrays();

          var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
            for (var i = 0; i < array.length; i += 1) {
              if (array[i] === value) {
                return i;
              }
            }
            return -1;
          };
          var $slice = callBound('String.prototype.slice');
          var toStrTags = {};
          var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
          var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              var arr = new global[typedArray]();
              if (!(Symbol.toStringTag in arr)) {
                throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
              }
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            });
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var anyTrue = false;
            forEach(toStrTags, function (getter, typedArray) {
              if (!anyTrue) {
                try {
                  anyTrue = getter.call(value) === typedArray;
                } catch (e) {/**/}
              }
            });
            return anyTrue;
          };

          module.exports = function isTypedArray(value) {
            if (!value || typeof value !== 'object') {return false;}
            if (!hasToStringTag) {
              var tag = $slice($toString(value), 8, -1);
              return $indexOf(typedArrays, tag) > -1;
            }
            if (!gOPD) {return false;}
            return tryTypedArrays(value);
          };

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "available-typed-arrays": 2, "call-bind/callBound": 7, "es-abstract/helpers/getOwnPropertyDescriptor": 17, "foreach": 20, "has-symbols": 24 }], 38: [function (require, module, exports) {
      module.exports = {
        "properties": [
        "-epub-caption-side",
        "-epub-hyphens",
        "-epub-text-combine",
        "-epub-text-emphasis",
        "-epub-text-emphasis-color",
        "-epub-text-emphasis-style",
        "-epub-text-orientation",
        "-epub-text-transform",
        "-epub-word-break",
        "-epub-writing-mode",
        "-internal-text-autosizing-status",
        "accelerator",
        "accent-color",
        "-wap-accesskey",
        "additive-symbols",
        "align-content",
        "-webkit-align-content",
        "align-items",
        "-webkit-align-items",
        "align-self",
        "-webkit-align-self",
        "alignment-baseline",
        "all",
        "alt",
        "-webkit-alt",
        "animation",
        "animation-delay",
        "-moz-animation-delay",
        "-ms-animation-delay",
        "-webkit-animation-delay",
        "animation-direction",
        "-moz-animation-direction",
        "-ms-animation-direction",
        "-webkit-animation-direction",
        "animation-duration",
        "-moz-animation-duration",
        "-ms-animation-duration",
        "-webkit-animation-duration",
        "animation-fill-mode",
        "-moz-animation-fill-mode",
        "-ms-animation-fill-mode",
        "-webkit-animation-fill-mode",
        "animation-iteration-count",
        "-moz-animation-iteration-count",
        "-ms-animation-iteration-count",
        "-webkit-animation-iteration-count",
        "-moz-animation",
        "-ms-animation",
        "animation-name",
        "-moz-animation-name",
        "-ms-animation-name",
        "-webkit-animation-name",
        "animation-play-state",
        "-moz-animation-play-state",
        "-ms-animation-play-state",
        "-webkit-animation-play-state",
        "animation-timing-function",
        "-moz-animation-timing-function",
        "-ms-animation-timing-function",
        "-webkit-animation-timing-function",
        "-webkit-animation-trigger",
        "-webkit-animation",
        "app-region",
        "-webkit-app-region",
        "appearance",
        "-moz-appearance",
        "-webkit-appearance",
        "ascent-override",
        "aspect-ratio",
        "-webkit-aspect-ratio",
        "audio-level",
        "azimuth",
        "backdrop-filter",
        "-webkit-backdrop-filter",
        "backface-visibility",
        "-moz-backface-visibility",
        "-ms-backface-visibility",
        "-webkit-backface-visibility",
        "background",
        "background-attachment",
        "-webkit-background-attachment",
        "background-blend-mode",
        "background-clip",
        "-moz-background-clip",
        "-webkit-background-clip",
        "background-color",
        "-webkit-background-color",
        "-webkit-background-composite",
        "background-image",
        "-webkit-background-image",
        "-moz-background-inline-policy",
        "background-origin",
        "-moz-background-origin",
        "-webkit-background-origin",
        "background-position",
        "-webkit-background-position",
        "background-position-x",
        "-webkit-background-position-x",
        "background-position-y",
        "-webkit-background-position-y",
        "background-repeat",
        "-webkit-background-repeat",
        "background-repeat-x",
        "background-repeat-y",
        "background-size",
        "-moz-background-size",
        "-webkit-background-size",
        "-webkit-background",
        "baseline-shift",
        "baseline-source",
        "behavior",
        "-moz-binding",
        "block-ellipsis",
        "-ms-block-progression",
        "block-size",
        "block-step",
        "block-step-align",
        "block-step-insert",
        "block-step-round",
        "block-step-size",
        "bookmark-label",
        "bookmark-level",
        "bookmark-state",
        "border",
        "-webkit-border-after-color",
        "-webkit-border-after-style",
        "-webkit-border-after",
        "-webkit-border-after-width",
        "-webkit-border-before-color",
        "-webkit-border-before-style",
        "-webkit-border-before",
        "-webkit-border-before-width",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "-moz-border-bottom-colors",
        "border-bottom-left-radius",
        "-webkit-border-bottom-left-radius",
        "border-bottom-right-radius",
        "-webkit-border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-boundary",
        "border-collapse",
        "border-color",
        "-moz-border-end-color",
        "-webkit-border-end-color",
        "border-end-end-radius",
        "-moz-border-end",
        "border-end-start-radius",
        "-moz-border-end-style",
        "-webkit-border-end-style",
        "-webkit-border-end",
        "-moz-border-end-width",
        "-webkit-border-end-width",
        "-webkit-border-fit",
        "-webkit-border-horizontal-spacing",
        "border-image",
        "-moz-border-image",
        "-o-border-image",
        "border-image-outset",
        "-webkit-border-image-outset",
        "border-image-repeat",
        "-webkit-border-image-repeat",
        "border-image-slice",
        "-webkit-border-image-slice",
        "border-image-source",
        "-webkit-border-image-source",
        "-webkit-border-image",
        "border-image-width",
        "-webkit-border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "-moz-border-left-colors",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "-moz-border-radius-bottomleft",
        "-moz-border-radius-bottomright",
        "-moz-border-radius",
        "-moz-border-radius-topleft",
        "-moz-border-radius-topright",
        "-webkit-border-radius",
        "border-right",
        "border-right-color",
        "-moz-border-right-colors",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "-moz-border-start-color",
        "-webkit-border-start-color",
        "border-start-end-radius",
        "-moz-border-start",
        "border-start-start-radius",
        "-moz-border-start-style",
        "-webkit-border-start-style",
        "-webkit-border-start",
        "-moz-border-start-width",
        "-webkit-border-start-width",
        "border-style",
        "border-top",
        "border-top-color",
        "-moz-border-top-colors",
        "border-top-left-radius",
        "-webkit-border-top-left-radius",
        "border-top-right-radius",
        "-webkit-border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "-webkit-border-vertical-spacing",
        "border-width",
        "bottom",
        "-moz-box-align",
        "-webkit-box-align",
        "box-decoration-break",
        "-webkit-box-decoration-break",
        "-moz-box-direction",
        "-webkit-box-direction",
        "-webkit-box-flex-group",
        "-moz-box-flex",
        "-webkit-box-flex",
        "-webkit-box-lines",
        "-moz-box-ordinal-group",
        "-webkit-box-ordinal-group",
        "-moz-box-orient",
        "-webkit-box-orient",
        "-moz-box-pack",
        "-webkit-box-pack",
        "-webkit-box-reflect",
        "box-shadow",
        "-moz-box-shadow",
        "-webkit-box-shadow",
        "box-sizing",
        "-moz-box-sizing",
        "-webkit-box-sizing",
        "box-snap",
        "break-after",
        "break-before",
        "break-inside",
        "buffered-rendering",
        "caption-side",
        "caret",
        "caret-color",
        "caret-shape",
        "chains",
        "clear",
        "clip",
        "clip-path",
        "-webkit-clip-path",
        "clip-rule",
        "color",
        "color-adjust",
        "-webkit-color-correction",
        "-apple-color-filter",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "color-scheme",
        "-webkit-column-axis",
        "-webkit-column-break-after",
        "-webkit-column-break-before",
        "-webkit-column-break-inside",
        "column-count",
        "-moz-column-count",
        "-webkit-column-count",
        "column-fill",
        "-moz-column-fill",
        "-webkit-column-fill",
        "column-gap",
        "-moz-column-gap",
        "-webkit-column-gap",
        "column-progression",
        "-webkit-column-progression",
        "column-rule",
        "column-rule-color",
        "-moz-column-rule-color",
        "-webkit-column-rule-color",
        "-moz-column-rule",
        "column-rule-style",
        "-moz-column-rule-style",
        "-webkit-column-rule-style",
        "-webkit-column-rule",
        "column-rule-width",
        "-moz-column-rule-width",
        "-webkit-column-rule-width",
        "column-span",
        "-moz-column-span",
        "-webkit-column-span",
        "column-width",
        "-moz-column-width",
        "-webkit-column-width",
        "columns",
        "-moz-columns",
        "-webkit-columns",
        "-webkit-composition-fill-color",
        "-webkit-composition-frame-color",
        "contain",
        "contain-intrinsic-block-size",
        "contain-intrinsic-height",
        "contain-intrinsic-inline-size",
        "contain-intrinsic-size",
        "contain-intrinsic-width",
        "content",
        "content-visibility",
        "-ms-content-zoom-chaining",
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min",
        "-ms-content-zoom-limit",
        "-ms-content-zoom-snap",
        "-ms-content-zoom-snap-points",
        "-ms-content-zoom-snap-type",
        "-ms-content-zooming",
        "continue",
        "counter-increment",
        "counter-reset",
        "counter-set",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "-webkit-cursor-visibility",
        "cx",
        "cy",
        "d",
        "-apple-dashboard-region",
        "-webkit-dashboard-region",
        "descent-override",
        "direction",
        "display",
        "display-align",
        "dominant-baseline",
        "elevation",
        "empty-cells",
        "enable-background",
        "epub-caption-side",
        "epub-hyphens",
        "epub-text-combine",
        "epub-text-emphasis",
        "epub-text-emphasis-color",
        "epub-text-emphasis-style",
        "epub-text-orientation",
        "epub-text-transform",
        "epub-word-break",
        "epub-writing-mode",
        "fallback",
        "fill",
        "fill-break",
        "fill-color",
        "fill-image",
        "fill-opacity",
        "fill-origin",
        "fill-position",
        "fill-repeat",
        "fill-rule",
        "fill-size",
        "filter",
        "-ms-filter",
        "-webkit-filter",
        "flex",
        "-ms-flex-align",
        "-webkit-flex-align",
        "flex-basis",
        "-webkit-flex-basis",
        "flex-direction",
        "-ms-flex-direction",
        "-webkit-flex-direction",
        "flex-flow",
        "-ms-flex-flow",
        "-webkit-flex-flow",
        "flex-grow",
        "-webkit-flex-grow",
        "-ms-flex-item-align",
        "-webkit-flex-item-align",
        "-ms-flex-line-pack",
        "-webkit-flex-line-pack",
        "-ms-flex",
        "-ms-flex-negative",
        "-ms-flex-order",
        "-webkit-flex-order",
        "-ms-flex-pack",
        "-webkit-flex-pack",
        "-ms-flex-positive",
        "-ms-flex-preferred-size",
        "flex-shrink",
        "-webkit-flex-shrink",
        "-webkit-flex",
        "flex-wrap",
        "-ms-flex-wrap",
        "-webkit-flex-wrap",
        "float",
        "float-defer",
        "-moz-float-edge",
        "float-offset",
        "float-reference",
        "flood-color",
        "flood-opacity",
        "flow",
        "flow-from",
        "-ms-flow-from",
        "-webkit-flow-from",
        "flow-into",
        "-ms-flow-into",
        "-webkit-flow-into",
        "font",
        "font-display",
        "font-family",
        "font-feature-settings",
        "-moz-font-feature-settings",
        "-ms-font-feature-settings",
        "-webkit-font-feature-settings",
        "font-kerning",
        "-webkit-font-kerning",
        "font-language-override",
        "-moz-font-language-override",
        "font-optical-sizing",
        "font-palette",
        "font-size",
        "font-size-adjust",
        "-webkit-font-size-delta",
        "-webkit-font-smoothing",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-synthesis-small-caps",
        "font-synthesis-style",
        "font-synthesis-weight",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-emoji",
        "font-variant-ligatures",
        "-webkit-font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "footnote-display",
        "footnote-policy",
        "-moz-force-broken-image-icon",
        "forced-color-adjust",
        "gap",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "grid",
        "-webkit-grid-after",
        "grid-area",
        "grid-auto-columns",
        "-webkit-grid-auto-columns",
        "grid-auto-flow",
        "-webkit-grid-auto-flow",
        "grid-auto-rows",
        "-webkit-grid-auto-rows",
        "-webkit-grid-before",
        "grid-column",
        "-ms-grid-column-align",
        "grid-column-end",
        "grid-column-gap",
        "-ms-grid-column",
        "-ms-grid-column-span",
        "grid-column-start",
        "-webkit-grid-column",
        "-ms-grid-columns",
        "-webkit-grid-columns",
        "-webkit-grid-end",
        "grid-gap",
        "grid-row",
        "-ms-grid-row-align",
        "grid-row-end",
        "grid-row-gap",
        "-ms-grid-row",
        "-ms-grid-row-span",
        "grid-row-start",
        "-webkit-grid-row",
        "-ms-grid-rows",
        "-webkit-grid-rows",
        "-webkit-grid-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "-ms-high-contrast-adjust",
        "-webkit-highlight",
        "hyphenate-character",
        "-webkit-hyphenate-character",
        "-webkit-hyphenate-limit-after",
        "-webkit-hyphenate-limit-before",
        "hyphenate-limit-chars",
        "-ms-hyphenate-limit-chars",
        "hyphenate-limit-last",
        "hyphenate-limit-lines",
        "-ms-hyphenate-limit-lines",
        "-webkit-hyphenate-limit-lines",
        "hyphenate-limit-zone",
        "-ms-hyphenate-limit-zone",
        "hyphens",
        "-moz-hyphens",
        "-ms-hyphens",
        "-webkit-hyphens",
        "image-orientation",
        "-moz-image-region",
        "image-rendering",
        "image-resolution",
        "-ms-ime-align",
        "ime-mode",
        "inherits",
        "initial-letter",
        "initial-letter-align",
        "-webkit-initial-letter",
        "initial-letter-wrap",
        "initial-value",
        "inline-size",
        "inline-sizing",
        "input-format",
        "-wap-input-format",
        "-wap-input-required",
        "input-security",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "-ms-interpolation-mode",
        "isolation",
        "justify-content",
        "-webkit-justify-content",
        "justify-items",
        "-webkit-justify-items",
        "justify-self",
        "-webkit-justify-self",
        "kerning",
        "layout-flow",
        "layout-grid",
        "layout-grid-char",
        "layout-grid-line",
        "layout-grid-mode",
        "layout-grid-type",
        "leading-trim",
        "left",
        "letter-spacing",
        "lighting-color",
        "-webkit-line-align",
        "-webkit-line-box-contain",
        "line-break",
        "-webkit-line-break",
        "line-clamp",
        "-webkit-line-clamp",
        "line-gap-override",
        "line-grid",
        "-webkit-line-grid-snap",
        "-webkit-line-grid",
        "line-height",
        "line-height-step",
        "line-increment",
        "line-padding",
        "line-snap",
        "-webkit-line-snap",
        "-o-link",
        "-o-link-source",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "-webkit-locale",
        "-webkit-logical-height",
        "-webkit-logical-width",
        "margin",
        "-webkit-margin-after-collapse",
        "-webkit-margin-after",
        "-webkit-margin-before-collapse",
        "-webkit-margin-before",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "-webkit-margin-bottom-collapse",
        "margin-break",
        "-webkit-margin-collapse",
        "-moz-margin-end",
        "-webkit-margin-end",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "-moz-margin-start",
        "-webkit-margin-start",
        "margin-top",
        "-webkit-margin-top-collapse",
        "margin-trim",
        "marker",
        "marker-end",
        "marker-knockout-left",
        "marker-knockout-right",
        "marker-mid",
        "marker-offset",
        "marker-pattern",
        "marker-segment",
        "marker-side",
        "marker-start",
        "marks",
        "-wap-marquee-dir",
        "-webkit-marquee-direction",
        "-webkit-marquee-increment",
        "-wap-marquee-loop",
        "-webkit-marquee-repetition",
        "-wap-marquee-speed",
        "-webkit-marquee-speed",
        "-wap-marquee-style",
        "-webkit-marquee-style",
        "-webkit-marquee",
        "mask",
        "-webkit-mask-attachment",
        "mask-border",
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width",
        "-webkit-mask-box-image-outset",
        "-webkit-mask-box-image-repeat",
        "-webkit-mask-box-image-slice",
        "-webkit-mask-box-image-source",
        "-webkit-mask-box-image",
        "-webkit-mask-box-image-width",
        "mask-clip",
        "-webkit-mask-clip",
        "mask-composite",
        "-webkit-mask-composite",
        "mask-image",
        "-webkit-mask-image",
        "mask-mode",
        "mask-origin",
        "-webkit-mask-origin",
        "mask-position",
        "-webkit-mask-position",
        "mask-position-x",
        "-webkit-mask-position-x",
        "mask-position-y",
        "-webkit-mask-position-y",
        "mask-repeat",
        "-webkit-mask-repeat",
        "-webkit-mask-repeat-x",
        "-webkit-mask-repeat-y",
        "mask-size",
        "-webkit-mask-size",
        "mask-source-type",
        "-webkit-mask-source-type",
        "mask-type",
        "-webkit-mask",
        "-webkit-match-nearest-mail-blockquote-color",
        "math-style",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-lines",
        "-webkit-max-logical-height",
        "-webkit-max-logical-width",
        "max-width",
        "max-zoom",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-intrinsic-sizing",
        "-webkit-min-logical-height",
        "-webkit-min-logical-width",
        "min-width",
        "min-zoom",
        "mix-blend-mode",
        "motion",
        "motion-offset",
        "motion-path",
        "motion-rotation",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "-webkit-nbsp-mode",
        "negative",
        "object-fit",
        "-o-object-fit",
        "object-position",
        "-o-object-position",
        "offset",
        "offset-anchor",
        "offset-block-end",
        "offset-block-start",
        "offset-distance",
        "offset-inline-end",
        "offset-inline-start",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "offset-rotation",
        "opacity",
        "-moz-opacity",
        "-webkit-opacity",
        "order",
        "-webkit-order",
        "-moz-orient",
        "orientation",
        "orphans",
        "-moz-osx-font-smoothing",
        "outline",
        "outline-color",
        "-moz-outline-color",
        "-moz-outline",
        "outline-offset",
        "-moz-outline-offset",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "outline-style",
        "-moz-outline-style",
        "outline-width",
        "-moz-outline-width",
        "overflow",
        "overflow-anchor",
        "overflow-block",
        "overflow-clip-margin",
        "overflow-inline",
        "-webkit-overflow-scrolling",
        "-ms-overflow-style",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "overscroll-behavior",
        "overscroll-behavior-block",
        "overscroll-behavior-inline",
        "overscroll-behavior-x",
        "overscroll-behavior-y",
        "pad",
        "padding",
        "-webkit-padding-after",
        "-webkit-padding-before",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "-moz-padding-end",
        "-webkit-padding-end",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "-moz-padding-start",
        "-webkit-padding-start",
        "padding-top",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-orientation",
        "paint-order",
        "pause",
        "pause-after",
        "pause-before",
        "-apple-pay-button-style",
        "-apple-pay-button-type",
        "pen-action",
        "perspective",
        "-moz-perspective",
        "-ms-perspective",
        "perspective-origin",
        "-moz-perspective-origin",
        "-ms-perspective-origin",
        "-webkit-perspective-origin",
        "perspective-origin-x",
        "-webkit-perspective-origin-x",
        "perspective-origin-y",
        "-webkit-perspective-origin-y",
        "-webkit-perspective",
        "pitch",
        "pitch-range",
        "place-content",
        "place-items",
        "place-self",
        "play-during",
        "pointer-events",
        "position",
        "prefix",
        "print-color-adjust",
        "-webkit-print-color-adjust",
        "property-name",
        "quotes",
        "r",
        "range",
        "-webkit-region-break-after",
        "-webkit-region-break-before",
        "-webkit-region-break-inside",
        "region-fragment",
        "-webkit-region-fragment",
        "-webkit-region-overflow",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "richness",
        "right",
        "rotate",
        "row-gap",
        "-webkit-rtl-ordering",
        "ruby-align",
        "ruby-merge",
        "ruby-overhang",
        "ruby-position",
        "-webkit-ruby-position",
        "running",
        "rx",
        "ry",
        "scale",
        "scroll-behavior",
        "-ms-scroll-chaining",
        "-ms-scroll-limit",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-max",
        "-ms-scroll-limit-y-min",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "-ms-scroll-rails",
        "scroll-snap-align",
        "scroll-snap-coordinate",
        "-webkit-scroll-snap-coordinate",
        "scroll-snap-destination",
        "-webkit-scroll-snap-destination",
        "scroll-snap-margin",
        "scroll-snap-margin-bottom",
        "scroll-snap-margin-left",
        "scroll-snap-margin-right",
        "scroll-snap-margin-top",
        "scroll-snap-points-x",
        "-ms-scroll-snap-points-x",
        "-webkit-scroll-snap-points-x",
        "scroll-snap-points-y",
        "-ms-scroll-snap-points-y",
        "-webkit-scroll-snap-points-y",
        "scroll-snap-stop",
        "scroll-snap-type",
        "-ms-scroll-snap-type",
        "-webkit-scroll-snap-type",
        "scroll-snap-type-x",
        "scroll-snap-type-y",
        "-ms-scroll-snap-x",
        "-ms-scroll-snap-y",
        "-ms-scroll-translation",
        "scrollbar-arrow-color",
        "scrollbar-base-color",
        "scrollbar-color",
        "scrollbar-dark-shadow-color",
        "scrollbar-darkshadow-color",
        "scrollbar-face-color",
        "scrollbar-gutter",
        "scrollbar-highlight-color",
        "scrollbar-shadow-color",
        "scrollbar-track-color",
        "scrollbar-width",
        "scrollbar3d-light-color",
        "scrollbar3dlight-color",
        "shape-image-threshold",
        "-webkit-shape-image-threshold",
        "shape-inside",
        "-webkit-shape-inside",
        "shape-margin",
        "-webkit-shape-margin",
        "shape-outside",
        "-webkit-shape-outside",
        "-webkit-shape-padding",
        "shape-rendering",
        "size",
        "size-adjust",
        "snap-height",
        "solid-color",
        "solid-opacity",
        "spatial-navigation-action",
        "spatial-navigation-contain",
        "spatial-navigation-function",
        "speak",
        "speak-as",
        "speak-header",
        "speak-numeral",
        "speak-punctuation",
        "speech-rate",
        "src",
        "-moz-stack-sizing",
        "stop-color",
        "stop-opacity",
        "stress",
        "string-set",
        "stroke",
        "stroke-align",
        "stroke-alignment",
        "stroke-break",
        "stroke-color",
        "stroke-dash-corner",
        "stroke-dash-justify",
        "stroke-dashadjust",
        "stroke-dasharray",
        "stroke-dashcorner",
        "stroke-dashoffset",
        "stroke-image",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-origin",
        "stroke-position",
        "stroke-repeat",
        "stroke-size",
        "stroke-width",
        "suffix",
        "supported-color-schemes",
        "-webkit-svg-shadow",
        "symbols",
        "syntax",
        "system",
        "tab-size",
        "-moz-tab-size",
        "-o-tab-size",
        "-o-table-baseline",
        "table-layout",
        "-webkit-tap-highlight-color",
        "text-align",
        "text-align-all",
        "text-align-last",
        "-moz-text-align-last",
        "text-anchor",
        "text-autospace",
        "-moz-text-blink",
        "-ms-text-combine-horizontal",
        "text-combine-upright",
        "-webkit-text-combine",
        "text-decoration",
        "text-decoration-blink",
        "text-decoration-color",
        "-moz-text-decoration-color",
        "-webkit-text-decoration-color",
        "text-decoration-line",
        "-moz-text-decoration-line",
        "text-decoration-line-through",
        "-webkit-text-decoration-line",
        "text-decoration-none",
        "text-decoration-overline",
        "text-decoration-skip",
        "text-decoration-skip-box",
        "text-decoration-skip-ink",
        "text-decoration-skip-inset",
        "text-decoration-skip-self",
        "text-decoration-skip-spaces",
        "-webkit-text-decoration-skip",
        "text-decoration-style",
        "-moz-text-decoration-style",
        "-webkit-text-decoration-style",
        "text-decoration-thickness",
        "text-decoration-underline",
        "-webkit-text-decoration",
        "-webkit-text-decorations-in-effect",
        "text-edge",
        "text-emphasis",
        "text-emphasis-color",
        "-webkit-text-emphasis-color",
        "text-emphasis-position",
        "-webkit-text-emphasis-position",
        "text-emphasis-skip",
        "text-emphasis-style",
        "-webkit-text-emphasis-style",
        "-webkit-text-emphasis",
        "-webkit-text-fill-color",
        "text-group-align",
        "text-indent",
        "text-justify",
        "text-justify-trim",
        "text-kashida",
        "text-kashida-space",
        "text-line-through",
        "text-line-through-color",
        "text-line-through-mode",
        "text-line-through-style",
        "text-line-through-width",
        "text-orientation",
        "-webkit-text-orientation",
        "text-overflow",
        "text-overline",
        "text-overline-color",
        "text-overline-mode",
        "text-overline-style",
        "text-overline-width",
        "text-rendering",
        "-webkit-text-security",
        "text-shadow",
        "text-size-adjust",
        "-moz-text-size-adjust",
        "-ms-text-size-adjust",
        "-webkit-text-size-adjust",
        "text-space-collapse",
        "text-space-trim",
        "text-spacing",
        "-webkit-text-stroke-color",
        "-webkit-text-stroke",
        "-webkit-text-stroke-width",
        "text-transform",
        "text-underline",
        "text-underline-color",
        "text-underline-mode",
        "text-underline-offset",
        "text-underline-position",
        "-webkit-text-underline-position",
        "text-underline-style",
        "text-underline-width",
        "text-wrap",
        "-webkit-text-zoom",
        "top",
        "touch-action",
        "touch-action-delay",
        "-ms-touch-action",
        "-webkit-touch-callout",
        "-ms-touch-select",
        "-apple-trailing-word",
        "transform",
        "transform-box",
        "-moz-transform",
        "-ms-transform",
        "-o-transform",
        "transform-origin",
        "-moz-transform-origin",
        "-ms-transform-origin",
        "-o-transform-origin",
        "-webkit-transform-origin",
        "transform-origin-x",
        "-webkit-transform-origin-x",
        "transform-origin-y",
        "-webkit-transform-origin-y",
        "transform-origin-z",
        "-webkit-transform-origin-z",
        "transform-style",
        "-moz-transform-style",
        "-ms-transform-style",
        "-webkit-transform-style",
        "-webkit-transform",
        "transition",
        "transition-delay",
        "-moz-transition-delay",
        "-ms-transition-delay",
        "-o-transition-delay",
        "-webkit-transition-delay",
        "transition-duration",
        "-moz-transition-duration",
        "-ms-transition-duration",
        "-o-transition-duration",
        "-webkit-transition-duration",
        "-moz-transition",
        "-ms-transition",
        "-o-transition",
        "transition-property",
        "-moz-transition-property",
        "-ms-transition-property",
        "-o-transition-property",
        "-webkit-transition-property",
        "transition-timing-function",
        "-moz-transition-timing-function",
        "-ms-transition-timing-function",
        "-o-transition-timing-function",
        "-webkit-transition-timing-function",
        "-webkit-transition",
        "translate",
        "uc-alt-skin",
        "uc-skin",
        "unicode-bidi",
        "unicode-range",
        "-webkit-user-drag",
        "-moz-user-focus",
        "-moz-user-input",
        "-moz-user-modify",
        "-webkit-user-modify",
        "user-select",
        "-moz-user-select",
        "-ms-user-select",
        "-webkit-user-select",
        "user-zoom",
        "vector-effect",
        "vertical-align",
        "viewport-fill",
        "viewport-fill-opacity",
        "viewport-fit",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "volume",
        "white-space",
        "-webkit-widget-region",
        "widows",
        "width",
        "will-change",
        "-moz-window-dragging",
        "-moz-window-shadow",
        "word-boundary-detection",
        "word-boundary-expansion",
        "word-break",
        "word-spacing",
        "word-wrap",
        "wrap-after",
        "wrap-before",
        "wrap-flow",
        "-ms-wrap-flow",
        "-webkit-wrap-flow",
        "wrap-inside",
        "-ms-wrap-margin",
        "-webkit-wrap-margin",
        "-webkit-wrap-padding",
        "-webkit-wrap-shape-inside",
        "-webkit-wrap-shape-outside",
        "wrap-through",
        "-ms-wrap-through",
        "-webkit-wrap-through",
        "-webkit-wrap",
        "writing-mode",
        "-webkit-writing-mode",
        "x",
        "y",
        "z-index",
        "zoom"] };


    }, {}], 39: [function (require, module, exports) {
      module.exports.all = require('./data/all.json').properties;

    }, { "./data/all.json": 38 }], 40: [function (require, module, exports) {
      module.exports = [
      "abs",
      "and",
      "annotation",
      "annotation-xml",
      "apply",
      "approx",
      "arccos",
      "arccosh",
      "arccot",
      "arccoth",
      "arccsc",
      "arccsch",
      "arcsec",
      "arcsech",
      "arcsin",
      "arcsinh",
      "arctan",
      "arctanh",
      "arg",
      "bind",
      "bvar",
      "card",
      "cartesianproduct",
      "cbytes",
      "ceiling",
      "cerror",
      "ci",
      "cn",
      "codomain",
      "complexes",
      "compose",
      "condition",
      "conjugate",
      "cos",
      "cosh",
      "cot",
      "coth",
      "cs",
      "csc",
      "csch",
      "csymbol",
      "curl",
      "declare",
      "degree",
      "determinant",
      "diff",
      "divergence",
      "divide",
      "domain",
      "domainofapplication",
      "emptyset",
      "encoding",
      "eq",
      "equivalent",
      "eulergamma",
      "exists",
      "exp",
      "exponentiale",
      "factorial",
      "factorof",
      "false",
      "floor",
      "fn",
      "forall",
      "function",
      "gcd",
      "geq",
      "grad",
      "gt",
      "ident",
      "image",
      "imaginary",
      "imaginaryi",
      "implies",
      "in",
      "infinity",
      "int",
      "integers",
      "intersect",
      "interval",
      "inverse",
      "lambda",
      "laplacian",
      "lcm",
      "leq",
      "limit",
      "list",
      "ln",
      "log",
      "logbase",
      "lowlimit",
      "lt",
      "maction",
      "malign",
      "maligngroup",
      "malignmark",
      "malignscope",
      "math",
      "matrix",
      "matrixrow",
      "max",
      "mean",
      "median",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mfraction",
      "mglyph",
      "mi",
      "min",
      "minus",
      "mlabeledtr",
      "mlongdiv",
      "mmultiscripts",
      "mn",
      "mo",
      "mode",
      "moment",
      "momentabout",
      "mover",
      "mpadded",
      "mphantom",
      "mprescripts",
      "mroot",
      "mrow",
      "ms",
      "mscarries",
      "mscarry",
      "msgroup",
      "msline",
      "mspace",
      "msqrt",
      "msrow",
      "mstack",
      "mstyle",
      "msub",
      "msubsup",
      "msup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover",
      "naturalnumbers",
      "neq",
      "none",
      "not",
      "notanumber",
      "notin",
      "notprsubset",
      "notsubset",
      "or",
      "otherwise",
      "outerproduct",
      "partialdiff",
      "pi",
      "piece",
      "piecewice",
      "piecewise",
      "plus",
      "power",
      "primes",
      "product",
      "prsubset",
      "quotient",
      "rationals",
      "real",
      "reals",
      "reln",
      "rem",
      "root",
      "scalarproduct",
      "sdev",
      "sec",
      "sech",
      "select",
      "selector",
      "semantics",
      "sep",
      "set",
      "setdiff",
      "share",
      "sin",
      "sinh",
      "span",
      "subset",
      "sum",
      "tan",
      "tanh",
      "tendsto",
      "times",
      "transpose",
      "true",
      "union",
      "uplimit",
      "var",
      "variance",
      "vector",
      "vectorproduct",
      "xor"];


    }, {}], 41: [function (require, module, exports) {
      let urlAlphabet =
      'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
      let customAlphabet = (alphabet, size) => {
        return () => {
          let id = '';
          let i = size;
          while (i--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      let nanoid = (size = 21) => {
        let id = '';
        let i = size;
        while (i--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module.exports = { nanoid, customAlphabet };

    }, {}], 42: [function (require, module, exports) {
      /* normalize-selector v0.1.0 (c) 2014 Kyle Simpson */

      (function UMD(name, context, definition) {
        if (typeof module !== "undefined" && module.exports) {module.exports = definition();} else
        if (typeof define === "function" && define.amd) {define(definition);} else
        {context[name] = definition(name, context);}
      })("normalizeSelector", this, function DEF(name, context) {
        "use strict";

        function normalizeSelector(sel) {

          // save unmatched text, if any
          function saveUnmatched() {
            if (unmatched) {
              // whitespace needed after combinator?
              if (tokens.length > 0 &&
              /^[~+>]$/.test(tokens[tokens.length - 1]))
              {
                tokens.push(" ");
              }

              // save unmatched text
              tokens.push(unmatched);
            }
          }

          var tokens = [],match,unmatched,regex,state = [0],
          next_match_idx = 0,prev_match_idx,
          not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/,
          whitespace_pattern = /^\s+$/,
          attribute_nonspecial_pattern = /[^\s=~!^|$*\[\]\(\)]{2}/,
          state_patterns = [
          /\s+|\/\*|["'>~+\[\(]/g, // general
          /\s+|\/\*|["'\[\]\(\)]/g, // [..] set
          /\s+|\/\*|["'\[\]\(\)]/g, // (..) set
          null, // string literal (placeholder)
          /\*\//g // comment
          ];


          sel = sel.trim();

          while (true) {
            unmatched = "";

            regex = state_patterns[state[state.length - 1]];

            regex.lastIndex = next_match_idx;
            match = regex.exec(sel);

            // matched text to process?
            if (match) {
              prev_match_idx = next_match_idx;
              next_match_idx = regex.lastIndex;

              // collect the previous string chunk not matched before this token
              if (prev_match_idx < next_match_idx - match[0].length) {
                unmatched = sel.substring(prev_match_idx, next_match_idx - match[0].length);
              }

              // need to force a space (possibly skipped
              // previously by the parser)?
              if (
              state[state.length - 1] === 1 &&
              attribute_nonspecial_pattern.test(
              tokens[tokens.length - 1].substr(-1) +
              unmatched.charAt(0)))

              {
                tokens.push(" ");
              }

              // general, [ ] pair, ( ) pair?
              if (state[state.length - 1] < 3) {
                saveUnmatched();

                // starting a [ ] pair?
                if (match[0] === "[") {
                  state.push(1);
                }
                // starting a ( ) pair?
                else if (match[0] === "(") {
                    state.push(2);
                  }
                  // starting a string literal?
                  else if (/^["']$/.test(match[0])) {
                      state.push(3);
                      state_patterns[3] = new RegExp(match[0], "g");
                    }
                    // starting a comment?
                    else if (match[0] === "/*") {
                        state.push(4);
                      }
                      // ending a [ ] or ( ) pair?
                      else if (/^[\]\)]$/.test(match[0]) && state.length > 0) {
                          state.pop();
                        }
                        // handling whitespace or a combinator?
                        else if (/^(?:\s+|[~+>])$/.test(match[0])) {
                            // need to insert whitespace before?
                            if (tokens.length > 0 &&
                            !whitespace_pattern.test(tokens[tokens.length - 1]) &&
                            state[state.length - 1] === 0)
                            {
                              // add normalized whitespace
                              tokens.push(" ");
                            }

                            // whitespace token we can skip?
                            if (whitespace_pattern.test(match[0])) {
                              continue;
                            }
                          }

                // save matched text
                tokens.push(match[0]);
              }
              // otherwise, string literal or comment
              else {
                  // save unmatched text
                  tokens[tokens.length - 1] += unmatched;

                  // unescaped terminator to string literal or comment?
                  if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
                    // comment terminator?
                    if (state[state.length - 1] === 4) {
                      // ok to drop comment?
                      if (tokens.length < 2 ||
                      whitespace_pattern.test(tokens[tokens.length - 2]))
                      {
                        tokens.pop();
                      }
                      // otherwise, turn comment into whitespace
                      else {
                          tokens[tokens.length - 1] = " ";
                        }

                      // handled already
                      match[0] = "";
                    }

                    state.pop();
                  }

                  // append matched text to existing token
                  tokens[tokens.length - 1] += match[0];
                }
            }
            // otherwise, end of processing (no more matches)
            else {
                unmatched = sel.substr(next_match_idx);
                saveUnmatched();

                break;
              }
          }

          return tokens.join("").trim();
        }

        return normalizeSelector;
      });


    }, {}], 43: [function (require, module, exports) {
      exports.endianness = function () {return 'LE';};

      exports.hostname = function () {
        if (typeof location !== 'undefined') {
          return location.hostname;
        } else
        return '';
      };

      exports.loadavg = function () {return [];};

      exports.uptime = function () {return 0;};

      exports.freemem = function () {
        return Number.MAX_VALUE;
      };

      exports.totalmem = function () {
        return Number.MAX_VALUE;
      };

      exports.cpus = function () {return [];};

      exports.type = function () {return 'Browser';};

      exports.release = function () {
        if (typeof navigator !== 'undefined') {
          return navigator.appVersion;
        }
        return '';
      };

      exports.networkInterfaces =
      exports.getNetworkInterfaces =
      function () {return {};};

      exports.arch = function () {return 'javascript';};

      exports.platform = function () {return 'browser';};

      exports.tmpdir = exports.tmpDir = function () {
        return '/tmp';
      };

      exports.EOL = '\n';

      exports.homedir = function () {
        return '/';
      };

    }, {}], 44: [function (require, module, exports) {
      (function (process) {(function () {
          // 'path' module extracted from Node.js v8.11.1 (only the posix part)
          // transplited with Babel

          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict';

          function assertPath(path) {
            if (typeof path !== 'string') {
              throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
            }
          }

          // Resolves . and .. elements in a path with directory names
          function normalizeStringPosix(path, allowAboveRoot) {
            var res = '';
            var lastSegmentLength = 0;
            var lastSlash = -1;
            var dots = 0;
            var code;
            for (var i = 0; i <= path.length; ++i) {
              if (i < path.length)
              code = path.charCodeAt(i);else
              if (code === 47 /*/*/)
                break;else

              code = 47 /*/*/;
              if (code === 47 /*/*/) {
                  if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                  } else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                        if (res.length > 2) {
                          var lastSlashIndex = res.lastIndexOf('/');
                          if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                              res = '';
                              lastSegmentLength = 0;
                            } else {
                              res = res.slice(0, lastSlashIndex);
                              lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                          }
                        } else if (res.length === 2 || res.length === 1) {
                          res = '';
                          lastSegmentLength = 0;
                          lastSlash = i;
                          dots = 0;
                          continue;
                        }
                      }
                    if (allowAboveRoot) {
                      if (res.length > 0)
                      res += '/..';else

                      res = '..';
                      lastSegmentLength = 2;
                    }
                  } else {
                    if (res.length > 0)
                    res += '/' + path.slice(lastSlash + 1, i);else

                    res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                  }
                  lastSlash = i;
                  dots = 0;
                } else if (code === 46 /*.*/ && dots !== -1) {
                ++dots;
              } else {
                dots = -1;
              }
            }
            return res;
          }

          function _format(sep, pathObject) {
            var dir = pathObject.dir || pathObject.root;
            var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
            if (!dir) {
              return base;
            }
            if (dir === pathObject.root) {
              return dir + base;
            }
            return dir + sep + base;
          }

          var posix = {
            // path.resolve([from ...], to)
            resolve: function resolve() {
              var resolvedPath = '';
              var resolvedAbsolute = false;
              var cwd;

              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0)
                path = arguments[i];else
                {
                  if (cwd === undefined)
                  cwd = process.cwd();
                  path = cwd;
                }

                assertPath(path);

                // Skip empty entries
                if (path.length === 0) {
                  continue;
                }

                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

              if (resolvedAbsolute) {
                if (resolvedPath.length > 0)
                return '/' + resolvedPath;else

                return '/';
              } else if (resolvedPath.length > 0) {
                return resolvedPath;
              } else {
                return '.';
              }
            },

            normalize: function normalize(path) {
              assertPath(path);

              if (path.length === 0) return '.';

              var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
              var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

              // Normalize the path
              path = normalizeStringPosix(path, !isAbsolute);

              if (path.length === 0 && !isAbsolute) path = '.';
              if (path.length > 0 && trailingSeparator) path += '/';

              if (isAbsolute) return '/' + path;
              return path;
            },

            isAbsolute: function isAbsolute(path) {
              assertPath(path);
              return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
            },

            join: function join() {
              if (arguments.length === 0)
              return '.';
              var joined;
              for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg);
                if (arg.length > 0) {
                  if (joined === undefined)
                  joined = arg;else

                  joined += '/' + arg;
                }
              }
              if (joined === undefined)
              return '.';
              return posix.normalize(joined);
            },

            relative: function relative(from, to) {
              assertPath(from);
              assertPath(to);

              if (from === to) return '';

              from = posix.resolve(from);
              to = posix.resolve(to);

              if (from === to) return '';

              // Trim any leading backslashes
              var fromStart = 1;
              for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== 47 /*/*/)
                  break;
              }
              var fromEnd = from.length;
              var fromLen = fromEnd - fromStart;

              // Trim any leading backslashes
              var toStart = 1;
              for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== 47 /*/*/)
                  break;
              }
              var toEnd = to.length;
              var toLen = toEnd - toStart;

              // Compare paths to find the longest common path from root
              var length = fromLen < toLen ? fromLen : toLen;
              var lastCommonSep = -1;
              var i = 0;
              for (; i <= length; ++i) {
                if (i === length) {
                  if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                      } else if (i === 0) {
                      // We get here if `from` is the root
                      // For example: from='/'; to='/foo'
                      return to.slice(toStart + i);
                    }
                  } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                      } else if (i === 0) {
                      // We get here if `to` is the root.
                      // For example: from='/foo'; to='/'
                      lastCommonSep = 0;
                    }
                  }
                  break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode)
                break;else
                if (fromCode === 47 /*/*/)
                  lastCommonSep = i;
              }

              var out = '';
              // Generate the relative path based on the path difference between `to`
              // and `from`
              for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                    if (out.length === 0)
                    out += '..';else

                    out += '/..';
                  }
              }

              // Lastly, append the rest of the destination (`to`) path that comes after
              // the common path parts
              if (out.length > 0)
              return out + to.slice(toStart + lastCommonSep);else
              {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === 47 /*/*/)
                  ++toStart;
                return to.slice(toStart);
              }
            },

            _makeLong: function _makeLong(path) {
              return path;
            },

            dirname: function dirname(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var code = path.charCodeAt(0);
              var hasRoot = code === 47 /*/*/;
              var end = -1;
              var matchedSlash = true;
              for (var i = path.length - 1; i >= 1; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    if (!matchedSlash) {
                      end = i;
                      break;
                    }
                  } else {
                  // We saw the first non-path separator
                  matchedSlash = false;
                }
              }

              if (end === -1) return hasRoot ? '/' : '.';
              if (hasRoot && end === 1) return '//';
              return path.slice(0, end);
            },

            basename: function basename(path, ext) {
              if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
              assertPath(path);

              var start = 0;
              var end = -1;
              var matchedSlash = true;
              var i;

              if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else {
                    if (firstNonSlashEnd === -1) {
                      // We saw the first non-path separator, remember this index in case
                      // we need it if the extension ends up not matching
                      matchedSlash = false;
                      firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                      // Try to match the explicit extension
                      if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                          // We matched the extension, so mark this as the end of our path
                          // component
                          end = i;
                        }
                      } else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                      }
                    }
                  }
                }

                if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
                return path.slice(start, end);
              } else {
                for (i = path.length - 1; i >= 0; --i) {
                  if (path.charCodeAt(i) === 47 /*/*/) {
                      // If we reached a path separator that was not part of a set of path
                      // separators at the end of the string, stop now
                      if (!matchedSlash) {
                        start = i + 1;
                        break;
                      }
                    } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                  }
                }

                if (end === -1) return '';
                return path.slice(start, end);
              }
            },

            extname: function extname(path) {
              assertPath(path);
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;
              for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1)
                    startDot = i;else
                    if (preDotState !== 1)
                    preDotState = 1;
                  } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }

              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                return '';
              }
              return path.slice(startDot, end);
            },

            format: function format(pathObject) {
              if (pathObject === null || typeof pathObject !== 'object') {
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
              }
              return _format('/', pathObject);
            },

            parse: function parse(path) {
              assertPath(path);

              var ret = { root: '', dir: '', base: '', ext: '', name: '' };
              if (path.length === 0) return ret;
              var code = path.charCodeAt(0);
              var isAbsolute = code === 47 /*/*/;
              var start;
              if (isAbsolute) {
                ret.root = '/';
                start = 1;
              } else {
                start = 0;
              }
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              var i = path.length - 1;

              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;

              // Get non-dir info
              for (; i >= start; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                    continue;
                  }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                    // If this is our first dot, mark it as the start of our extension
                    if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                  } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }

              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                if (end !== -1) {
                  if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
                }
              } else {
                if (startPart === 0 && isAbsolute) {
                  ret.name = path.slice(1, startDot);
                  ret.base = path.slice(1, end);
                } else {
                  ret.name = path.slice(startPart, startDot);
                  ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
              }

              if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

              return ret;
            },

            sep: '/',
            delimiter: ':',
            win32: null,
            posix: null };


          posix.posix = posix;

          module.exports = posix;

        }).call(this);}).call(this, require('_process'));
    }, { "_process": 115 }], 45: [function (require, module, exports) {
      var x = String;
      var create = function () {return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };};
      module.exports = create();
      module.exports.createColors = create;

    }, {}], 46: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.default = parseMedia;

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      var _parsers = require('./parsers');

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media query list into an array of nodes. A typical node signature:
       *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',
       *    'media-feature-expression', 'media-feature', 'colon', 'value'
       *  {string} node.value -- the contents of a particular element, trimmed
       *    e.g.: `screen`, `max-width`, `1024px`
       *  {string} node.after -- whitespaces that follow the element
       *  {string} node.before -- whitespaces that precede the element
       *  {string} node.sourceIndex -- the index of the element in a source media
       *    query list, 0-based
       *  {object} node.parent -- a link to the parent node (a container)
       *
       * Some nodes (media queries, media feature expressions) contain other nodes.
       * They additionally have:
       *  {array} node.nodes -- an array of nodes of the type described here
       *  {funciton} node.each -- traverses direct children of the node, calling
       *    a callback for each one
       *  {funciton} node.walk -- traverses ALL descendants of the node, calling
       *    a callback for each one
       */

      function parseMedia(value) {
        return new _Container2.default({
          nodes: (0, _parsers.parseMediaList)(value),
          type: 'media-query-list',
          value: value.trim() });

      }
    }, { "./nodes/Container": 47, "./parsers": 49 }], 47: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });


      var _Node = require('./Node');

      var _Node2 = _interopRequireDefault(_Node);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      function Container(opts) {
        var _this = this;

        this.constructor(opts);

        this.nodes = opts.nodes;

        if (this.after === undefined) {
          this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : '';
        }

        if (this.before === undefined) {
          this.before = this.nodes.length > 0 ? this.nodes[0].before : '';
        }

        if (this.sourceIndex === undefined) {
          this.sourceIndex = this.before.length;
        }

        this.nodes.forEach(function (node) {
          node.parent = _this; // eslint-disable-line no-param-reassign
        });
      } /**
       * A node that contains other nodes and support traversing over them
       */

      Container.prototype = Object.create(_Node2.default.prototype);
      Container.constructor = _Node2.default;

      /**
       * Iterate over descendant nodes of the node
       *
       * @param {RegExp|string} filter - Optional. Only nodes with node.type that
       *    satisfies the filter will be traversed over
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.walk = function walk(filter, cb) {
        var hasFilter = typeof filter === 'string' || filter instanceof RegExp;
        var callback = hasFilter ? cb : filter;
        var filterReg = typeof filter === 'string' ? new RegExp(filter) : filter;

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          var filtered = hasFilter ? filterReg.test(node.type) : true;
          if (filtered && callback && callback(node, i, this.nodes) === false) {
            return false;
          }
          if (node.nodes && node.walk(filter, cb) === false) {
            return false;
          }
        }
        return true;
      };

      /**
       * Iterate over immediate children of the node
       *
       * @param {function} cb - callback to call on each node. Takes theese params:
       *    node - the node being processed, i - it's index, nodes - the array
       *    of all nodes
       *    If false is returned, the iteration breaks
       *
       * @return (boolean) false, if the iteration was broken
       */
      Container.prototype.each = function each() {
        var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i];
          if (cb(node, i, this.nodes) === false) {
            return false;
          }
        }
        return true;
      };

      exports.default = Container;
    }, { "./Node": 48 }], 48: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true });

      /**
       * A very generic node. Pretty much any element of a media query
       */

      function Node(opts) {
        this.after = opts.after;
        this.before = opts.before;
        this.type = opts.type;
        this.value = opts.value;
        this.sourceIndex = opts.sourceIndex;
      }

      exports.default = Node;
    }, {}], 49: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true });

      exports.parseMediaFeature = parseMediaFeature;
      exports.parseMediaQuery = parseMediaQuery;
      exports.parseMediaList = parseMediaList;

      var _Node = require('./nodes/Node');

      var _Node2 = _interopRequireDefault(_Node);

      var _Container = require('./nodes/Container');

      var _Container2 = _interopRequireDefault(_Container);

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

      /**
       * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`
       *
       * @param {string} string - the source expression string, can be inside parens
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes, the first element being a media feature,
       *    the secont - its value (may be missing)
       */

      function parseMediaFeature(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var modesEntered = [{
          mode: 'normal',
          character: null }];

        var result = [];
        var lastModeIndex = 0;
        var mediaFeature = '';
        var colon = null;
        var mediaFeatureValue = null;
        var indexLocal = index;

        var stringNormalized = string;
        // Strip trailing parens (if any), and correct the starting index
        if (string[0] === '(' && string[string.length - 1] === ')') {
          stringNormalized = string.substring(1, string.length - 1);
          indexLocal++;
        }

        for (var i = 0; i < stringNormalized.length; i++) {
          var character = stringNormalized[i];

          // If entering/exiting a string
          if (character === '\'' || character === '"') {
            if (modesEntered[lastModeIndex].isCalculationEnabled === true) {
              modesEntered.push({
                mode: 'string',
                isCalculationEnabled: false,
                character: character });

              lastModeIndex++;
            } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\') {
              modesEntered.pop();
              lastModeIndex--;
            }
          }

          // If entering/exiting interpolation
          if (character === '{') {
            modesEntered.push({
              mode: 'interpolation',
              isCalculationEnabled: true });

            lastModeIndex++;
          } else if (character === '}') {
            modesEntered.pop();
            lastModeIndex--;
          }

          // If a : is met outside of a string, function call or interpolation, than
          // this : separates a media feature and a value
          if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {
            var mediaFeatureValueStr = stringNormalized.substring(i + 1);
            mediaFeatureValue = {
              type: 'value',
              before: /^(\s*)/.exec(mediaFeatureValueStr)[1],
              after: /(\s*)$/.exec(mediaFeatureValueStr)[1],
              value: mediaFeatureValueStr.trim() };

            // +1 for the colon
            mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;
            colon = {
              type: 'colon',
              sourceIndex: i + indexLocal,
              after: mediaFeatureValue.before,
              value: ':' };
            break;
          }

          mediaFeature += character;
        }

        // Forming a media feature node
        mediaFeature = {
          type: 'media-feature',
          before: /^(\s*)/.exec(mediaFeature)[1],
          after: /(\s*)$/.exec(mediaFeature)[1],
          value: mediaFeature.trim() };

        mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;
        result.push(mediaFeature);

        if (colon !== null) {
          colon.before = mediaFeature.after;
          result.push(colon);
        }

        if (mediaFeatureValue !== null) {
          result.push(mediaFeatureValue);
        }

        return result;
      }

      /**
       * Parses a media query, e.g. `screen and (color)`, `only tv`
       *
       * @param {string} string - the source media query string
       * @param {Number} index - the index of `string` in the overall input
       *
       * @return {Array} an array of Nodes and Containers
       */

      function parseMediaQuery(string) {
        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var result = [];

        // How many timies the parser entered parens/curly braces
        var localLevel = 0;
        // Has any keyword, media type, media feature expression or interpolation
        // ('element' hereafter) started
        var insideSomeValue = false;
        var node = void 0;

        function resetNode() {
          return {
            before: '',
            after: '',
            value: '' };

        }

        node = resetNode();

        for (var i = 0; i < string.length; i++) {
          var character = string[i];
          // If not yet entered any element
          if (!insideSomeValue) {
            if (character.search(/\s/) !== -1) {
              // A whitespace
              // Don't form 'after' yet; will do it later
              node.before += character;
            } else {
              // Not a whitespace - entering an element
              // Expression start
              if (character === '(') {
                node.type = 'media-feature-expression';
                localLevel++;
              }
              node.value = character;
              node.sourceIndex = index + i;
              insideSomeValue = true;
            }
          } else {
            // Already in the middle of some alement
            node.value += character;

            // Here parens just increase localLevel and don't trigger a start of
            // a media feature expression (since they can't be nested)
            // Interpolation start
            if (character === '{' || character === '(') {
              localLevel++;
            }
            // Interpolation/function call/media feature expression end
            if (character === ')' || character === '}') {
              localLevel--;
            }
          }

          // If exited all parens/curlies and the next symbol
          if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\s/) !== -1)) {
            if (['not', 'only', 'and'].indexOf(node.value) !== -1) {
              node.type = 'keyword';
            }
            // if it's an expression, parse its contents
            if (node.type === 'media-feature-expression') {
              node.nodes = parseMediaFeature(node.value, node.sourceIndex);
            }
            result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));
            node = resetNode();
            insideSomeValue = false;
          }
        }

        // Now process the result array - to specify undefined types of the nodes
        // and specify the `after` prop
        for (var _i = 0; _i < result.length; _i++) {
          node = result[_i];
          if (_i > 0) {
            result[_i - 1].after = node.before;
          }

          // Node types. Might not be set because contains interpolation/function
          // calls or fully consists of them
          if (node.type === undefined) {
            if (_i > 0) {
              // only `and` can follow an expression
              if (result[_i - 1].type === 'media-feature-expression') {
                node.type = 'keyword';
                continue;
              }
              // Anything after 'only|not' is a media type
              if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {
                node.type = 'media-type';
                continue;
              }
              // Anything after 'and' is an expression
              if (result[_i - 1].value === 'and') {
                node.type = 'media-feature-expression';
                continue;
              }

              if (result[_i - 1].type === 'media-type') {
                // if it is the last element - it might be an expression
                // or 'and' depending on what is after it
                if (!result[_i + 1]) {
                  node.type = 'media-feature-expression';
                } else {
                  node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';
                }
              }
            }

            if (_i === 0) {
              // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then
              // its type would have been set by now
              if (!result[_i + 1]) {
                node.type = 'media-type';
                continue;
              }

              // `screen and` or `#{...} (max-width: 10px)`
              if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {
                node.type = 'media-type';
                continue;
              }
              if (result[_i + 2]) {
                // `screen and (color) ...`
                if (result[_i + 2].type === 'media-feature-expression') {
                  node.type = 'media-type';
                  result[_i + 1].type = 'keyword';
                  continue;
                }
                // `only screen and ...`
                if (result[_i + 2].type === 'keyword') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  continue;
                }
              }
              if (result[_i + 3]) {
                // `screen and (color) ...`
                if (result[_i + 3].type === 'media-feature-expression') {
                  node.type = 'keyword';
                  result[_i + 1].type = 'media-type';
                  result[_i + 2].type = 'keyword';
                  continue;
                }
              }
            }
          }
        }
        return result;
      }

      /**
       * Parses a media query list. Takes a possible `url()` at the start into
       * account, and divides the list into media queries that are parsed separately
       *
       * @param {string} string - the source media query list string
       *
       * @return {Array} an array of Nodes/Containers
       */

      function parseMediaList(string) {
        var result = [];
        var interimIndex = 0;
        var levelLocal = 0;

        // Check for a `url(...)` part (if it is contents of an @import rule)
        var doesHaveUrl = /^(\s*)url\s*\(/.exec(string);
        if (doesHaveUrl !== null) {
          var i = doesHaveUrl[0].length;
          var parenthesesLv = 1;
          while (parenthesesLv > 0) {
            var character = string[i];
            if (character === '(') {
              parenthesesLv++;
            }
            if (character === ')') {
              parenthesesLv--;
            }
            i++;
          }
          result.unshift(new _Node2.default({
            type: 'url',
            value: string.substring(0, i).trim(),
            sourceIndex: doesHaveUrl[1].length,
            before: doesHaveUrl[1],
            after: /^(\s*)/.exec(string.substring(i))[1] }));

          interimIndex = i;
        }

        // Start processing the media query list
        for (var _i2 = interimIndex; _i2 < string.length; _i2++) {
          var _character = string[_i2];

          // Dividing the media query list into comma-separated media queries
          // Only count commas that are outside of any parens
          // (i.e., not part of function call params list, etc.)
          if (_character === '(') {
            levelLocal++;
          }
          if (_character === ')') {
            levelLocal--;
          }
          if (levelLocal === 0 && _character === ',') {
            var _mediaQueryString = string.substring(interimIndex, _i2);
            var _spaceBefore = /^(\s*)/.exec(_mediaQueryString)[1];
            result.push(new _Container2.default({
              type: 'media-query',
              value: _mediaQueryString.trim(),
              sourceIndex: interimIndex + _spaceBefore.length,
              nodes: parseMediaQuery(_mediaQueryString, interimIndex),
              before: _spaceBefore,
              after: /(\s*)$/.exec(_mediaQueryString)[1] }));

            interimIndex = _i2 + 1;
          }
        }

        var mediaQueryString = string.substring(interimIndex);
        var spaceBefore = /^(\s*)/.exec(mediaQueryString)[1];
        result.push(new _Container2.default({
          type: 'media-query',
          value: mediaQueryString.trim(),
          sourceIndex: interimIndex + spaceBefore.length,
          nodes: parseMediaQuery(mediaQueryString, interimIndex),
          before: spaceBefore,
          after: /(\s*)$/.exec(mediaQueryString)[1] }));


        return result;
      }
    }, { "./nodes/Container": 47, "./nodes/Node": 48 }], 50: [function (require, module, exports) {
      module.exports = function resolveNestedSelector(selector, node) {
        var parent = node.parent;
        var parentIsNestAtRule = parent.type === 'atrule' && parent.name === 'nest';

        if (parent.type === 'root') return [selector];
        if (parent.type !== 'rule' && !parentIsNestAtRule) return resolveNestedSelector(selector, parent);

        var parentSelectors = parentIsNestAtRule ?
        parent.params.split(',').map(function (s) {return s.trim();}) :
        parent.selectors;

        var resolvedSelectors = parentSelectors.reduce(function (result, parentSelector) {
          if (selector.indexOf('&') !== -1) {
            var newlyResolvedSelectors = resolveNestedSelector(parentSelector, parent).map(function (resolvedParentSelector) {
              return selector.replace(/&/g, resolvedParentSelector);
            });
            return result.concat(newlyResolvedSelectors);
          }

          var combinedSelector = [parentSelector, selector].join(' ');
          return result.concat(resolveNestedSelector(combinedSelector, parent));
        }, []);

        return resolvedSelectors;
      };

    }, {}], 51: [function (require, module, exports) {
      let { Input } = require('postcss');

      let SafeParser = require('./safe-parser');

      module.exports = function safeParse(css, opts) {
        let input = new Input(css, opts);

        let parser = new SafeParser(input);
        parser.parse();

        return parser.root;
      };

    }, { "./safe-parser": 52, "postcss": 103 }], 52: [function (require, module, exports) {
      let tokenizer = require('postcss/lib/tokenize');
      let Comment = require('postcss/lib/comment');
      let Parser = require('postcss/lib/parser');

      class SafeParser extends Parser {
        createTokenizer() {
          this.tokenizer = tokenizer(this.input, { ignoreErrors: true });
        }

        comment(token) {
          let node = new Comment();
          this.init(node, token[2]);
          let pos =
          this.input.fromOffset(token[3]) ||
          this.input.fromOffset(this.input.css.length - 1);
          node.source.end = {
            offset: token[3],
            line: pos.line,
            column: pos.col };


          let text = token[1].slice(2);
          if (text.slice(-2) === '*/') text = text.slice(0, -2);

          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }

        decl(tokens) {
          if (tokens.length > 1 && tokens.some(i => i[0] === 'word')) {
            super.decl(tokens);
          }
        }

        unclosedBracket() {}

        unknownWord(tokens) {
          this.spaces += tokens.map(i => i[1]).join('');
        }

        unexpectedClose() {
          this.current.raws.after += '}';
        }

        doubleColon() {}

        unnamedAtrule(node) {
          node.name = '';
        }

        precheckMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;

          let nextStart, prevEnd;
          for (nextStart = colon - 1; nextStart >= 0; nextStart--) {
            if (tokens[nextStart][0] === 'word') break;
          }
          if (nextStart === 0) return;

          for (prevEnd = nextStart - 1; prevEnd >= 0; prevEnd--) {
            if (tokens[prevEnd][0] !== 'space') {
              prevEnd += 1;
              break;
            }
          }

          let other = tokens.slice(nextStart);
          let spaces = tokens.slice(prevEnd, nextStart);
          tokens.splice(prevEnd, tokens.length - prevEnd);
          this.spaces = spaces.map(i => i[1]).join('');

          this.decl(other);
        }

        checkMissedSemicolon() {}

        endFile() {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || '') + this.spaces;

          while (this.current.parent) {
            this.current = this.current.parent;
            this.current.raws.after = '';
          }
        }}


      module.exports = SafeParser;

    }, { "postcss/lib/comment": 89, "postcss/lib/parser": 102, "postcss/lib/tokenize": 112 }], 53: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _processor = _interopRequireDefault(require("./processor"));

      var selectors = _interopRequireWildcard(require("./selectors"));

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var parser = function parser(processor) {
        return new _processor["default"](processor);
      };

      Object.assign(parser, selectors);
      delete parser.__esModule;
      var _default = parser;
      exports["default"] = _default;
      module.exports = exports.default;
    }, { "./processor": 55, "./selectors": 64 }], 54: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _root = _interopRequireDefault(require("./selectors/root"));

      var _selector = _interopRequireDefault(require("./selectors/selector"));

      var _className = _interopRequireDefault(require("./selectors/className"));

      var _comment = _interopRequireDefault(require("./selectors/comment"));

      var _id = _interopRequireDefault(require("./selectors/id"));

      var _tag = _interopRequireDefault(require("./selectors/tag"));

      var _string = _interopRequireDefault(require("./selectors/string"));

      var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));

      var _attribute = _interopRequireWildcard(require("./selectors/attribute"));

      var _universal = _interopRequireDefault(require("./selectors/universal"));

      var _combinator = _interopRequireDefault(require("./selectors/combinator"));

      var _nesting = _interopRequireDefault(require("./selectors/nesting"));

      var _sortAscending = _interopRequireDefault(require("./sortAscending"));

      var _tokenize = _interopRequireWildcard(require("./tokenize"));

      var tokens = _interopRequireWildcard(require("./tokenTypes"));

      var types = _interopRequireWildcard(require("./selectors/types"));

      var _util = require("./util");

      var _WHITESPACE_TOKENS, _Object$assign;

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL] };

      }

      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL] };

      }

      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn },

          end: {
            line: endLine,
            column: endColumn } };


      }

      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }

      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return undefined;
        }

        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }

      function unescapeProp(node, prop) {
        var value = node[prop];

        if (typeof value !== "string") {
          return;
        }

        if (value.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node, 'raws');
          node[prop] = (0, _util.unesc)(value);

          if (node.raws[prop] === undefined) {
            node.raws[prop] = value;
          }
        }

        return node;
      }

      function indexesOf(array, item) {
        var i = -1;
        var indexes = [];

        while ((i = array.indexOf(item, i + 1)) !== -1) {
          indexes.push(i);
        }

        return indexes;
      }

      function uniqs() {
        var list = Array.prototype.concat.apply([], arguments);
        return list.filter(function (item, i) {
          return i === list.indexOf(item);
        });
      }

      var Parser = /*#__PURE__*/function () {
        function Parser(rule, options) {
          if (options === void 0) {
            options = {};
          }

          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false },
          options);
          this.position = 0;
          this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe });

          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root["default"]({
            source: rootSource });

          this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector["default"]({
            source: {
              start: {
                line: 1,
                column: 1 } } });



          this.root.append(selector);
          this.current = selector;
          this.loop();
        }

        var _proto = Parser.prototype;

        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;

          return function (message, errorOptions) {
            if (typeof _this.rule === 'string') {
              return new Error(message);
            }

            return _this.rule.error(message, errorOptions);
          };
        };

        _proto.attribute = function attribute() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;

          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
          }

          var len = attr.length;
          var node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS] };


          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
          }

          var pos = 0;
          var spaceBefore = '';
          var commentBefore = '';
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;

          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];

            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                // if (
                //     len === 1 ||
                //     pos === 0 && this.content(next) === '|'
                // ) {
                //     return this.expected('attribute', token[TOKEN.START_POS], content);
                // }
                spaceAfterMeaningfulToken = true;

                if (this.options.lossy) {
                  break;
                }

                if (lastAdded) {
                  (0, _util.ensureObject)(node, 'spaces', lastAdded);
                  var prevContent = node.spaces[lastAdded].after || '';
                  node.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

                  if (existingComment) {
                    node.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }

                break;

              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = '';
                  }

                  node.namespace = (node.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

                  if (rawValue) {
                    node.raws.namespace += content;
                  }

                  lastAdded = 'namespace';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
                  node.value += "$";

                  if (oldRawValue) {
                    node.raws.value = oldRawValue + "$";
                  }

                  break;
                }

              // Falls through

              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.combinator:
                if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                }

                if (content !== '|') {
                  spaceAfterMeaningfulToken = false;
                  break;
                }

                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node.operator = content;
                  lastAdded = 'operator';
                } else if (!node.namespace && !node.attribute) {
                  node.namespace = true;
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.word:
                if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node.operator && !node.namespace) {
                  node.namespace = content;
                  lastAdded = 'namespace';
                } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, 'spaces', 'attribute');
                    node.spaces.attribute.before = spaceBefore;
                    spaceBefore = '';
                  }

                  if (commentBefore) {
                    (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
                    node.raws.spaces.attribute.before = commentBefore;
                    commentBefore = '';
                  }

                  node.attribute = (node.attribute || "") + content;

                  var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

                  if (_rawValue) {
                    node.raws.attribute += content;
                  }

                  lastAdded = 'attribute';
                } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                  var _unescaped = (0, _util.unesc)(content);

                  var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

                  var oldValue = node.value || '';
                  node.value = oldValue + _unescaped;
                  node.quoteMark = null;

                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws.value = (_oldRawValue || oldValue) + content;
                  }

                  lastAdded = 'value';
                } else {
                  var insensitive = content === 'i' || content === "I";

                  if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
                    node.insensitive = insensitive;

                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node, 'raws');
                      node.raws.insensitiveFlag = content;
                    }

                    lastAdded = 'insensitive';

                    if (spaceBefore) {
                      (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                      node.spaces.insensitive.before = spaceBefore;
                      spaceBefore = '';
                    }

                    if (commentBefore) {
                      (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                      node.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = '';
                    }
                  } else if (node.value || node.value === '') {
                    lastAdded = 'value';
                    node.value += content;

                    if (node.raws.value) {
                      node.raws.value += content;
                    }
                  }
                }

                spaceAfterMeaningfulToken = false;
                break;

              case tokens.str:
                if (!node.attribute || !node.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                var _unescapeValue = (0, _attribute.unescapeValue)(content),
                unescaped = _unescapeValue.unescaped,
                quoteMark = _unescapeValue.quoteMark;

                node.value = unescaped;
                node.quoteMark = quoteMark;
                lastAdded = 'value';
                (0, _util.ensureObject)(node, 'raws');
                node.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.equals:
                if (!node.attribute) {
                  return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
                }

                if (node.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS] });

                }

                node.operator = node.operator ? node.operator + content : content;
                lastAdded = 'operator';
                spaceAfterMeaningfulToken = false;
                break;

              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
                    var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
                    var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
                    (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
                    node.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node[lastAdded] || '';
                    var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
                    (0, _util.ensureObject)(node, 'raws');
                    node.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }

                break;

              default:
                return this.error("Unexpected \"" + content + "\" found.", {
                  index: token[_tokenize.FIELDS.START_POS] });}



            pos++;
          }

          unescapeProp(node, "attribute");
          unescapeProp(node, "namespace");
          this.newNode(new _attribute["default"](node));
          this.position++;
        }
        /**
         * return a node containing meaningless garbage up to (but not including) the specified token position.
         * if the token position is negative, all remaining tokens are consumed.
         *
         * This returns an array containing a single string node if all whitespace,
         * otherwise an array of comment nodes with space before and after.
         *
         * These tokens are not added to the current selector, the caller can add them or use them to amend
         * a previous node's space metadata.
         *
         * In lossy mode, this returns only comments.
         */;


        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }

          var startPosition = this.position;
          var nodes = [];
          var space = "";
          var lastComment = undefined;

          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};

              if (space) {
                spaces.before = space;
                space = "";
              }

              lastComment = new _comment["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces: spaces });

              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);

          if (space) {
            if (lastComment) {
              lastComment.spaces.after = space;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string["default"]({
                value: '',
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space,
                  after: '' } }));


            }
          }

          return nodes;
        }
        /**
         * 
         * @param {*} nodes 
         */;


        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;

          if (requiredSpace === void 0) {
            requiredSpace = false;
          }

          var space = "";
          var rawSpace = "";
          nodes.forEach(function (n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });

          if (rawSpace === space) {
            rawSpace = undefined;
          }

          var result = {
            space: space,
            rawSpace: rawSpace };

          return result;
        };

        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }

          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };

        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};

            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }

            var node = new _combinator["default"]({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws: raws });

            this.position = this.position + 3;
            return node;
          } else {
            this.unexpected();
          }
        };

        _proto.combinator = function combinator() {
          var _this3 = this;

          if (this.content() === '|') {
            return this.namespace();
          } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

            if (nodes.length > 0) {
              var last = this.current.last;

              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
                space = _this$convertWhitespa.space,
                rawSpace = _this$convertWhitespa.rawSpace;

                if (rawSpace !== undefined) {
                  last.rawSpaceAfter += rawSpace;
                }

                last.spaces.after += space;
              } else {
                nodes.forEach(function (n) {
                  return _this3.newNode(n);
                });
              }
            }

            return;
          }

          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = undefined;

          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }

          var node;

          if (this.isNamedCombinator()) {
            node = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node = new _combinator["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS] });

            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
          } else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }

          if (node) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
              _space = _this$convertWhitespa2.space,
              _rawSpace = _this$convertWhitespa2.rawSpace;

              node.spaces.before = _space;
              node.rawSpaceBefore = _rawSpace;
            }
          } else {
            // descendant combinator
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
            _space2 = _this$convertWhitespa3.space,
            _rawSpace2 = _this$convertWhitespa3.rawSpace;

            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }

            var spaces = {};
            var raws = {
              spaces: {} };


            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }

            node = new _combinator["default"]({
              value: ' ',
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: spaces,
              raws: raws });

          }

          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }

          return this.newNode(node);
        };

        _proto.comma = function comma() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }

          this.current._inferEndPosition();

          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1]) } });


          this.current.parent.append(selector);
          this.current = selector;
          this.position++;
        };

        _proto.comment = function comment() {
          var current = this.currToken;
          this.newNode(new _comment["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };

        _proto.missingBackslash = function missingBackslash() {
          return this.error('Expected a backslash preceding the semicolon.', {
            index: this.currToken[_tokenize.FIELDS.START_POS] });

        };

        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };

        _proto.namespace = function namespace() {
          var before = this.prevToken && this.content(this.prevToken) || true;

          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
        };

        _proto.nesting = function nesting() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);

            if (nextContent === "|") {
              this.position++;
              return;
            }
          }

          var current = this.currToken;
          this.newNode(new _nesting["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;

          if (last && last.type === types.PSEUDO) {
            var selector = new _selector["default"]({
              source: {
                start: tokenStart(this.tokens[this.position - 1]) } });


            var cache = this.current;
            last.append(selector);
            this.current = selector;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }

            this.current = cache;
          } else {
            // I think this case should be an error. It's used to implement a basic parse of media queries
            // but I don't think it's a good idea.
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;

            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }

              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }

              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }

            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS] }));

            }
          }

          if (unbalanced) {
            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.pseudo = function pseudo() {
          var _this4 = this;

          var pseudoStr = '';
          var startingToken = this.currToken;

          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }

          if (!this.currToken) {
            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
          }

          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function (first, length) {
              pseudoStr += first;

              _this4.newNode(new _pseudo["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS] }));


              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error('Misplaced parenthesis.', {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS] });

              }
            });
          } else {
            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };

        _proto.space = function space() {
          var content = this.content(); // Handle space before and after the selector

          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
            return node.type === 'comment';
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };

        _proto.string = function string() {
          var current = this.currToken;
          this.newNode(new _string["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }));

          this.position++;
        };

        _proto.universal = function universal(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          var current = this.currToken;
          this.newNode(new _universal["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS] }),
          namespace);
          this.position++;
        };

        _proto.splitWord = function splitWord(namespace, firstCallback) {
          var _this5 = this;

          var nextToken = this.nextToken;
          var word = this.content();

          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word += current;

            if (current.lastIndexOf('\\') === current.length - 1) {
              var next = this.nextToken;

              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word += this.requiredSpace(this.content(next));
                this.position++;
              }
            }

            nextToken = this.nextToken;
          }

          var hasClass = indexesOf(word, '.').filter(function (i) {
            // Allow escaped dot within class name
            var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

            var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word, '#').filter(function (i) {
            return word[i - 1] !== '\\';
          }); // Eliminate Sass interpolations from the list of id indexes

          var interpolations = indexesOf(word, '#{');

          if (interpolations.length) {
            hasId = hasId.filter(function (hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }

          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function (ind, i) {
            var index = indices[i + 1] || word.length;
            var value = word.slice(ind, index);

            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value, indices.length);
            }

            var node;
            var current = _this5.currToken;
            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _className["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source: source,
                sourceIndex: sourceIndex };

              node = new _id["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value,
                source: source,
                sourceIndex: sourceIndex };

              unescapeProp(tagOpts, "value");
              node = new _tag["default"](tagOpts);
            }

            _this5.newNode(node, namespace); // Ensure that the namespace is used only once


            namespace = null;
          });
          this.position++;
        };

        _proto.word = function word(namespace) {
          var nextToken = this.nextToken;

          if (nextToken && this.content(nextToken) === '|') {
            this.position++;
            return this.namespace();
          }

          return this.splitWord(namespace);
        };

        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }

          this.current._inferEndPosition();

          return this.root;
        };

        _proto.parse = function parse(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;

            case tokens.comment:
              this.comment();
              break;

            case tokens.openParenthesis:
              this.parentheses();
              break;

            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }

              break;

            case tokens.openSquare:
              this.attribute();
              break;

            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;

            case tokens.colon:
              this.pseudo();
              break;

            case tokens.comma:
              this.comma();
              break;

            case tokens.asterisk:
              this.universal();
              break;

            case tokens.ampersand:
              this.nesting();
              break;

            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;

            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.

            case tokens.closeSquare:
              this.missingSquareBracket();

            case tokens.semicolon:
              this.missingBackslash();

            default:
              this.unexpected();}

        }
        /**
         * Helpers
         */;


        _proto.expected = function expected(description, index, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(', ') + " or " + last;
          }

          var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

          if (!found) {
            return this.error("Expected " + an + " " + description + ".", {
              index: index });

          }

          return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
            index: index });

        };

        _proto.requiredSpace = function requiredSpace(space) {
          return this.options.lossy ? ' ' : space;
        };

        _proto.optionalSpace = function optionalSpace(space) {
          return this.options.lossy ? '' : space;
        };

        _proto.lossySpace = function lossySpace(space, required) {
          if (this.options.lossy) {
            return required ? ' ' : '';
          } else {
            return space;
          }
        };

        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);

          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };

        _proto.newNode = function newNode(node, namespace) {
          if (namespace) {
            if (/^ +$/.test(namespace)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || '') + namespace;
              }

              namespace = true;
            }

            node.namespace = namespace;
            unescapeProp(node, "namespace");
          }

          if (this.spaces) {
            node.spaces.before = this.spaces;
            this.spaces = '';
          }

          return this.current.append(node);
        };

        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }

          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };

        /**
         * returns the index of the next non-whitespace, non-comment token.
         * returns -1 if no meaningful token is found.
         */
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }

          var searchPosition = startPosition;

          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }

          return -1;
        };

        _createClass(Parser, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          } },
        {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          } },
        {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          } }]);


        return Parser;
      }();

      exports["default"] = Parser;
      module.exports = exports.default;
    }, { "./selectors/attribute": 56, "./selectors/className": 57, "./selectors/combinator": 58, "./selectors/comment": 59, "./selectors/id": 63, "./selectors/nesting": 66, "./selectors/pseudo": 68, "./selectors/root": 69, "./selectors/selector": 70, "./selectors/string": 71, "./selectors/tag": 72, "./selectors/types": 73, "./selectors/universal": 74, "./sortAscending": 75, "./tokenTypes": 76, "./tokenize": 77, "./util": 80 }], 55: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _parser = _interopRequireDefault(require("./parser"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var Processor = /*#__PURE__*/function () {
        function Processor(func, options) {
          this.func = func || function noop() {};

          this.funcRes = null;
          this.options = options;
        }

        var _proto = Processor.prototype;

        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };

        _proto._isLossy = function _isLossy(options) {
          if (options === void 0) {
            options = {};
          }

          var merged = Object.assign({}, this.options, options);

          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };

        _proto._root = function _root(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var parser = new _parser["default"](rule, this._parseOptions(options));
          return parser.root;
        };

        _proto._parseOptions = function _parseOptions(options) {
          return {
            lossy: this._isLossy(options) };

        };

        _proto._run = function _run(rule, options) {
          var _this = this;

          if (options === void 0) {
            options = {};
          }

          return new Promise(function (resolve, reject) {
            try {
              var root = _this._root(rule, options);

              Promise.resolve(_this.func(root)).then(function (transform) {
                var string = undefined;

                if (_this._shouldUpdateSelector(rule, options)) {
                  string = root.toString();
                  rule.selector = string;
                }

                return {
                  transform: transform,
                  root: root,
                  string: string };

              }).then(resolve, reject);
            } catch (e) {
              reject(e);
              return;
            }
          });
        };

        _proto._runSync = function _runSync(rule, options) {
          if (options === void 0) {
            options = {};
          }

          var root = this._root(rule, options);

          var transform = this.func(root);

          if (transform && typeof transform.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }

          var string = undefined;

          if (options.updateSelector && typeof rule !== "string") {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string };

        }
        /**
         * Process rule into a selector AST.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<parser.Root>} The AST of the selector after processing it.
         */;


        _proto.ast = function ast(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.root;
          });
        }
        /**
         * Process rule into a selector AST synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {parser.Root} The AST of the selector after processing it.
         */;


        _proto.astSync = function astSync(rule, options) {
          return this._runSync(rule, options).root;
        }
        /**
         * Process a selector into a transformed value asynchronously
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {Promise<any>} The value returned by the processor.
         */;


        _proto.transform = function transform(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.transform;
          });
        }
        /**
         * Process a selector into a transformed value synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {any} The value returned by the processor.
         */;


        _proto.transformSync = function transformSync(rule, options) {
          return this._runSync(rule, options).transform;
        }
        /**
         * Process a selector into a new selector string asynchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.process = function process(rule, options) {
          return this._run(rule, options).then(function (result) {
            return result.string || result.root.toString();
          });
        }
        /**
         * Process a selector into a new selector string synchronously.
         *
         * @param rule {postcss.Rule | string} The css selector to be processed
         * @param options The options for processing
         * @returns {string} the selector after processing.
         */;


        _proto.processSync = function processSync(rule, options) {
          var result = this._runSync(rule, options);

          return result.string || result.root.toString();
        };

        return Processor;
      }();

      exports["default"] = Processor;
      module.exports = exports.default;
    }, { "./parser": 54 }], 56: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.unescapeValue = unescapeValue;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _unesc = _interopRequireDefault(require("../util/unesc"));

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      var _CSSESC_QUOTE_OPTIONS;

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var deprecate = require("util-deprecate");

      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m = unescaped.match(WRAPPED_IN_QUOTES);

        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }

        unescaped = (0, _unesc["default"])(unescaped);

        if (unescaped !== value) {
          deprecatedUsage = true;
        }

        return {
          deprecatedUsage: deprecatedUsage,
          unescaped: unescaped,
          quoteMark: quoteMark };

      }

      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== undefined) {
          return opts;
        }

        if (opts.value === undefined) {
          return opts;
        }

        warnOfDeprecatedConstructor();

        var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

        if (!opts.raws) {
          opts.raws = {};
        }

        if (opts.raws.value === undefined) {
          opts.raws.value = opts.value;
        }

        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }

      var Attribute = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Attribute, _Namespace);

        function Attribute(opts) {
          var _this;

          if (opts === void 0) {
            opts = {};
          }

          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, 'unquoted', {
            get: deprecate(function () {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function () {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") });

          _this._constructed = true;
          return _this;
        }
        /**
         * Returns the Attribute's value quoted such that it would be legal to use
         * in the value of a css file. The original value's quotation setting
         * used for stringification is left unchanged. See `setValue(value, options)`
         * if you want to control the quote settings of a new value for the attribute.
         *
         * You can also change the quotation used for the current value by setting quoteMark.
         *
         * Options:
         *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
         *     option is not set, the original value for quoteMark will be used. If
         *     indeterminate, a double quote is used. The legal values are:
         *     * `null` - the value will be unquoted and characters will be escaped as necessary.
         *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
         *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
         *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
         *     over the quoteMark option value.
         *   * smart {boolean} - if true, will select a quote mark based on the value
         *     and the other options specified here. See the `smartQuoteMark()`
         *     method.
         **/


        var _proto = Attribute.prototype;

        _proto.getQuotedValue = function getQuotedValue(options) {
          if (options === void 0) {
            options = {};
          }

          var quoteMark = this._determineQuoteMark(options);

          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped;
        };

        _proto._determineQuoteMark = function _determineQuoteMark(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        }
        /**
         * Set the unescaped value with the specified quotation options. The value
         * provided must not include any wrapping quote marks -- those quotes will
         * be interpreted as part of the value and escaped accordingly.
         */;


        _proto.setValue = function setValue(value, options) {
          if (options === void 0) {
            options = {};
          }

          this._value = value;
          this._quoteMark = this._determineQuoteMark(options);

          this._syncRawValue();
        }
        /**
         * Intelligently select a quoteMark value based on the value's contents. If
         * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
         * mark will be picked that minimizes the number of escapes.
         *
         * If there's no clear winner, the quote mark from these options is used,
         * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
         * true). If the quoteMark is unspecified, a double quote is used.
         *
         * @param options This takes the quoteMark and preferCurrentQuoteMark options
         * from the quoteValue method.
         */;


        _proto.smartQuoteMark = function smartQuoteMark(options) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, '').length;
          var numDoubleQuotes = v.replace(/[^"]/g, '').length;

          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true });


            if (escaped === v) {
              return Attribute.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options);

              if (pref === Attribute.NO_QUOTE) {
                // pick a quote mark that isn't none and see if it's smaller
                var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v, opts);

                if (quoteValue.length < escaped.length) {
                  return quote;
                }
              }

              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute.DOUBLE_QUOTE;
          } else {
            return Attribute.SINGLE_QUOTE;
          }
        }
        /**
         * Selects the preferred quote mark based on the options and the current quote mark value.
         * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
         * instead.
         */;


        _proto.preferredQuoteMark = function preferredQuoteMark(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

          if (quoteMark === undefined) {
            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
          }

          if (quoteMark === undefined) {
            quoteMark = Attribute.DOUBLE_QUOTE;
          }

          return quoteMark;
        };

        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };

        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(value, {
              isIdentifier: true });


            if (escaped !== value) {
              this.raws[prop] = escaped;
            } else {
              delete this.raws[prop];
            }
          }
        };

        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: '',
            after: '' };

          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };

        _proto._stringFor = function _stringFor(name, spaceName, concat) {
          if (spaceName === void 0) {
            spaceName = name;
          }

          if (concat === void 0) {
            concat = defaultAttrConcat;
          }

          var attrSpaces = this._spacesFor(spaceName);

          return concat(this.stringifyProperty(name), attrSpaces);
        }
        /**
         * returns the offset of the attribute part specified relative to the
         * start of the node of the output string.
         *
         * * "ns" - alias for "namespace"
         * * "namespace" - the namespace if it exists.
         * * "attribute" - the attribute name
         * * "attributeNS" - the start of the attribute or its namespace
         * * "operator" - the match operator of the attribute
         * * "value" - The value (string or identifier)
         * * "insensitive" - the case insensitivity flag;
         * @param part One of the possible values inside an attribute.
         * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
         */;


        _proto.offsetOf = function offsetOf(name) {
          var count = 1;

          var attributeSpaces = this._spacesFor("attribute");

          count += attributeSpaces.before.length;

          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }

          if (name === "attributeNS") {
            return count;
          }

          count += this.namespaceString.length;

          if (this.namespace) {
            count += 1;
          }

          if (name === "attribute") {
            return count;
          }

          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;

          var operatorSpaces = this._spacesFor("operator");

          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");

          if (name === "operator") {
            return operator ? count : -1;
          }

          count += operator.length;
          count += operatorSpaces.after.length;

          var valueSpaces = this._spacesFor("value");

          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");

          if (name === "value") {
            return value ? count : -1;
          }

          count += value.length;
          count += valueSpaces.after.length;

          var insensitiveSpaces = this._spacesFor("insensitive");

          count += insensitiveSpaces.before.length;

          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }

          return -1;
        };

        _proto.toString = function toString() {
          var _this2 = this;

          var selector = [this.rawSpaceBefore, '['];
          selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

          if (this.operator && (this.value || this.value === '')) {
            selector.push(this._stringFor('operator'));
            selector.push(this._stringFor('value'));
            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }

              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }

          selector.push(']');
          selector.push(this.rawSpaceAfter);
          return selector.join('');
        };

        _createClass(Attribute, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set(value) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */ },

        {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          }
          /**
           * Set the quote mark to be used by this attribute's value.
           * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
           * value is updated accordingly.
           *
           * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
           */,

          set: function set(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }

            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;

              this._syncRawValue();
            }
          } },
        {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          } },
        {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? 'i' : '';
          } },
        {
          key: "value",
          get: function get() {
            return this._value;
          }
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */,

          set: function set(v) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v),
              deprecatedUsage = _unescapeValue2.deprecatedUsage,
              unescaped = _unescapeValue2.unescaped,
              quoteMark = _unescapeValue2.quoteMark;

              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }

              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }

              this._value = unescaped;
              this._quoteMark = quoteMark;

              this._syncRawValue();
            } else {
              this._value = v;
            }
          } },
        {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set(name) {
            this._handleEscapes("attribute", name);

            this._attribute = name;
          } }]);


        return Attribute;
      }(_namespace["default"]);

      exports["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: 'single',
          wrap: true },

        '"': {
          quotes: 'double',
          wrap: true } },

      _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true },
      _CSSESC_QUOTE_OPTIONS);

      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    }, { "../util/unesc": 82, "./namespace": 65, "./types": 73, "cssesc": 15, "util-deprecate": 452 }], 57: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var ClassName = /*#__PURE__*/function (_Node) {
        _inheritsLoose(ClassName, _Node);

        function ClassName(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.CLASS;
          _this._constructed = true;
          return _this;
        }

        var _proto = ClassName.prototype;

        _proto.valueToString = function valueToString() {
          return '.' + _Node.prototype.valueToString.call(this);
        };

        _createClass(ClassName, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc["default"])(v, {
                isIdentifier: true });


              if (escaped !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }

            this._value = v;
          } }]);


        return ClassName;
      }(_node["default"]);

      exports["default"] = ClassName;
      module.exports = exports.default;
    }, { "../util": 80, "./node": 67, "./types": 73, "cssesc": 15 }], 58: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Combinator = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Combinator, _Node);

        function Combinator(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMBINATOR;
          return _this;
        }

        return Combinator;
      }(_node["default"]);

      exports["default"] = Combinator;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 59: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Comment = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Comment, _Node);

        function Comment(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.COMMENT;
          return _this;
        }

        return Comment;
      }(_node["default"]);

      exports["default"] = Comment;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 60: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

      var _attribute = _interopRequireDefault(require("./attribute"));

      var _className = _interopRequireDefault(require("./className"));

      var _combinator = _interopRequireDefault(require("./combinator"));

      var _comment = _interopRequireDefault(require("./comment"));

      var _id = _interopRequireDefault(require("./id"));

      var _nesting = _interopRequireDefault(require("./nesting"));

      var _pseudo = _interopRequireDefault(require("./pseudo"));

      var _root = _interopRequireDefault(require("./root"));

      var _selector = _interopRequireDefault(require("./selector"));

      var _string = _interopRequireDefault(require("./string"));

      var _tag = _interopRequireDefault(require("./tag"));

      var _universal = _interopRequireDefault(require("./universal"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      var attribute = function attribute(opts) {
        return new _attribute["default"](opts);
      };

      exports.attribute = attribute;

      var className = function className(opts) {
        return new _className["default"](opts);
      };

      exports.className = className;

      var combinator = function combinator(opts) {
        return new _combinator["default"](opts);
      };

      exports.combinator = combinator;

      var comment = function comment(opts) {
        return new _comment["default"](opts);
      };

      exports.comment = comment;

      var id = function id(opts) {
        return new _id["default"](opts);
      };

      exports.id = id;

      var nesting = function nesting(opts) {
        return new _nesting["default"](opts);
      };

      exports.nesting = nesting;

      var pseudo = function pseudo(opts) {
        return new _pseudo["default"](opts);
      };

      exports.pseudo = pseudo;

      var root = function root(opts) {
        return new _root["default"](opts);
      };

      exports.root = root;

      var selector = function selector(opts) {
        return new _selector["default"](opts);
      };

      exports.selector = selector;

      var string = function string(opts) {
        return new _string["default"](opts);
      };

      exports.string = string;

      var tag = function tag(opts) {
        return new _tag["default"](opts);
      };

      exports.tag = tag;

      var universal = function universal(opts) {
        return new _universal["default"](opts);
      };

      exports.universal = universal;
    }, { "./attribute": 56, "./className": 57, "./combinator": 58, "./comment": 59, "./id": 63, "./nesting": 66, "./pseudo": 68, "./root": 69, "./selector": 70, "./string": 71, "./tag": 72, "./universal": 74 }], 61: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var types = _interopRequireWildcard(require("./types"));

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;return function () {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}it = o[Symbol.iterator]();return it.next.bind(it);}

      function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}

      function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Container = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Container, _Node);

        function Container(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;

          if (!_this.nodes) {
            _this.nodes = [];
          }

          return _this;
        }

        var _proto = Container.prototype;

        _proto.append = function append(selector) {
          selector.parent = this;
          this.nodes.push(selector);
          return this;
        };

        _proto.prepend = function prepend(selector) {
          selector.parent = this;
          this.nodes.unshift(selector);
          return this;
        };

        _proto.at = function at(index) {
          return this.nodes[index];
        };

        _proto.index = function index(child) {
          if (typeof child === 'number') {
            return child;
          }

          return this.nodes.indexOf(child);
        };

        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = undefined;
          this.nodes.splice(child, 1);
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          return this;
        };

        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
            var node = _step.value;
            node.parent = undefined;
          }

          this.nodes = [];
          return this;
        };

        _proto.empty = function empty() {
          return this.removeAll();
        };

        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (oldIndex <= index) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index;

          for (var id in this.indexes) {
            index = this.indexes[id];

            if (index <= oldIndex) {
              this.indexes[id] = index + 1;
            }
          }

          return this;
        };

        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = undefined;
          this.each(function (node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);

              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node.isAtPosition(line, col)) {
              found = node;
              return false;
            }
          });
          return found;
        }
        /**
         * Return the most specific node at the line and column number given.
         * The source location is based on the original parsed location, locations aren't
         * updated as selector nodes are mutated.
         * 
         * Note that this location is relative to the location of the first character
         * of the selector, and not the location of the selector in the overall document
         * when used in conjunction with postcss.
         *
         * If not found, returns undefined.
         * @param {number} line The line number of the node to find. (1-based index)
         * @param {number} col  The column number of the node to find. (1-based index)
         */;


        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return undefined;
          }
        };

        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };

        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }

          if (!this.indexes) {
            this.indexes = {};
          }

          this.lastEach++;
          var id = this.lastEach;
          this.indexes[id] = 0;

          if (!this.length) {
            return undefined;
          }

          var index, result;

          while (this.indexes[id] < this.length) {
            index = this.indexes[id];
            result = callback(this.at(index), index);

            if (result === false) {
              break;
            }

            this.indexes[id] += 1;
          }

          delete this.indexes[id];

          if (result === false) {
            return false;
          }
        };

        _proto.walk = function walk(callback) {
          return this.each(function (node, i) {
            var result = callback(node, i);

            if (result !== false && node.length) {
              result = node.walk(callback);
            }

            if (result === false) {
              return false;
            }
          });
        };

        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ATTRIBUTE) {
              return callback.call(_this2, selector);
            }
          });
        };

        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;

          return this.walk(function (selector) {
            if (selector.type === types.CLASS) {
              return callback.call(_this3, selector);
            }
          });
        };

        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMBINATOR) {
              return callback.call(_this4, selector);
            }
          });
        };

        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;

          return this.walk(function (selector) {
            if (selector.type === types.COMMENT) {
              return callback.call(_this5, selector);
            }
          });
        };

        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;

          return this.walk(function (selector) {
            if (selector.type === types.ID) {
              return callback.call(_this6, selector);
            }
          });
        };

        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;

          return this.walk(function (selector) {
            if (selector.type === types.NESTING) {
              return callback.call(_this7, selector);
            }
          });
        };

        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;

          return this.walk(function (selector) {
            if (selector.type === types.PSEUDO) {
              return callback.call(_this8, selector);
            }
          });
        };

        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;

          return this.walk(function (selector) {
            if (selector.type === types.TAG) {
              return callback.call(_this9, selector);
            }
          });
        };

        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;

          return this.walk(function (selector) {
            if (selector.type === types.UNIVERSAL) {
              return callback.call(_this10, selector);
            }
          });
        };

        _proto.split = function split(callback) {
          var _this11 = this;

          var current = [];
          return this.reduce(function (memo, node, index) {
            var split = callback.call(_this11, node);
            current.push(node);

            if (split) {
              memo.push(current);
              current = [];
            } else if (index === _this11.length - 1) {
              memo.push(current);
            }

            return memo;
          }, []);
        };

        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };

        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };

        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };

        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };

        _proto.filter = function filter(callback) {
          return this.nodes.filter(callback);
        };

        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };

        _proto.toString = function toString() {
          return this.map(String).join('');
        };

        _createClass(Container, [{
          key: "first",
          get: function get() {
            return this.at(0);
          } },
        {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          } },
        {
          key: "length",
          get: function get() {
            return this.nodes.length;
          } }]);


        return Container;
      }(_node["default"]);

      exports["default"] = Container;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 62: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.isNode = isNode;
      exports.isPseudoElement = isPseudoElement;
      exports.isPseudoClass = isPseudoClass;
      exports.isContainer = isContainer;
      exports.isNamespace = isNamespace;
      exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

      var _types = require("./types");

      var _IS_TYPE;

      var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

      function isNode(node) {
        return typeof node === "object" && IS_TYPE[node.type];
      }

      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }

      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo;
      var isRoot = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      exports.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      exports.isUniversal = isUniversal;

      function isPseudoElement(node) {
        return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after");
      }

      function isPseudoClass(node) {
        return isPseudo(node) && !isPseudoElement(node);
      }

      function isContainer(node) {
        return !!(isNode(node) && node.walk);
      }

      function isNamespace(node) {
        return isAttribute(node) || isTag(node);
      }
    }, { "./types": 73 }], 63: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var ID = /*#__PURE__*/function (_Node) {
        _inheritsLoose(ID, _Node);

        function ID(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.ID;
          return _this;
        }

        var _proto = ID.prototype;

        _proto.valueToString = function valueToString() {
          return '#' + _Node.prototype.valueToString.call(this);
        };

        return ID;
      }(_node["default"]);

      exports["default"] = ID;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 64: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;

      var _types = require("./types");

      Object.keys(_types).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _types[key]) return;
        exports[key] = _types[key];
      });

      var _constructors = require("./constructors");

      Object.keys(_constructors).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _constructors[key]) return;
        exports[key] = _constructors[key];
      });

      var _guards = require("./guards");

      Object.keys(_guards).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _guards[key]) return;
        exports[key] = _guards[key];
      });
    }, { "./constructors": 60, "./guards": 62, "./types": 73 }], 65: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _cssesc = _interopRequireDefault(require("cssesc"));

      var _util = require("../util");

      var _node = _interopRequireDefault(require("./node"));

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Namespace = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Namespace, _Node);

        function Namespace() {
          return _Node.apply(this, arguments) || this;
        }

        var _proto = Namespace.prototype;

        _proto.qualifiedName = function qualifiedName(value) {
          if (this.namespace) {
            return this.namespaceString + "|" + value;
          } else {
            return value;
          }
        };

        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };

        _createClass(Namespace, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            if (namespace === true || namespace === "*" || namespace === "&") {
              this._namespace = namespace;

              if (this.raws) {
                delete this.raws.namespace;
              }

              return;
            }

            var escaped = (0, _cssesc["default"])(namespace, {
              isIdentifier: true });

            this._namespace = namespace;

            if (escaped !== namespace) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          } },
        {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set(namespace) {
            this.namespace = namespace;
          } },
        {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");

              if (ns === true) {
                return '';
              } else {
                return ns;
              }
            } else {
              return '';
            }
          } }]);


        return Namespace;
      }(_node["default"]);

      exports["default"] = Namespace;
      ;
      module.exports = exports.default;
    }, { "../util": 80, "./node": 67, "cssesc": 15 }], 66: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Nesting = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Nesting, _Node);

        function Nesting(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.NESTING;
          _this.value = '&';
          return _this;
        }

        return Nesting;
      }(_node["default"]);

      exports["default"] = Nesting;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 67: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _util = require("../util");

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      var cloneNode = function cloneNode(obj, parent) {
        if (typeof obj !== 'object' || obj === null) {
          return obj;
        }

        var cloned = new obj.constructor();

        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }

          var value = obj[i];
          var type = typeof value;

          if (i === 'parent' && type === 'object') {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
              return cloneNode(j, cloned);
            });
          } else {
            cloned[i] = cloneNode(value, cloned);
          }
        }

        return cloned;
      };

      var Node = /*#__PURE__*/function () {
        function Node(opts) {
          if (opts === void 0) {
            opts = {};
          }

          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || '';
          this.spaces.after = this.spaces.after || '';
        }

        var _proto = Node.prototype;

        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }

          this.parent = undefined;
          return this;
        };

        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index in arguments) {
              this.parent.insertBefore(this, arguments[index]);
            }

            this.remove();
          }

          return this;
        };

        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };

        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };

        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }

          var cloned = cloneNode(this);

          for (var name in overrides) {
            cloned[name] = overrides[name];
          }

          return cloned;
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows non standard syntax to be appended to an existing property
         * by specifying the escaped value. By specifying the escaped value,
         * illegal characters are allowed to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped optional. the escaped value of the property.
         */;


        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

          if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name]; // delete any escaped value that was created by the setter.
          }
        }
        /**
         * Some non-standard syntax doesn't follow normal escaping rules for css.
         * This allows the escaped value to be specified directly, allowing illegal
         * characters to be directly inserted into css output.
         * @param {string} name the property to set
         * @param {any} value the unescaped value of the property
         * @param {string} valueEscaped the escaped value of the property.
         */;


        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }

          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          this.raws[name] = valueEscaped;
        }
        /**
         * When you want a value to passed through to CSS directly. This method
         * deletes the corresponding raw value causing the stringifier to fallback
         * to the unescaped value.
         * @param {string} name the property to set.
         * @param {any} value The value that is both escaped and unescaped.
         */;


        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
          this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

          if (this.raws) {
            delete this.raws[name];
          }
        }
        /**
         *
         * @param {number} line The number (starting with 1)
         * @param {number} column The column number (starting with 1)
         */;


        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }

            if (this.source.end.line < line) {
              return false;
            }

            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }

            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }

            return true;
          }

          return undefined;
        };

        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };

        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };

        _proto.toString = function toString() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
        };

        _createClass(Node, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

            if (rawSpace === undefined) {
              rawSpace = this.spaces && this.spaces.before;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          } },
        {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

            if (rawSpace === undefined) {
              rawSpace = this.spaces.after;
            }

            return rawSpace || "";
          },
          set: function set(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          } }]);


        return Node;
      }();

      exports["default"] = Node;
      module.exports = exports.default;
    }, { "../util": 80 }], 68: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Pseudo = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Pseudo, _Container);

        function Pseudo(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.PSEUDO;
          return _this;
        }

        var _proto = Pseudo.prototype;

        _proto.toString = function toString() {
          var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
        };

        return Pseudo;
      }(_container["default"]);

      exports["default"] = Pseudo;
      module.exports = exports.default;
    }, { "./container": 61, "./types": 73 }], 69: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}

      function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Root = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Root, _Container);

        function Root(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.ROOT;
          return _this;
        }

        var _proto = Root.prototype;

        _proto.toString = function toString() {
          var str = this.reduce(function (memo, selector) {
            memo.push(String(selector));
            return memo;
          }, []).join(',');
          return this.trailingComma ? str + ',' : str;
        };

        _proto.error = function error(message, options) {
          if (this._error) {
            return this._error(message, options);
          } else {
            return new Error(message);
          }
        };

        _createClass(Root, [{
          key: "errorGenerator",
          set: function set(handler) {
            this._error = handler;
          } }]);


        return Root;
      }(_container["default"]);

      exports["default"] = Root;
      module.exports = exports.default;
    }, { "./container": 61, "./types": 73 }], 70: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _container = _interopRequireDefault(require("./container"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Selector = /*#__PURE__*/function (_Container) {
        _inheritsLoose(Selector, _Container);

        function Selector(opts) {
          var _this;

          _this = _Container.call(this, opts) || this;
          _this.type = _types.SELECTOR;
          return _this;
        }

        return Selector;
      }(_container["default"]);

      exports["default"] = Selector;
      module.exports = exports.default;
    }, { "./container": 61, "./types": 73 }], 71: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _node = _interopRequireDefault(require("./node"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var String = /*#__PURE__*/function (_Node) {
        _inheritsLoose(String, _Node);

        function String(opts) {
          var _this;

          _this = _Node.call(this, opts) || this;
          _this.type = _types.STRING;
          return _this;
        }

        return String;
      }(_node["default"]);

      exports["default"] = String;
      module.exports = exports.default;
    }, { "./node": 67, "./types": 73 }], 72: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Tag = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Tag, _Namespace);

        function Tag(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.TAG;
          return _this;
        }

        return Tag;
      }(_namespace["default"]);

      exports["default"] = Tag;
      module.exports = exports.default;
    }, { "./namespace": 65, "./types": 73 }], 73: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
      var TAG = 'tag';
      exports.TAG = TAG;
      var STRING = 'string';
      exports.STRING = STRING;
      var SELECTOR = 'selector';
      exports.SELECTOR = SELECTOR;
      var ROOT = 'root';
      exports.ROOT = ROOT;
      var PSEUDO = 'pseudo';
      exports.PSEUDO = PSEUDO;
      var NESTING = 'nesting';
      exports.NESTING = NESTING;
      var ID = 'id';
      exports.ID = ID;
      var COMMENT = 'comment';
      exports.COMMENT = COMMENT;
      var COMBINATOR = 'combinator';
      exports.COMBINATOR = COMBINATOR;
      var CLASS = 'class';
      exports.CLASS = CLASS;
      var ATTRIBUTE = 'attribute';
      exports.ATTRIBUTE = ATTRIBUTE;
      var UNIVERSAL = 'universal';
      exports.UNIVERSAL = UNIVERSAL;
    }, {}], 74: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = void 0;

      var _namespace = _interopRequireDefault(require("./namespace"));

      var _types = require("./types");

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}

      function _inheritsLoose(subClass, superClass) {subClass.prototype = Object.create(superClass.prototype);subClass.prototype.constructor = subClass;_setPrototypeOf(subClass, superClass);}

      function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

      var Universal = /*#__PURE__*/function (_Namespace) {
        _inheritsLoose(Universal, _Namespace);

        function Universal(opts) {
          var _this;

          _this = _Namespace.call(this, opts) || this;
          _this.type = _types.UNIVERSAL;
          _this.value = '*';
          return _this;
        }

        return Universal;
      }(_namespace["default"]);

      exports["default"] = Universal;
      module.exports = exports.default;
    }, { "./namespace": 65, "./types": 73 }], 75: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = sortAscending;

      function sortAscending(list) {
        return list.sort(function (a, b) {
          return a - b;
        });
      }

      ;
      module.exports = exports.default;
    }, {}], 76: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
      var ampersand = 38; // `&`.charCodeAt(0);

      exports.ampersand = ampersand;
      var asterisk = 42; // `*`.charCodeAt(0);

      exports.asterisk = asterisk;
      var at = 64; // `@`.charCodeAt(0);

      exports.at = at;
      var comma = 44; // `,`.charCodeAt(0);

      exports.comma = comma;
      var colon = 58; // `:`.charCodeAt(0);

      exports.colon = colon;
      var semicolon = 59; // `;`.charCodeAt(0);

      exports.semicolon = semicolon;
      var openParenthesis = 40; // `(`.charCodeAt(0);

      exports.openParenthesis = openParenthesis;
      var closeParenthesis = 41; // `)`.charCodeAt(0);

      exports.closeParenthesis = closeParenthesis;
      var openSquare = 91; // `[`.charCodeAt(0);

      exports.openSquare = openSquare;
      var closeSquare = 93; // `]`.charCodeAt(0);

      exports.closeSquare = closeSquare;
      var dollar = 36; // `$`.charCodeAt(0);

      exports.dollar = dollar;
      var tilde = 126; // `~`.charCodeAt(0);

      exports.tilde = tilde;
      var caret = 94; // `^`.charCodeAt(0);

      exports.caret = caret;
      var plus = 43; // `+`.charCodeAt(0);

      exports.plus = plus;
      var equals = 61; // `=`.charCodeAt(0);

      exports.equals = equals;
      var pipe = 124; // `|`.charCodeAt(0);

      exports.pipe = pipe;
      var greaterThan = 62; // `>`.charCodeAt(0);

      exports.greaterThan = greaterThan;
      var space = 32; // ` `.charCodeAt(0);

      exports.space = space;
      var singleQuote = 39; // `'`.charCodeAt(0);

      exports.singleQuote = singleQuote;
      var doubleQuote = 34; // `"`.charCodeAt(0);

      exports.doubleQuote = doubleQuote;
      var slash = 47; // `/`.charCodeAt(0);

      exports.slash = slash;
      var bang = 33; // `!`.charCodeAt(0);

      exports.bang = bang;
      var backslash = 92; // '\\'.charCodeAt(0);

      exports.backslash = backslash;
      var cr = 13; // '\r'.charCodeAt(0);

      exports.cr = cr;
      var feed = 12; // '\f'.charCodeAt(0);

      exports.feed = feed;
      var newline = 10; // '\n'.charCodeAt(0);

      exports.newline = newline;
      var tab = 9; // '\t'.charCodeAt(0);
      // Expose aliases primarily for readability.

      exports.tab = tab;
      var str = singleQuote; // No good single character representation!

      exports.str = str;
      var comment = -1;
      exports.comment = comment;
      var word = -2;
      exports.word = word;
      var combinator = -3;
      exports.combinator = combinator;
    }, {}], 77: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = tokenize;
      exports.FIELDS = void 0;

      var t = _interopRequireWildcard(require("./tokenTypes"));

      var _unescapable, _wordDelimiters;

      function _getRequireWildcardCache() {if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {return cache;};return cache;}

      function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { "default": obj };}var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj["default"] = obj;if (cache) {cache.set(obj, newObj);}return newObj;}

      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";

      for (var i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      /**
       *  Returns the last index of the bar css word
       * @param {string} css The string in which the word begins
       * @param {number} start The index into the string where word's first letter occurs
       */


      function consumeWord(css, start) {
        var next = start;
        var code;

        do {
          code = css.charCodeAt(next);

          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            // All other characters are part of the word
            next++;
          }
        } while (next < css.length);

        return next - 1;
      }
      /**
       *  Returns the last index of the escape sequence
       * @param {string} css The string in which the sequence begins
       * @param {number} start The index into the string where escape character (`\`) occurs.
       */


      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);

        if (unescapable[code]) {// just consume the escape char
        } else if (hex[code]) {
          var hexDigits = 0; // consume up to 6 hex chars

          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          // the next char is part of the current word
          next++;
        }

        return next;
      }

      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6 };

      exports.FIELDS = FIELDS;

      function tokenize(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css,
        length = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

        function unclosed(what, fix) {
          if (input.safe) {
            // fyi: this is never set to true.
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error('Unclosed ' + what, line, start - offset, start);
          }
        }

        while (start < length) {
          code = css.charCodeAt(start);

          if (code === t.newline) {
            offset = start;
            line += 1;
          }

          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);

                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

              tokenType = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;

            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;

              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            // Consume these characters as single tokens.

            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;

              do {
                escaped = false;
                next = css.indexOf(quote, next + 1);

                if (next === -1) {
                  unclosed('quote', quote);
                }

                escapePos = next;

                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);

              tokenType = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;

            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf('*/', start + 2) + 1;

                if (next === 0) {
                  unclosed('comment', '*/');
                }

                content = css.slice(start, next + 1);
                lines = content.split('\n');
                last = lines.length - 1;

                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }

                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset;
              }

              end = next + 1;
              break;}
          // Ensure that the token structure remains consistent


          tokens.push([tokenType, // [0] Token type
          line, // [1] Starting line
          start - offset, // [2] Starting column
          endLine, // [3] Ending line
          endColumn, // [4] Ending column
          start, // [5] Start position / Source index
          end // [6] End position
          ]); // Reset offset for the next token

          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }

          start = end;
        }

        return tokens;
      }
    }, { "./tokenTypes": 76 }], 78: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = ensureObject;

      function ensureObject(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            obj[prop] = {};
          }

          obj = obj[prop];
        }
      }

      module.exports = exports.default;
    }, {}], 79: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = getProp;

      function getProp(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }

        while (props.length > 0) {
          var prop = props.shift();

          if (!obj[prop]) {
            return undefined;
          }

          obj = obj[prop];
        }

        return obj;
      }

      module.exports = exports.default;
    }, {}], 80: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

      var _unesc = _interopRequireDefault(require("./unesc"));

      exports.unesc = _unesc["default"];

      var _getProp = _interopRequireDefault(require("./getProp"));

      exports.getProp = _getProp["default"];

      var _ensureObject = _interopRequireDefault(require("./ensureObject"));

      exports.ensureObject = _ensureObject["default"];

      var _stripComments = _interopRequireDefault(require("./stripComments"));

      exports.stripComments = _stripComments["default"];

      function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { "default": obj };}
    }, { "./ensureObject": 78, "./getProp": 79, "./stripComments": 81, "./unesc": 82 }], 81: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = stripComments;

      function stripComments(str) {
        var s = "";
        var commentStart = str.indexOf("/*");
        var lastEnd = 0;

        while (commentStart >= 0) {
          s = s + str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);

          if (commentEnd < 0) {
            return s;
          }

          lastEnd = commentEnd + 2;
          commentStart = str.indexOf("/*", lastEnd);
        }

        s = s + str.slice(lastEnd);
        return s;
      }

      module.exports = exports.default;
    }, {}], 82: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;
      exports["default"] = unesc;

      // Many thanks for this post which made this migration much easier.
      // https://mathiasbynens.be/notes/css-escapes

      /**
       * 
       * @param {string} str 
       * @returns {[string, number]|undefined}
       */
      function gobbleHex(str) {
        var lower = str.toLowerCase();
        var hex = '';
        var spaceTerminated = false;

        for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
          var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

          spaceTerminated = code === 32;

          if (!valid) {
            break;
          }

          hex += lower[i];
        }

        if (hex.length === 0) {
          return undefined;
        }

        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
        // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
        // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

        if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }

        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }

      var CONTAINS_ESCAPE = /\\/;

      function unesc(str) {
        var needToProcess = CONTAINS_ESCAPE.test(str);

        if (!needToProcess) {
          return str;
        }

        var ret = "";

        for (var i = 0; i < str.length; i++) {
          if (str[i] === "\\") {
            var gobbled = gobbleHex(str.slice(i + 1, i + 7));

            if (gobbled !== undefined) {
              ret += gobbled[0];
              i += gobbled[1];
              continue;
            } // Retain a pair of \\ if double escaped `\\\\`
            // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


            if (str[i + 1] === "\\") {
              ret += "\\";
              i++;
              continue;
            } // if \\ is at the end of the string retain it
            // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


            if (str.length === i + 1) {
              ret += str[i];
            }

            continue;
          }

          ret += str[i];
        }

        return ret;
      }

      module.exports = exports.default;
    }, {}], 83: [function (require, module, exports) {
      var parse = require("./parse");
      var walk = require("./walk");
      var stringify = require("./stringify");

      function ValueParser(value) {
        if (this instanceof ValueParser) {
          this.nodes = parse(value);
          return this;
        }
        return new ValueParser(value);
      }

      ValueParser.prototype.toString = function () {
        return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
      };

      ValueParser.prototype.walk = function (cb, bubble) {
        walk(this.nodes, cb, bubble);
        return this;
      };

      ValueParser.unit = require("./unit");

      ValueParser.walk = walk;

      ValueParser.stringify = stringify;

      module.exports = ValueParser;

    }, { "./parse": 84, "./stringify": 85, "./unit": 86, "./walk": 87 }], 84: [function (require, module, exports) {
      var openParentheses = "(".charCodeAt(0);
      var closeParentheses = ")".charCodeAt(0);
      var singleQuote = "'".charCodeAt(0);
      var doubleQuote = '"'.charCodeAt(0);
      var backslash = "\\".charCodeAt(0);
      var slash = "/".charCodeAt(0);
      var comma = ",".charCodeAt(0);
      var colon = ":".charCodeAt(0);
      var star = "*".charCodeAt(0);
      var uLower = "u".charCodeAt(0);
      var uUpper = "U".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var isUnicodeRange = /^[a-f0-9?-]+$/i;

      module.exports = function (input) {
        var tokens = [];
        var value = input;

        var next,
        quote,
        prev,
        token,
        escape,
        escapePos,
        whitespacePos,
        parenthesesOpenPos;
        var pos = 0;
        var code = value.charCodeAt(pos);
        var max = value.length;
        var stack = [{ nodes: tokens }];
        var balanced = 0;
        var parent;

        var name = "";
        var before = "";
        var after = "";

        while (pos < max) {
          // Whitespaces
          if (code <= 32) {
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            token = value.slice(pos, next);

            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
              after = token;
            } else if (prev && prev.type === "div") {
              prev.after = token;
              prev.sourceEndIndex += token.length;
            } else if (
            code === comma ||
            code === colon ||
            code === slash &&
            value.charCodeAt(next + 1) !== star && (
            !parent ||
            parent && parent.type === "function" && parent.value !== "calc"))
            {
              before = token;
            } else {
              tokens.push({
                type: "space",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            }

            pos = next;

            // Quotes
          } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
              type: "string",
              sourceIndex: pos,
              quote: quote };

            do {
              escape = false;
              next = value.indexOf(quote, next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape = !escape;
                }
              } else {
                value += quote;
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape);
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);

            // Comments
          } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);

            token = {
              type: "comment",
              sourceIndex: pos,
              sourceEndIndex: next + 2 };


            if (next === -1) {
              token.unclosed = true;
              next = value.length;
              token.sourceEndIndex = next;
            }

            token.value = value.slice(pos + 2, next);
            tokens.push(token);

            pos = next + 2;
            code = value.charCodeAt(pos);

            // Operation within calc
          } else if (
          (code === slash || code === star) &&
          parent &&
          parent.type === "function" &&
          parent.value === "calc")
          {
            token = value[pos];
            tokens.push({
              type: "word",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token });

            pos += 1;
            code = value.charCodeAt(pos);

            // Dividers
          } else if (code === slash || code === comma || code === colon) {
            token = value[pos];

            tokens.push({
              type: "div",
              sourceIndex: pos - before.length,
              sourceEndIndex: pos + token.length,
              value: token,
              before: before,
              after: "" });

            before = "";

            pos += 1;
            code = value.charCodeAt(pos);

            // Open parentheses
          } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
              next += 1;
              code = value.charCodeAt(next);
            } while (code <= 32);
            parenthesesOpenPos = pos;
            token = {
              type: "function",
              sourceIndex: pos - name.length,
              value: name,
              before: value.slice(parenthesesOpenPos + 1, next) };

            pos = next;

            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
              next -= 1;
              do {
                escape = false;
                next = value.indexOf(")", next + 1);
                if (~next) {
                  escapePos = next;
                  while (value.charCodeAt(escapePos - 1) === backslash) {
                    escapePos -= 1;
                    escape = !escape;
                  }
                } else {
                  value += ")";
                  next = value.length - 1;
                  token.unclosed = true;
                }
              } while (escape);
              // Whitespaces before closed
              whitespacePos = next;
              do {
                whitespacePos -= 1;
                code = value.charCodeAt(whitespacePos);
              } while (code <= 32);
              if (parenthesesOpenPos < whitespacePos) {
                if (pos !== whitespacePos + 1) {
                  token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value.slice(pos, whitespacePos + 1) }];


                } else {
                  token.nodes = [];
                }
                if (token.unclosed && whitespacePos + 1 !== next) {
                  token.after = "";
                  token.nodes.push({
                    type: "space",
                    sourceIndex: whitespacePos + 1,
                    sourceEndIndex: next,
                    value: value.slice(whitespacePos + 1, next) });

                } else {
                  token.after = value.slice(whitespacePos + 1, next);
                  token.sourceEndIndex = next;
                }
              } else {
                token.after = "";
                token.nodes = [];
              }
              pos = next + 1;
              token.sourceEndIndex = token.unclosed ? next : pos;
              code = value.charCodeAt(pos);
              tokens.push(token);
            } else {
              balanced += 1;
              token.after = "";
              token.sourceEndIndex = pos + 1;
              tokens.push(token);
              stack.push(token);
              tokens = token.nodes = [];
              parent = token;
            }
            name = "";

            // Close parentheses
          } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);

            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;

            // Words
          } else {
            next = pos;
            do {
              if (code === backslash) {
                next += 1;
              }
              next += 1;
              code = value.charCodeAt(next);
            } while (
            next < max &&
            !(
            code <= 32 ||
            code === singleQuote ||
            code === doubleQuote ||
            code === comma ||
            code === colon ||
            code === slash ||
            code === openParentheses ||
            code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === slash &&
            parent.type === "function" &&
            parent.value === "calc" ||
            code === closeParentheses && balanced));


            token = value.slice(pos, next);

            if (openParentheses === code) {
              name = token;
            } else if (
            (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
            plus === token.charCodeAt(1) &&
            isUnicodeRange.test(token.slice(2)))
            {
              tokens.push({
                type: "unicode-range",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            } else {
              tokens.push({
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: next,
                value: token });

            }

            pos = next;
          }
        }

        for (pos = stack.length - 1; pos; pos -= 1) {
          stack[pos].unclosed = true;
          stack[pos].sourceEndIndex = value.length;
        }

        return stack[0].nodes;
      };

    }, {}], 85: [function (require, module, exports) {
      function stringifyNode(node, custom) {
        var type = node.type;
        var value = node.value;
        var buf;
        var customResult;

        if (custom && (customResult = custom(node)) !== undefined) {
          return customResult;
        } else if (type === "word" || type === "space") {
          return value;
        } else if (type === "string") {
          buf = node.quote || "";
          return buf + value + (node.unclosed ? "" : buf);
        } else if (type === "comment") {
          return "/*" + value + (node.unclosed ? "" : "*/");
        } else if (type === "div") {
          return (node.before || "") + value + (node.after || "");
        } else if (Array.isArray(node.nodes)) {
          buf = stringify(node.nodes, custom);
          if (type !== "function") {
            return buf;
          }
          return (
            value +
            "(" + (
            node.before || "") +
            buf + (
            node.after || "") + (
            node.unclosed ? "" : ")"));

        }
        return value;
      }

      function stringify(nodes, custom) {
        var result, i;

        if (Array.isArray(nodes)) {
          result = "";
          for (i = nodes.length - 1; ~i; i -= 1) {
            result = stringifyNode(nodes[i], custom) + result;
          }
          return result;
        }
        return stringifyNode(nodes, custom);
      }

      module.exports = stringify;

    }, {}], 86: [function (require, module, exports) {
      var minus = "-".charCodeAt(0);
      var plus = "+".charCodeAt(0);
      var dot = ".".charCodeAt(0);
      var exp = "e".charCodeAt(0);
      var EXP = "E".charCodeAt(0);

      // Check if three code points would start a number
      // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
      function likeNumber(value) {
        var code = value.charCodeAt(0);
        var nextCode;

        if (code === plus || code === minus) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          var nextNextCode = value.charCodeAt(2);

          if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code === dot) {
          nextCode = value.charCodeAt(1);

          if (nextCode >= 48 && nextCode <= 57) {
            return true;
          }

          return false;
        }

        if (code >= 48 && code <= 57) {
          return true;
        }

        return false;
      }

      // Consume a number
      // https://www.w3.org/TR/css-syntax-3/#consume-number
      module.exports = function (value) {
        var pos = 0;
        var length = value.length;
        var code;
        var nextCode;
        var nextNextCode;

        if (length === 0 || !likeNumber(value)) {
          return false;
        }

        code = value.charCodeAt(pos);

        if (code === plus || code === minus) {
          pos++;
        }

        while (pos < length) {
          code = value.charCodeAt(pos);

          if (code < 48 || code > 57) {
            break;
          }

          pos += 1;
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);

        if (code === dot && nextCode >= 48 && nextCode <= 57) {
          pos += 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        code = value.charCodeAt(pos);
        nextCode = value.charCodeAt(pos + 1);
        nextNextCode = value.charCodeAt(pos + 2);

        if (
        (code === exp || code === EXP) && (
        nextCode >= 48 && nextCode <= 57 ||
        (nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
        {
          pos += nextCode === plus || nextCode === minus ? 3 : 2;

          while (pos < length) {
            code = value.charCodeAt(pos);

            if (code < 48 || code > 57) {
              break;
            }

            pos += 1;
          }
        }

        return {
          number: value.slice(0, pos),
          unit: value.slice(pos) };

      };

    }, {}], 87: [function (require, module, exports) {
      module.exports = function walk(nodes, cb, bubble) {
        var i, max, node, result;

        for (i = 0, max = nodes.length; i < max; i += 1) {
          node = nodes[i];
          if (!bubble) {
            result = cb(node, i, nodes);
          }

          if (
          result !== false &&
          node.type === "function" &&
          Array.isArray(node.nodes))
          {
            walk(node.nodes, cb, bubble);
          }

          if (bubble) {
            cb(node, i, nodes);
          }
        }
      };

    }, {}], 88: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      class AtRule extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'atrule';
        }

        append(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.append(...children);
        }

        prepend(...children) {
          if (!this.proxyOf.nodes) this.nodes = [];
          return super.prepend(...children);
        }}


      module.exports = AtRule;
      AtRule.default = AtRule;

      Container.registerAtRule(AtRule);

    }, { "./container": 90 }], 89: [function (require, module, exports) {
      'use strict';

      let Node = require('./node');

      class Comment extends Node {
        constructor(defaults) {
          super(defaults);
          this.type = 'comment';
        }}


      module.exports = Comment;
      Comment.default = Comment;

    }, { "./node": 100 }], 90: [function (require, module, exports) {
      'use strict';

      let { isClean, my } = require('./symbols');
      let Declaration = require('./declaration');
      let Comment = require('./comment');
      let Node = require('./node');

      let parse, Rule, AtRule;

      function cleanSource(nodes) {
        return nodes.map(i => {
          if (i.nodes) i.nodes = cleanSource(i.nodes);
          delete i.source;
          return i;
        });
      }

      function markDirtyUp(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i of node.proxyOf.nodes) {
            markDirtyUp(i);
          }
        }
      }

      class Container extends Node {
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }

        each(callback) {
          if (!this.proxyOf.nodes) return undefined;
          let iterator = this.getIterator();

          let index, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index], index);
            if (result === false) break;

            this.indexes[iterator] += 1;
          }

          delete this.indexes[iterator];
          return result;
        }

        walk(callback) {
          return this.each((child, i) => {
            let result;
            try {
              result = callback(child, i);
            } catch (e) {
              throw child.addToError(e);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }

            return result;
          });
        }

        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i) => {
              if (child.type === 'decl') {
                return callback(child, i);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'decl' && prop.test(child.prop)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'decl' && child.prop === prop) {
              return callback(child, i);
            }
          });
        }

        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;

            return this.walk((child, i) => {
              if (child.type === 'rule') {
                return callback(child, i);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'rule' && selector.test(child.selector)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'rule' && child.selector === selector) {
              return callback(child, i);
            }
          });
        }

        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i) => {
              if (child.type === 'atrule') {
                return callback(child, i);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i) => {
              if (child.type === 'atrule' && name.test(child.name)) {
                return callback(child, i);
              }
            });
          }
          return this.walk((child, i) => {
            if (child.type === 'atrule' && child.name === name) {
              return callback(child, i);
            }
          });
        }

        walkComments(callback) {
          return this.walk((child, i) => {
            if (child.type === 'comment') {
              return callback(child, i);
            }
          });
        }

        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes) this.proxyOf.nodes.push(node);
          }

          this.markDirty();

          return this;
        }

        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, 'prepend').reverse();
            for (let node of nodes) this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes) node.cleanRaws(keepBetween);
          }
        }

        insertBefore(exist, add) {
          exist = this.index(exist);

          let type = exist === 0 ? 'prepend' : false;
          let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();
          for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (exist <= index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        insertAfter(exist, add) {
          exist = this.index(exist);

          let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
          for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (exist < index) {
              this.indexes[id] = index + nodes.length;
            }
          }

          this.markDirty();

          return this;
        }

        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = undefined;
          this.proxyOf.nodes.splice(child, 1);

          let index;
          for (let id in this.indexes) {
            index = this.indexes[id];
            if (index >= child) {
              this.indexes[id] = index - 1;
            }
          }

          this.markDirty();

          return this;
        }

        removeAll() {
          for (let node of this.proxyOf.nodes) node.parent = undefined;
          this.proxyOf.nodes = [];

          this.markDirty();

          return this;
        }

        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }

          this.walkDecls(decl => {
            if (opts.props && !opts.props.includes(decl.prop)) return;
            if (opts.fast && !decl.value.includes(opts.fast)) return;

            decl.value = decl.value.replace(pattern, callback);
          });

          this.markDirty();

          return this;
        }

        every(condition) {
          return this.nodes.every(condition);
        }

        some(condition) {
          return this.nodes.some(condition);
        }

        index(child) {
          if (typeof child === 'number') return child;
          if (child.proxyOf) child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }

        get first() {
          if (!this.proxyOf.nodes) return undefined;
          return this.proxyOf.nodes[0];
        }

        get last() {
          if (!this.proxyOf.nodes) return undefined;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }

        normalize(nodes, sample) {
          if (typeof nodes === 'string') {
            nodes = cleanSource(parse(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, 'ignore');
            }
          } else if (nodes.type === 'root' && this.type !== 'document') {
            nodes = nodes.nodes.slice(0);
            for (let i of nodes) {
              if (i.parent) i.parent.removeChild(i, 'ignore');
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === 'undefined') {
              throw new Error('Value field is missed in node creation');
            } else if (typeof nodes.value !== 'string') {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment(nodes)];
          } else {
            throw new Error('Unknown node type in node creation');
          }

          let processed = nodes.map(i => {
            /* c8 ignore next */
            if (!i[my]) Container.rebuild(i);
            i = i.proxyOf;
            if (i.parent) i.parent.removeChild(i);
            if (i[isClean]) markDirtyUp(i);
            if (typeof i.raws.before === 'undefined') {
              if (sample && typeof sample.raws.before !== 'undefined') {
                i.raws.before = sample.raws.before.replace(/\S/g, '');
              }
            }
            i.parent = this;
            return i;
          });

          return processed;
        }

        getProxyProcessor() {
          return {
            set(node, prop, value) {
              if (node[prop] === value) return true;
              node[prop] = value;
              if (prop === 'name' || prop === 'params' || prop === 'selector') {
                node.markDirty();
              }
              return true;
            },

            get(node, prop) {
              if (prop === 'proxyOf') {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (
              prop === 'each' ||
              typeof prop === 'string' && prop.startsWith('walk'))
              {
                return (...args) => {
                  return node[prop](
                  ...args.map(i => {
                    if (typeof i === 'function') {
                      return (child, index) => i(child.toProxy(), index);
                    } else {
                      return i;
                    }
                  }));

                };
              } else if (prop === 'every' || prop === 'some') {
                return cb => {
                  return node[prop]((child, ...other) =>
                  cb(child.toProxy(), ...other));

                };
              } else if (prop === 'root') {
                return () => node.root().toProxy();
              } else if (prop === 'nodes') {
                return node.nodes.map(i => i.toProxy());
              } else if (prop === 'first' || prop === 'last') {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            } };

        }

        getIterator() {
          if (!this.lastEach) this.lastEach = 0;
          if (!this.indexes) this.indexes = {};

          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;

          return iterator;
        }}


      Container.registerParse = dependant => {
        parse = dependant;
      };

      Container.registerRule = dependant => {
        Rule = dependant;
      };

      Container.registerAtRule = dependant => {
        AtRule = dependant;
      };

      module.exports = Container;
      Container.default = Container;

      /* c8 ignore start */
      Container.rebuild = node => {
        if (node.type === 'atrule') {
          Object.setPrototypeOf(node, AtRule.prototype);
        } else if (node.type === 'rule') {
          Object.setPrototypeOf(node, Rule.prototype);
        } else if (node.type === 'decl') {
          Object.setPrototypeOf(node, Declaration.prototype);
        } else if (node.type === 'comment') {
          Object.setPrototypeOf(node, Comment.prototype);
        }

        node[my] = true;

        if (node.nodes) {
          node.nodes.forEach(child => {
            Container.rebuild(child);
          });
        }
      };
      /* c8 ignore stop */

    }, { "./comment": 89, "./declaration": 92, "./node": 100, "./symbols": 111 }], 91: [function (require, module, exports) {
      'use strict';

      let pico = require('picocolors');

      let terminalHighlight = require('./terminal-highlight');

      class CssSyntaxError extends Error {
        constructor(message, line, column, source, file, plugin) {
          super(message);
          this.name = 'CssSyntaxError';
          this.reason = message;

          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin) {
            this.plugin = plugin;
          }
          if (typeof line !== 'undefined' && typeof column !== 'undefined') {
            if (typeof line === 'number') {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }

          this.setMessage();

          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CssSyntaxError);
          }
        }

        setMessage() {
          this.message = this.plugin ? this.plugin + ': ' : '';
          this.message += this.file ? this.file : '<css input>';
          if (typeof this.line !== 'undefined') {
            this.message += ':' + this.line + ':' + this.column;
          }
          this.message += ': ' + this.reason;
        }

        showSourceCode(color) {
          if (!this.source) return '';

          let css = this.source;
          if (color == null) color = pico.isColorSupported;
          if (terminalHighlight) {
            if (color) css = terminalHighlight(css);
          }

          let lines = css.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);

          let maxWidth = String(end).length;

          let mark, aside;
          if (color) {
            let { bold, red, gray } = pico.createColors(true);
            mark = text => bold(red(text));
            aside = text => gray(text);
          } else {
            mark = aside = str => str;
          }

          return lines.
          slice(start, end).
          map((line, index) => {
            let number = start + 1 + index;
            let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
            if (number === this.line) {
              let spacing =
              aside(gutter.replace(/\d/g, ' ')) +
              line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
              return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
            }
            return ' ' + aside(gutter) + line;
          }).
          join('\n');
        }

        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = '\n\n' + code + '\n';
          }
          return this.name + ': ' + this.message + code;
        }}


      module.exports = CssSyntaxError;
      CssSyntaxError.default = CssSyntaxError;

    }, { "./terminal-highlight": 4, "picocolors": 45 }], 92: [function (require, module, exports) {
      'use strict';

      let Node = require('./node');

      class Declaration extends Node {
        constructor(defaults) {
          if (
          defaults &&
          typeof defaults.value !== 'undefined' &&
          typeof defaults.value !== 'string')
          {
            defaults = _extends({}, defaults, { value: String(defaults.value) });
          }
          super(defaults);
          this.type = 'decl';
        }

        get variable() {
          return this.prop.startsWith('--') || this.prop[0] === '$';
        }}


      module.exports = Declaration;
      Declaration.default = Declaration;

    }, { "./node": 100 }], 93: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      let LazyResult, Processor;

      class Document extends Container {
        constructor(defaults) {
          // type needs to be passed to super, otherwise child roots won't be normalized correctly
          super(_extends({ type: 'document' }, defaults));

          if (!this.nodes) {
            this.nodes = [];
          }
        }

        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);

          return lazy.stringify();
        }}


      Document.registerLazyResult = dependant => {
        LazyResult = dependant;
      };

      Document.registerProcessor = dependant => {
        Processor = dependant;
      };

      module.exports = Document;
      Document.default = Document;

    }, { "./container": 90 }], 94: [function (require, module, exports) {
      'use strict';

      let Declaration = require('./declaration');
      let PreviousMap = require('./previous-map');
      let Comment = require('./comment');
      let AtRule = require('./at-rule');
      let Input = require('./input');
      let Root = require('./root');
      let Rule = require('./rule');

      function fromJSON(json, inputs) {
        if (Array.isArray(json)) return json.map(n => fromJSON(n));

        let { inputs: ownInputs } = json,defaults = _objectWithoutPropertiesLoose(json, ["inputs"]);
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = _extends({}, input, { __proto__: Input.prototype });
            if (inputHydrated.map) {
              inputHydrated.map = _extends({},
              inputHydrated.map, {
                __proto__: PreviousMap.prototype });

            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults.nodes) {
          defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
        }
        if (defaults.source) {
          let _defaults$source = defaults.source,{ inputId } = _defaults$source,source = _objectWithoutPropertiesLoose(_defaults$source, ["inputId"]);
          defaults.source = source;
          if (inputId != null) {
            defaults.source.input = inputs[inputId];
          }
        }
        if (defaults.type === 'root') {
          return new Root(defaults);
        } else if (defaults.type === 'decl') {
          return new Declaration(defaults);
        } else if (defaults.type === 'rule') {
          return new Rule(defaults);
        } else if (defaults.type === 'comment') {
          return new Comment(defaults);
        } else if (defaults.type === 'atrule') {
          return new AtRule(defaults);
        } else {
          throw new Error('Unknown node type: ' + json.type);
        }
      }

      module.exports = fromJSON;
      fromJSON.default = fromJSON;

    }, { "./at-rule": 88, "./comment": 89, "./declaration": 92, "./input": 95, "./previous-map": 104, "./root": 107, "./rule": 108 }], 95: [function (require, module, exports) {
      'use strict';

      let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
      let { fileURLToPath, pathToFileURL } = require('url');
      let { resolve, isAbsolute } = require('path');
      let { nanoid } = require('nanoid/non-secure');

      let terminalHighlight = require('./terminal-highlight');
      let CssSyntaxError = require('./css-syntax-error');
      let PreviousMap = require('./previous-map');

      let fromOffsetCache = Symbol('fromOffsetCache');

      let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      let pathAvailable = Boolean(resolve && isAbsolute);

      class Input {
        constructor(css, opts = {}) {
          if (
          css === null ||
          typeof css === 'undefined' ||
          typeof css === 'object' && !css.toString)
          {
            throw new Error(`PostCSS received ${css} instead of CSS string`);
          }

          this.css = css.toString();

          if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }

          if (opts.from) {
            if (
            !pathAvailable ||
            /^\w+:\/\//.test(opts.from) ||
            isAbsolute(opts.from))
            {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }

          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
          }

          if (!this.file) {
            this.id = '<input css ' + nanoid(6) + '>';
          }
          if (this.map) this.map.file = this.from;
        }

        fromOffset(offset) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split('\n');
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;

            for (let i = 0, l = lines.length; i < l; i++) {
              lineToIndex[i] = prevIndex;
              prevIndex += lines[i].length + 1;
            }

            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];

          let min = 0;
          if (offset >= lastLine) {
            min = lineToIndex.length - 1;
          } else {
            let max = lineToIndex.length - 2;
            let mid;
            while (min < max) {
              mid = min + (max - min >> 1);
              if (offset < lineToIndex[mid]) {
                max = mid - 1;
              } else if (offset >= lineToIndex[mid + 1]) {
                min = mid + 1;
              } else {
                min = mid;
                break;
              }
            }
          }
          return {
            line: min + 1,
            col: offset - lineToIndex[min] + 1 };

        }

        error(message, line, column, opts = {}) {
          let result, endLine, endColumn;

          if (line && typeof line === 'object') {
            let start = line;
            let end = column;
            if (typeof line.offset === 'number') {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === 'number') {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }

          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError(
            message,
            origin.endLine === undefined ?
            origin.line :
            { line: origin.line, column: origin.column },
            origin.endLine === undefined ?
            origin.column :
            { line: origin.endLine, column: origin.endColumn },
            origin.source,
            origin.file,
            opts.plugin);

          } else {
            result = new CssSyntaxError(
            message,
            endLine === undefined ? line : { line, column },
            endLine === undefined ? column : { line: endLine, column: endColumn },
            this.css,
            this.file,
            opts.plugin);

          }

          result.input = { line, column, endLine, endColumn, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }

          return result;
        }

        origin(line, column, endLine, endColumn) {
          if (!this.map) return false;
          let consumer = this.map.consumer();

          let from = consumer.originalPositionFor({ line, column });
          if (!from.source) return false;

          let to;
          if (typeof endLine === 'number') {
            to = consumer.originalPositionFor({ line: endLine, column: endColumn });
          }

          let fromUrl;

          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));

          }

          let result = {
            url: fromUrl.toString(),
            line: from.line,
            column: from.column,
            endLine: to && to.line,
            endColumn: to && to.column };


          if (fromUrl.protocol === 'file:') {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              /* c8 ignore next 2 */
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }

          let source = consumer.sourceContentFor(from.source);
          if (source) result.source = source;

          return result;
        }

        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);
        }

        get from() {
          return this.file || this.id;
        }

        toJSON() {
          let json = {};
          for (let name of ['hasBOM', 'css', 'file', 'id']) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = _extends({}, this.map);
            if (json.map.consumerCache) {
              json.map.consumerCache = undefined;
            }
          }
          return json;
        }}


      module.exports = Input;
      Input.default = Input;

      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input);
      }

    }, { "./css-syntax-error": 91, "./previous-map": 104, "./terminal-highlight": 4, "nanoid/non-secure": 41, "path": 4, "source-map-js": 4, "url": 4 }], 96: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          let { isClean, my } = require('./symbols');
          let MapGenerator = require('./map-generator');
          let stringify = require('./stringify');
          let Container = require('./container');
          let Document = require('./document');
          let warnOnce = require('./warn-once');
          let Result = require('./result');
          let parse = require('./parse');
          let Root = require('./root');

          const TYPE_TO_CLASS_NAME = {
            document: 'Document',
            root: 'Root',
            atrule: 'AtRule',
            rule: 'Rule',
            decl: 'Declaration',
            comment: 'Comment' };


          const PLUGIN_PROPS = {
            postcssPlugin: true,
            prepare: true,
            Once: true,
            Document: true,
            Root: true,
            Declaration: true,
            Rule: true,
            AtRule: true,
            Comment: true,
            DeclarationExit: true,
            RuleExit: true,
            AtRuleExit: true,
            CommentExit: true,
            RootExit: true,
            DocumentExit: true,
            OnceExit: true };


          const NOT_VISITORS = {
            postcssPlugin: true,
            prepare: true,
            Once: true };


          const CHILDREN = 0;

          function isPromise(obj) {
            return typeof obj === 'object' && typeof obj.then === 'function';
          }

          function getEvents(node) {
            let key = false;
            let type = TYPE_TO_CLASS_NAME[node.type];
            if (node.type === 'decl') {
              key = node.prop.toLowerCase();
            } else if (node.type === 'atrule') {
              key = node.name.toLowerCase();
            }

            if (key && node.append) {
              return [
              type,
              type + '-' + key,
              CHILDREN,
              type + 'Exit',
              type + 'Exit-' + key];

            } else if (key) {
              return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];
            } else if (node.append) {
              return [type, CHILDREN, type + 'Exit'];
            } else {
              return [type, type + 'Exit'];
            }
          }

          function toStack(node) {
            let events;
            if (node.type === 'document') {
              events = ['Document', CHILDREN, 'DocumentExit'];
            } else if (node.type === 'root') {
              events = ['Root', CHILDREN, 'RootExit'];
            } else {
              events = getEvents(node);
            }

            return {
              node,
              events,
              eventIndex: 0,
              visitors: [],
              visitorIndex: 0,
              iterator: 0 };

          }

          function cleanMarks(node) {
            node[isClean] = false;
            if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
            return node;
          }

          let postcss = {};

          class LazyResult {
            constructor(processor, css, opts) {
              this.stringified = false;
              this.processed = false;

              let root;
              if (
              typeof css === 'object' &&
              css !== null && (
              css.type === 'root' || css.type === 'document'))
              {
                root = cleanMarks(css);
              } else if (css instanceof LazyResult || css instanceof Result) {
                root = cleanMarks(css.root);
                if (css.map) {
                  if (typeof opts.map === 'undefined') opts.map = {};
                  if (!opts.map.inline) opts.map.inline = false;
                  opts.map.prev = css.map;
                }
              } else {
                let parser = parse;
                if (opts.syntax) parser = opts.syntax.parse;
                if (opts.parser) parser = opts.parser;
                if (parser.parse) parser = parser.parse;

                try {
                  root = parser(css, opts);
                } catch (error) {
                  this.processed = true;
                  this.error = error;
                }

                if (root && !root[my]) {
                  /* c8 ignore next 2 */
                  Container.rebuild(root);
                }
              }

              this.result = new Result(processor, root, opts);
              this.helpers = _extends({}, postcss, { result: this.result, postcss });
              this.plugins = this.processor.plugins.map(plugin => {
                if (typeof plugin === 'object' && plugin.prepare) {
                  return _extends({}, plugin, plugin.prepare(this.result));
                } else {
                  return plugin;
                }
              });
            }

            get [Symbol.toStringTag]() {
              return 'LazyResult';
            }

            get processor() {
              return this.result.processor;
            }

            get opts() {
              return this.result.opts;
            }

            get css() {
              return this.stringify().css;
            }

            get content() {
              return this.stringify().content;
            }

            get map() {
              return this.stringify().map;
            }

            get root() {
              return this.sync().root;
            }

            get messages() {
              return this.sync().messages;
            }

            warnings() {
              return this.sync().warnings();
            }

            toString() {
              return this.css;
            }

            then(onFulfilled, onRejected) {
              if (process.env.NODE_ENV !== 'production') {
                if (!('from' in this.opts)) {
                  warnOnce(
                  'Without `from` option PostCSS could generate wrong source map ' +
                  'and will not find Browserslist config. Set it to CSS file path ' +
                  'or to `undefined` to prevent this warning.');

                }
              }
              return this.async().then(onFulfilled, onRejected);
            }

            catch(onRejected) {
              return this.async().catch(onRejected);
            }

            finally(onFinally) {
              return this.async().then(onFinally, onFinally);
            }

            async() {
              if (this.error) return Promise.reject(this.error);
              if (this.processed) return Promise.resolve(this.result);
              if (!this.processing) {
                this.processing = this.runAsync();
              }
              return this.processing;
            }

            sync() {
              if (this.error) throw this.error;
              if (this.processed) return this.result;
              this.processed = true;

              if (this.processing) {
                throw this.getAsyncError();
              }

              for (let plugin of this.plugins) {
                let promise = this.runOnRoot(plugin);
                if (isPromise(promise)) {
                  throw this.getAsyncError();
                }
              }

              this.prepareVisitors();
              if (this.hasListener) {
                let root = this.result.root;
                while (!root[isClean]) {
                  root[isClean] = true;
                  this.walkSync(root);
                }
                if (this.listeners.OnceExit) {
                  if (root.type === 'document') {
                    for (let subRoot of root.nodes) {
                      this.visitSync(this.listeners.OnceExit, subRoot);
                    }
                  } else {
                    this.visitSync(this.listeners.OnceExit, root);
                  }
                }
              }

              return this.result;
            }

            stringify() {
              if (this.error) throw this.error;
              if (this.stringified) return this.result;
              this.stringified = true;

              this.sync();

              let opts = this.result.opts;
              let str = stringify;
              if (opts.syntax) str = opts.syntax.stringify;
              if (opts.stringifier) str = opts.stringifier;
              if (str.stringify) str = str.stringify;

              let map = new MapGenerator(str, this.result.root, this.result.opts);
              let data = map.generate();
              this.result.css = data[0];
              this.result.map = data[1];

              return this.result;
            }

            walkSync(node) {
              node[isClean] = true;
              let events = getEvents(node);
              for (let event of events) {
                if (event === CHILDREN) {
                  if (node.nodes) {
                    node.each(child => {
                      if (!child[isClean]) this.walkSync(child);
                    });
                  }
                } else {
                  let visitors = this.listeners[event];
                  if (visitors) {
                    if (this.visitSync(visitors, node.toProxy())) return;
                  }
                }
              }
            }

            visitSync(visitors, node) {
              for (let [plugin, visitor] of visitors) {
                this.result.lastPlugin = plugin;
                let promise;
                try {
                  promise = visitor(node, this.helpers);
                } catch (e) {
                  throw this.handleError(e, node.proxyOf);
                }
                if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
                  return true;
                }
                if (isPromise(promise)) {
                  throw this.getAsyncError();
                }
              }
            }

            runOnRoot(plugin) {
              this.result.lastPlugin = plugin;
              try {
                if (typeof plugin === 'object' && plugin.Once) {
                  if (this.result.root.type === 'document') {
                    let roots = this.result.root.nodes.map((root) =>
                    plugin.Once(root, this.helpers));


                    if (isPromise(roots[0])) {
                      return Promise.all(roots);
                    }

                    return roots;
                  }

                  return plugin.Once(this.result.root, this.helpers);
                } else if (typeof plugin === 'function') {
                  return plugin(this.result.root, this.result);
                }
              } catch (error) {
                throw this.handleError(error);
              }
            }

            getAsyncError() {
              throw new Error('Use process(css).then(cb) to work with async plugins');
            }

            handleError(error, node) {
              let plugin = this.result.lastPlugin;
              try {
                if (node) node.addToError(error);
                this.error = error;
                if (error.name === 'CssSyntaxError' && !error.plugin) {
                  error.plugin = plugin.postcssPlugin;
                  error.setMessage();
                } else if (plugin.postcssVersion) {
                  if (process.env.NODE_ENV !== 'production') {
                    let pluginName = plugin.postcssPlugin;
                    let pluginVer = plugin.postcssVersion;
                    let runtimeVer = this.result.processor.version;
                    let a = pluginVer.split('.');
                    let b = runtimeVer.split('.');

                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                      // eslint-disable-next-line no-console
                      console.error(
                      'Unknown error from PostCSS plugin. Your current PostCSS ' +
                      'version is ' +
                      runtimeVer +
                      ', but ' +
                      pluginName +
                      ' uses ' +
                      pluginVer +
                      '. Perhaps this is the source of the error below.');

                    }
                  }
                }
              } catch (err) {
                /* c8 ignore next 3 */
                // eslint-disable-next-line no-console
                if (console && console.error) console.error(err);
              }
              return error;
            }

            async runAsync() {
              this.plugin = 0;
              for (let i = 0; i < this.plugins.length; i++) {
                let plugin = this.plugins[i];
                let promise = this.runOnRoot(plugin);
                if (isPromise(promise)) {
                  try {
                    await promise;
                  } catch (error) {
                    throw this.handleError(error);
                  }
                }
              }

              this.prepareVisitors();
              if (this.hasListener) {
                let root = this.result.root;
                while (!root[isClean]) {
                  root[isClean] = true;
                  let stack = [toStack(root)];
                  while (stack.length > 0) {
                    let promise = this.visitTick(stack);
                    if (isPromise(promise)) {
                      try {
                        await promise;
                      } catch (e) {
                        let node = stack[stack.length - 1].node;
                        throw this.handleError(e, node);
                      }
                    }
                  }
                }

                if (this.listeners.OnceExit) {
                  for (let [plugin, visitor] of this.listeners.OnceExit) {
                    this.result.lastPlugin = plugin;
                    try {
                      if (root.type === 'document') {
                        let roots = root.nodes.map((subRoot) =>
                        visitor(subRoot, this.helpers));


                        await Promise.all(roots);
                      } else {
                        await visitor(root, this.helpers);
                      }
                    } catch (e) {
                      throw this.handleError(e);
                    }
                  }
                }
              }

              this.processed = true;
              return this.stringify();
            }

            prepareVisitors() {
              this.listeners = {};
              let add = (plugin, type, cb) => {
                if (!this.listeners[type]) this.listeners[type] = [];
                this.listeners[type].push([plugin, cb]);
              };
              for (let plugin of this.plugins) {
                if (typeof plugin === 'object') {
                  for (let event in plugin) {
                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                      throw new Error(
                      `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                      `Try to update PostCSS (${this.processor.version} now).`);

                    }
                    if (!NOT_VISITORS[event]) {
                      if (typeof plugin[event] === 'object') {
                        for (let filter in plugin[event]) {
                          if (filter === '*') {
                            add(plugin, event, plugin[event][filter]);
                          } else {
                            add(
                            plugin,
                            event + '-' + filter.toLowerCase(),
                            plugin[event][filter]);

                          }
                        }
                      } else if (typeof plugin[event] === 'function') {
                        add(plugin, event, plugin[event]);
                      }
                    }
                  }
                }
              }
              this.hasListener = Object.keys(this.listeners).length > 0;
            }

            visitTick(stack) {
              let visit = stack[stack.length - 1];
              let { node, visitors } = visit;

              if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
                stack.pop();
                return;
              }

              if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
                let [plugin, visitor] = visitors[visit.visitorIndex];
                visit.visitorIndex += 1;
                if (visit.visitorIndex === visitors.length) {
                  visit.visitors = [];
                  visit.visitorIndex = 0;
                }
                this.result.lastPlugin = plugin;
                try {
                  return visitor(node.toProxy(), this.helpers);
                } catch (e) {
                  throw this.handleError(e, node);
                }
              }

              if (visit.iterator !== 0) {
                let iterator = visit.iterator;
                let child;
                while (child = node.nodes[node.indexes[iterator]]) {
                  node.indexes[iterator] += 1;
                  if (!child[isClean]) {
                    child[isClean] = true;
                    stack.push(toStack(child));
                    return;
                  }
                }
                visit.iterator = 0;
                delete node.indexes[iterator];
              }

              let events = visit.events;
              while (visit.eventIndex < events.length) {
                let event = events[visit.eventIndex];
                visit.eventIndex += 1;
                if (event === CHILDREN) {
                  if (node.nodes && node.nodes.length) {
                    node[isClean] = true;
                    visit.iterator = node.getIterator();
                  }
                  return;
                } else if (this.listeners[event]) {
                  visit.visitors = this.listeners[event];
                  return;
                }
              }
              stack.pop();
            }}


          LazyResult.registerPostcss = dependant => {
            postcss = dependant;
          };

          module.exports = LazyResult;
          LazyResult.default = LazyResult;

          Root.registerLazyResult(LazyResult);
          Document.registerLazyResult(LazyResult);

        }).call(this);}).call(this, require('_process'));
    }, { "./container": 90, "./document": 93, "./map-generator": 98, "./parse": 101, "./result": 106, "./root": 107, "./stringify": 110, "./symbols": 111, "./warn-once": 113, "_process": 115 }], 97: [function (require, module, exports) {
      'use strict';

      let list = {
        split(string, separators, last) {
          let array = [];
          let current = '';
          let split = false;

          let func = 0;
          let quote = false;
          let escape = false;

          for (let letter of string) {
            if (escape) {
              escape = false;
            } else if (letter === '\\') {
              escape = true;
            } else if (quote) {
              if (letter === quote) {
                quote = false;
              }
            } else if (letter === '"' || letter === "'") {
              quote = letter;
            } else if (letter === '(') {
              func += 1;
            } else if (letter === ')') {
              if (func > 0) func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter)) split = true;
            }

            if (split) {
              if (current !== '') array.push(current.trim());
              current = '';
              split = false;
            } else {
              current += letter;
            }
          }

          if (last || current !== '') array.push(current.trim());
          return array;
        },

        space(string) {
          let spaces = [' ', '\n', '\t'];
          return list.split(string, spaces);
        },

        comma(string) {
          return list.split(string, [','], true);
        } };


      module.exports = list;
      list.default = list;

    }, {}], 98: [function (require, module, exports) {
      (function (Buffer) {(function () {
          'use strict';

          let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
          let { dirname, resolve, relative, sep } = require('path');
          let { pathToFileURL } = require('url');

          let Input = require('./input');

          let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
          let pathAvailable = Boolean(dirname && resolve && relative && sep);

          class MapGenerator {
            constructor(stringify, root, opts, cssString) {
              this.stringify = stringify;
              this.mapOpts = opts.map || {};
              this.root = root;
              this.opts = opts;
              this.css = cssString;
            }

            isMap() {
              if (typeof this.opts.map !== 'undefined') {
                return !!this.opts.map;
              }
              return this.previous().length > 0;
            }

            previous() {
              if (!this.previousMaps) {
                this.previousMaps = [];
                if (this.root) {
                  this.root.walk(node => {
                    if (node.source && node.source.input.map) {
                      let map = node.source.input.map;
                      if (!this.previousMaps.includes(map)) {
                        this.previousMaps.push(map);
                      }
                    }
                  });
                } else {
                  let input = new Input(this.css, this.opts);
                  if (input.map) this.previousMaps.push(input.map);
                }
              }

              return this.previousMaps;
            }

            isInline() {
              if (typeof this.mapOpts.inline !== 'undefined') {
                return this.mapOpts.inline;
              }

              let annotation = this.mapOpts.annotation;
              if (typeof annotation !== 'undefined' && annotation !== true) {
                return false;
              }

              if (this.previous().length) {
                return this.previous().some(i => i.inline);
              }
              return true;
            }

            isSourcesContent() {
              if (typeof this.mapOpts.sourcesContent !== 'undefined') {
                return this.mapOpts.sourcesContent;
              }
              if (this.previous().length) {
                return this.previous().some(i => i.withContent());
              }
              return true;
            }

            clearAnnotation() {
              if (this.mapOpts.annotation === false) return;

              if (this.root) {
                let node;
                for (let i = this.root.nodes.length - 1; i >= 0; i--) {
                  node = this.root.nodes[i];
                  if (node.type !== 'comment') continue;
                  if (node.text.indexOf('# sourceMappingURL=') === 0) {
                    this.root.removeChild(i);
                  }
                }
              } else if (this.css) {
                this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '');
              }
            }

            setSourcesContent() {
              let already = {};
              if (this.root) {
                this.root.walk(node => {
                  if (node.source) {
                    let from = node.source.input.from;
                    if (from && !already[from]) {
                      already[from] = true;
                      this.map.setSourceContent(
                      this.toUrl(this.path(from)),
                      node.source.input.css);

                    }
                  }
                });
              } else if (this.css) {
                let from = this.opts.from ?
                this.toUrl(this.path(this.opts.from)) :
                '<no source>';
                this.map.setSourceContent(from, this.css);
              }
            }

            applyPrevMaps() {
              for (let prev of this.previous()) {
                let from = this.toUrl(this.path(prev.file));
                let root = prev.root || dirname(prev.file);
                let map;

                if (this.mapOpts.sourcesContent === false) {
                  map = new SourceMapConsumer(prev.text);
                  if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(() => null);
                  }
                } else {
                  map = prev.consumer();
                }

                this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
              }
            }

            isAnnotation() {
              if (this.isInline()) {
                return true;
              }
              if (typeof this.mapOpts.annotation !== 'undefined') {
                return this.mapOpts.annotation;
              }
              if (this.previous().length) {
                return this.previous().some(i => i.annotation);
              }
              return true;
            }

            toBase64(str) {
              if (Buffer) {
                return Buffer.from(str).toString('base64');
              } else {
                return window.btoa(unescape(encodeURIComponent(str)));
              }
            }

            addAnnotation() {
              let content;

              if (this.isInline()) {
                content =
                'data:application/json;base64,' + this.toBase64(this.map.toString());
              } else if (typeof this.mapOpts.annotation === 'string') {
                content = this.mapOpts.annotation;
              } else if (typeof this.mapOpts.annotation === 'function') {
                content = this.mapOpts.annotation(this.opts.to, this.root);
              } else {
                content = this.outputFile() + '.map';
              }
              let eol = '\n';
              if (this.css.includes('\r\n')) eol = '\r\n';

              this.css += eol + '/*# sourceMappingURL=' + content + ' */';
            }

            outputFile() {
              if (this.opts.to) {
                return this.path(this.opts.to);
              } else if (this.opts.from) {
                return this.path(this.opts.from);
              } else {
                return 'to.css';
              }
            }

            generateMap() {
              if (this.root) {
                this.generateString();
              } else if (this.previous().length === 1) {
                let prev = this.previous()[0].consumer();
                prev.file = this.outputFile();
                this.map = SourceMapGenerator.fromSourceMap(prev);
              } else {
                this.map = new SourceMapGenerator({ file: this.outputFile() });
                this.map.addMapping({
                  source: this.opts.from ?
                  this.toUrl(this.path(this.opts.from)) :
                  '<no source>',
                  generated: { line: 1, column: 0 },
                  original: { line: 1, column: 0 } });

              }

              if (this.isSourcesContent()) this.setSourcesContent();
              if (this.root && this.previous().length > 0) this.applyPrevMaps();
              if (this.isAnnotation()) this.addAnnotation();

              if (this.isInline()) {
                return [this.css];
              } else {
                return [this.css, this.map];
              }
            }

            path(file) {
              if (file.indexOf('<') === 0) return file;
              if (/^\w+:\/\//.test(file)) return file;
              if (this.mapOpts.absolute) return file;

              let from = this.opts.to ? dirname(this.opts.to) : '.';

              if (typeof this.mapOpts.annotation === 'string') {
                from = dirname(resolve(from, this.mapOpts.annotation));
              }

              file = relative(from, file);
              return file;
            }

            toUrl(path) {
              if (sep === '\\') {
                path = path.replace(/\\/g, '/');
              }
              return encodeURI(path).replace(/[#?]/g, encodeURIComponent);
            }

            sourcePath(node) {
              if (this.mapOpts.from) {
                return this.toUrl(this.mapOpts.from);
              } else if (this.mapOpts.absolute) {
                if (pathToFileURL) {
                  return pathToFileURL(node.source.input.from).toString();
                } else {
                  throw new Error(
                  '`map.absolute` option is not available in this PostCSS build');

                }
              } else {
                return this.toUrl(this.path(node.source.input.from));
              }
            }

            generateString() {
              this.css = '';
              this.map = new SourceMapGenerator({ file: this.outputFile() });

              let line = 1;
              let column = 1;

              let noSource = '<no source>';
              let mapping = {
                source: '',
                generated: { line: 0, column: 0 },
                original: { line: 0, column: 0 } };


              let lines, last;
              this.stringify(this.root, (str, node, type) => {
                this.css += str;

                if (node && type !== 'end') {
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  if (node.source && node.source.start) {
                    mapping.source = this.sourcePath(node);
                    mapping.original.line = node.source.start.line;
                    mapping.original.column = node.source.start.column - 1;
                    this.map.addMapping(mapping);
                  } else {
                    mapping.source = noSource;
                    mapping.original.line = 1;
                    mapping.original.column = 0;
                    this.map.addMapping(mapping);
                  }
                }

                lines = str.match(/\n/g);
                if (lines) {
                  line += lines.length;
                  last = str.lastIndexOf('\n');
                  column = str.length - last;
                } else {
                  column += str.length;
                }

                if (node && type !== 'start') {
                  let p = node.parent || { raws: {} };
                  if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
                    if (node.source && node.source.end) {
                      mapping.source = this.sourcePath(node);
                      mapping.original.line = node.source.end.line;
                      mapping.original.column = node.source.end.column - 1;
                      mapping.generated.line = line;
                      mapping.generated.column = column - 2;
                      this.map.addMapping(mapping);
                    } else {
                      mapping.source = noSource;
                      mapping.original.line = 1;
                      mapping.original.column = 0;
                      mapping.generated.line = line;
                      mapping.generated.column = column - 1;
                      this.map.addMapping(mapping);
                    }
                  }
                }
              });
            }

            generate() {
              this.clearAnnotation();
              if (pathAvailable && sourceMapAvailable && this.isMap()) {
                return this.generateMap();
              } else {
                let result = '';
                this.stringify(this.root, i => {
                  result += i;
                });
                return [result];
              }
            }}


          module.exports = MapGenerator;

        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "./input": 95, "buffer": 6, "path": 4, "source-map-js": 4, "url": 4 }], 99: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          let MapGenerator = require('./map-generator');
          let stringify = require('./stringify');
          let warnOnce = require('./warn-once');
          let parse = require('./parse');
          const Result = require('./result');

          class NoWorkResult {
            constructor(processor, css, opts) {
              css = css.toString();
              this.stringified = false;

              this._processor = processor;
              this._css = css;
              this._opts = opts;
              this._map = undefined;
              let root;

              let str = stringify;
              this.result = new Result(this._processor, root, this._opts);
              this.result.css = css;

              let self = this;
              Object.defineProperty(this.result, 'root', {
                get() {
                  return self.root;
                } });


              let map = new MapGenerator(str, root, this._opts, css);
              if (map.isMap()) {
                let [generatedCSS, generatedMap] = map.generate();
                if (generatedCSS) {
                  this.result.css = generatedCSS;
                }
                if (generatedMap) {
                  this.result.map = generatedMap;
                }
              }
            }

            get [Symbol.toStringTag]() {
              return 'NoWorkResult';
            }

            get processor() {
              return this.result.processor;
            }

            get opts() {
              return this.result.opts;
            }

            get css() {
              return this.result.css;
            }

            get content() {
              return this.result.css;
            }

            get map() {
              return this.result.map;
            }

            get root() {
              if (this._root) {
                return this._root;
              }

              let root;
              let parser = parse;

              try {
                root = parser(this._css, this._opts);
              } catch (error) {
                this.error = error;
              }

              this._root = root;

              return root;
            }

            get messages() {
              return [];
            }

            warnings() {
              return [];
            }

            toString() {
              return this._css;
            }

            then(onFulfilled, onRejected) {
              if (process.env.NODE_ENV !== 'production') {
                if (!('from' in this._opts)) {
                  warnOnce(
                  'Without `from` option PostCSS could generate wrong source map ' +
                  'and will not find Browserslist config. Set it to CSS file path ' +
                  'or to `undefined` to prevent this warning.');

                }
              }

              return this.async().then(onFulfilled, onRejected);
            }

            catch(onRejected) {
              return this.async().catch(onRejected);
            }

            finally(onFinally) {
              return this.async().then(onFinally, onFinally);
            }

            async() {
              if (this.error) return Promise.reject(this.error);
              return Promise.resolve(this.result);
            }

            sync() {
              if (this.error) throw this.error;
              return this.result;
            }}


          module.exports = NoWorkResult;
          NoWorkResult.default = NoWorkResult;

        }).call(this);}).call(this, require('_process'));
    }, { "./map-generator": 98, "./parse": 101, "./result": 106, "./stringify": 110, "./warn-once": 113, "_process": 115 }], 100: [function (require, module, exports) {
      'use strict';

      let { isClean, my } = require('./symbols');
      let CssSyntaxError = require('./css-syntax-error');
      let Stringifier = require('./stringifier');
      let stringify = require('./stringify');

      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();

        for (let i in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i)) {
            /* c8 ignore next 2 */
            continue;
          }
          if (i === 'proxyCache') continue;
          let value = obj[i];
          let type = typeof value;

          if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
          } else if (i === 'source') {
            cloned[i] = value;
          } else if (Array.isArray(value)) {
            cloned[i] = value.map(j => cloneNode(j, cloned));
          } else {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
          }
        }

        return cloned;
      }

      class Node {
        constructor(defaults = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;

          for (let name in defaults) {
            if (name === 'nodes') {
              this.nodes = [];
              for (let node of defaults[name]) {
                if (typeof node.clone === 'function') {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults[name];
            }
          }
        }

        error(message, opts = {}) {
          if (this.source) {
            let { start, end } = this.rangeBy(opts);
            return this.source.input.error(
            message,
            { line: start.line, column: start.column },
            { line: end.line, column: end.column },
            opts);

          }
          return new CssSyntaxError(message);
        }

        warn(result, text, opts) {
          let data = { node: this };
          for (let i in opts) data[i] = opts[i];
          return result.warn(text, data);
        }

        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = undefined;
          return this;
        }

        toString(stringifier = stringify) {
          if (stringifier.stringify) stringifier = stringifier.stringify;
          let result = '';
          stringifier(this, i => {
            result += i;
          });
          return result;
        }

        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }

        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }

        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }

        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }

        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }

            if (!foundSelf) {
              this.remove();
            }
          }

          return this;
        }

        next() {
          if (!this.parent) return undefined;
          let index = this.parent.index(this);
          return this.parent.nodes[index + 1];
        }

        prev() {
          if (!this.parent) return undefined;
          let index = this.parent.index(this);
          return this.parent.nodes[index - 1];
        }

        before(add) {
          this.parent.insertBefore(this, add);
          return this;
        }

        after(add) {
          this.parent.insertAfter(this, add);
          return this;
        }

        root() {
          let result = this;
          while (result.parent && result.parent.type !== 'document') {
            result = result.parent;
          }
          return result;
        }

        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }

        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween) delete this.raws.between;
        }

        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || new Map();
          let inputsNextIndex = 0;

          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              /* c8 ignore next 2 */
              continue;
            }
            if (name === 'parent' || name === 'proxyCache') continue;
            let value = this[name];

            if (Array.isArray(value)) {
              fixed[name] = value.map(i => {
                if (typeof i === 'object' && i.toJSON) {
                  return i.toJSON(null, inputs);
                } else {
                  return i;
                }
              });
            } else if (typeof value === 'object' && value.toJSON) {
              fixed[name] = value.toJSON(null, inputs);
            } else if (name === 'source') {
              let inputId = inputs.get(value.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                inputId,
                start: value.start,
                end: value.end };

            } else {
              fixed[name] = value;
            }
          }

          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
          }

          return fixed;
        }

        positionInside(index) {
          let string = this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;

          for (let i = 0; i < index; i++) {
            if (string[i] === '\n') {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }

          return { line, column };
        }

        positionBy(opts) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index);
          } else if (opts.word) {
            let index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
          }
          return pos;
        }

        rangeBy(opts) {
          let start = {
            line: this.source.start.line,
            column: this.source.start.column };

          let end = this.source.end ?
          {
            line: this.source.end.line,
            column: this.source.end.column + 1 } :

          {
            line: start.line,
            column: start.column + 1 };


          if (opts.word) {
            let index = this.toString().indexOf(opts.word);
            if (index !== -1) {
              start = this.positionInside(index);
              end = this.positionInside(index + opts.word.length);
            }
          } else {
            if (opts.start) {
              start = {
                line: opts.start.line,
                column: opts.start.column };

            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }

            if (opts.end) {
              end = {
                line: opts.end.line,
                column: opts.end.column };

            } else if (opts.endIndex) {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }

          if (
          end.line < start.line ||
          end.line === start.line && end.column <= start.column)
          {
            end = { line: start.line, column: start.column + 1 };
          }

          return { start, end };
        }

        getProxyProcessor() {
          return {
            set(node, prop, value) {
              if (node[prop] === value) return true;
              node[prop] = value;
              if (
              prop === 'prop' ||
              prop === 'value' ||
              prop === 'name' ||
              prop === 'params' ||
              prop === 'important' ||
              /* c8 ignore next */
              prop === 'text')
              {
                node.markDirty();
              }
              return true;
            },

            get(node, prop) {
              if (prop === 'proxyOf') {
                return node;
              } else if (prop === 'root') {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            } };

        }

        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }

        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s = this.source;
            error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);

          }
          return error;
        }

        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }

        get proxyOf() {
          return this;
        }}


      module.exports = Node;
      Node.default = Node;

    }, { "./css-syntax-error": 91, "./stringifier": 109, "./stringify": 110, "./symbols": 111 }], 101: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          let Container = require('./container');
          let Parser = require('./parser');
          let Input = require('./input');

          function parse(css, opts) {
            let input = new Input(css, opts);
            let parser = new Parser(input);
            try {
              parser.parse();
            } catch (e) {
              if (process.env.NODE_ENV !== 'production') {
                if (e.name === 'CssSyntaxError' && opts && opts.from) {
                  if (/\.scss$/i.test(opts.from)) {
                    e.message +=
                    '\nYou tried to parse SCSS with ' +
                    'the standard CSS parser; ' +
                    'try again with the postcss-scss parser';
                  } else if (/\.sass/i.test(opts.from)) {
                    e.message +=
                    '\nYou tried to parse Sass with ' +
                    'the standard CSS parser; ' +
                    'try again with the postcss-sass parser';
                  } else if (/\.less$/i.test(opts.from)) {
                    e.message +=
                    '\nYou tried to parse Less with ' +
                    'the standard CSS parser; ' +
                    'try again with the postcss-less parser';
                  }
                }
              }
              throw e;
            }

            return parser.root;
          }

          module.exports = parse;
          parse.default = parse;

          Container.registerParse(parse);

        }).call(this);}).call(this, require('_process'));
    }, { "./container": 90, "./input": 95, "./parser": 102, "_process": 115 }], 102: [function (require, module, exports) {
      'use strict';

      let Declaration = require('./declaration');
      let tokenizer = require('./tokenize');
      let Comment = require('./comment');
      let AtRule = require('./at-rule');
      let Root = require('./root');
      let Rule = require('./rule');

      class Parser {
        constructor(input) {
          this.input = input;

          this.root = new Root();
          this.current = this.root;
          this.spaces = '';
          this.semicolon = false;
          this.customProperty = false;

          this.createTokenizer();
          this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
        }

        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }

        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            switch (token[0]) {
              case 'space':
                this.spaces += token[1];
                break;

              case ';':
                this.freeSemicolon(token);
                break;

              case '}':
                this.end(token);
                break;

              case 'comment':
                this.comment(token);
                break;

              case 'at-word':
                this.atrule(token);
                break;

              case '{':
                this.emptyRule(token);
                break;

              default:
                this.other(token);
                break;}

          }
          this.endFile();
        }

        comment(token) {
          let node = new Comment();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);

          let text = token[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }

        emptyRule(token) {
          let node = new Rule();
          this.init(node, token[2]);
          node.selector = '';
          node.raws.between = '';
          this.current = node;
        }

        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith('--');

          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);

            if (type === '(' || type === '[') {
              if (!bracket) bracket = token;
              brackets.push(type === '(' ? ')' : ']');
            } else if (customProperty && colon && type === '{') {
              if (!bracket) bracket = token;
              brackets.push('}');
            } else if (brackets.length === 0) {
              if (type === ';') {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === '{') {
                this.rule(tokens);
                return;
              } else if (type === '}') {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ':') {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0) bracket = null;
            }

            token = this.tokenizer.nextToken();
          }

          if (this.tokenizer.endOfFile()) end = true;
          if (brackets.length > 0) this.unclosedBracket(bracket);

          if (end && colon) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== 'space' && token !== 'comment') break;
              this.tokenizer.back(tokens.pop());
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }

        rule(tokens) {
          tokens.pop();

          let node = new Rule();
          this.init(node, tokens[0][2]);

          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, 'selector', tokens);
          this.current = node;
        }

        decl(tokens, customProperty) {
          let node = new Declaration();
          this.init(node, tokens[0][2]);

          let last = tokens[tokens.length - 1];
          if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(last[3] || last[2]);

          while (tokens[0][0] !== 'word') {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);

          node.prop = '';
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
              break;
            }
            node.prop += tokens.shift()[1];
          }

          node.raws.between = '';

          let token;
          while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === 'word' && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }

          if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = this.spacesAndCommentsFromStart(tokens);
          this.precheckMissedSemicolon(tokens);

          for (let i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === '!important') {
              node.important = true;
              let string = this.stringFrom(tokens, i);
              string = this.spacesFromEnd(tokens) + string;
              if (string !== ' !important') node.raws.important = string;
              break;
            } else if (token[1].toLowerCase() === 'important') {
              let cache = tokens.slice(0);
              let str = '';
              for (let j = i; j > 0; j--) {
                let type = cache[j][0];
                if (str.trim().indexOf('!') === 0 && type !== 'space') {
                  break;
                }
                str = cache.pop()[1] + str;
              }
              if (str.trim().indexOf('!') === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache;
              }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
              break;
            }
          }

          let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');
          this.raw(node, 'value', tokens);
          if (hasWord) {
            node.raws.between += firstSpaces;
          } else {
            node.value = firstSpaces + node.value;
          }

          if (node.value.includes(':') && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }

        atrule(token) {
          let node = new AtRule();
          node.name = token[1].slice(1);
          if (node.name === '') {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);

          let type;
          let prev;
          let shift;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];

          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];

            if (type === '(' || type === '[') {
              brackets.push(type === '(' ? ')' : ']');
            } else if (type === '{' && brackets.length > 0) {
              brackets.push('}');
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }

            if (brackets.length === 0) {
              if (type === ';') {
                node.source.end = this.getPosition(token[2]);
                this.semicolon = true;
                break;
              } else if (type === '{') {
                open = true;
                break;
              } else if (type === '}') {
                if (params.length > 0) {
                  shift = params.length - 1;
                  prev = params[shift];
                  while (prev && prev[0] === 'space') {
                    prev = params[--shift];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }

            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }

          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              this.spaces = node.raws.between;
              node.raws.between = '';
            }
          } else {
            node.raws.afterName = '';
            node.params = '';
          }

          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }

        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;

          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
          this.spaces = '';

          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }

        endFile() {
          if (this.current.parent) this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        }

        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = '';
            }
          }
        }

        // Helpers

        getPosition(offset) {
          let pos = this.input.fromOffset(offset);
          return {
            offset,
            line: pos.line,
            column: pos.col };

        }

        init(node, offset) {
          this.current.push(node);
          node.source = {
            start: this.getPosition(offset),
            input: this.input };

          node.raws.before = this.spaces;
          this.spaces = '';
          if (node.type !== 'comment') this.semicolon = false;
        }

        raw(node, prop, tokens) {
          let token, type;
          let length = tokens.length;
          let value = '';
          let clean = true;
          let next, prev;
          let pattern = /^([#.|])?(\w)+/i;

          for (let i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];

            if (type === 'comment' && node.type === 'rule') {
              prev = tokens[i - 1];
              next = tokens[i + 1];

              if (
              prev[0] !== 'space' &&
              next[0] !== 'space' &&
              pattern.test(prev[1]) &&
              pattern.test(next[1]))
              {
                value += token[1];
              } else {
                clean = false;
              }

              continue;
            }

            if (type === 'comment' || type === 'space' && i === length - 1) {
              clean = false;
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i) => all + i[1], '');
            node.raws[prop] = { value, raw };
          }
          node[prop] = value;
        }

        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = '';
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }

        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = '';
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }

        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = '';
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }

        stringFrom(tokens, from) {
          let result = '';
          for (let i = from; i < tokens.length; i++) {
            result += tokens[i][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }

        colon(tokens) {
          let brackets = 0;
          let token, type, prev;
          for (let [i, element] of tokens.entries()) {
            token = element;
            type = token[0];

            if (type === '(') {
              brackets += 1;
            }
            if (type === ')') {
              brackets -= 1;
            }
            if (brackets === 0 && type === ':') {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === 'word' && prev[1] === 'progid') {
                continue;
              } else {
                return i;
              }
            }

            prev = token;
          }
          return false;
        }

        // Errors

        unclosedBracket(bracket) {
          throw this.input.error(
          'Unclosed bracket',
          { offset: bracket[2] },
          { offset: bracket[2] + 1 });

        }

        unknownWord(tokens) {
          throw this.input.error(
          'Unknown word',
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length });

        }

        unexpectedClose(token) {
          throw this.input.error(
          'Unexpected }',
          { offset: token[2] },
          { offset: token[2] + 1 });

        }

        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error('Unclosed block', pos.line, pos.column);
        }

        doubleColon(token) {
          throw this.input.error(
          'Double colon',
          { offset: token[2] },
          { offset: token[2] + token[1].length });

        }

        unnamedAtrule(node, token) {
          throw this.input.error(
          'At-rule without name',
          { offset: token[2] },
          { offset: token[2] + token[1].length });

        }

        precheckMissedSemicolon() /* tokens */{
          // Hook for Safe Parser
        }

        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false) return;

          let founded = 0;
          let token;
          for (let j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
              founded += 1;
              if (founded === 2) break;
            }
          }
          // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
          // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
          // And because we need it after that one we do +1 to get the next one.
          throw this.input.error(
          'Missed semicolon',
          token[0] === 'word' ? token[3] + 1 : token[2]);

        }}


      module.exports = Parser;

    }, { "./at-rule": 88, "./comment": 89, "./declaration": 92, "./root": 107, "./rule": 108, "./tokenize": 112 }], 103: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          let CssSyntaxError = require('./css-syntax-error');
          let Declaration = require('./declaration');
          let LazyResult = require('./lazy-result');
          let Container = require('./container');
          let Processor = require('./processor');
          let stringify = require('./stringify');
          let fromJSON = require('./fromJSON');
          let Document = require('./document');
          let Warning = require('./warning');
          let Comment = require('./comment');
          let AtRule = require('./at-rule');
          let Result = require('./result.js');
          let Input = require('./input');
          let parse = require('./parse');
          let list = require('./list');
          let Rule = require('./rule');
          let Root = require('./root');
          let Node = require('./node');

          function postcss(...plugins) {
            if (plugins.length === 1 && Array.isArray(plugins[0])) {
              plugins = plugins[0];
            }
            return new Processor(plugins);
          }

          postcss.plugin = function plugin(name, initializer) {
            // eslint-disable-next-line no-console
            if (console && console.warn) {
              // eslint-disable-next-line no-console
              console.warn(
              name +
              ': postcss.plugin was deprecated. Migration guide:\n' +
              'https://evilmartians.com/chronicles/postcss-8-plugin-migration');

              if (process.env.LANG && process.env.LANG.startsWith('cn')) {
                /* c8 ignore next 7 */
                // eslint-disable-next-line no-console
                console.warn(
                name +
                ':  postcss.plugin . :\n' +
                'https://www.w3ctech.com/topic/2226');

              }
            }
            function creator(...args) {
              let transformer = initializer(...args);
              transformer.postcssPlugin = name;
              transformer.postcssVersion = new Processor().version;
              return transformer;
            }

            let cache;
            Object.defineProperty(creator, 'postcss', {
              get() {
                if (!cache) cache = creator();
                return cache;
              } });


            creator.process = function (css, processOpts, pluginOpts) {
              return postcss([creator(pluginOpts)]).process(css, processOpts);
            };

            return creator;
          };

          postcss.stringify = stringify;
          postcss.parse = parse;
          postcss.fromJSON = fromJSON;
          postcss.list = list;

          postcss.comment = defaults => new Comment(defaults);
          postcss.atRule = defaults => new AtRule(defaults);
          postcss.decl = defaults => new Declaration(defaults);
          postcss.rule = defaults => new Rule(defaults);
          postcss.root = defaults => new Root(defaults);
          postcss.document = defaults => new Document(defaults);

          postcss.CssSyntaxError = CssSyntaxError;
          postcss.Declaration = Declaration;
          postcss.Container = Container;
          postcss.Processor = Processor;
          postcss.Document = Document;
          postcss.Comment = Comment;
          postcss.Warning = Warning;
          postcss.AtRule = AtRule;
          postcss.Result = Result;
          postcss.Input = Input;
          postcss.Rule = Rule;
          postcss.Root = Root;
          postcss.Node = Node;

          LazyResult.registerPostcss(postcss);

          module.exports = postcss;
          postcss.default = postcss;

        }).call(this);}).call(this, require('_process'));
    }, { "./at-rule": 88, "./comment": 89, "./container": 90, "./css-syntax-error": 91, "./declaration": 92, "./document": 93, "./fromJSON": 94, "./input": 95, "./lazy-result": 96, "./list": 97, "./node": 100, "./parse": 101, "./processor": 105, "./result.js": 106, "./root": 107, "./rule": 108, "./stringify": 110, "./warning": 114, "_process": 115 }], 104: [function (require, module, exports) {
      (function (Buffer) {(function () {
          'use strict';

          let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js');
          let { existsSync, readFileSync } = require('fs');
          let { dirname, join } = require('path');

          function fromBase64(str) {
            if (Buffer) {
              return Buffer.from(str, 'base64').toString();
            } else {
              /* c8 ignore next 2 */
              return window.atob(str);
            }
          }

          class PreviousMap {
            constructor(css, opts) {
              if (opts.map === false) return;
              this.loadAnnotation(css);
              this.inline = this.startWith(this.annotation, 'data:');

              let prev = opts.map ? opts.map.prev : undefined;
              let text = this.loadMap(opts.from, prev);
              if (!this.mapFile && opts.from) {
                this.mapFile = opts.from;
              }
              if (this.mapFile) this.root = dirname(this.mapFile);
              if (text) this.text = text;
            }

            consumer() {
              if (!this.consumerCache) {
                this.consumerCache = new SourceMapConsumer(this.text);
              }
              return this.consumerCache;
            }

            withContent() {
              return !!(
              this.consumer().sourcesContent &&
              this.consumer().sourcesContent.length > 0);

            }

            startWith(string, start) {
              if (!string) return false;
              return string.substr(0, start.length) === start;
            }

            getAnnotationURL(sourceMapString) {
              return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim();
            }

            loadAnnotation(css) {
              let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
              if (!comments) return;

              // sourceMappingURLs from comments, strings, etc.
              let start = css.lastIndexOf(comments.pop());
              let end = css.indexOf('*/', start);

              if (start > -1 && end > -1) {
                // Locate the last sourceMappingURL to avoid pickin
                this.annotation = this.getAnnotationURL(css.substring(start, end));
              }
            }

            decodeInline(text) {
              let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
              let baseUri = /^data:application\/json;base64,/;
              let charsetUri = /^data:application\/json;charset=utf-?8,/;
              let uri = /^data:application\/json,/;

              if (charsetUri.test(text) || uri.test(text)) {
                return decodeURIComponent(text.substr(RegExp.lastMatch.length));
              }

              if (baseCharsetUri.test(text) || baseUri.test(text)) {
                return fromBase64(text.substr(RegExp.lastMatch.length));
              }

              let encoding = text.match(/data:application\/json;([^,]+),/)[1];
              throw new Error('Unsupported source map encoding ' + encoding);
            }

            loadFile(path) {
              this.root = dirname(path);
              if (existsSync(path)) {
                this.mapFile = path;
                return readFileSync(path, 'utf-8').toString().trim();
              }
            }

            loadMap(file, prev) {
              if (prev === false) return false;

              if (prev) {
                if (typeof prev === 'string') {
                  return prev;
                } else if (typeof prev === 'function') {
                  let prevPath = prev(file);
                  if (prevPath) {
                    let map = this.loadFile(prevPath);
                    if (!map) {
                      throw new Error(
                      'Unable to load previous source map: ' + prevPath.toString());

                    }
                    return map;
                  }
                } else if (prev instanceof SourceMapConsumer) {
                  return SourceMapGenerator.fromSourceMap(prev).toString();
                } else if (prev instanceof SourceMapGenerator) {
                  return prev.toString();
                } else if (this.isMap(prev)) {
                  return JSON.stringify(prev);
                } else {
                  throw new Error(
                  'Unsupported previous source map format: ' + prev.toString());

                }
              } else if (this.inline) {
                return this.decodeInline(this.annotation);
              } else if (this.annotation) {
                let map = this.annotation;
                if (file) map = join(dirname(file), map);
                return this.loadFile(map);
              }
            }

            isMap(map) {
              if (typeof map !== 'object') return false;
              return (
                typeof map.mappings === 'string' ||
                typeof map._mappings === 'string' ||
                Array.isArray(map.sections));

            }}


          module.exports = PreviousMap;
          PreviousMap.default = PreviousMap;

        }).call(this);}).call(this, require("buffer").Buffer);
    }, { "buffer": 6, "fs": 4, "path": 4, "source-map-js": 4 }], 105: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          let NoWorkResult = require('./no-work-result');
          let LazyResult = require('./lazy-result');
          let Document = require('./document');
          let Root = require('./root');

          class Processor {
            constructor(plugins = []) {
              this.version = '8.4.5';
              this.plugins = this.normalize(plugins);
            }

            use(plugin) {
              this.plugins = this.plugins.concat(this.normalize([plugin]));
              return this;
            }

            process(css, opts = {}) {
              if (
              this.plugins.length === 0 &&
              typeof opts.parser === 'undefined' &&
              typeof opts.stringifier === 'undefined' &&
              typeof opts.syntax === 'undefined')
              {
                return new NoWorkResult(this, css, opts);
              } else {
                return new LazyResult(this, css, opts);
              }
            }

            normalize(plugins) {
              let normalized = [];
              for (let i of plugins) {
                if (i.postcss === true) {
                  i = i();
                } else if (i.postcss) {
                  i = i.postcss;
                }

                if (typeof i === 'object' && Array.isArray(i.plugins)) {
                  normalized = normalized.concat(i.plugins);
                } else if (typeof i === 'object' && i.postcssPlugin) {
                  normalized.push(i);
                } else if (typeof i === 'function') {
                  normalized.push(i);
                } else if (typeof i === 'object' && (i.parse || i.stringify)) {
                  if (process.env.NODE_ENV !== 'production') {
                    throw new Error(
                    'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
                    'one of the syntax/parser/stringifier options as outlined ' +
                    'in your PostCSS runner documentation.');

                  }
                } else {
                  throw new Error(i + ' is not a PostCSS plugin');
                }
              }
              return normalized;
            }}


          module.exports = Processor;
          Processor.default = Processor;

          Root.registerProcessor(Processor);
          Document.registerProcessor(Processor);

        }).call(this);}).call(this, require('_process'));
    }, { "./document": 93, "./lazy-result": 96, "./no-work-result": 99, "./root": 107, "_process": 115 }], 106: [function (require, module, exports) {
      'use strict';

      let Warning = require('./warning');

      class Result {
        constructor(processor, root, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root;
          this.opts = opts;
          this.css = undefined;
          this.map = undefined;
        }

        toString() {
          return this.css;
        }

        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }

          let warning = new Warning(text, opts);
          this.messages.push(warning);

          return warning;
        }

        warnings() {
          return this.messages.filter(i => i.type === 'warning');
        }

        get content() {
          return this.css;
        }}


      module.exports = Result;
      Result.default = Result;

    }, { "./warning": 114 }], 107: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');

      let LazyResult, Processor;

      class Root extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'root';
          if (!this.nodes) this.nodes = [];
        }

        removeChild(child, ignore) {
          let index = this.index(child);

          if (!ignore && index === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index].raws.before;
          }

          return super.removeChild(child);
        }

        normalize(child, sample, type) {
          let nodes = super.normalize(child);

          if (sample) {
            if (type === 'prepend') {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }

          return nodes;
        }

        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }}


      Root.registerLazyResult = dependant => {
        LazyResult = dependant;
      };

      Root.registerProcessor = dependant => {
        Processor = dependant;
      };

      module.exports = Root;
      Root.default = Root;

    }, { "./container": 90 }], 108: [function (require, module, exports) {
      'use strict';

      let Container = require('./container');
      let list = require('./list');

      class Rule extends Container {
        constructor(defaults) {
          super(defaults);
          this.type = 'rule';
          if (!this.nodes) this.nodes = [];
        }

        get selectors() {
          return list.comma(this.selector);
        }

        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
          this.selector = values.join(sep);
        }}


      module.exports = Rule;
      Rule.default = Rule;

      Container.registerRule(Rule);

    }, { "./container": 90, "./list": 97 }], 109: [function (require, module, exports) {
      'use strict';

      const DEFAULT_RAW = {
        colon: ': ',
        indent: '    ',
        beforeDecl: '\n',
        beforeRule: '\n',
        beforeOpen: ' ',
        beforeClose: '\n',
        beforeComment: '\n',
        after: '\n',
        emptyBody: '',
        commentLeft: ' ',
        commentRight: ' ',
        semicolon: false };


      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }

      class Stringifier {
        constructor(builder) {
          this.builder = builder;
        }

        stringify(node, semicolon) {
          /* c8 ignore start */
          if (!this[node.type]) {
            throw new Error(
            'Unknown AST node type ' +
            node.type +
            '. ' +
            'Maybe you need to change PostCSS stringifier.');

          }
          /* c8 ignore stop */
          this[node.type](node, semicolon);
        }

        document(node) {
          this.body(node);
        }

        root(node) {
          this.body(node);
          if (node.raws.after) this.builder(node.raws.after);
        }

        comment(node) {
          let left = this.raw(node, 'left', 'commentLeft');
          let right = this.raw(node, 'right', 'commentRight');
          this.builder('/*' + left + node.text + right + '*/', node);
        }

        decl(node, semicolon) {
          let between = this.raw(node, 'between', 'colon');
          let string = node.prop + between + this.rawValue(node, 'value');

          if (node.important) {
            string += node.raws.important || ' !important';
          }

          if (semicolon) string += ';';
          this.builder(string, node);
        }

        rule(node) {
          this.block(node, this.rawValue(node, 'selector'));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, 'end');
          }
        }

        atrule(node, semicolon) {
          let name = '@' + node.name;
          let params = node.params ? this.rawValue(node, 'params') : '';

          if (typeof node.raws.afterName !== 'undefined') {
            name += node.raws.afterName;
          } else if (params) {
            name += ' ';
          }

          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || '') + (semicolon ? ';' : '');
            this.builder(name + params + end, node);
          }
        }

        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== 'comment') break;
            last -= 1;
          }

          let semicolon = this.raw(node, 'semicolon');
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            let before = this.raw(child, 'before');
            if (before) this.builder(before);
            this.stringify(child, last !== i || semicolon);
          }
        }

        block(node, start) {
          let between = this.raw(node, 'between', 'beforeOpen');
          this.builder(start + between + '{', node, 'start');

          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, 'after');
          } else {
            after = this.raw(node, 'after', 'emptyBody');
          }

          if (after) this.builder(after);
          this.builder('}', node, 'end');
        }

        raw(node, own, detect) {
          let value;
          if (!detect) detect = own;

          // Already had
          if (own) {
            value = node.raws[own];
            if (typeof value !== 'undefined') return value;
          }

          let parent = node.parent;

          if (detect === 'before') {
            // Hack for first rule in CSS
            if (!parent || parent.type === 'root' && parent.first === node) {
              return '';
            }

            // `root` nodes in `document` should use only their own raws
            if (parent && parent.type === 'document') {
              return '';
            }
          }

          // Floating child without parent
          if (!parent) return DEFAULT_RAW[detect];

          // Detect style by other nodes
          let root = node.root();
          if (!root.rawCache) root.rawCache = {};
          if (typeof root.rawCache[detect] !== 'undefined') {
            return root.rawCache[detect];
          }

          if (detect === 'before' || detect === 'after') {
            return this.beforeAfter(node, detect);
          } else {
            let method = 'raw' + capitalize(detect);
            if (this[method]) {
              value = this[method](root, node);
            } else {
              root.walk(i => {
                value = i.raws[own];
                if (typeof value !== 'undefined') return false;
              });
            }
          }

          if (typeof value === 'undefined') value = DEFAULT_RAW[detect];

          root.rawCache[detect] = value;
          return value;
        }

        rawSemicolon(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length && i.last.type === 'decl') {
              value = i.raws.semicolon;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawEmptyBody(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length === 0) {
              value = i.raws.after;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawIndent(root) {
          if (root.raws.indent) return root.raws.indent;
          let value;
          root.walk(i => {
            let p = i.parent;
            if (p && p !== root && p.parent && p.parent === root) {
              if (typeof i.raws.before !== 'undefined') {
                let parts = i.raws.before.split('\n');
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, '');
                return false;
              }
            }
          });
          return value;
        }

        rawBeforeComment(root, node) {
          let value;
          root.walkComments(i => {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false;
            }
          });
          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (value) {
            value = value.replace(/\S/g, '');
          }
          return value;
        }

        rawBeforeDecl(root, node) {
          let value;
          root.walkDecls(i => {
            if (typeof i.raws.before !== 'undefined') {
              value = i.raws.before;
              if (value.includes('\n')) {
                value = value.replace(/[^\n]+$/, '');
              }
              return false;
            }
          });
          if (typeof value === 'undefined') {
            value = this.raw(node, null, 'beforeRule');
          } else if (value) {
            value = value.replace(/\S/g, '');
          }
          return value;
        }

        rawBeforeRule(root) {
          let value;
          root.walk(i => {
            if (i.nodes && (i.parent !== root || root.first !== i)) {
              if (typeof i.raws.before !== 'undefined') {
                value = i.raws.before;
                if (value.includes('\n')) {
                  value = value.replace(/[^\n]+$/, '');
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, '');
          return value;
        }

        rawBeforeClose(root) {
          let value;
          root.walk(i => {
            if (i.nodes && i.nodes.length > 0) {
              if (typeof i.raws.after !== 'undefined') {
                value = i.raws.after;
                if (value.includes('\n')) {
                  value = value.replace(/[^\n]+$/, '');
                }
                return false;
              }
            }
          });
          if (value) value = value.replace(/\S/g, '');
          return value;
        }

        rawBeforeOpen(root) {
          let value;
          root.walk(i => {
            if (i.type !== 'decl') {
              value = i.raws.between;
              if (typeof value !== 'undefined') return false;
            }
          });
          return value;
        }

        rawColon(root) {
          let value;
          root.walkDecls(i => {
            if (typeof i.raws.between !== 'undefined') {
              value = i.raws.between.replace(/[^\s:]/g, '');
              return false;
            }
          });
          return value;
        }

        beforeAfter(node, detect) {
          let value;
          if (node.type === 'decl') {
            value = this.raw(node, null, 'beforeDecl');
          } else if (node.type === 'comment') {
            value = this.raw(node, null, 'beforeComment');
          } else if (detect === 'before') {
            value = this.raw(node, null, 'beforeRule');
          } else {
            value = this.raw(node, null, 'beforeClose');
          }

          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== 'root') {
            depth += 1;
            buf = buf.parent;
          }

          if (value.includes('\n')) {
            let indent = this.raw(node, null, 'indent');
            if (indent.length) {
              for (let step = 0; step < depth; step++) value += indent;
            }
          }

          return value;
        }

        rawValue(node, prop) {
          let value = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }

          return value;
        }}


      module.exports = Stringifier;
      Stringifier.default = Stringifier;

    }, {}], 110: [function (require, module, exports) {
      'use strict';

      let Stringifier = require('./stringifier');

      function stringify(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }

      module.exports = stringify;
      stringify.default = stringify;

    }, { "./stringifier": 109 }], 111: [function (require, module, exports) {
      'use strict';

      module.exports.isClean = Symbol('isClean');

      module.exports.my = Symbol('my');

    }, {}], 112: [function (require, module, exports) {
      'use strict';

      const SINGLE_QUOTE = "'".charCodeAt(0);
      const DOUBLE_QUOTE = '"'.charCodeAt(0);
      const BACKSLASH = '\\'.charCodeAt(0);
      const SLASH = '/'.charCodeAt(0);
      const NEWLINE = '\n'.charCodeAt(0);
      const SPACE = ' '.charCodeAt(0);
      const FEED = '\f'.charCodeAt(0);
      const TAB = '\t'.charCodeAt(0);
      const CR = '\r'.charCodeAt(0);
      const OPEN_SQUARE = '['.charCodeAt(0);
      const CLOSE_SQUARE = ']'.charCodeAt(0);
      const OPEN_PARENTHESES = '('.charCodeAt(0);
      const CLOSE_PARENTHESES = ')'.charCodeAt(0);
      const OPEN_CURLY = '{'.charCodeAt(0);
      const CLOSE_CURLY = '}'.charCodeAt(0);
      const SEMICOLON = ';'.charCodeAt(0);
      const ASTERISK = '*'.charCodeAt(0);
      const COLON = ':'.charCodeAt(0);
      const AT = '@'.charCodeAt(0);

      const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      const RE_BAD_BRACKET = /.[\n"'(/\\]/;
      const RE_HEX_ESCAPE = /[\da-f]/i;

      module.exports = function tokenizer(input, options = {}) {
        let css = input.css.valueOf();
        let ignore = options.ignoreErrors;

        let code, next, quote, content, escape;
        let escaped, escapePos, prev, n, currentToken;

        let length = css.length;
        let pos = 0;
        let buffer = [];
        let returned = [];

        function position() {
          return pos;
        }

        function unclosed(what) {
          throw input.error('Unclosed ' + what, pos);
        }

        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }

        function nextToken(opts) {
          if (returned.length) return returned.pop();
          if (pos >= length) return;

          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;

          code = css.charCodeAt(pos);

          switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED:{
                next = pos;
                do {
                  next += 1;
                  code = css.charCodeAt(next);
                } while (
                code === SPACE ||
                code === NEWLINE ||
                code === TAB ||
                code === CR ||
                code === FEED);


                currentToken = ['space', css.slice(pos, next)];
                pos = next - 1;
                break;
              }

            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES:{
                let controlChar = String.fromCharCode(code);
                currentToken = [controlChar, controlChar, pos];
                break;
              }

            case OPEN_PARENTHESES:{
                prev = buffer.length ? buffer.pop()[1] : '';
                n = css.charCodeAt(pos + 1);
                if (
                prev === 'url' &&
                n !== SINGLE_QUOTE &&
                n !== DOUBLE_QUOTE &&
                n !== SPACE &&
                n !== NEWLINE &&
                n !== TAB &&
                n !== FEED &&
                n !== CR)
                {
                  next = pos;
                  do {
                    escaped = false;
                    next = css.indexOf(')', next + 1);
                    if (next === -1) {
                      if (ignore || ignoreUnclosed) {
                        next = pos;
                        break;
                      } else {
                        unclosed('bracket');
                      }
                    }
                    escapePos = next;
                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                      escapePos -= 1;
                      escaped = !escaped;
                    }
                  } while (escaped);

                  currentToken = ['brackets', css.slice(pos, next + 1), pos, next];

                  pos = next;
                } else {
                  next = css.indexOf(')', pos + 1);
                  content = css.slice(pos, next + 1);

                  if (next === -1 || RE_BAD_BRACKET.test(content)) {
                    currentToken = ['(', '(', pos];
                  } else {
                    currentToken = ['brackets', content, pos, next];
                    pos = next;
                  }
                }

                break;
              }

            case SINGLE_QUOTE:
            case DOUBLE_QUOTE:{
                quote = code === SINGLE_QUOTE ? "'" : '"';
                next = pos;
                do {
                  escaped = false;
                  next = css.indexOf(quote, next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos + 1;
                      break;
                    } else {
                      unclosed('string');
                    }
                  }
                  escapePos = next;
                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);

                currentToken = ['string', css.slice(pos, next + 1), pos, next];
                pos = next;
                break;
              }

            case AT:{
                RE_AT_END.lastIndex = pos + 1;
                RE_AT_END.test(css);
                if (RE_AT_END.lastIndex === 0) {
                  next = css.length - 1;
                } else {
                  next = RE_AT_END.lastIndex - 2;
                }

                currentToken = ['at-word', css.slice(pos, next + 1), pos, next];

                pos = next;
                break;
              }

            case BACKSLASH:{
                next = pos;
                escape = true;
                while (css.charCodeAt(next + 1) === BACKSLASH) {
                  next += 1;
                  escape = !escape;
                }
                code = css.charCodeAt(next + 1);
                if (
                escape &&
                code !== SLASH &&
                code !== SPACE &&
                code !== NEWLINE &&
                code !== TAB &&
                code !== CR &&
                code !== FEED)
                {
                  next += 1;
                  if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                    while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                      next += 1;
                    }
                    if (css.charCodeAt(next + 1) === SPACE) {
                      next += 1;
                    }
                  }
                }

                currentToken = ['word', css.slice(pos, next + 1), pos, next];

                pos = next;
                break;
              }

            default:{
                if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                  next = css.indexOf('*/', pos + 2) + 1;
                  if (next === 0) {
                    if (ignore || ignoreUnclosed) {
                      next = css.length;
                    } else {
                      unclosed('comment');
                    }
                  }

                  currentToken = ['comment', css.slice(pos, next + 1), pos, next];
                  pos = next;
                } else {
                  RE_WORD_END.lastIndex = pos + 1;
                  RE_WORD_END.test(css);
                  if (RE_WORD_END.lastIndex === 0) {
                    next = css.length - 1;
                  } else {
                    next = RE_WORD_END.lastIndex - 2;
                  }

                  currentToken = ['word', css.slice(pos, next + 1), pos, next];
                  buffer.push(currentToken);
                  pos = next;
                }

                break;
              }}


          pos++;
          return currentToken;
        }

        function back(token) {
          returned.push(token);
        }

        return {
          back,
          nextToken,
          endOfFile,
          position };

      };

    }, {}], 113: [function (require, module, exports) {
      /* eslint-disable no-console */
      'use strict';

      let printed = {};

      module.exports = function warnOnce(message) {
        if (printed[message]) return;
        printed[message] = true;

        if (typeof console !== 'undefined' && console.warn) {
          console.warn(message);
        }
      };

    }, {}], 114: [function (require, module, exports) {
      'use strict';

      class Warning {
        constructor(text, opts = {}) {
          this.type = 'warning';
          this.text = text;

          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }

          for (let opt in opts) this[opt] = opts[opt];
        }

        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              plugin: this.plugin,
              index: this.index,
              word: this.word }).
            message;
          }

          if (this.plugin) {
            return this.plugin + ': ' + this.text;
          }

          return this.text;
        }}


      module.exports = Warning;
      Warning.default = Warning;

    }, {}], 115: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }


      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }



      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {return [];};

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {return '/';};
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {return 0;};

    }, {}], 116: [function (require, module, exports) {
      (function (global) {(function () {
          /*! https://mths.be/punycode v1.4.1 by @mathias */
          ;(function (root) {

            /** Detect free variables */
            var freeExports = typeof exports == 'object' && exports &&
            !exports.nodeType && exports;
            var freeModule = typeof module == 'object' && module &&
            !module.nodeType && module;
            var freeGlobal = typeof global == 'object' && global;
            if (
            freeGlobal.global === freeGlobal ||
            freeGlobal.window === freeGlobal ||
            freeGlobal.self === freeGlobal)
            {
              root = freeGlobal;
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,

            /** Highest positive signed 32-bit float value */
            maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

            /** Bootstring parameters */
            base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128, // 0x80
            delimiter = '-', // '\x2D'

            /** Regular expressions */
            regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
            regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

            /** Error messages */
            errors = {
              'overflow': 'Overflow: input needs wider integers to process',
              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
              'invalid-input': 'Invalid input' },


            /** Convenience shortcuts */
            baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,

            /** Temporary variable */
            key;

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw new RangeError(errors[type]);
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@');
              var result = '';
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E');
              var labels = string.split('.');
              var encoded = map(labels, fn).join('.');
              return result + encoded;
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) {// low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function (value) {
                var output = '';
                if (value > 0xFFFF) {
                  value -= 0x10000;
                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                  value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
              }).join('');
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,
              /** Cached calculation results */
              baseMinusT;

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic');
                }
                output.push(input.charCodeAt(j));
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                  if (index >= inputLength) {
                    error('invalid-input');
                  }

                  digit = basicToDigit(input.charCodeAt(index++));

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                  }

                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                  if (digit < t) {
                    break;
                  }

                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                  }

                  w *= baseMinusT;

                }

                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow');
                }

                n += floor(i / out);
                i %= out;

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);

              }

              return ucs2encode(output);
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],
              /** `inputLength` will hold the number of code points in `input`. */
              inputLength,
              /** Cached calculation results */
              handledCPCountPlusOne,
              baseMinusT,
              qMinusT;

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input);

              // Cache the length
              inputLength = input.length;

              // Initialize the state
              n = initialN;
              delta = 0;
              bias = initialBias;

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue));
                }
              }

              handledCPCount = basicLength = output.length;

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter);
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {

                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow');
                }

                delta += (m - n) * handledCPCountPlusOne;
                n = m;

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base;; /* no condition */k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(
                      stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));

                      q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }

                ++delta;
                ++n;

              }
              return output.join('');
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function (string) {
                return regexPunycode.test(string) ?
                decode(string.slice(4).toLowerCase()) :
                string;
              });
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function (string) {
                return regexNonASCII.test(string) ?
                'xn--' + encode(string) :
                string;
              });
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              'version': '1.4.1',
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode },

              'decode': decode,
              'encode': encode,
              'toASCII': toASCII,
              'toUnicode': toUnicode };


            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (
            typeof define == 'function' &&
            typeof define.amd == 'object' &&
            define.amd)
            {
              define('punycode', function () {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
              } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              // in Rhino or a web browser
              root.punycode = punycode;
            }

          })(this);

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 117: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      // If obj.hasOwnProperty has been overridden, then calling
      // obj.hasOwnProperty(prop) will break.
      // See: https://github.com/joyent/node/issues/1707
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      module.exports = function (qs, sep, eq, options) {
        sep = sep || '&';
        eq = eq || '=';
        var obj = {};

        if (typeof qs !== 'string' || qs.length === 0) {
          return obj;
        }

        var regexp = /\+/g;
        qs = qs.split(sep);

        var maxKeys = 1000;
        if (options && typeof options.maxKeys === 'number') {
          maxKeys = options.maxKeys;
        }

        var len = qs.length;
        // maxKeys <= 0 means that we should not limit keys count
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }

        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,vstr,k,v;

          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = '';
          }

          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);

          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }

        return obj;
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };

    }, {}], 118: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var stringifyPrimitive = function (v) {
        switch (typeof v) {
          case 'string':
            return v;

          case 'boolean':
            return v ? 'true' : 'false';

          case 'number':
            return isFinite(v) ? v : '';

          default:
            return '';}

      };

      module.exports = function (obj, sep, eq, name) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
          obj = undefined;
        }

        if (typeof obj === 'object') {
          return map(objectKeys(obj), function (k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (isArray(obj[k])) {
              return map(obj[k], function (v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);

        }

        if (!name) return '';
        return encodeURIComponent(stringifyPrimitive(name)) + eq +
        encodeURIComponent(stringifyPrimitive(obj));
      };

      var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };

      function map(xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          res.push(f(xs[i], i));
        }
        return res;
      }

      var objectKeys = Object.keys || function (obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
        }
        return res;
      };

    }, {}], 119: [function (require, module, exports) {
      'use strict';

      exports.decode = exports.parse = require('./decode');
      exports.encode = exports.stringify = require('./encode');

    }, { "./decode": 117, "./encode": 118 }], 120: [function (require, module, exports) {
      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
        factory(global.SPECIFICITY = {});
      })(this, function (exports) {'use strict';

        // Calculate the specificity for a selector by dividing it into simple selectors and counting them
        var calculate = function (input) {
          var selectors,
          selector,
          i,
          len,
          results = [];

          // Separate input by commas
          selectors = input.split(',');

          for (i = 0, len = selectors.length; i < len; i += 1) {
            selector = selectors[i];
            if (selector.length > 0) {
              results.push(calculateSingle(selector));
            }
          }

          return results;
        };

        /**
         * Calculates the specificity of CSS selectors
         * http://www.w3.org/TR/css3-selectors/#specificity
         *
         * Returns an object with the following properties:
         *  - selector: the input
         *  - specificity: e.g. 0,1,0,0
         *  - parts: array with details about each part of the selector that counts towards the specificity
         *  - specificityArray: e.g. [0, 1, 0, 0]
         */
        var calculateSingle = function (input) {
          var selector = input,
          findMatch,
          typeCount = {
            'a': 0,
            'b': 0,
            'c': 0 },

          parts = [],
          // The following regular expressions assume that selectors matching the preceding regular expressions have been removed
          attributeRegex = /(\[[^\]]+\])/g,
          idRegex = /(#[^\#\s\+>~\.\[:\)]+)/g,
          classRegex = /(\.[^\s\+>~\.\[:\)]+)/g,
          pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi,
          // A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()
          // The negation psuedo class (:not) is filtered out because specificity is calculated on its argument
          // :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules
          pseudoClassWithBracketsRegex = /(:(?!not|global|local)[\w-]+\([^\)]*\))/gi,
          // A regex for other pseudo classes, which don't have brackets
          pseudoClassRegex = /(:(?!not|global|local)[^\s\+>~\.\[:]+)/g,
          elementRegex = /([^\s\+>~\.\[:]+)/g;

          // Find matches for a regular expression in a string and push their details to parts
          // Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
          findMatch = function (regex, type) {
            var matches, i, len, match, index, length;
            if (regex.test(selector)) {
              matches = selector.match(regex);
              for (i = 0, len = matches.length; i < len; i += 1) {
                typeCount[type] += 1;
                match = matches[i];
                index = selector.indexOf(match);
                length = match.length;
                parts.push({
                  selector: input.substr(index, length),
                  type: type,
                  index: index,
                  length: length });

                // Replace this simple selector with whitespace so it won't be counted in further simple selectors
                selector = selector.replace(match, Array(length + 1).join(' '));
              }
            }
          };

          // Replace escaped characters with plain text, using the "A" character
          // https://www.w3.org/TR/CSS21/syndata.html#characters
          (function () {
            var replaceWithPlainText = function (regex) {
              var matches, i, len, match;
              if (regex.test(selector)) {
                matches = selector.match(regex);
                for (i = 0, len = matches.length; i < len; i += 1) {
                  match = matches[i];
                  selector = selector.replace(match, Array(match.length + 1).join('A'));
                }
              }
            },
            // Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character
            escapeHexadecimalRegex = /\\[0-9A-Fa-f]{6}\s?/g,
            // Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character
            escapeHexadecimalRegex2 = /\\[0-9A-Fa-f]{1,5}\s/g,
            // Matches a backslash followed by any character
            escapeSpecialCharacter = /\\./g;

            replaceWithPlainText(escapeHexadecimalRegex);
            replaceWithPlainText(escapeHexadecimalRegex2);
            replaceWithPlainText(escapeSpecialCharacter);
          })();

          // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
          (function () {
            var regex = /{[^]*/gm,
            matches,i,len,match;
            if (regex.test(selector)) {
              matches = selector.match(regex);
              for (i = 0, len = matches.length; i < len; i += 1) {
                match = matches[i];
                selector = selector.replace(match, Array(match.length + 1).join(' '));
              }
            }
          })();

          // Add attribute selectors to parts collection (type b)
          findMatch(attributeRegex, 'b');

          // Add ID selectors to parts collection (type a)
          findMatch(idRegex, 'a');

          // Add class selectors to parts collection (type b)
          findMatch(classRegex, 'b');

          // Add pseudo-element selectors to parts collection (type c)
          findMatch(pseudoElementRegex, 'c');

          // Add pseudo-class selectors to parts collection (type b)
          findMatch(pseudoClassWithBracketsRegex, 'b');
          findMatch(pseudoClassRegex, 'b');

          // Remove universal selector and separator characters
          selector = selector.replace(/[\*\s\+>~]/g, ' ');

          // Remove any stray dots or hashes which aren't attached to words
          // These may be present if the user is live-editing this selector
          selector = selector.replace(/[#\.]/g, ' ');

          // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
          // Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity
          selector = selector.replace(/:not/g, '    ');
          selector = selector.replace(/:local/g, '      ');
          selector = selector.replace(/:global/g, '       ');
          selector = selector.replace(/[\(\)]/g, ' ');

          // The only things left should be element selectors (type c)
          findMatch(elementRegex, 'c');

          // Order the parts in the order they appear in the original selector
          // This is neater for external apps to deal with
          parts.sort(function (a, b) {
            return a.index - b.index;
          });

          return {
            selector: input,
            specificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),
            specificityArray: [0, typeCount.a, typeCount.b, typeCount.c],
            parts: parts };

        };

        /**
         * Compares two CSS selectors for specificity
         * Alternatively you can replace one of the CSS selectors with a specificity array
         *
         *  - it returns -1 if a has a lower specificity than b
         *  - it returns 1 if a has a higher specificity than b
         *  - it returns 0 if a has the same specificity than b
         */
        var compare = function (a, b) {
          var aSpecificity,
          bSpecificity,
          i;

          if (typeof a === 'string') {
            if (a.indexOf(',') !== -1) {
              throw 'Invalid CSS selector';
            } else {
              aSpecificity = calculateSingle(a)['specificityArray'];
            }
          } else if (Array.isArray(a)) {
            if (a.filter(function (e) {return typeof e === 'number';}).length !== 4) {
              throw 'Invalid specificity array';
            } else {
              aSpecificity = a;
            }
          } else {
            throw 'Invalid CSS selector or specificity array';
          }

          if (typeof b === 'string') {
            if (b.indexOf(',') !== -1) {
              throw 'Invalid CSS selector';
            } else {
              bSpecificity = calculateSingle(b)['specificityArray'];
            }
          } else if (Array.isArray(b)) {
            if (b.filter(function (e) {return typeof e === 'number';}).length !== 4) {
              throw 'Invalid specificity array';
            } else {
              bSpecificity = b;
            }
          } else {
            throw 'Invalid CSS selector or specificity array';
          }

          for (i = 0; i < 4; i += 1) {
            if (aSpecificity[i] < bSpecificity[i]) {
              return -1;
            } else if (aSpecificity[i] > bSpecificity[i]) {
              return 1;
            }
          }

          return 0;
        };

        exports.calculate = calculate;
        exports.compare = compare;

        Object.defineProperty(exports, '__esModule', { value: true });

      });

    }, {}], 121: [function (require, module, exports) {
      var SKIP = 'skip';
      var CHECK = 'check';
      var ONLY = 'only';

      module.exports = function (options, callback) {
        var source = options.source;
        var target = options.target;

        var skipComments = options.comments ? options.comments === SKIP : true;
        var skipStrings = options.strings ? options.strings === SKIP : true;
        var skipFunctionNames = options.functionNames ? options.functionNames === SKIP : true;
        var skipFunctionArguments = options.functionArguments === SKIP;
        var skipParentheticals = options.parentheticals === SKIP;

        var onceOptionUsed = false;
        Object.keys(options).forEach(function (key) {
          if (options[key] !== ONLY) return;
          if (!onceOptionUsed) {
            onceOptionUsed = true;
          } else {
            throw new Error('Only one syntax feature option can be the "only" one to check');
          }
        });

        var onlyComments = options.comments === ONLY;
        var onlyStrings = options.strings === ONLY;
        var onlyFunctionNames = options.functionNames === ONLY;
        var onlyFunctionArguments = options.functionArguments === ONLY;
        var onlyParentheticals = options.parentheticals === ONLY;

        var insideString = false;
        var insideComment = false;
        var insideSingleLineComment = false;
        var insideParens = false;
        var insideFunctionArguments = false;
        var openingParenCount = 0;
        var matchCount = 0;
        var openingQuote;

        var targetIsArray = Array.isArray(target);

        // If the target is just a string, it is easy to check whether
        // some index of the source matches it.
        // If the target is an array of strings, though, we have to
        // check whether some index of the source matches *any* of
        // those target strings (stopping after the first match).
        var getMatch = function () {
          if (!targetIsArray) {
            return getMatchBase.bind(null, target);
          }
          return function (index) {
            for (var ti = 0, tl = target.length; ti < tl; ti++) {
              var checkResult = getMatchBase(target[ti], index);
              if (checkResult) return checkResult;
            }
            return false;
          };
        }();

        function getMatchBase(targetString, index) {
          var targetStringLength = targetString.length;

          // Target is a single character
          if (targetStringLength === 1 && source[index] !== targetString) return false;

          // Target is multiple characters
          if (source.substr(index, targetStringLength) !== targetString) return false;

          return {
            insideParens: insideParens,
            insideFunctionArguments: insideFunctionArguments,
            insideComment: insideComment,
            insideString: insideString,
            startIndex: index,
            endIndex: index + targetStringLength,
            target: targetString };

        }

        for (var i = 0, l = source.length; i < l; i++) {
          var currentChar = source[i];

          // Register the beginning of a comment
          if (
          !insideString && !insideComment &&
          currentChar === "/" &&
          source[i - 1] !== "\\" // escaping
          ) {
              // standard comments
              if (source[i + 1] === "*") {
                insideComment = true;
                continue;
              }
              // single-line comments
              if (source[i + 1] === "/") {
                insideComment = true;
                insideSingleLineComment = true;
                continue;
              }
            }

          if (insideComment) {
            // Register the end of a standard comment
            if (
            !insideSingleLineComment &&
            currentChar === "*" &&
            source[i - 1] !== "\\" // escaping
            && source[i + 1] === "/" &&
            source[i - 1] !== "/" // don't end if it's /*/
            ) {
                insideComment = false;
                continue;
              }

            // Register the end of a single-line comment
            if (
            insideSingleLineComment &&
            currentChar === "\n")
            {
              insideComment = false;
              insideSingleLineComment = false;
            }

            if (skipComments) continue;
          }

          // Register the beginning of a string
          if (!insideComment && !insideString && (currentChar === "\"" || currentChar === "'")) {
            if (source[i - 1] === "\\") continue; // escaping

            openingQuote = currentChar;
            insideString = true;

            // For string-quotes rule
            if (target === currentChar) handleMatch(getMatch(i));
            continue;
          }

          if (insideString) {
            // Register the end of a string
            if (currentChar === openingQuote) {
              if (source[i - 1] === "\\") continue; // escaping
              insideString = false;
              continue;
            }

            if (skipStrings) continue;
          }

          // Register the beginning of parens/functions
          if (!insideString && !insideComment && currentChar === "(") {
            // Keep track of opening parentheticals so that we
            // know when the outermost function (possibly
            // containing nested functions) is closing
            openingParenCount++;

            insideParens = true;
            // Only inside a function if there is a function name
            // before the opening paren
            if (/[a-zA-Z]/.test(source[i - 1])) {
              insideFunctionArguments = true;
            }

            if (target === "(") handleMatch(getMatch(i));
            continue;
          }

          if (insideParens) {
            // Register the end of a function
            if (currentChar === ")") {
              openingParenCount--;
              // Do this here so the match is still technically inside a function
              if (target === ")") handleMatch(getMatch(i));
              if (openingParenCount === 0) {
                insideParens = false;
                insideFunctionArguments = false;
              }
              continue;
            }
          }

          var isFunctionName = /^[a-zA-Z]*\(/.test(source.slice(i));
          if (skipFunctionNames && isFunctionName) continue;
          if (onlyFunctionNames && !isFunctionName) continue;

          var match = getMatch(i);

          if (!match) continue;
          handleMatch(match);
          if (options.once) return;
        }

        function handleMatch(match) {
          if (onlyParentheticals && !insideParens) return;
          if (skipParentheticals && insideParens) return;
          if (onlyFunctionArguments && !insideFunctionArguments) return;
          if (skipFunctionArguments && insideFunctionArguments) return;
          if (onlyStrings && !insideString) return;
          if (onlyComments && !insideComment) return;
          matchCount++;
          callback(match, matchCount);
        }
      };

    }, {}], 122: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('./utils/isStandardSyntaxComment');

      const COMMAND_PREFIX = 'stylelint-';
      const disableCommand = `${COMMAND_PREFIX}disable`;
      const enableCommand = `${COMMAND_PREFIX}enable`;
      const disableLineCommand = `${COMMAND_PREFIX}disable-line`;
      const disableNextLineCommand = `${COMMAND_PREFIX}disable-next-line`;
      const ALL_RULES = 'all';

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('postcss').Root} PostcssRoot */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').DisabledRangeObject} DisabledRangeObject */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */

      /**
       * @param {PostcssComment} comment
       * @param {number} start
       * @param {boolean} strictStart
       * @param {string|undefined} description
       * @param {number} [end]
       * @param {boolean} [strictEnd]
       * @returns {DisabledRange}
       */
      function createDisableRange(comment, start, strictStart, description, end, strictEnd) {
        return {
          comment,
          start,
          end: end || undefined,
          strictStart,
          strictEnd: typeof strictEnd === 'boolean' ? strictEnd : undefined,
          description };

      }

      /**
       * Run it like a PostCSS plugin
       * @param {PostcssRoot} root
       * @param {PostcssResult} result
       * @returns {PostcssResult}
       */
      module.exports = function assignDisabledRanges(root, result) {
        result.stylelint = result.stylelint || {
          disabledRanges: {},
          ruleSeverities: {},
          customMessages: {} };


        /**
         * Most of the functions below work via side effects mutating this object
         * @type {DisabledRangeObject}
         */
        const disabledRanges = {
          all: [] };


        result.stylelint.disabledRanges = disabledRanges;

        // Work around postcss/postcss-scss#109 by merging adjacent `//` comments
        // into a single node before passing to `checkComment`.

        /** @type {PostcssComment?} */
        let inlineEnd;

        root.walkComments(comment => {
          if (inlineEnd) {
            // Ignore comments already processed by grouping with a previous one.
            if (inlineEnd === comment) inlineEnd = null;

            return;
          }

          const nextComment = comment.next();

          // If any of these conditions are not met, do not merge comments.
          if (
          !(
          !isStandardSyntaxComment(comment) &&
          isStylelintCommand(comment) &&
          nextComment &&
          nextComment.type === 'comment' && (
          comment.text.includes('--') || nextComment.text.startsWith('--'))))

          {
            checkComment(comment);

            return;
          }

          let lastLine = comment.source && comment.source.end && comment.source.end.line || 0;
          const fullComment = comment.clone();

          let current = nextComment;

          while (!isStandardSyntaxComment(current) && !isStylelintCommand(current)) {
            const currentLine = current.source && current.source.end && current.source.end.line || 0;

            if (lastLine + 1 !== currentLine) break;

            fullComment.text += `\n${current.text}`;

            if (fullComment.source && current.source) {
              fullComment.source.end = current.source.end;
            }

            inlineEnd = current;
            const next = current.next();

            if (!next || next.type !== 'comment') break;

            current = next;
            lastLine = currentLine;
          }

          checkComment(fullComment);
        });

        return result;

        /**
         * @param {PostcssComment} comment
         */
        function isStylelintCommand(comment) {
          return comment.text.startsWith(disableCommand) || comment.text.startsWith(enableCommand);
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableLineCommand(comment) {
          if (comment.source && comment.source.start) {
            const line = comment.source.start.line;
            const description = getDescription(comment.text);

            for (const ruleName of getCommandRules(disableLineCommand, comment.text)) {
              disableLine(comment, line, ruleName, description);
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableNextLineCommand(comment) {
          if (comment.source && comment.source.end) {
            const line = comment.source.end.line;
            const description = getDescription(comment.text);

            for (const ruleName of getCommandRules(disableNextLineCommand, comment.text)) {
              disableLine(comment, line + 1, ruleName, description);
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {string|undefined} description
         */
        function disableLine(comment, line, ruleName, description) {
          if (ruleIsDisabled(ALL_RULES)) {
            throw comment.error('All rules have already been disabled', {
              plugin: 'stylelint' });

          }

          if (ruleName === ALL_RULES) {
            for (const disabledRuleName of Object.keys(disabledRanges)) {
              if (ruleIsDisabled(disabledRuleName)) continue;

              const strict = disabledRuleName === ALL_RULES;

              startDisabledRange(comment, line, disabledRuleName, strict, description);
              endDisabledRange(line, disabledRuleName, strict);
            }
          } else {
            if (ruleIsDisabled(ruleName)) {
              throw comment.error(`"${ruleName}" has already been disabled`, {
                plugin: 'stylelint' });

            }

            startDisabledRange(comment, line, ruleName, true, description);
            endDisabledRange(line, ruleName, true);
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processDisableCommand(comment) {
          const description = getDescription(comment.text);

          for (const ruleToDisable of getCommandRules(disableCommand, comment.text)) {
            const isAllRules = ruleToDisable === ALL_RULES;

            if (ruleIsDisabled(ruleToDisable)) {
              throw comment.error(
              isAllRules ?
              'All rules have already been disabled' :
              `"${ruleToDisable}" has already been disabled`,
              {
                plugin: 'stylelint' });


            }

            if (comment.source && comment.source.start) {
              const line = comment.source.start.line;

              if (isAllRules) {
                for (const ruleName of Object.keys(disabledRanges)) {
                  startDisabledRange(comment, line, ruleName, ruleName === ALL_RULES, description);
                }
              } else {
                startDisabledRange(comment, line, ruleToDisable, true, description);
              }
            }
          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function processEnableCommand(comment) {
          for (const ruleToEnable of getCommandRules(enableCommand, comment.text)) {
            // TODO TYPES
            // need fallback if endLine will be undefined
            const endLine = /** @type {number} */
            comment.source && comment.source.end && comment.source.end.line;


            if (ruleToEnable === ALL_RULES) {
              if (
              Object.values(disabledRanges).every(
              ranges => ranges.length === 0 || typeof ranges[ranges.length - 1].end === 'number'))

              {
                throw comment.error('No rules have been disabled', {
                  plugin: 'stylelint' });

              }

              for (const [ruleName, ranges] of Object.entries(disabledRanges)) {
                const lastRange = ranges[ranges.length - 1];

                if (!lastRange || !lastRange.end) {
                  endDisabledRange(endLine, ruleName, ruleName === ALL_RULES);
                }
              }

              continue;
            }

            if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {
              // Get a starting point from the where all rules were disabled
              if (!disabledRanges[ruleToEnable]) {
                disabledRanges[ruleToEnable] = disabledRanges.all.map(({ start, end, description }) =>
                createDisableRange(comment, start, false, description, end, false));

              } else {
                const ranges = disabledRanges[ALL_RULES];
                const range = ranges ? ranges[ranges.length - 1] : null;

                if (range) {
                  disabledRanges[ruleToEnable].push(_extends({}, range));
                }
              }

              endDisabledRange(endLine, ruleToEnable, true);

              continue;
            }

            if (ruleIsDisabled(ruleToEnable)) {
              endDisabledRange(endLine, ruleToEnable, true);

              continue;
            }

            throw comment.error(`"${ruleToEnable}" has not been disabled`, {
              plugin: 'stylelint' });

          }
        }

        /**
         * @param {PostcssComment} comment
         */
        function checkComment(comment) {
          const text = comment.text;

          // Ignore comments that are not relevant commands

          if (text.indexOf(COMMAND_PREFIX) !== 0) {
            return result;
          }

          if (text.startsWith(disableLineCommand)) {
            processDisableLineCommand(comment);
          } else if (text.startsWith(disableNextLineCommand)) {
            processDisableNextLineCommand(comment);
          } else if (text.startsWith(disableCommand)) {
            processDisableCommand(comment);
          } else if (text.startsWith(enableCommand)) {
            processEnableCommand(comment);
          }
        }

        /**
         * @param {string} command
         * @param {string} fullText
         * @returns {string[]}
         */
        function getCommandRules(command, fullText) {
          const rules = fullText.
          slice(command.length).
          split(/\s-{2,}\s/u)[0] // Allow for description (f.e. /* stylelint-disable a, b -- Description */).
          .trim().
          split(',').
          filter(Boolean).
          map(r => r.trim());

          if (rules.length === 0) {
            return [ALL_RULES];
          }

          return rules;
        }

        /**
         * @param {string} fullText
         * @returns {string|undefined}
         */
        function getDescription(fullText) {
          const descriptionStart = fullText.indexOf('--');

          if (descriptionStart === -1) return;

          return fullText.slice(descriptionStart + 2).trim();
        }

        /**
         * @param {PostcssComment} comment
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         * @param {string|undefined} description
         */
        function startDisabledRange(comment, line, ruleName, strict, description) {
          const rangeObj = createDisableRange(comment, line, strict, description);

          ensureRuleRanges(ruleName);
          disabledRanges[ruleName].push(rangeObj);
        }

        /**
         * @param {number} line
         * @param {string} ruleName
         * @param {boolean} strict
         */
        function endDisabledRange(line, ruleName, strict) {
          const ranges = disabledRanges[ruleName];
          const lastRangeForRule = ranges ? ranges[ranges.length - 1] : null;

          if (!lastRangeForRule) {
            return;
          }

          // Add an `end` prop to the last range of that rule
          lastRangeForRule.end = line;
          lastRangeForRule.strictEnd = strict;
        }

        /**
         * @param {string} ruleName
         */
        function ensureRuleRanges(ruleName) {
          if (!disabledRanges[ruleName]) {
            disabledRanges[ruleName] = disabledRanges.all.map(({ comment, start, end, description }) =>
            createDisableRange(comment, start, false, description, end, false));

          }
        }

        /**
         * @param {string} ruleName
         * @returns {boolean}
         */
        function ruleIsDisabled(ruleName) {
          const ranges = disabledRanges[ruleName];

          if (!ranges) return false;

          const lastRange = ranges[ranges.length - 1];

          if (!lastRange) return false;

          if (!lastRange.end) return true;

          return false;
        }
      };

    }, { "./utils/isStandardSyntaxComment": 411 }], 123: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').LintResult} StylelintResult */

      /**
       * @param {PostcssResult} [postcssResult]
       * @param {import('stylelint').CssSyntaxError} [cssSyntaxError]
       * @return {StylelintResult}
       */
      module.exports = function (postcssResult, cssSyntaxError) {
        /** @type {StylelintResult} */
        let stylelintResult;
        /** @type {string | undefined} */
        let source;

        if (postcssResult && postcssResult.root) {
          if (postcssResult.root.source) {
            source = postcssResult.root.source.input.file;

            if (!source && 'id' in postcssResult.root.source.input) {
              source = postcssResult.root.source.input.id;
            }
          }

          const deprecationMessages = postcssResult.messages.filter(
          message => message.stylelintType === 'deprecation');

          const deprecations = deprecationMessages.map(deprecationMessage => {
            return {
              text: deprecationMessage.text,
              reference: deprecationMessage.stylelintReference };

          });

          const invalidOptionMessages = postcssResult.messages.filter(
          message => message.stylelintType === 'invalidOption');

          const invalidOptionWarnings = invalidOptionMessages.map(invalidOptionMessage => {
            return {
              text: invalidOptionMessage.text };

          });

          const parseErrors = postcssResult.messages.filter(
          message => message.stylelintType === 'parseError');


          // Remove deprecation warnings, invalid options, and parse errors from the messages
          postcssResult.messages = postcssResult.messages.filter(
          (message) =>
          message.stylelintType !== 'deprecation' &&
          message.stylelintType !== 'invalidOption' &&
          message.stylelintType !== 'parseError');


          // This defines the stylelint result object that formatters receive
          stylelintResult = {
            source,
            deprecations,
            invalidOptionWarnings,
            // TODO TYPES check which types are valid? postcss? stylelint?
            /* eslint-disable-next-line object-shorthand */
            parseErrors: /** @type {any} */parseErrors,
            errored: postcssResult.stylelint.stylelintError,
            warnings: postcssResult.messages.map(message => {
              return {
                line: message.line,
                column: message.column,
                rule: message.rule,
                severity: message.severity,
                text: message.text };

            }),
            ignored: postcssResult.stylelint.ignored,
            _postcssResult: postcssResult };

        } else if (cssSyntaxError) {
          if (cssSyntaxError.name !== 'CssSyntaxError') {
            throw cssSyntaxError;
          }

          stylelintResult = {
            source: cssSyntaxError.file || '<input css 1>',
            deprecations: [],
            invalidOptionWarnings: [],
            parseErrors: [],
            errored: true,
            warnings: [
            {
              line: cssSyntaxError.line,
              column: cssSyntaxError.column,
              rule: cssSyntaxError.name,
              severity: 'error',
              text: `${cssSyntaxError.reason} (${cssSyntaxError.name})` }] };



        } else {
          throw new Error(
          'createPartialStylelintResult must be called with either postcssResult or CssSyntaxError');

        }

        return stylelintResult;
      };

    }, {}], 124: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').Rule} StylelintRule */

      /**
       * @param {string} ruleName
       * @param {StylelintRule} rule
       * @returns {{ruleName: string, rule: StylelintRule}}
       */
      function createPlugin(ruleName, rule) {
        return {
          ruleName,
          rule };

      }

      module.exports = /** @type {typeof import('stylelint').createPlugin} */createPlugin;

    }, {}], 125: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          /* const augmentConfig = require('./augmentConfig'); */
          const createStylelintResult = require('./createStylelintResult');
          /* const getConfigForFile = require('./getConfigForFile'); */
          const getConfigForFile = async stylelint => ({
            config: require('./normalizeAllRuleSettings')(stylelint._options.config) });

          const getPostcssResult = require('./getPostcssResult');
          /* const isPathIgnored = require('./isPathIgnored'); */
          const isPathIgnored = async () => false;
          const lintSource = require('./lintSource');
          /* const { cosmiconfig } = require('cosmiconfig'); */

          const IS_TEST = process.env.NODE_ENV === 'test';
          const STOP_DIR = IS_TEST ? process.cwd() : undefined;

          /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

          /**
           * The stylelint "internal API" is passed among functions
           * so that methods on a stylelint instance can invoke
           * each other while sharing options and caches.
           *
           * @param {import('stylelint').LinterOptions} options
           * @returns {StylelintInternalApi}
           */
          function createStylelint(options = {}) {
            const cwd = options.cwd || process.cwd();

            /** @type {StylelintInternalApi} */
            // @ts-expect-error -- TS2740: Type '{ _options: LinterOptions; }' is missing the following properties from type 'InternalApi'
            const stylelint = { _options: _extends({}, options, { cwd }) };

            /* stylelint._extendExplorer = cosmiconfig('', {
            	transform: augmentConfig.augmentConfigExtended(cwd),
            	stopDir: STOP_DIR,
            }); */

            stylelint._specifiedConfigCache = new Map();
            stylelint._postcssResultCache = new Map();
            stylelint._createStylelintResult = createStylelintResult.bind(null, stylelint);
            stylelint._getPostcssResult = getPostcssResult.bind(null, stylelint);
            stylelint._lintSource = lintSource.bind(null, stylelint);

            stylelint.getConfigForFile = getConfigForFile.bind(null, stylelint);
            stylelint.isPathIgnored = isPathIgnored.bind(null, stylelint);

            return stylelint;
          }

          module.exports = /** @type {typeof import('stylelint').createLinter} */createStylelint;

        }).call(this);}).call(this, require('_process'));
    }, { "./createStylelintResult": 126, "./getPostcssResult": 133, "./lintSource": 136, "./normalizeAllRuleSettings": 138, "_process": 115 }], 126: [function (require, module, exports) {
      'use strict';

      const createPartialStylelintResult = require('./createPartialStylelintResult');

      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').LintResult} StylelintResult */

      /**
       * @param {import('stylelint').InternalApi} stylelint
       * @param {PostcssResult} [postcssResult]
       * @param {string} [filePath]
       * @param {import('stylelint').CssSyntaxError} [cssSyntaxError]
       * @return {Promise<StylelintResult>}
       */
      module.exports = async function createStylelintResult(
      stylelint,
      postcssResult,
      filePath,
      cssSyntaxError)
      {
        let stylelintResult = createPartialStylelintResult(postcssResult, cssSyntaxError);

        const configForFile = await stylelint.getConfigForFile(filePath, filePath);

        const config = configForFile === null ? {} : configForFile.config;
        const file = stylelintResult.source || cssSyntaxError && cssSyntaxError.file;

        if (config.resultProcessors) {
          for (const resultProcessor of config.resultProcessors) {
            // Result processors might just mutate the result object,
            // or might return a new one
            const returned = resultProcessor(stylelintResult, file);

            if (returned) {
              stylelintResult = returned;
            }
          }
        }

        return stylelintResult;
      };

    }, { "./createPartialStylelintResult": 123 }], 127: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */
      /** @typedef {import('stylelint').DisableOptionsReport} StylelintDisableOptionsReport */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function descriptionlessDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(
          result._postcssResult,
          'reportDescriptionlessDisables');


          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          const rangeData = stylelintResult.disabledRanges;

          /** @type {Set<PostcssComment>} */
          const alreadyReported = new Set();

          for (const rule of Object.keys(rangeData)) {
            for (const range of rangeData[rule]) {
              if (range.description) continue;

              if (alreadyReported.has(range.comment)) continue;

              if (enabled === optionsMatches(options, 'except', rule)) {
                // An 'all' rule will get copied for each individual rule. If the
                // configuration is `[false, {except: ['specific-rule']}]`, we
                // don't want to report the copies that match except, so we record
                // the comment as already reported.
                if (!enabled && rule === 'all') alreadyReported.add(range.comment);

                continue;
              }

              alreadyReported.add(range.comment);

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Disable for "${rule}" is missing a description`,
                rule: '--report-descriptionless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: options.severity });

            }
          }
        }
      };

    }, { "./utils/optionsMatches": 429, "./validateDisableSettings": 446 }], 128: [function (require, module, exports) {
      'use strict';

      /**
       * @type {import('stylelint').Formatter}
       */
      const formatter = (results) =>
      results.
      flatMap((result) =>
      result.warnings.map(
      (warning) =>
      `${result.source}: ` +
      `line ${warning.line}, ` +
      `col ${warning.column}, ` +
      `${warning.severity} - ` +
      `${warning.text}`)).


      join('\n');

      module.exports = formatter;

    }, {}], 129: [function (require, module, exports) {
      'use strict';

      const importLazy = require('import-lazy');

      /** @type {typeof import('stylelint').formatters} */
      const formatters = {
        compact: importLazy(() => require('./compactFormatter'))('compactFormatter'),
        json: importLazy(() => require('./jsonFormatter'))('jsonFormatter'),
        /* string: importLazy(() => require('./stringFormatter'))('stringFormatter'), */
        string: () => {},
        tap: importLazy(() => require('./tapFormatter'))('tapFormatter'),
        unix: importLazy(() => require('./unixFormatter'))('unixFormatter'),
        /* verbose: importLazy(() => require('./verboseFormatter'))('verboseFormatter'), */
        verbose: () => {} };


      module.exports = formatters;

    }, { "./compactFormatter": 128, "./jsonFormatter": 130, "./tapFormatter": 131, "./unixFormatter": 132, "import-lazy": 31 }], 130: [function (require, module, exports) {
      'use strict';

      /**
       * Omit any properties starting with `_`, which are fake-private
       *
       * @type {import('stylelint').Formatter}
       */
      module.exports = function jsonFormatter(results) {
        const cleanedResults = results.map((result) =>
        Object.entries(result).
        filter(([key]) => !key.startsWith('_')).
        reduce(( /** @type {{ [key: string]: any }} */obj, [key, value]) => {
          obj[key] = value;

          return obj;
        }, {}));


        return JSON.stringify(cleanedResults);
      };

    }, {}], 131: [function (require, module, exports) {
      'use strict';

      /**
       * @type {import('stylelint').Formatter}
       */
      const tapFormatter = results => {
        const lines = [`TAP version 13\n1..${results.length}`];

        for (const [index, result] of results.entries()) {
          lines.push(
          `${result.errored ? 'not ok' : 'ok'} ${index + 1} - ${result.ignored ? 'ignored ' : ''}${
          result.source
          }`);


          if (result.warnings.length > 0) {
            lines.push('---', 'messages:');

            for (const warning of result.warnings) {
              lines.push(
              ` - message: "${warning.text}"`,
              `   severity: ${warning.severity}`,
              `   data:`,
              `     line: ${warning.line}`,
              `     column: ${warning.column}`,
              `     ruleId: ${warning.rule}`);

            }

            lines.push('---');
          }
        }

        lines.push('');

        return lines.join('\n');
      };

      module.exports = tapFormatter;

    }, {}], 132: [function (require, module, exports) {
      'use strict';

      /**
       * @type {import('stylelint').Formatter}
       */
      const unixFormatter = results => {
        const lines = results.flatMap((result) =>
        result.warnings.map(
        (warning) =>
        `${result.source}:${warning.line}:${warning.column}: ` +
        `${warning.text} [${warning.severity}]\n`));


        const total = lines.length;
        let output = lines.join('');

        if (total > 0) {
          output += `\n${total} problem${total !== 1 ? 's' : ''}\n`;
        }

        return output;
      };

      module.exports = unixFormatter;

    }, {}], 133: [function (require, module, exports) {
      'use strict';

      const LazyResult = require('postcss/lib/lazy-result').default;
      const path = require('path');
      const { default: postcss } = require('postcss');
      /* const { promises: fs } = require('fs'); */

      /** @typedef {import('postcss').Result} Result */
      /** @typedef {import('postcss').Syntax} Syntax */
      /** @typedef {import('stylelint').CustomSyntax} CustomSyntax */
      /** @typedef {import('stylelint').GetPostcssOptions} GetPostcssOptions */
      /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */

      const postcssProcessor = postcss();

      /**
       * @param {StylelintInternalApi} stylelint
       * @param {GetPostcssOptions} options
       *
       * @returns {Promise<Result>}
       */
      module.exports = async function getPostcssResult(stylelint, options = {}) {
        const cached = options.filePath ? stylelint._postcssResultCache.get(options.filePath) : undefined;

        if (cached) {
          return cached;
        }

        if (stylelint._options.syntax) {
          let error = 'The "syntax" option is no longer available. ';

          error +=
          stylelint._options.syntax === 'css' ?
          'You can remove the "--syntax" CLI flag as stylelint will now parse files as CSS by default' :
          `You should install an appropriate syntax, e.g. postcss-scss, and use the "customSyntax" option`;

          return Promise.reject(new Error(error));
        }

        const syntax = options.customSyntax ?
        getCustomSyntax(options.customSyntax) :
        cssSyntax(stylelint, options.filePath);

        const postcssOptions = {
          from: options.filePath,
          syntax };


        /** @type {string | undefined} */
        let getCode;

        if (options.code !== undefined) {
          getCode = options.code;
        } else if (options.filePath) {
          /* getCode = await fs.readFile(options.filePath, 'utf8'); */
        }

        if (getCode === undefined) {
          return Promise.reject(new Error('code or filePath required'));
        }

        if (options.codeProcessors && options.codeProcessors.length) {
          if (stylelint._options.fix) {
            console.warn(
            'Autofix is incompatible with processors and will be disabled. Are you sure you need a processor?');

            stylelint._options.fix = false;
          }

          const sourceName = options.code ? options.codeFilename : options.filePath;

          for (const codeProcessor of options.codeProcessors) {
            getCode = codeProcessor(getCode, sourceName);
          }
        }

        const postcssResult = await new LazyResult(postcssProcessor, getCode, postcssOptions);

        if (options.filePath) {
          stylelint._postcssResultCache.set(options.filePath, postcssResult);
        }

        return postcssResult;
      };

      /**
       * @param {CustomSyntax} customSyntax
       * @returns {Syntax}
       */
      function getCustomSyntax(customSyntax) {
        let resolved;

        if (typeof customSyntax === 'string') {
          try {
            resolved = require(customSyntax);
          } catch (error) {
            if (
            error &&
            typeof error === 'object' &&
            // @ts-expect-error -- TS2571: Object is of type 'unknown'.
            error.code === 'MODULE_NOT_FOUND' &&
            // @ts-expect-error -- TS2571: Object is of type 'unknown'.
            error.message.includes(customSyntax))
            {
              throw new Error(
              `Cannot resolve custom syntax module "${customSyntax}". Check that module "${customSyntax}" is available and spelled correctly.\n\nCaused by: ${error}`);

            }

            throw error;
          }

          /*
           * PostCSS allows for syntaxes that only contain a parser, however,
           * it then expects the syntax to be set as the `parse` option.
           */
          if (!resolved.parse) {
            resolved = {
              parse: resolved,
              stringify: postcss.stringify };

          }

          return resolved;
        }

        if (typeof customSyntax === 'object') {
          if (typeof customSyntax.parse === 'function') {
            resolved = _extends({}, customSyntax);
          } else {
            throw new TypeError(
            `An object provided to the "customSyntax" option must have a "parse" property. Ensure the "parse" property exists and its value is a function.`);

          }

          return resolved;
        }

        throw new Error(`Custom syntax must be a string or a Syntax object`);
      }

      /** @type {{ [key: string]: string }} */
      const previouslyInferredExtensions = {
        html: 'postcss-html',
        js: '@stylelint/postcss-css-in-js',
        jsx: '@stylelint/postcss-css-in-js',
        less: 'postcss-less',
        md: 'postcss-markdown',
        sass: 'postcss-sass',
        sss: 'sugarss',
        scss: 'postcss-scss',
        svelte: 'postcss-html',
        ts: '@stylelint/postcss-css-in-js',
        tsx: '@stylelint/postcss-css-in-js',
        vue: 'postcss-html',
        xml: 'postcss-html',
        xst: 'postcss-html' };


      /**
       * @param {StylelintInternalApi} stylelint
       * @param {string|undefined} filePath
       * @returns {Syntax}
       */
      function cssSyntax(stylelint, filePath) {
        const fileExtension = filePath ? path.extname(filePath).slice(1).toLowerCase() : '';
        const extensions = ['css', 'pcss', 'postcss'];

        if (previouslyInferredExtensions[fileExtension]) {
          console.warn(
          `${filePath}: When linting something other than CSS, you should install an appropriate syntax, e.g. "${previouslyInferredExtensions[fileExtension]}", and use the "customSyntax" option`);

        }

        return {
          parse:
          stylelint._options.fix && extensions.includes(fileExtension) ?
          require('postcss-safe-parser') :
          postcss.parse,
          stringify: postcss.stringify };

      }

    }, { "path": 44, "postcss": 103, "postcss-safe-parser": 51, "postcss/lib/lazy-result": 96 }], 134: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('stylelint').RangeType} RangeType */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function invalidScopeDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(result._postcssResult, 'reportInvalidScopeDisables');

          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          const configRules = (stylelintResult.config || {}).rules || {};

          const usedRules = new Set(Object.keys(configRules));

          usedRules.add('all');

          const rangeData = stylelintResult.disabledRanges;
          const disabledRules = Object.keys(rangeData);

          for (const rule of disabledRules) {
            if (usedRules.has(rule)) continue;

            if (enabled === optionsMatches(options, 'except', rule)) continue;

            for (const range of rangeData[rule]) {
              if (!range.strictStart && !range.strictEnd) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Rule "${rule}" isn't enabled`,
                rule: '--report-invalid-scope-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: options.severity });

            }
          }
        }
      };

    }, { "./utils/optionsMatches": 429, "./validateDisableSettings": 446 }], 135: [function (require, module, exports) {
      'use strict';

      const assignDisabledRanges = require('./assignDisabledRanges');
      const getOsEol = require('./utils/getOsEol');
      const reportUnknownRuleNames = require('./reportUnknownRuleNames');
      const rulesOrder = require('./rules');

      /** @typedef {import('stylelint').LinterOptions} LinterOptions */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').Config} StylelintConfig */

      /**
       * @param {LinterOptions} stylelintOptions
       * @param {PostcssResult} postcssResult
       * @param {StylelintConfig} config
       * @returns {Promise<any>}
       */
      function lintPostcssResult(stylelintOptions, postcssResult, config) {
        postcssResult.stylelint.ruleSeverities = {};
        postcssResult.stylelint.customMessages = {};
        postcssResult.stylelint.stylelintError = false;
        postcssResult.stylelint.quiet = config.quiet;
        postcssResult.stylelint.config = config;

        /** @type {string | undefined} */
        let newline;
        const postcssDoc = postcssResult.root;

        if (postcssDoc) {
          if (!('type' in postcssDoc)) {
            throw new Error('Unexpected Postcss root object!');
          }

          const newlineMatch = postcssDoc.source && postcssDoc.source.input.css.match(/\r?\n/);

          newline = newlineMatch ? newlineMatch[0] : getOsEol();

          assignDisabledRanges(postcssDoc, postcssResult);
        }

        const isFileFixCompatible = isFixCompatible(postcssResult);

        if (!isFileFixCompatible) {
          postcssResult.stylelint.disableWritingFix = true;
        }

        const postcssRoots = /** @type {import('postcss').Root[]} */
        postcssDoc && postcssDoc.constructor.name === 'Document' ? postcssDoc.nodes : [postcssDoc];


        // Promises for the rules. Although the rule code runs synchronously now,
        // the use of Promises makes it compatible with the possibility of async
        // rules down the line.
        /** @type {Array<Promise<any>>} */
        const performRules = [];

        const rules = config.rules ?
        Object.keys(config.rules).sort(
        (a, b) => Object.keys(rulesOrder).indexOf(a) - Object.keys(rulesOrder).indexOf(b)) :

        [];

        for (const ruleName of rules) {
          const ruleFunction =
          rulesOrder[ruleName] || config.pluginFunctions && config.pluginFunctions[ruleName];

          if (ruleFunction === undefined) {
            performRules.push(
            Promise.all(
            postcssRoots.map((postcssRoot) =>
            reportUnknownRuleNames(ruleName, postcssRoot, postcssResult))));




            continue;
          }

          const ruleSettings = config.rules && config.rules[ruleName];

          if (ruleSettings === null || ruleSettings[0] === null) {
            continue;
          }

          const primaryOption = ruleSettings[0];
          const secondaryOptions = ruleSettings[1];

          // Log the rule's severity in the PostCSS result
          const defaultSeverity = config.defaultSeverity || 'error';
          // disableFix in secondary option
          const disableFix = secondaryOptions && secondaryOptions.disableFix === true || false;

          if (disableFix) {
            postcssResult.stylelint.ruleDisableFix = true;
          }

          postcssResult.stylelint.ruleSeverities[ruleName] =
          secondaryOptions && secondaryOptions.severity || defaultSeverity;
          postcssResult.stylelint.customMessages[ruleName] = secondaryOptions && secondaryOptions.message;

          performRules.push(
          Promise.all(
          postcssRoots.map((postcssRoot) =>
          ruleFunction(primaryOption, secondaryOptions, {
            fix:
            !disableFix &&
            stylelintOptions.fix &&
            // Next two conditionals are temporary measures until #2643 is resolved
            isFileFixCompatible &&
            !postcssResult.stylelint.disabledRanges[ruleName],
            newline })(
          postcssRoot, postcssResult))));



        }

        return Promise.all(performRules);
      }

      /**
       * There are currently some bugs in the autofixer of Stylelint.
       * The autofixer does not yet adhere to stylelint-disable comments, so if there are disabled
       * ranges we can not autofix this document. More info in issue #2643.
       *
       * @param {PostcssResult} postcssResult
       * @returns {boolean}
       */
      function isFixCompatible({ stylelint }) {
        // Check for issue #2643
        if (stylelint.disabledRanges.all.length) return false;

        return true;
      }

      module.exports = lintPostcssResult;

    }, { "./assignDisabledRanges": 122, "./reportUnknownRuleNames": 147, "./rules": 237, "./utils/getOsEol": 370 }], 136: [function (require, module, exports) {
      'use strict';

      const isPathNotFoundError = require('./utils/isPathNotFoundError');
      const lintPostcssResult = require('./lintPostcssResult');
      const path = require('path');

      /** @typedef {import('stylelint').InternalApi} StylelintInternalApi */
      /** @typedef {import('stylelint').GetLintSourceOptions} Options */
      /** @typedef {import('postcss').Result} Result */
      /** @typedef {import('stylelint').PostcssResult} PostcssResult */
      /** @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult */

      /**
       * Run stylelint on a PostCSS Result, either one that is provided
       * or one that we create
       * @param {StylelintInternalApi} stylelint
       * @param {Options} options
       * @returns {Promise<PostcssResult>}
       */
      module.exports = async function lintSource(stylelint, options = {}) {
        if (!options.filePath && options.code === undefined && !options.existingPostcssResult) {
          return Promise.reject(new Error('You must provide filePath, code, or existingPostcssResult'));
        }

        const isCodeNotFile = options.code !== undefined;

        const inputFilePath = isCodeNotFile ? options.codeFilename : options.filePath;

        if (inputFilePath !== undefined && !path.isAbsolute(inputFilePath)) {
          if (isCodeNotFile) {
            return Promise.reject(new Error('codeFilename must be an absolute path'));
          }

          return Promise.reject(new Error('filePath must be an absolute path'));
        }

        const isIgnored = await stylelint.isPathIgnored(inputFilePath).catch(err => {
          if (isCodeNotFile && isPathNotFoundError(err)) return false;

          throw err;
        });

        if (isIgnored) {
          return options.existingPostcssResult ?
          Object.assign(options.existingPostcssResult, {
            stylelint: createEmptyStylelintPostcssResult() }) :

          createEmptyPostcssResult(inputFilePath);
        }

        const configSearchPath = stylelint._options.configFile || inputFilePath;
        const cwd = stylelint._options.cwd;

        const configForFile = await stylelint.
        getConfigForFile(configSearchPath, inputFilePath).
        catch(err => {
          if (isCodeNotFile && isPathNotFoundError(err)) return stylelint.getConfigForFile(cwd);

          throw err;
        });

        if (!configForFile) {
          return Promise.reject(new Error('Config file not found'));
        }

        const config = configForFile.config;
        const existingPostcssResult = options.existingPostcssResult;
        const stylelintResult = {
          ruleSeverities: {},
          customMessages: {},
          disabledRanges: {} };


        const postcssResult =
        existingPostcssResult || (
        await stylelint._getPostcssResult({
          code: options.code,
          codeFilename: options.codeFilename,
          filePath: inputFilePath,
          codeProcessors: config.codeProcessors,
          customSyntax: config.customSyntax }));


        const stylelintPostcssResult = Object.assign(postcssResult, {
          stylelint: stylelintResult });


        await lintPostcssResult(stylelint._options, stylelintPostcssResult, config);

        return stylelintPostcssResult;
      };

      /**
       * @returns {StylelintPostcssResult}
       */
      function createEmptyStylelintPostcssResult() {
        return {
          ruleSeverities: {},
          customMessages: {},
          disabledRanges: {},
          ignored: true,
          stylelintError: false };

      }

      /**
       * @param {string} [filePath]
       * @returns {PostcssResult}
       */
      function createEmptyPostcssResult(filePath) {
        return {
          root: {
            source: {
              input: { file: filePath } } },


          messages: [],
          opts: undefined,
          stylelint: createEmptyStylelintPostcssResult(),
          warn: () => {} };

      }

    }, { "./lintPostcssResult": 135, "./utils/isPathNotFoundError": 403, "path": 44 }], 137: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('./utils/optionsMatches');
      const putIfAbsent = require('./utils/putIfAbsent');
      const validateDisableSettings = require('./validateDisableSettings');

      /** @typedef {import('postcss').Comment} PostcssComment */
      /** @typedef {import('stylelint').DisabledRange} DisabledRange */
      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisableReportRange */

      /**
       * @param {import('stylelint').LintResult[]} results
       */
      module.exports = function needlessDisables(results) {
        for (const result of results) {
          const settings = validateDisableSettings(result._postcssResult, 'reportNeedlessDisables');

          if (!settings) continue;

          const [enabled, options, stylelintResult] = settings;

          const rangeData = stylelintResult.disabledRanges;

          if (!rangeData) continue;

          const disabledWarnings = stylelintResult.disabledWarnings || [];

          // A map from `stylelint-disable` comments to the set of rules that
          // are usefully disabled by each comment. We track this
          // comment-by-comment rather than range-by-range because ranges that
          // disable *all* rules are duplicated for each rule they apply to in
          // practice.
          /** @type {Map<PostcssComment, Set<string>>}} */
          const usefulDisables = new Map();

          for (const warning of disabledWarnings) {
            const rule = warning.rule;
            const ruleRanges = rangeData[rule];

            if (ruleRanges) {
              for (const range of ruleRanges) {
                if (isWarningInRange(warning, range)) {
                  putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
                }
              }
            }

            for (const range of rangeData.all) {
              if (isWarningInRange(warning, range)) {
                putIfAbsent(usefulDisables, range.comment, () => new Set()).add(rule);
              }
            }
          }

          const allRangeComments = new Set(rangeData.all.map(range => range.comment));

          for (const [rule, ranges] of Object.entries(rangeData)) {
            for (const range of ranges) {
              if (rule !== 'all' && allRangeComments.has(range.comment)) continue;

              if (enabled === optionsMatches(options, 'except', rule)) continue;

              const useful = usefulDisables.get(range.comment) || new Set();

              // Only emit a warning if this range's comment isn't useful for this rule.
              // For the special rule "all", only emit a warning if it's not useful for
              // *any* rules, because it covers all of them.
              if (rule === 'all' ? useful.size !== 0 : useful.has(rule)) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Needless disable for "${rule}"`,
                rule: '--report-needless-disables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: options.severity });

            }
          }
        }
      };

      /**
       * @param {import('stylelint').DisabledWarning} warning
       * @param {RangeType} range
       * @return {boolean}
       */
      function isWarningInRange(warning, range) {
        const line = warning.line;

        // Need to check if range.end exist, because line number type cannot be compared to undefined
        return (
          range.start <= line && (
          range.end !== undefined && range.end >= line || range.end === undefined));

      }

    }, { "./utils/optionsMatches": 429, "./utils/putIfAbsent": 431, "./validateDisableSettings": 446 }], 138: [function (require, module, exports) {
      'use strict';

      const normalizeRuleSettings = require('./normalizeRuleSettings');
      const rules = require('./rules');

      /** @typedef {import('stylelint').ConfigRules} StylelintConfigRules */
      /** @typedef {import('stylelint').Config} StylelintConfig */

      /**
       * @param {StylelintConfig} config
       * @return {StylelintConfig}
       */
      function normalizeAllRuleSettings(config) {
        if (!config.rules) return config;

        /** @type {StylelintConfigRules} */
        const normalizedRules = {};

        for (const [ruleName, rawRuleSettings] of Object.entries(config.rules)) {
          const rule = rules[ruleName] || config.pluginFunctions && config.pluginFunctions[ruleName];

          if (rule) {
            normalizedRules[ruleName] = normalizeRuleSettings(
            rawRuleSettings,
            ruleName,
            rule.primaryOptionArray);

          } else {
            normalizedRules[ruleName] = [];
          }
        }

        config.rules = normalizedRules;

        return config;
      }

      module.exports = normalizeAllRuleSettings;

    }, { "./normalizeRuleSettings": 139, "./rules": 237 }], 139: [function (require, module, exports) {
      'use strict';

      const rules = require('./rules');
      const { isPlainObject } = require('is-plain-object');

      // Rule settings can take a number of forms, e.g.
      // a. "rule-name": null
      // b. "rule-name": [null, ...]
      // c. "rule-name": primaryOption
      // d. "rule-name": [primaryOption]
      // e. "rule-name": [primaryOption, secondaryOption]
      // Where primaryOption can be anything: primitive, Object, or Array.

      /**
       * This function normalizes all the possibilities into the
       * standard form: [primaryOption, secondaryOption]
       * Except in the cases with null, a & b, in which case
       * null is returned
       * @template T
       * @template {Object} O
       * @param {import('stylelint').ConfigRuleSettings<T, O>} rawSettings
       * @param {string} ruleName
       * @param {boolean} [primaryOptionArray] If primaryOptionArray is not provided, we try to get it from the rules themselves, which will not work for plugins
       * @return {[T] | [T, O] | null}
       */
      module.exports = function normalizeRuleSettings(
      rawSettings,
      ruleName,
      // If primaryOptionArray is not provided, we try to get it from the
      // rules themselves, which will not work for plugins
      primaryOptionArray)
      {
        if (rawSettings === null || rawSettings === undefined) {
          return null;
        }

        if (!Array.isArray(rawSettings)) {
          return [rawSettings];
        }
        // Everything below is an array ...

        if (rawSettings.length > 0 && (rawSettings[0] === null || rawSettings[0] === undefined)) {
          return null;
        }

        if (primaryOptionArray === undefined) {
          const rule = rules[ruleName];

          if (rule && 'primaryOptionArray' in rule) {
            primaryOptionArray = rule.primaryOptionArray;
          }
        }

        if (!primaryOptionArray) {
          return rawSettings;
        }
        // Everything below is a rule that CAN have an array for a primary option ...
        // (they might also have something else, e.g. rule-properties-order can
        // have the string "alphabetical")

        if (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {
          return rawSettings;
        }

        if (rawSettings.length === 2 && !isPlainObject(rawSettings[0]) && isPlainObject(rawSettings[1])) {
          return rawSettings;
        }

        // `T` must be an array type, but TSC thinks it's probably invalid to
        // cast `[T]` to `T` so we cast through `any` first.
        return [/** @type {T} */ /** @type {any} */rawSettings];
      };

    }, { "./rules": 237, "is-plain-object": 35 }], 140: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          const createStylelint = require('./createStylelint');
          const path = require('path');

          /** @typedef {import('stylelint').PostcssPluginOptions} PostcssPluginOptions */
          /** @typedef {import('stylelint').Config} StylelintConfig */

          /**
           * @type {import('postcss').PluginCreator<PostcssPluginOptions>}
           * */
          module.exports = (options = {}) => {
            const [cwd, tailoredOptions] = isConfig(options) ?
            [process.cwd(), { config: options }] :
            [options.cwd || process.cwd(), options];
            const stylelint = createStylelint(tailoredOptions);

            return {
              postcssPlugin: 'stylelint',
              Once(root, { result }) {
                let filePath = root.source && root.source.input.file;

                if (filePath && !path.isAbsolute(filePath)) {
                  filePath = path.join(cwd, filePath);
                }

                return stylelint._lintSource({
                  filePath,
                  existingPostcssResult: result });

              } };

          };

          module.exports.postcss = true;

          /**
           * @param {PostcssPluginOptions} options
           * @returns {options is StylelintConfig}
           */
          function isConfig(options) {
            return 'rules' in options;
          }

        }).call(this);}).call(this, require('_process'));
    }, { "./createStylelint": 125, "_process": 115, "path": 44 }], 141: [function (require, module, exports) {
      'use strict';

      const descriptionlessDisables = require('./descriptionlessDisables');
      const invalidScopeDisables = require('./invalidScopeDisables');
      const needlessDisables = require('./needlessDisables');
      const reportDisables = require('./reportDisables');

      /** @typedef {import('stylelint').Formatter} Formatter */
      /** @typedef {import('stylelint').LintResult} StylelintResult */
      /** @typedef {import('stylelint').LinterOptions["maxWarnings"]} maxWarnings */
      /** @typedef {import('stylelint').LinterResult} LinterResult */

      /**
       * @param {StylelintResult[]} stylelintResults
       * @param {maxWarnings} maxWarnings
       * @param {Formatter} formatter
       * @param {string} cwd
       *
       * @returns {LinterResult}
       */
      function prepareReturnValue(stylelintResults, maxWarnings, formatter, cwd) {
        reportDisables(stylelintResults);
        needlessDisables(stylelintResults);
        invalidScopeDisables(stylelintResults);
        descriptionlessDisables(stylelintResults);

        const errored = stylelintResults.some(
        (result) =>
        result.errored ||
        result.parseErrors.length > 0 ||
        result.warnings.some(warning => warning.severity === 'error'));


        /** @type {LinterResult} */
        const returnValue = {
          cwd,
          errored,
          results: [],
          output: '',
          reportedDisables: [] };


        if (maxWarnings !== undefined) {
          const foundWarnings = stylelintResults.reduce((count, file) => count + file.warnings.length, 0);

          if (foundWarnings > maxWarnings) {
            returnValue.maxWarningsExceeded = { maxWarnings, foundWarnings };
          }
        }

        returnValue.output = formatter(stylelintResults, returnValue);
        returnValue.results = stylelintResults;

        return returnValue;
      }

      module.exports = prepareReturnValue;

    }, { "./descriptionlessDisables": 127, "./invalidScopeDisables": 134, "./needlessDisables": 137, "./reportDisables": 146 }], 142: [function (require, module, exports) {
      'use strict';

      const keywordSets = {};

      keywordSets.nonLengthUnits = new Set([
      // Relative length units
      '%',
      // Time length units
      's',
      'ms',
      // Angle
      'deg',
      'grad',
      'turn',
      'rad',
      // Frequency
      'Hz',
      'kHz',
      // Resolution
      'dpi',
      'dpcm',
      'dppx']);


      keywordSets.lengthUnits = new Set([
      // Relative length units
      'em',
      'ex',
      'ch',
      'rem',
      'rlh',
      'lh',
      // Viewport-percentage lengths
      'vh',
      'vw',
      'vmin',
      'vmax',
      'vm',
      // Absolute length units
      'px',
      'mm',
      'cm',
      'in',
      'pt',
      'pc',
      'q',
      'mozmm',
      // Flexible length units
      'fr']);


      keywordSets.units = uniteSets(keywordSets.nonLengthUnits, keywordSets.lengthUnits);

      keywordSets.camelCaseFunctionNames = new Set([
      'translateX',
      'translateY',
      'translateZ',
      'scaleX',
      'scaleY',
      'scaleZ',
      'rotateX',
      'rotateY',
      'rotateZ',
      'skewX',
      'skewY']);


      keywordSets.basicKeywords = new Set(['initial', 'inherit', 'unset']);

      keywordSets.systemFontValues = uniteSets(keywordSets.basicKeywords, [
      'caption',
      'icon',
      'menu',
      'message-box',
      'small-caption',
      'status-bar']);


      keywordSets.fontFamilyKeywords = uniteSets(keywordSets.basicKeywords, [
      'serif',
      'sans-serif',
      'cursive',
      'fantasy',
      'monospace',
      'system-ui']);


      keywordSets.fontWeightRelativeKeywords = new Set(['bolder', 'lighter']);

      keywordSets.fontWeightAbsoluteKeywords = new Set(['bold']);

      keywordSets.fontWeightNumericKeywords = new Set([
      '100',
      '200',
      '300',
      '400',
      '500',
      '600',
      '700',
      '800',
      '900']);


      keywordSets.fontWeightKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontWeightRelativeKeywords,
      keywordSets.fontWeightAbsoluteKeywords,
      keywordSets.fontWeightNumericKeywords);


      keywordSets.animationNameKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.animationTimingFunctionKeywords = uniteSets(keywordSets.basicKeywords, [
      'linear',
      'ease',
      'ease-in',
      'ease-in-out',
      'ease-out',
      'step-start',
      'step-end',
      'steps',
      'cubic-bezier']);


      keywordSets.animationIterationCountKeywords = new Set(['infinite']);

      keywordSets.animationDirectionKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'reverse',
      'alternate',
      'alternate-reverse']);


      keywordSets.animationFillModeKeywords = new Set(['none', 'forwards', 'backwards', 'both']);

      keywordSets.animationPlayStateKeywords = uniteSets(keywordSets.basicKeywords, [
      'running',
      'paused']);


      // cf. https://developer.mozilla.org/en-US/docs/Web/CSS/animation
      keywordSets.animationShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.animationNameKeywords,
      keywordSets.animationTimingFunctionKeywords,
      keywordSets.animationIterationCountKeywords,
      keywordSets.animationDirectionKeywords,
      keywordSets.animationFillModeKeywords,
      keywordSets.animationPlayStateKeywords);


      // These are the ones that can have single-colon notation
      keywordSets.levelOneAndTwoPseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter']);


      // These are the ones that require double-colon notation
      keywordSets.levelThreeAndUpPseudoElements = new Set([
      'before',
      'after',
      'first-line',
      'first-letter',
      'selection',
      'spelling-error',
      'grammar-error',
      'backdrop',
      'marker',
      'placeholder',
      'shadow',
      'slotted',
      'content',
      'file-selector-button']);


      keywordSets.shadowTreePseudoElements = new Set(['part']);

      keywordSets.vendorSpecificPseudoElements = new Set([
      '-moz-progress-bar',
      '-moz-range-progress',
      '-moz-range-thumb',
      '-moz-range-track',
      '-ms-browse',
      '-ms-check',
      '-ms-clear',
      '-ms-expand',
      '-ms-fill',
      '-ms-fill-lower',
      '-ms-fill-upper',
      '-ms-reveal',
      '-ms-thumb',
      '-ms-ticks-after',
      '-ms-ticks-before',
      '-ms-tooltip',
      '-ms-track',
      '-ms-value',
      '-webkit-progress-bar',
      '-webkit-progress-value',
      '-webkit-slider-runnable-track',
      '-webkit-slider-thumb']);


      keywordSets.pseudoElements = uniteSets(
      keywordSets.levelOneAndTwoPseudoElements,
      keywordSets.levelThreeAndUpPseudoElements,
      keywordSets.vendorSpecificPseudoElements,
      keywordSets.shadowTreePseudoElements);


      keywordSets.aNPlusBNotationPseudoClasses = new Set([
      'nth-column',
      'nth-last-column',
      'nth-last-of-type',
      'nth-of-type']);


      keywordSets.linguisticPseudoClasses = new Set(['dir', 'lang']);

      keywordSets.atRulePagePseudoClasses = new Set(['first', 'right', 'left', 'blank']);

      keywordSets.logicalCombinationsPseudoClasses = new Set(['has', 'is', 'matches', 'not', 'where']);

      keywordSets.aNPlusBOfSNotationPseudoClasses = new Set(['nth-child', 'nth-last-child']);

      keywordSets.otherPseudoClasses = new Set([
      'active',
      'any-link',
      'autofill',
      'blank',
      'checked',
      /*
        https://www.w3.org/Style/CSS/Test/CSS3/Selectors/20011105/html/tests/css3-modsel-85.html
        https://www.w3.org/Style/CSS/Test/CSS3/Selectors/20011105/html/tests/css3-modsel-84.html
      */
      'contains',
      'current',
      'default',
      'defined',
      'disabled',
      'drop',
      'empty',
      'enabled',
      'first-child',
      'first-of-type',
      'focus',
      'focus-ring',
      'focus-within',
      'focus-visible',
      'fullscreen',
      'future',
      'host',
      'host-context',
      'hover',
      'indeterminate',
      'in-range',
      'invalid',
      'last-child',
      'last-of-type',
      'link',
      'only-child',
      'only-of-type',
      'optional',
      'out-of-range',
      'past',
      'placeholder-shown',
      'playing',
      'paused',
      'read-only',
      'read-write',
      'required',
      'root',
      'scope',
      'state',
      'target',
      'user-error',
      'user-invalid',
      'valid',
      'visited']);


      keywordSets.webkitProprietaryPseudoElements = new Set([
      'scrollbar',
      'scrollbar-button',
      'scrollbar-track',
      'scrollbar-track-piece',
      'scrollbar-thumb',
      'scrollbar-corner',
      'resize']);


      keywordSets.webkitProprietaryPseudoClasses = new Set([
      'horizontal',
      'vertical',
      'decrement',
      'increment',
      'start',
      'end',
      'double-button',
      'single-button',
      'no-button',
      'corner-present',
      'window-inactive']);


      keywordSets.pseudoClasses = uniteSets(
      keywordSets.aNPlusBNotationPseudoClasses,
      keywordSets.linguisticPseudoClasses,
      keywordSets.logicalCombinationsPseudoClasses,
      keywordSets.aNPlusBOfSNotationPseudoClasses,
      keywordSets.otherPseudoClasses);


      keywordSets.shorthandTimeProperties = new Set(['transition', 'animation']);

      keywordSets.longhandTimeProperties = new Set([
      'transition-duration',
      'transition-delay',
      'animation-duration',
      'animation-delay']);


      keywordSets.timeProperties = uniteSets(
      keywordSets.shorthandTimeProperties,
      keywordSets.longhandTimeProperties);


      keywordSets.camelCaseKeywords = new Set([
      'optimizeSpeed',
      'optimizeQuality',
      'optimizeLegibility',
      'geometricPrecision',
      'currentColor',
      'crispEdges',
      'visiblePainted',
      'visibleFill',
      'visibleStroke',
      'sRGB',
      'linearRGB']);


      // https://developer.mozilla.org/docs/Web/CSS/counter-increment
      keywordSets.counterIncrementKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.counterResetKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.gridRowKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridColumnKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      keywordSets.gridAreaKeywords = uniteSets(keywordSets.basicKeywords, ['auto', 'span']);

      // https://developer.mozilla.org/ru/docs/Web/CSS/list-style-type
      keywordSets.listStyleTypeKeywords = uniteSets(keywordSets.basicKeywords, [
      'none',
      'disc',
      'circle',
      'square',
      'decimal',
      'cjk-decimal',
      'decimal-leading-zero',
      'lower-roman',
      'upper-roman',
      'lower-greek',
      'lower-alpha',
      'lower-latin',
      'upper-alpha',
      'upper-latin',
      'arabic-indic',
      'armenian',
      'bengali',
      'cambodian',
      'cjk-earthly-branch',
      'cjk-ideographic',
      'devanagari',
      'ethiopic-numeric',
      'georgian',
      'gujarati',
      'gurmukhi',
      'hebrew',
      'hiragana',
      'hiragana-iroha',
      'japanese-formal',
      'japanese-informal',
      'kannada',
      'katakana',
      'katakana-iroha',
      'khmer',
      'korean-hangul-formal',
      'korean-hanja-formal',
      'korean-hanja-informal',
      'lao',
      'lower-armenian',
      'malayalam',
      'mongolian',
      'myanmar',
      'oriya',
      'persian',
      'simp-chinese-formal',
      'simp-chinese-informal',
      'tamil',
      'telugu',
      'thai',
      'tibetan',
      'trad-chinese-formal',
      'trad-chinese-informal',
      'upper-armenian',
      'disclosure-open',
      'disclosure-closed',
      // Non-standard extensions (without prefixe)
      'ethiopic-halehame',
      'ethiopic-halehame-am',
      'ethiopic-halehame-ti-er',
      'ethiopic-halehame-ti-et',
      'hangul',
      'hangul-consonant',
      'urdu']);


      keywordSets.listStylePositionKeywords = uniteSets(keywordSets.basicKeywords, ['inside', 'outside']);

      keywordSets.listStyleImageKeywords = uniteSets(keywordSets.basicKeywords, ['none']);

      keywordSets.listStyleShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.listStyleTypeKeywords,
      keywordSets.listStylePositionKeywords,
      keywordSets.listStyleImageKeywords);


      keywordSets.fontStyleKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'italic',
      'oblique']);


      keywordSets.fontVariantKeywords = uniteSets(keywordSets.basicKeywords, [
      'normal',
      'none',
      'historical-forms',
      'none',
      'common-ligatures',
      'no-common-ligatures',
      'discretionary-ligatures',
      'no-discretionary-ligatures',
      'historical-ligatures',
      'no-historical-ligatures',
      'contextual',
      'no-contextual',
      'small-caps',
      'small-caps',
      'all-small-caps',
      'petite-caps',
      'all-petite-caps',
      'unicase',
      'titling-caps',
      'lining-nums',
      'oldstyle-nums',
      'proportional-nums',
      'tabular-nums',
      'diagonal-fractions',
      'stacked-fractions',
      'ordinal',
      'slashed-zero',
      'jis78',
      'jis83',
      'jis90',
      'jis04',
      'simplified',
      'traditional',
      'full-width',
      'proportional-width',
      'ruby']);


      keywordSets.fontStretchKeywords = uniteSets(keywordSets.basicKeywords, [
      'semi-condensed',
      'condensed',
      'extra-condensed',
      'ultra-condensed',
      'semi-expanded',
      'expanded',
      'extra-expanded',
      'ultra-expanded']);


      keywordSets.fontSizeKeywords = uniteSets(keywordSets.basicKeywords, [
      'xx-small',
      'x-small',
      'small',
      'medium',
      'large',
      'x-large',
      'xx-large',
      'larger',
      'smaller']);


      keywordSets.lineHeightKeywords = uniteSets(keywordSets.basicKeywords, ['normal']);

      keywordSets.fontShorthandKeywords = uniteSets(
      keywordSets.basicKeywords,
      keywordSets.fontStyleKeywords,
      keywordSets.fontVariantKeywords,
      keywordSets.fontWeightKeywords,
      keywordSets.fontStretchKeywords,
      keywordSets.fontSizeKeywords,
      keywordSets.lineHeightKeywords,
      keywordSets.fontFamilyKeywords);


      keywordSets.keyframeSelectorKeywords = new Set(['from', 'to']);

      // https://www.w3.org/TR/css-page-3/#syntax-page-selector
      keywordSets.pageMarginAtRules = new Set([
      'top-left-corner',
      'top-left',
      'top-center',
      'top-right',
      'top-right-corner',
      'bottom-left-corner',
      'bottom-left',
      'bottom-center',
      'bottom-right',
      'bottom-right-corner',
      'left-top',
      'left-middle',
      'left-bottom',
      'right-top',
      'right-middle',
      'right-bottom']);


      // https://developer.mozilla.org/en/docs/Web/CSS/At-rule
      keywordSets.atRules = uniteSets(keywordSets.pageMarginAtRules, [
      'annotation',
      'apply',
      'character-variant',
      'charset',
      'counter-style',
      'custom-media',
      'custom-selector',
      'document',
      'font-face',
      'font-feature-values',
      'import',
      'keyframes',
      'media',
      'namespace',
      'nest',
      'ornaments',
      'page',
      'property',
      'styleset',
      'stylistic',
      'supports',
      'swash',
      'viewport']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.deprecatedMediaFeatureNames = new Set([
      'device-aspect-ratio',
      'device-height',
      'device-width',
      'max-device-aspect-ratio',
      'max-device-height',
      'max-device-width',
      'min-device-aspect-ratio',
      'min-device-height',
      'min-device-width']);


      // https://drafts.csswg.org/mediaqueries/#descdef-media-update
      keywordSets.mediaFeatureNames = uniteSets(keywordSets.deprecatedMediaFeatureNames, [
      'any-hover',
      'any-pointer',
      'aspect-ratio',
      'color',
      'color-gamut',
      'color-index',
      'dynamic-range',
      'forced-colors',
      'grid',
      'height',
      'hover',
      'inverted-colors',
      'light-level',
      'max-aspect-ratio',
      'max-color',
      'max-color-index',
      'max-height',
      'max-monochrome',
      'max-resolution',
      'max-width',
      'min-aspect-ratio',
      'min-color',
      'min-color-index',
      'min-height',
      'min-monochrome',
      'min-resolution',
      'min-width',
      'monochrome',
      'orientation',
      'overflow-block',
      'overflow-inline',
      'pointer',
      'prefers-color-scheme',
      'prefers-contrast',
      'prefers-reduced-motion',
      'prefers-reduced-transparency',
      'resolution',
      'scan',
      'scripting',
      'update',
      'video-dynamic-range',
      'width']);


      // https://www.w3.org/TR/CSS22/ui.html#system-colors
      keywordSets.systemColors = new Set([
      'activeborder',
      'activecaption',
      'appworkspace',
      'background',
      'buttonface',
      'buttonhighlight',
      'buttonshadow',
      'buttontext',
      'captiontext',
      'graytext',
      'highlight',
      'highlighttext',
      'inactiveborder',
      'inactivecaption',
      'inactivecaptiontext',
      'infobackground',
      'infotext',
      'menu',
      'menutext',
      'scrollbar',
      'threeddarkshadow',
      'threedface',
      'threedhighlight',
      'threedlightshadow',
      'threedshadow',
      'window',
      'windowframe',
      'windowtext']);


      // htmlTags includes only "standard" tags. So we augment it with older tags etc.
      keywordSets.nonStandardHtmlTags = new Set([
      'acronym',
      'applet',
      'basefont',
      'big',
      'blink',
      'center',
      'content',
      'dir',
      'font',
      'frame',
      'frameset',
      'hgroup',
      'isindex',
      'keygen',
      'listing',
      'marquee',
      'nobr',
      'noembed',
      'plaintext',
      'spacer',
      'strike',
      'tt',
      'xmp']);


      // extracted from https://developer.mozilla.org/en-US/docs/Web/SVG/Element
      keywordSets.validMixedCaseSvgElements = new Set([
      'animateMotion',
      'animateTransform',
      'clipPath',
      'feBlend',
      'feColorMatrix',
      'feComponentTransfer',
      'feComposite',
      'feConvolveMatrix',
      'feDiffuseLighting',
      'feDisplacementMap',
      'feDistantLight',
      'feDropShadow',
      'feFlood',
      'feFuncA',
      'feFuncB',
      'feFuncG',
      'feFuncR',
      'feGaussianBlur',
      'feImage',
      'feMerge',
      'feMergeNode',
      'feMorphology',
      'feOffset',
      'fePointLight',
      'feSpecularLighting',
      'feSpotLight',
      'feTile',
      'feTurbulence',
      'foreignObject',
      'linearGradient',
      'radialGradient',
      'textPath']);


      /**
       * @param {(string[] | Set<string>)[]} args
       */
      function uniteSets(...args) {
        return new Set([...args].reduce((result, set) => [...result, ...set], []));
      }

      module.exports = keywordSets;

    }, {}], 143: [function (require, module, exports) {
      'use strict';

      module.exports = ['calc', 'clamp', 'max', 'min'];

    }, {}], 144: [function (require, module, exports) {
      'use strict';

      const propertySets = {};

      propertySets.acceptCustomIdents = new Set([
      'animation',
      'animation-name',
      'font',
      'font-family',
      'counter-increment',
      'grid-row',
      'grid-column',
      'grid-area',
      'list-style',
      'list-style-type']);


      module.exports = propertySets;

    }, {}], 145: [function (require, module, exports) {
      'use strict';

      /** @type {Record<string, string[]>} */
      module.exports = {
        margin: ['margin-top', 'margin-bottom', 'margin-left', 'margin-right'],
        padding: ['padding-top', 'padding-bottom', 'padding-left', 'padding-right'],
        background: [
        'background-image',
        'background-size',
        'background-position',
        'background-repeat',
        'background-origin',
        'background-clip',
        'background-attachment',
        'background-color'],

        font: [
        'font-style',
        'font-variant',
        'font-weight',
        'font-stretch',
        'font-size',
        'font-family',
        'line-height'],

        border: [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width',
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style',
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'border-top': ['border-top-width', 'border-top-style', 'border-top-color'],
        'border-bottom': ['border-bottom-width', 'border-bottom-style', 'border-bottom-color'],
        'border-left': ['border-left-width', 'border-left-style', 'border-left-color'],
        'border-right': ['border-right-width', 'border-right-style', 'border-right-color'],
        'border-width': [
        'border-top-width',
        'border-bottom-width',
        'border-left-width',
        'border-right-width'],

        'border-style': [
        'border-top-style',
        'border-bottom-style',
        'border-left-style',
        'border-right-style'],

        'border-color': [
        'border-top-color',
        'border-bottom-color',
        'border-left-color',
        'border-right-color'],

        'list-style': ['list-style-type', 'list-style-position', 'list-style-image'],
        'border-radius': [
        'border-top-right-radius',
        'border-top-left-radius',
        'border-bottom-right-radius',
        'border-bottom-left-radius'],

        transition: [
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'],

        animation: [
        'animation-name',
        'animation-duration',
        'animation-timing-function',
        'animation-delay',
        'animation-iteration-count',
        'animation-direction',
        'animation-fill-mode',
        'animation-play-state'],

        'border-block-end': [
        'border-block-end-width',
        'border-block-end-style',
        'border-block-end-color'],

        'border-block-start': [
        'border-block-start-width',
        'border-block-start-style',
        'border-block-start-color'],

        'border-image': [
        'border-image-source',
        'border-image-slice',
        'border-image-width',
        'border-image-outset',
        'border-image-repeat'],

        'border-inline-end': [
        'border-inline-end-width',
        'border-inline-end-style',
        'border-inline-end-color'],

        'border-inline-start': [
        'border-inline-start-width',
        'border-inline-start-style',
        'border-inline-start-color'],

        'column-rule': ['column-rule-width', 'column-rule-style', 'column-rule-color'],
        columns: ['column-width', 'column-count'],
        flex: ['flex-grow', 'flex-shrink', 'flex-basis'],
        'flex-flow': ['flex-direction', 'flex-wrap'],
        grid: [
        'grid-template-rows',
        'grid-template-columns',
        'grid-template-areas',
        'grid-auto-rows',
        'grid-auto-columns',
        'grid-auto-flow',
        'grid-column-gap',
        'grid-row-gap'],

        'grid-area': ['grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end'],
        'grid-column': ['grid-column-start', 'grid-column-end'],
        'grid-gap': ['grid-row-gap', 'grid-column-gap'],
        'grid-row': ['grid-row-start', 'grid-row-end'],
        'grid-template': ['grid-template-columns', 'grid-template-rows', 'grid-template-areas'],
        outline: ['outline-color', 'outline-style', 'outline-width'],
        'text-decoration': ['text-decoration-color', 'text-decoration-style', 'text-decoration-line'],
        'text-emphasis': ['text-emphasis-style', 'text-emphasis-color'],
        mask: [
        'mask-image',
        'mask-mode',
        'mask-position',
        'mask-size',
        'mask-repeat',
        'mask-origin',
        'mask-clip',
        'mask-composite'] };



    }, {}], 146: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').RangeType} RangeType */
      /** @typedef {import('stylelint').DisableReportRange} DisabledRange */
      /** @typedef {import('stylelint').LintResult} StylelintResult */
      /** @typedef {import('stylelint').ConfigRuleSettings<any, Object>} StylelintConfigRuleSettings */

      /**
       * Returns a report describing which `results` (if any) contain disabled ranges
       * for rules that disallow disables via `reportDisables: true`.
       *
       * @param {StylelintResult[]} results
       */
      module.exports = function (results) {
        for (const result of results) {
          // File with `CssSyntaxError` don't have `_postcssResult`s.
          if (!result._postcssResult) {
            continue;
          }

          /** @type {{[ruleName: string]: Array<RangeType>}} */
          const rangeData = result._postcssResult.stylelint.disabledRanges;

          if (!rangeData) continue;

          const config = result._postcssResult.stylelint.config;

          if (!config || !config.rules) continue;

          // If no rules actually disallow disables, don't bother looking for ranges
          // that correspond to disabled rules.
          if (!Object.values(config.rules).some(rule => reportDisablesForRule(rule))) {
            continue;
          }

          for (const [rule, ranges] of Object.entries(rangeData)) {
            for (const range of ranges) {
              if (!reportDisablesForRule(config.rules[rule] || [])) continue;

              // If the comment doesn't have a location, we can't report a useful error.
              // In practice we expect all comments to have locations, though.
              if (!range.comment.source || !range.comment.source.start) continue;

              result.warnings.push({
                text: `Rule "${rule}" may not be disabled`,
                rule: 'reportDisables',
                line: range.comment.source.start.line,
                column: range.comment.source.start.column,
                severity: 'error' });

            }
          }
        }
      };

      /**
       * @param {StylelintConfigRuleSettings} options
       * @return {boolean}
       */
      function reportDisablesForRule(options) {
        if (!options || !options[1]) return false;

        return Boolean(options[1].reportDisables);
      }

    }, {}], 147: [function (require, module, exports) {
      'use strict';

      const levenshtein = require('fastest-levenshtein');
      const rules = require('./rules');

      const MAX_LEVENSHTEIN_DISTANCE = 6;
      const MAX_SUGGESTIONS_COUNT = 3;

      /**
       * @param {string} ruleName
       * @return {string[]}
       */
      function extractSuggestions(ruleName) {
        const suggestions = Array.from({ length: MAX_LEVENSHTEIN_DISTANCE });

        for (let i = 0; i < suggestions.length; i++) {
          suggestions[i] = [];
        }

        for (const existRuleName of Object.keys(rules)) {
          const distance = levenshtein.distance(existRuleName, ruleName);

          if (distance <= MAX_LEVENSHTEIN_DISTANCE) {
            suggestions[distance - 1].push(existRuleName);
          }
        }

        /** @type {string[]} */
        let result = [];

        for (const [i, suggestion] of suggestions.entries()) {
          if (suggestion.length > 0) {
            if (i < 3) {
              return suggestion.slice(0, MAX_SUGGESTIONS_COUNT);
            }

            result = result.concat(suggestion);
          }
        }

        return result.slice(0, MAX_SUGGESTIONS_COUNT);
      }

      /**
       * @param {string} ruleName
       * @param {string[]} [suggestions=[]]
       * @return {string}
       */
      function rejectMessage(ruleName, suggestions = []) {
        return `Unknown rule ${ruleName}.${
        suggestions.length > 0 ? ` Did you mean ${suggestions.join(', ')}?` : ''
        }`;
      }

      /** @type {Map<string, string[]>} */
      const cache = new Map();

      /**
       * @param {string} unknownRuleName
       * @param {import('postcss').Root} postcssRoot
       * @param {import('stylelint').PostcssResult} postcssResult
       * @returns {void}
       */
      module.exports = function reportUnknownRuleNames(unknownRuleName, postcssRoot, postcssResult) {
        const suggestions = cache.has(unknownRuleName) ?
        /** @type {string[]} */cache.get(unknownRuleName) :
        extractSuggestions(unknownRuleName);

        cache.set(unknownRuleName, suggestions);
        postcssResult.warn(rejectMessage(unknownRuleName, suggestions), {
          severity: 'error',
          rule: unknownRuleName,
          node: postcssRoot,
          index: 0 });

      };

    }, { "./rules": 237, "fastest-levenshtein": 19 }], 148: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          const createStylelint = require('./createStylelint');
          const path = require('path');

          /**
           * Resolves the effective configuation for a given file. Resolves to `undefined`
           * if no config is found.
           * @param {string} filePath - The path to the file to get the config for.
           * @param {Pick<
           *   import('stylelint').LinterOptions,
           *   | 'cwd'
           *   | 'config'
           *   | 'configBasedir'
           *   | 'configFile'
           * >} [options] - The options to use when creating the Stylelint instance.
           * @returns {Promise<import('stylelint').Config | undefined>}
           */
          module.exports = async function resolveConfig(
          filePath,
          { cwd = process.cwd(), config, configBasedir, configFile } = {})
          {
            if (!filePath) {
              return undefined;
            }

            const stylelint = createStylelint({
              config,
              configFile,
              configBasedir,
              cwd });


            const absoluteFilePath = !path.isAbsolute(filePath) ?
            path.join(cwd, filePath) :
            path.normalize(filePath);

            const configSearchPath = stylelint._options.configFile || absoluteFilePath;

            const resolved = await stylelint.getConfigForFile(configSearchPath, absoluteFilePath);

            if (!resolved) {
              return undefined;
            }

            return resolved.config;
          };

        }).call(this);}).call(this, require('_process'));
    }, { "./createStylelint": 125, "_process": 115, "path": 44 }], 149: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'alpha-value-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const ALPHA_PROPS = new Set(['opacity', 'shape-image-threshold']);
      const ALPHA_FUNCS = new Set(['hsl', 'hsla', 'hwb', 'lab', 'lch', 'rgb', 'rgba']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['number', 'percentage'] },

          {
            actual: secondaryOptions,
            possible: {
              exceptProperties: [isString, isRegExp] },

            optional: true });



          if (!validOptions) return;

          const optionFuncs = Object.freeze({
            number: {
              expFunc: isNumber,
              fixFunc: asNumber },

            percentage: {
              expFunc: isPercentage,
              fixFunc: asPercentage } });



          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              /** @type {import('postcss-value-parser').Node | undefined} */
              let alpha;

              if (ALPHA_PROPS.has(decl.prop.toLowerCase())) {
                alpha = findAlphaInValue(node);
              } else {
                if (node.type !== 'function') return;

                if (!ALPHA_FUNCS.has(node.value.toLowerCase())) return;

                alpha = findAlphaInFunction(node);
              }

              if (!alpha) return;

              const { value } = alpha;

              if (!isStandardSyntaxValue(value)) return;

              if (!isNumber(value) && !isPercentage(value)) return;

              /** @type {'number' | 'percentage'} */
              let expectation = primary;

              if (optionsMatches(secondaryOptions, 'exceptProperties', decl.prop)) {
                if (expectation === 'number') {
                  expectation = 'percentage';
                } else if (expectation === 'percentage') {
                  expectation = 'number';
                }
              }

              if (optionFuncs[expectation].expFunc(value)) return;

              const fixed = optionFuncs[expectation].fixFunc(value);
              const unfixed = value;

              if (context.fix) {
                alpha.value = String(fixed);
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index: declarationValueIndex(decl) + alpha.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} value
       * @returns {string | undefined}
       */
      function asPercentage(value) {
        const number = Number(value);

        return `${Number((number * 100).toPrecision(3))}%`;
      }

      /**
       * @param {string} value
       * @returns {string | undefined}
       */
      function asNumber(value) {
        const dimension = valueParser.unit(value);

        if (!dimension) return undefined;

        const number = Number(dimension.number);

        return Number((number / 100).toPrecision(3)).toString();
      }

      /**
       * @template {import('postcss-value-parser').Node} T
       * @param {T} node
       * @returns {T | undefined}
       */
      function findAlphaInValue(node) {
        return node.type === 'word' || node.type === 'function' ? node : undefined;
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       * @returns {import('postcss-value-parser').Node | undefined}
       */
      function findAlphaInFunction(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');

        if (args.length === 4) return args[3];

        const slashNodeIndex = node.nodes.findIndex(({ type, value }) => type === 'div' && value === '/');

        if (slashNodeIndex !== -1) {
          const nodesAfterSlash = node.nodes.slice(slashNodeIndex + 1, node.nodes.length);

          return nodesAfterSlash.find(({ type }) => type === 'word');
        }

        return undefined;
      }

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function isPercentage(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '%';
      }

      /**
       * @param {string} value
       * @returns {boolean}
       */
      function isNumber(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isStandardSyntaxValue": 421, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 150: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        // To allow for just a string as a parameter (not only arrays of strings)
        const primaryValues = [primary].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primaryValues,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          /** @type {string[]} */
          const atRuleNames = primaryValues;

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (atRuleNames.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 151: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected at-rule "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        // To allow for just a string as a parameter (not only arrays of strings)
        const primaryValues = [primary].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primaryValues,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          /** @type {string[]} */
          const atRuleNames = primaryValues;

          root.walkAtRules(atRule => {
            const name = atRule.name;

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            if (!atRuleNames.includes(vendor.unprefixed(name).toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(name),
              node: atRule,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 152: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterBlocklessAtRule');
      const isBlocklessAtRuleAfterSameNameBlocklessAtRule = require('../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before at-rule',
        rejected: 'Unexpected empty line before at-rule' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: [
              'after-same-name',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless',
              'first-nested'],

              ignore: [
              'after-comment',
              'first-nested',
              'inside-block',
              'blockless-after-same-name-blockless',
              'blockless-after-blockless'],

              ignoreAtRules: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          /** @type {'always' | 'never'} */
          const expectation = primary;

          root.walkAtRules(atRule => {
            const isNested = atRule.parent && atRule.parent.type !== 'root';

            // Ignore the first node
            if (isFirstNodeOfRoot(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            if (
            optionsMatches(secondaryOptions, 'ignore', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(atRule)) {
              return;
            }

            // Optionally ignore the expectation if the node is blockless
            // and following another blockless at-rule with the same name
            if (
            optionsMatches(secondaryOptions, 'ignore', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              return;
            }

            // Optionally ignore the expectation if the node is inside a block
            if (optionsMatches(secondaryOptions, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(atRule)) {
              return;
            }

            const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before);
            let expectEmptyLineBefore = expectation === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'after-same-name') &&
            isAtRuleAfterSameNameAtRule(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'inside-block') && isNested ||
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'blockless-after-blockless') &&
            isBlocklessAtRuleAfterBlocklessAtRule(atRule) ||
            optionsMatches(secondaryOptions, 'except', 'blockless-after-same-name-blockless') &&
            isBlocklessAtRuleAfterSameNameBlocklessAtRule(atRule))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix && context.newline) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(atRule, context.newline);
              } else {
                removeEmptyLinesBefore(atRule, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: atRule, result, ruleName });
          });
        };
      };

      /**
       * @param {import('postcss').AtRule} atRule
       */
      function isAtRuleAfterSameNameAtRule(atRule) {
        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        // @ts-expect-error -- TS2339: Property 'name' does not exist on type 'Node'.
        return previousNode && previousNode.type === 'atrule' && previousNode.name === atRule.name;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 350, "../../utils/getPreviousNonSharedLineCommentNode": 371, "../../utils/hasEmptyLine": 377, "../../utils/isAfterComment": 383, "../../utils/isBlocklessAtRuleAfterBlocklessAtRule": 386, "../../utils/isBlocklessAtRuleAfterSameNameBlocklessAtRule": 387, "../../utils/isFirstNested": 395, "../../utils/isFirstNodeOfRoot": 396, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesBefore": 434, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 153: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'at-rule-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          /** @type {'lower' | 'upper'} */
          const expectation = primary;

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            const expectedName = expectation === 'lower' ? name.toLowerCase() : name.toUpperCase();

            if (name === expectedName) {
              return;
            }

            if (context.fix) {
              atRule.name = expectedName;

              return;
            }

            report({
              message: messages.expected(name, expectedName),
              node: atRule,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 154: [function (require, module, exports) {
      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected newline after at-rule name "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../atRuleNameSpaceChecker": 160 }], 155: [function (require, module, exports) {
      'use strict';

      const atRuleNameSpaceChecker = require('../atRuleNameSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-name-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: name => `Expected single space after at-rule name "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          atRuleNameSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            atRule => {
              if (typeof atRule.raws.afterName === 'string') {
                atRule.raws.afterName = atRule.raws.afterName.replace(/^\s*/, ' ');
              }
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../atRuleNameSpaceChecker": 160 }], 156: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'at-rule-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: atRule => `Unexpected unknown at-rule "${atRule}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const name = atRule.name;

            // Return early if at-rule is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreAtRules', atRule.name)) {
              return;
            }

            if (vendor.prefix(name) || keywordSets.atRules.has(name.toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(`@${name}`),
              node: atRule,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 157: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'at-rule-property-required-list';

      const messages = ruleMessages(ruleName, {
        expected: (property, atRule) => `Expected property "${property}" for at-rule "${atRule}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          /** @type {Record<string, string[]>} */
          const list = primary;

          root.walkAtRules(atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const { name, nodes } = atRule;
            const atRuleName = name.toLowerCase();

            if (!list[atRuleName]) {
              return;
            }

            for (const property of list[atRuleName]) {
              const propertyName = property.toLowerCase();

              const hasProperty = nodes.find(
              node => node.type === 'decl' && node.prop.toLowerCase() === propertyName);


              if (hasProperty) {
                continue;
              }

              report({
                message: messages.expected(propertyName, atRuleName),
                node: atRule,
                result,
                ruleName });

              continue;
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;

      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "is-plain-object": 35 }], 158: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondary, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            const nextNode = atRule.next();

            if (!nextNode) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              err: msg => {
                if (context.fix) {
                  nodeToCheck.raws.before = context.newline + nodeToCheck.raws.before;
                } else {
                  report({
                    message: msg,
                    node: atRule,
                    index: atRule.toString().length + 1,
                    result,
                    ruleName });

                }
              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 375, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/nextNonCommentNode": 427, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 159: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'at-rule-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (hasBlock(atRule)) {
              return;
            }

            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            const nodeString = rawNodeString(atRule);

            checker.before({
              source: nodeString,
              index: nodeString.length,
              err: m => {
                report({
                  message: m,
                  node: atRule,
                  index: nodeString.length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 375, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 160: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../utils/isStandardSyntaxAtRule');
      const report = require('../utils/report');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: (opts: { source: string, index: number, err: (msg: string) => void, errTarget: string }) => void,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       *   fix?: ((atRule: import('postcss').AtRule) => void) | null,
       * }} options
       */
      module.exports = function atRuleNameSpaceChecker(options) {
        options.root.walkAtRules(atRule => {
          if (!isStandardSyntaxAtRule(atRule)) {
            return;
          }

          checkColon(
          `@${atRule.name}${atRule.raws.afterName || ''}${atRule.params}`,
          atRule.name.length,
          atRule);

        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkColon(source, index, node) {
          options.locationChecker({
            source,
            index,
            err: m => {
              if (options.fix) {
                options.fix(node);

                return;
              }

              report({
                message: m,
                node,
                index,
                result: options.result,
                ruleName: options.checkedRuleName });

            },
            errTarget: `@${node.name}` });

        }
      };

    }, { "../utils/isStandardSyntaxAtRule": 408, "../utils/report": 435 }], 161: [function (require, module, exports) {
      'use strict';

      const addEmptyLineAfter = require('../../utils/addEmptyLineAfter');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesAfter = require('../../utils/removeEmptyLinesAfter');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before closing brace',
        rejected: 'Unexpected empty line before closing brace' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always-multi-line', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['after-closing-brace'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Get whitespace after ""}", ignoring extra semicolon
            const before = (statement.raws.after || '').replace(/;+/, '');

            // Calculate index
            const statementString = statement.toString();
            let index = statementString.length - 1;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // Set expectation
            const expectEmptyLineBefore = (() => {
              const childNodeTypes = statement.nodes.map(item => item.type);

              // Reverse the primary options if `after-closing-brace` is set
              if (
              optionsMatches(secondaryOptions, 'except', 'after-closing-brace') &&
              statement.type === 'atrule' &&
              !childNodeTypes.includes('decl'))
              {
                return primary === 'never';
              }

              return primary === 'always-multi-line' && !isSingleLineString(blockString(statement));
            })();

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            if (context.fix) {
              const { newline } = context;

              if (typeof newline !== 'string') return;

              if (expectEmptyLineBefore) {
                addEmptyLineAfter(statement, newline);
              } else {
                removeEmptyLinesAfter(statement, newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              result,
              ruleName,
              node: statement,
              index });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineAfter": 349, "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/hasEmptyLine": 377, "../../utils/isSingleLineString": 407, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesAfter": 433, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 162: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'block-closing-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "}"',
        expectedAfterSingleLine: () => 'Expected newline after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected newline after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            if (!hasBlock(statement)) {
              return;
            }

            if (
            statement.type === 'atrule' &&
            optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name))
            {
              return;
            }

            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            // Allow an end-of-line comment x spaces after the brace
            const nextNodeIsSingleLineComment =
            nextNode.type === 'comment' &&
            !/[^ ]/.test(nextNode.raws.before || '') &&
            !nextNode.toString().includes('\n');

            const nodeToCheck = nextNodeIsSingleLineComment ? nextNode.next() : nextNode;

            if (!nodeToCheck) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nodeToCheck);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            // Only check one after, because there might be other
            // spaces handled by the indentation rule
            checker.afterOneOnly({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                if (context.fix) {
                  const nodeToCheckRaws = nodeToCheck.raws;

                  if (typeof nodeToCheckRaws.before !== 'string') return;

                  if (primary.startsWith('always')) {
                    const index = nodeToCheckRaws.before.search(/\r?\n/);

                    nodeToCheckRaws.before =
                    index >= 0 ?
                    nodeToCheckRaws.before.slice(index) :
                    context.newline + nodeToCheckRaws.before;

                    return;
                  }

                  if (primary.startsWith('never')) {
                    nodeToCheckRaws.before = '';

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/optionsMatches": 429, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/whitespaceChecker": 445 }], 163: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'block-closing-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: 'Expected newline before "}"',
        expectedBeforeMultiLine: 'Expected newline before "}" of a multi-line block',
        rejectedBeforeMultiLine: 'Unexpected whitespace before "}" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Ignore extra semicolon
            const after = (statement.raws.after || '').replace(/;+/, '');

            if (after === undefined) {
              return;
            }

            const blockIsMultiLine = !isSingleLineString(blockString(statement));
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            // We're really just checking whether a
            // newline *starts* the block's final space -- between
            // the last declaration and the closing brace. We can
            // ignore any other whitespace between them, because that
            // will be checked by the indentation rule.
            if (!after.startsWith('\n') && !after.startsWith('\r\n')) {
              if (primary === 'always') {
                complain(messages.expectedBefore);
              } else if (blockIsMultiLine && primary === 'always-multi-line') {
                complain(messages.expectedBeforeMultiLine);
              }
            }

            if (after !== '' && blockIsMultiLine && primary === 'never-multi-line') {
              complain(messages.rejectedBeforeMultiLine);
            }

            /**
             * @param {string} message
             */
            function complain(message) {
              if (context.fix) {
                const statementRaws = statement.raws;

                if (typeof statementRaws.after !== 'string') return;

                if (primary.startsWith('always')) {
                  const firstWhitespaceIndex = statementRaws.after.search(/\s/);
                  const newlineBefore =
                  firstWhitespaceIndex >= 0 ?
                  statementRaws.after.slice(0, firstWhitespaceIndex) :
                  statementRaws.after;
                  const newlineAfter =
                  firstWhitespaceIndex >= 0 ? statementRaws.after.slice(firstWhitespaceIndex) : '';
                  const newlineIndex = newlineAfter.search(/\r?\n/);

                  statementRaws.after =
                  newlineIndex >= 0 ?
                  newlineBefore + newlineAfter.slice(newlineIndex) :
                  newlineBefore + context.newline + newlineAfter;

                  return;
                }

                if (primary === 'never-multi-line') {
                  statementRaws.after = statementRaws.after.replace(/\s/g, '');

                  return;
                }
              }

              report({
                message,
                result,
                ruleName,
                node: statement,
                index });

            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/isSingleLineString": 407, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 164: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "}"',
        rejectedAfter: () => 'Unexpected whitespace after "}"',
        expectedAfterSingleLine: () => 'Expected single space after "}" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "}" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "}" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "}" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('space', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            const nextNode = statement.next();

            if (!nextNode) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            let reportIndex = statement.toString().length;
            let source = rawNodeString(nextNode);

            // Skip a semicolon at the beginning, if any
            if (source && source.startsWith(';')) {
              source = source.slice(1);
              reportIndex++;
            }

            checker.after({
              source,
              index: -1,
              lineCheckStr: blockString(statement),
              err: msg => {
                report({
                  message: msg,
                  node: statement,
                  index: reportIndex,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 165: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-closing-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "}"',
        rejectedBefore: () => 'Unexpected whitespace before "}"',
        expectedBeforeSingleLine: () => 'Expected single space before "}" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "}" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "}" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "}" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = blockString(statement);
            const statementString = statement.toString();

            let index = statementString.length - 2;

            if (statementString[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length - 1,
              err: msg => {
                if (context.fix) {
                  const statementRaws = statement.raws;

                  if (typeof statementRaws.after !== 'string') return;

                  if (primary.startsWith('always')) {
                    statementRaws.after = statementRaws.after.replace(/\s*$/, ' ');

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementRaws.after = statementRaws.after.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: msg,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 166: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean } = require('../../utils/validateTypes');

      const ruleName = 'block-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isBoolean },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            if (!hasEmptyBlock(statement) && !ignoreComments) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            const hasCommentsOnly = statement.nodes.every(node => node.type === 'comment');

            if (!hasCommentsOnly) {
              return;
            }

            let index = beforeBlockString(statement, { noRawBefore: true }).length;

            // For empty blocks when using SugarSS parser
            if (statement.raws.between === undefined) {
              index--;
            }

            report({
              message: messages.rejected,
              node: statement,
              index,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 167: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after "{"',
        expectedAfterMultiLine: () => 'Expected newline after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const backupCommentNextBefores = new Map();

            /**
             * next node with checking newlines after comment
             *
             * @param {import('postcss').ChildNode | undefined} startNode
             * @returns {import('postcss').ChildNode | undefined}
             */
            function nextNode(startNode) {
              if (!startNode || !startNode.next) return;

              if (startNode.type === 'comment') {
                const reNewLine = /\r?\n/;
                const newLineMatch = reNewLine.test(startNode.raws.before || '');

                const next = startNode.next();

                if (next && newLineMatch && !reNewLine.test(next.raws.before || '')) {
                  backupCommentNextBefores.set(next, next.raws.before);
                  next.raws.before = startNode.raws.before;
                }

                return nextNode(next);
              }

              return startNode;
            }

            // Allow an end-of-line comment
            const nodeToCheck = nextNode(statement.first);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  const nodeToCheckRaws = nodeToCheck.raws;

                  if (typeof nodeToCheckRaws.before !== 'string') return;

                  if (primary.startsWith('always')) {
                    const index = nodeToCheckRaws.before.search(/\r?\n/);

                    nodeToCheckRaws.before =
                    index >= 0 ?
                    nodeToCheckRaws.before.slice(index) :
                    context.newline + nodeToCheckRaws.before;

                    backupCommentNextBefores.delete(nodeToCheck);

                    return;
                  }

                  if (primary === 'never-multi-line') {
                    // Restore the `before` of the node next to the comment node.
                    for (const [node, before] of backupCommentNextBefores.entries()) {
                      node.raws.before = before;
                    }

                    backupCommentNextBefores.clear();

                    // Fix
                    const reNewLine = /\r?\n/;
                    let fixTarget = statement.first;

                    while (fixTarget) {
                      const fixTargetRaws = fixTarget.raws;

                      if (typeof fixTargetRaws.before !== 'string') continue;

                      if (reNewLine.test(fixTargetRaws.before || '')) {
                        fixTargetRaws.before = fixTargetRaws.before.replace(/\r?\n/g, '');
                      }

                      if (fixTarget.type !== 'comment') {
                        break;
                      }

                      fixTarget = fixTarget.next();
                    }

                    nodeToCheckRaws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });


            // Restore the `before` of the node next to the comment node.
            for (const [node, before] of backupCommentNextBefores.entries()) {
              node.raws.before = before;
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 168: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before "{"',
        expectedBeforeSingleLine: () => 'Expected newline before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected newline before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statement: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.beforeAllowingIndentation({
              lineCheckStr: blockString(statement),
              source,
              index: source.length,
              err: m => {
                if (context.fix) {
                  const statementRaws = statement.raws;

                  if (typeof statementRaws.between !== 'string') return;

                  if (primary.startsWith('always')) {
                    const spaceIndex = statementRaws.between.search(/\s+$/);

                    if (spaceIndex >= 0) {
                      statement.raws.between =
                      statementRaws.between.slice(0, spaceIndex) +
                      context.newline +
                      statementRaws.between.slice(spaceIndex);
                    } else {
                      statementRaws.between += context.newline;
                    }

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementRaws.between = statementRaws.between.replace(/\s*$/, '');

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 169: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'block-opening-brace-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "{"',
        rejectedAfter: () => 'Unexpected whitespace after "{"',
        expectedAfterSingleLine: () => 'Expected single space after "{" of a single-line block',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "{" of a single-line block',
        expectedAfterMultiLine: () => 'Expected single space after "{" of a multi-line block',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "{" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            checker.after({
              source: blockString(statement),
              index: 0,
              err: m => {
                if (context.fix) {
                  const statementFirst = statement.first;

                  if (statementFirst == null) return;

                  if (primary.startsWith('always')) {
                    statementFirst.raws.before = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statementFirst.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index: beforeBlockString(statement, { noRawBefore: true }).length + 1,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 170: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const hasBlock = require('../../utils/hasBlock');
      const hasEmptyBlock = require('../../utils/hasEmptyBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'block-opening-brace-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "{"',
        rejectedBefore: () => 'Unexpected whitespace before "{"',
        expectedBeforeSingleLine: () => 'Expected single space before "{" of a single-line block',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "{" of a single-line block',
        expectedBeforeMultiLine: () => 'Expected single space before "{" of a multi-line block',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "{" of a multi-line block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [
            'always',
            'never',
            'always-single-line',
            'never-single-line',
            'always-multi-line',
            'never-multi-line'] },


          {
            actual: secondaryOptions,
            possible: {
              ignoreAtRules: [isString, isRegExp],
              ignoreSelectors: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Check both kinds of statements: rules and at-rules
          root.walkRules(check);
          root.walkAtRules(check);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function check(statement) {
            // Return early if blockless or has an empty block
            if (!hasBlock(statement) || hasEmptyBlock(statement)) {
              return;
            }

            // Return early if at-rule is to be ignored
            if (
            statement.type === 'atrule' &&
            optionsMatches(secondaryOptions, 'ignoreAtRules', statement.name))
            {
              return;
            }

            // Return early if selector is to be ignored
            if (
            statement.type === 'rule' &&
            optionsMatches(secondaryOptions, 'ignoreSelectors', statement.selector))
            {
              return;
            }

            const source = beforeBlockString(statement);
            const beforeBraceNoRaw = beforeBlockString(statement, {
              noRawBefore: true });


            let index = beforeBraceNoRaw.length - 1;

            if (beforeBraceNoRaw[index - 1] === '\r') {
              index -= 1;
            }

            checker.before({
              source,
              index: source.length,
              lineCheckStr: blockString(statement),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    statement.raws.between = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    statement.raws.between = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: statement,
                  index,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/blockString": 354, "../../utils/hasBlock": 375, "../../utils/hasEmptyBlock": 376, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/whitespaceChecker": 445 }], 171: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxColorFunction = require('../../utils/isStandardSyntaxColorFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const { isValueFunction } = require('../../utils/typeGuards');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-function-notation';

      const messages = ruleMessages(ruleName, {
        expected: primary => `Expected ${primary} color-function notation` });


      const LEGACY_FUNCS = new Set(['rgba', 'hsla']);
      const LEGACY_NOTATION_FUNCS = new Set(['rgb', 'rgba', 'hsl', 'hsla']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['modern', 'legacy'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (!isValueFunction(node)) return;

              if (!isStandardSyntaxColorFunction(node)) return;

              const { value, sourceIndex, nodes } = node;

              if (!LEGACY_NOTATION_FUNCS.has(value.toLowerCase())) return;

              if (primary === 'modern' && !hasCommas(node)) return;

              if (primary === 'legacy' && hasCommas(node)) return;

              if (context.fix && primary === 'modern') {
                let commaCount = 0;

                // Convert punctuation
                node.nodes = nodes.map(childNode => {
                  if (isComma(childNode)) {
                    // Non-alpha commas to space and alpha commas to slashes
                    if (commaCount < 2) {
                      // @ts-expect-error -- TS2322: Type '"space"' is not assignable to type '"div"'.
                      childNode.type = 'space';
                      childNode.value = atLeastOneSpace(childNode.after);
                      commaCount++;
                    } else {
                      childNode.value = '/';
                      childNode.before = atLeastOneSpace(childNode.before);
                      childNode.after = atLeastOneSpace(childNode.after);
                    }
                  }

                  return childNode;
                });

                // Remove trailing 'a' from legacy function name
                if (LEGACY_FUNCS.has(node.value.toLowerCase())) {
                  node.value = node.value.slice(0, -1);
                }

                needsFix = true;

                return;
              }

              report({
                message: messages.expected(primary),
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} whitespace
       */
      function atLeastOneSpace(whitespace) {
        return whitespace !== '' ? whitespace : ' ';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {node is import('postcss-value-parser').DivNode}
       */
      function isComma(node) {
        return node.type === 'div' && node.value === ',';
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       */
      function hasCommas(node) {
        return node.nodes && node.nodes.some(childNode => isComma(childNode));
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isStandardSyntaxColorFunction": 409, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 172: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'color-hex-alpha';

      const messages = ruleMessages(ruleName, {
        expected: hex => `Expected alpha channel in "${hex}"`,
        unexpected: hex => `Unexpected alpha channel in "${hex}"` });


      const HEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            const parsedValue = valueParser(decl.value);

            parsedValue.walk(node => {
              if (isUrlFunction(node)) return false;

              if (!isHexColor(node)) return;

              const { value } = node;

              if (primary === 'always' && hasAlphaChannel(value)) return;

              if (primary === 'never' && !hasAlphaChannel(value)) return;

              report({
                message: primary === 'never' ? messages.unexpected(value) : messages.expected(value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isUrlFunction({ type, value }) {
        return type === 'function' && value === 'url';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      /**
       * @param {string} hex
       */
      function hasAlphaChannel(hex) {
        return hex.length === 5 || hex.length === 9;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 173: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));
            let needsFix = false;

            parsedValue.walk(node => {
              const { value } = node;

              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              const expected = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

              if (value === expected) return;

              if (context.fix) {
                node.value = expected;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(value, expected),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 174: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-hex-length';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['short', 'long'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));
            let needsFix = false;

            parsedValue.walk(node => {
              const { value: hexValue } = node;

              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              if (primary === 'long' && hexValue.length !== 4 && hexValue.length !== 5) {
                return;
              }

              if (primary === 'short' && (hexValue.length < 6 || !canShrink(hexValue))) {
                return;
              }

              const variant = primary === 'long' ? longer : shorter;
              const expectedHex = variant(hexValue);

              if (context.fix) {
                node.value = expectedHex;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(hexValue, expectedHex),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} hex
       */
      function canShrink(hex) {
        hex = hex.toLowerCase();

        return (
          hex[1] === hex[2] &&
          hex[3] === hex[4] &&
          hex[5] === hex[6] && (
          hex.length === 7 || hex.length === 9 && hex[7] === hex[8]));

      }

      /**
       * @param {string} hex
       */
      function shorter(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i += 2) {
          hexVariant += hex[i];
        }

        return hexVariant;
      }

      /**
       * @param {string} hex
       */
      function longer(hex) {
        let hexVariant = '#';

        for (let i = 1; i < hex.length; i++) {
          hexVariant += hex[i] + hex[i];
        }

        return hexVariant;
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 175: [function (require, module, exports) {
      const { colord, extend } = require('colord');
      const valueParser = require('postcss-value-parser');

      const namesPlugin = require('colord/plugins/names');
      const hwbPlugin = require('colord/plugins/hwb');
      const labPlugin = require('colord/plugins/lab');
      const lchPlugin = require('colord/plugins/lch');

      extend([
      // Type definitions are not compatible with commonjs.
      /** @type {any} */namesPlugin,
      /** @type {any} */hwbPlugin,
      /** @type {any} */labPlugin,
      /** @type {any} */lchPlugin,

      /* Syntaxes that is removed in Color Module Level 4 specification. */

      // hwb() with comma
      (_colordClass, parsers) => {
        parsers.string.push([parseHwbWithCommaString, /** @type {any} */'hwb-with-comma']);
      },
      // gray()
      (_colordClass, parsers) => {
        parsers.string.push([parseGrayString, /** @type {any} */'gray']);
      }]);


      module.exports = {
        colord };


      /**
       * Parses a valid hwb with comma CSS color function
       * https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb()#syntax
       * @type {import('colord/types').ParseFunction<string>}
       */
      function parseHwbWithCommaString(input) {
        input = input.toLowerCase();

        if (!input.startsWith('hwb(') || !input.endsWith(')') || input.includes('/')) {
          return null;
        }

        const [hue, whiteness = '', blackness = '', alpha, ...extraArgs] = input.slice(4, -1).split(',');

        if (!hue.trim() || !whiteness.trim() || !blackness.trim() || extraArgs.length > 0) {
          return null;
        }

        // Change the delimiter and parse with colord.
        const colordInstance = colord(
        `hwb(${hue} ${whiteness} ${blackness}${alpha ? ` / ${alpha}` : ''})`);


        if (!colordInstance.isValid()) {
          return null;
        }

        return colordInstance.rgba;
      }

      /**
       * Parses a valid gray() CSS color function
       * @type {import('colord/types').ParseFunction<string>}
       */
      function parseGrayString(input) {
        input = input.toLowerCase();

        if (!input.startsWith('gray(') || !input.endsWith(')')) {
          return null;
        }

        const [lightness, alpha, ...extraArgs] = input.slice(5, -1).split(',');

        if (extraArgs.length > 0) {
          return null;
        }

        const lightnessWithUnit = valueParser.unit(lightness.trim());

        if (!lightnessWithUnit || !['', '%'].includes(lightnessWithUnit.unit)) {
          return null;
        }

        /**
         * @type {import('colord/types').LabColor | import('colord/types').LabaColor}
         */
        let colorObject = {
          l: Number(lightnessWithUnit.number),
          a: 0,
          b: 0 };


        if (alpha) {
          const alphaWithUnit = valueParser.unit(alpha.trim());

          if (!alphaWithUnit || !['', '%'].includes(alphaWithUnit.unit)) {
            return null;
          }

          colorObject = _extends({},
          colorObject, {
            alpha: Number(alphaWithUnit.number) / (alphaWithUnit.unit ? 100 : 1) });

        }

        return colord(colorObject).rgba;
      }

    }, { "colord": 10, "colord/plugins/hwb": 11, "colord/plugins/lab": 12, "colord/plugins/lch": 13, "colord/plugins/names": 14, "postcss-value-parser": 83 }], 176: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const optionsMatches = require('../../utils/optionsMatches');
      const propertySets = require('../../reference/propertySets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');
      const { colord } = require('./colordUtils');

      const ruleName = 'color-named';

      const messages = ruleMessages(ruleName, {
        expected: (named, original) => `Expected "${original}" to be "${named}"`,
        rejected: named => `Unexpected named color "${named}"` });


      // Todo tested on case insensitivity
      const NODE_TYPES = new Set(['word', 'function']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['never', 'always-where-possible'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignore: ['inside-function'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (propertySets.acceptCustomIdents.has(decl.prop)) {
              return;
            }

            // Return early if the property is to be ignored
            if (optionsMatches(secondaryOptions, 'ignoreProperties', decl.prop)) {
              return;
            }

            valueParser(decl.value).walk(node => {
              const value = node.value;
              const type = node.type;
              const sourceIndex = node.sourceIndex;

              if (optionsMatches(secondaryOptions, 'ignore', 'inside-function') && type === 'function') {
                return false;
              }

              if (!isStandardSyntaxFunction(node)) {
                return false;
              }

              if (!isStandardSyntaxValue(value)) {
                return;
              }

              // Return early if neither a word nor a function
              if (!NODE_TYPES.has(type)) {
                return;
              }

              // Check for named colors for "never" option
              if (
              primary === 'never' &&
              type === 'word' &&
              /^[a-z]+$/iu.test(value) &&
              value.toLowerCase() !== 'transparent' &&
              colord(value).isValid())
              {
                complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex);

                return;
              }

              // Check "always-where-possible" option ...
              if (primary !== 'always-where-possible') {
                return;
              }

              let colorString = null;

              if (type === 'function') {
                // First by checking for alternative color function representations ...
                // Remove all spaces to match what's in `representations`
                colorString = valueParser.
                stringify(node).
                replace(/\s*([,/()])\s*/g, '$1').
                replace(/\s{2,}/g, ' ');
              } else if (type === 'word' && value.startsWith('#')) {
                // Then by checking for alternative hex representations
                colorString = value;
              } else {
                return;
              }

              const color = colord(colorString);

              if (!color.isValid()) {
                return;
              }

              const namedColor = color.toName();

              if (namedColor && namedColor.toLowerCase() !== 'transparent') {
                complain(
                messages.expected(namedColor, colorString),
                decl,
                declarationValueIndex(decl) + sourceIndex);

              }
            });
          });

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           */
          function complain(message, node, index) {
            report({
              result,
              ruleName,
              message,
              node,
              index });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/propertySets": 144, "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxFunction": 413, "../../utils/isStandardSyntaxValue": 421, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "./colordUtils": 175, "postcss-value-parser": 83 }], 177: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'color-no-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected hex color "${hex}"` });


      const HEX = /^#[0-9A-Za-z]+/;
      const IGNORED_FUNCTIONS = new Set(['url']);

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (isIgnoredFunction(node)) return false;

              if (!isHexColor(node)) return;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isIgnoredFunction({ type, value }) {
        return type === 'function' && IGNORED_FUNCTIONS.has(value.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isHexColor({ type, value }) {
        return type === 'word' && HEX.test(value);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 178: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxHexColor = require('../../utils/isStandardSyntaxHexColor');
      const isValidHex = require('../../utils/isValidHex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'color-no-invalid-hex';

      const messages = ruleMessages(ruleName, {
        rejected: hex => `Unexpected invalid hex color "${hex}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxHexColor(decl.value)) {
              return;
            }

            valueParser(decl.value).walk(({ value, type, sourceIndex }) => {
              if (type === 'function' && value.endsWith('url')) return false;

              if (type !== 'word') return;

              const hexMatch = /^#[0-9A-Za-z]+/.exec(value);

              if (!hexMatch) return;

              const hexValue = hexMatch[0];

              if (isValidHex(hexValue)) return;

              report({
                message: messages.rejected(hexValue),
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxHexColor": 414, "../../utils/isValidHex": 423, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 179: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSharedLineComment = require('../../utils/isSharedLineComment');
      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before comment',
        rejected: 'Unexpected empty line before comment' });


      const stylelintCommandPrefix = 'stylelint-';

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested'],
              ignore: ['stylelint-commands', 'after-comment'],
              ignoreComments: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // Ignore the first node
            if (isFirstNodeOfRoot(comment)) {
              return;
            }

            // Optionally ignore stylelint commands
            if (
            comment.text.startsWith(stylelintCommandPrefix) &&
            optionsMatches(secondaryOptions, 'ignore', 'stylelint-commands'))
            {
              return;
            }

            // Optionally ignore newlines between comments
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(comment)) {
              return;
            }

            // Ignore comments matching the ignoreComments option.
            if (optionsMatches(secondaryOptions, 'ignoreComments', comment.text)) {
              return;
            }

            // Ignore shared-line comments
            if (isSharedLineComment(comment)) {
              return;
            }

            // Ignore non-standard comments
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            const expectEmptyLineBefore = (() => {
              if (optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(comment)) {
                return false;
              }

              return primary === 'always';
            })();

            const before = comment.raws.before || '';
            const hasEmptyLineBefore = hasEmptyLine(before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (typeof context.newline !== 'string') return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(comment, context.newline);
              } else {
                removeEmptyLinesBefore(comment, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 350, "../../utils/hasEmptyLine": 377, "../../utils/isAfterComment": 383, "../../utils/isFirstNested": 395, "../../utils/isFirstNodeOfRoot": 396, "../../utils/isSharedLineComment": 406, "../../utils/isStandardSyntaxComment": 411, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesBefore": 434, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 180: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-no-empty';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty comment' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            // To ignore non-standard comments
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            // To ignore comments that are not empty
            if (comment.text && comment.text.length !== 0) {
              return;
            }

            report({
              message: messages.rejected,
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxComment": 411, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 181: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected comment to match pattern "${pattern}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkComments(comment => {
            const text = comment.text;

            if (normalizedPattern.test(text)) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 182: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'comment-whitespace-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected whitespace after "/*"',
        rejectedOpening: 'Unexpected whitespace after "/*"',
        expectedClosing: 'Expected whitespace before "*/"',
        rejectedClosing: 'Unexpected whitespace before "*/"' });


      /**
       * @param {import('postcss').Comment} comment
       */
      function addWhitespaceBefore(comment) {
        if (comment.text.startsWith('*')) {
          comment.text = comment.text.replace(/^(\*+)/, `$1 `);
        } else {
          comment.raws.left = ' ';
        }
      }

      /**
       * @param {import('postcss').Comment} comment
       */
      function addWhitespaceAfter(comment) {
        if (comment.text[comment.text.length - 1] === '*') {
          comment.text = comment.text.replace(/(\*+)$/, ` $1`);
        } else {
          comment.raws.right = ' ';
        }
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            if (!isStandardSyntaxComment(comment)) {
              return;
            }

            const rawComment = comment.toString();
            const firstFourChars = rawComment.substr(0, 4);

            // Return early if sourcemap or copyright comment
            if (/^\/\*[#!]\s/.test(firstFourChars)) {
              return;
            }

            const leftMatches = rawComment.match(/(^\/\*+)(\s)?/);

            if (leftMatches == null) throw new Error(`Invalid comment: "${rawComment}"`);

            const rightMatches = rawComment.match(/(\s)?(\*+\/)$/);

            if (rightMatches == null) throw new Error(`Invalid comment: "${rawComment}"`);

            const opener = leftMatches[1];
            const leftSpace = leftMatches[2] || '';
            const rightSpace = rightMatches[1] || '';
            const closer = rightMatches[2];

            if (primary === 'never' && leftSpace !== '') {
              complain(messages.rejectedOpening, opener.length);
            }

            if (primary === 'always' && !isWhitespace(leftSpace)) {
              complain(messages.expectedOpening, opener.length);
            }

            if (primary === 'never' && rightSpace !== '') {
              complain(messages.rejectedClosing, comment.toString().length - closer.length - 1);
            }

            if (primary === 'always' && !isWhitespace(rightSpace)) {
              complain(messages.expectedClosing, comment.toString().length - closer.length - 1);
            }

            /**
             * @param {string} message
             * @param {number} index
             */
            function complain(message, index) {
              if (context.fix) {
                if (primary === 'never') {
                  comment.raws.left = '';
                  comment.raws.right = '';
                  comment.text = comment.text.replace(/^(\*+)(\s+)?/, '$1').replace(/(\s+)?(\*+)$/, '$2');
                } else {
                  if (!leftSpace) {
                    addWhitespaceBefore(comment);
                  }

                  if (!rightSpace) {
                    addWhitespaceAfter(comment);
                  }
                }

                return;
              }

              report({
                message,
                index,
                result,
                ruleName,
                node: comment });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxComment": 411, "../../utils/isWhitespace": 425, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 183: [function (require, module, exports) {
      'use strict';

      const containsString = require('../../utils/containsString');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'comment-word-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: pattern => `Unexpected word matching pattern "${pattern}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkComments(comment => {
            const text = comment.text;
            const rawComment = comment.toString();
            const firstFourChars = rawComment.substr(0, 4);

            // Return early if sourcemap
            if (firstFourChars === '/*# ') {
              return;
            }

            const matchesWord = matchesStringOrRegExp(text, primary) || containsString(text, primary);

            if (!matchesWord) {
              return;
            }

            report({
              message: messages.rejected(matchesWord.pattern),
              node: comment,
              result,
              ruleName });

          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/containsString": 358, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 184: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'custom-media-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom media query name to match pattern "${pattern}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() !== 'custom-media') {
              return;
            }

            const match = atRule.params.match(/^--(\S+)\b/);

            if (match == null) throw new Error(`Unexpected at-rule params: "${atRule.params}"`);

            const customMediaName = match[1];

            if (regexpPattern.test(customMediaName)) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: atRule,
              index: atRuleParamIndex(atRule),
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 185: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRule } = require('../../utils/typeGuards');

      const ruleName = 'custom-property-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before custom property',
        rejected: 'Unexpected empty line before custom property' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested', 'after-comment', 'after-custom-property'],
              ignore: ['after-comment', 'first-nested', 'inside-single-line-block'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (!isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') &&
            parent != null && (
            isAtRule(parent) || isRule(parent)) &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = primary === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-custom-property') &&
            isAfterCustomProperty(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (context.newline == null) return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: decl,
              result,
              ruleName });

          });
        };
      };

      /**
       * @param {import('postcss').Declaration} decl
       */
      function isAfterCustomProperty(decl) {
        const prevNode = getPreviousNonSharedLineCommentNode(decl);

        return prevNode != null && isDeclaration(prevNode) && isCustomProperty(prevNode.prop);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 350, "../../utils/blockString": 354, "../../utils/getPreviousNonSharedLineCommentNode": 371, "../../utils/hasEmptyLine": 377, "../../utils/isAfterComment": 383, "../../utils/isCustomProperty": 393, "../../utils/isFirstNested": 395, "../../utils/isSingleLineString": 407, "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesBefore": 434, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442 }], 186: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'custom-property-no-missing-var-function';

      const messages = ruleMessages(ruleName, {
        rejected: customProperty => `Unexpected missing var function for "${customProperty}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) return;

          /** @type {Set<string>} */
          const knownCustomProperties = new Set();

          root.walkAtRules(/^property$/i, atRule => {
            knownCustomProperties.add(atRule.params);
          });

          root.walkDecls(({ prop }) => {
            if (isCustomProperty(prop)) knownCustomProperties.add(prop);
          });

          root.walkDecls(decl => {
            const { value } = decl;
            const parsedValue = valueParser(value);

            parsedValue.walk(node => {
              if (isVarFunction(node)) return false;

              if (!isDashedIdent(node)) return;

              if (!knownCustomProperties.has(node.value)) return;

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });


              return false;
            });
          });
        };
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isDashedIdent({ type, value }) {
        return type === 'word' && value.startsWith('--');
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isVarFunction({ type, value }) {
        return type === 'function' && value === 'var';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/isCustomProperty": 393, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 187: [function (require, module, exports) {
      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'custom-property-pattern';

      const messages = ruleMessages(ruleName, {
        expected: pattern => `Expected custom property name to match pattern "${pattern}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regexpPattern = isString(primary) ? new RegExp(primary) : primary;

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isCustomProperty(prop)) {
              return;
            }

            if (regexpPattern.test(prop.slice(2))) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 393, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 188: [function (require, module, exports) {
      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after "!"',
        rejectedAfter: () => 'Unexpected whitespace after "!"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const declValue = getDeclarationValue(decl);
              let target;
              /** @type {(value: string) => void} */
              let setFixed;

              if (bangIndex < declValue.length) {
                target = declValue;
                setFixed = value => {
                  setDeclarationValue(decl, value);
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= declValue.length;
                setFixed = value => {
                  decl.raws.important = value;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex + 1);
              const targetAfter = target.slice(bangIndex + 1);

              if (primary === 'always') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (primary === 'never') {
                setFixed(targetBefore + targetAfter.replace(/^\s*/, ''));

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../declarationBangSpaceChecker": 209 }], 189: [function (require, module, exports) {
      'use strict';

      const declarationBangSpaceChecker = require('../declarationBangSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-bang-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before "!"',
        rejectedBefore: () => 'Unexpected whitespace before "!"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationBangSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              let bangIndex = index - declarationValueIndex(decl);
              const value = getDeclarationValue(decl);
              let target;
              /** @type {(val: string) => void} */
              let setFixed;

              if (bangIndex < value.length) {
                target = value;
                setFixed = val => {
                  setDeclarationValue(decl, val);
                };
              } else if (decl.important) {
                target = decl.raws.important || ' !important';
                bangIndex -= value.length;
                setFixed = val => {
                  decl.raws.important = val;
                };
              } else {
                return false; // not standard
              }

              const targetBefore = target.slice(0, bangIndex);
              const targetAfter = target.slice(bangIndex);

              if (primary === 'always') {
                // eslint-disable-next-line prefer-template
                setFixed(targetBefore.replace(/\s*$/, '') + ' ' + targetAfter);

                return true;
              }

              if (primary === 'never') {
                setFixed(targetBefore.replace(/\s*$/, '') + targetAfter);

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../declarationBangSpaceChecker": 209 }], 190: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-no-duplicate-custom-properties';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected duplicate "${property}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            const decls = new Set();

            eachDecl(decl => {
              const prop = decl.prop;

              if (!isStandardSyntaxProperty(prop)) {
                return;
              }

              if (!isCustomProperty(prop)) {
                return;
              }

              const isDuplicate = decls.has(prop);

              if (isDuplicate) {
                report({
                  message: messages.rejected(prop),
                  node: decl,
                  result,
                  ruleName });


                return;
              }

              decls.add(prop);
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/eachDeclarationBlock": 360, "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxProperty": 416, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 191: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-duplicate-properties';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected duplicate "${property}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignore: [
              'consecutive-duplicates',
              'consecutive-duplicates-with-different-values',
              'consecutive-duplicates-with-same-prefixless-values'],

              ignoreProperties: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreDuplicates = optionsMatches(secondaryOptions, 'ignore', 'consecutive-duplicates');
          const ignoreDiffValues = optionsMatches(
          secondaryOptions,
          'ignore',
          'consecutive-duplicates-with-different-values');

          const ignorePrefixlessSameValues = optionsMatches(
          secondaryOptions,
          'ignore',
          'consecutive-duplicates-with-same-prefixless-values');


          eachDeclarationBlock(root, eachDecl => {
            /** @type {string[]} */
            const decls = [];
            /** @type {string[]} */
            const values = [];

            eachDecl(decl => {
              const prop = decl.prop;
              const value = decl.value;

              if (!isStandardSyntaxProperty(prop)) {
                return;
              }

              if (isCustomProperty(prop)) {
                return;
              }

              // Return early if the property is to be ignored
              if (optionsMatches(secondaryOptions, 'ignoreProperties', prop)) {
                return;
              }

              // Ignore the src property as commonly duplicated in at-fontface
              if (prop.toLowerCase() === 'src') {
                return;
              }

              const indexDuplicate = decls.indexOf(prop.toLowerCase());

              if (indexDuplicate !== -1) {
                if (ignoreDiffValues || ignorePrefixlessSameValues) {
                  // fails if duplicates are not consecutive
                  if (indexDuplicate !== decls.length - 1) {
                    report({
                      message: messages.rejected(prop),
                      node: decl,
                      result,
                      ruleName });


                    return;
                  }

                  const duplicateValue = values[indexDuplicate];

                  if (ignorePrefixlessSameValues) {
                    // fails if values of consecutive, unprefixed duplicates are equal
                    if (vendor.unprefixed(value) !== vendor.unprefixed(duplicateValue)) {
                      report({
                        message: messages.rejected(prop),
                        node: decl,
                        result,
                        ruleName });


                      return;
                    }
                  }

                  // fails if values of consecutive duplicates are equal
                  if (value === duplicateValue) {
                    report({
                      message: messages.rejected(prop),
                      node: decl,
                      result,
                      ruleName });


                    return;
                  }

                  return;
                }

                if (ignoreDuplicates && indexDuplicate === decls.length - 1) {
                  return;
                }

                report({
                  message: messages.rejected(prop),
                  node: decl,
                  result,
                  ruleName });

              }

              decls.push(prop.toLowerCase());
              values.push(value.toLowerCase());
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/eachDeclarationBlock": 360, "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxProperty": 416, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 192: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('../../utils/arrayEqual');
      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'declaration-block-no-redundant-longhand-properties';

      const messages = ruleMessages(ruleName, {
        expected: props => `Expected shorthand property "${props}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreShorthands: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const longhandProperties = Object.entries(shorthandData).reduce(
          ( /** @type {Record<string, string[]>} */longhandProps, [key, values]) => {
            if (optionsMatches(secondaryOptions, 'ignoreShorthands', key)) {
              return longhandProps;
            }

            for (const value of values) {
              (longhandProps[value] || (longhandProps[value] = [])).push(key);
            }

            return longhandProps;
          },
          {});


          eachDeclarationBlock(root, eachDecl => {
            /** @type {Record<string, string[]>} */
            const longhandDeclarations = {};

            eachDecl(decl => {
              const prop = decl.prop.toLowerCase();
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop);

              const shorthandProperties = longhandProperties[unprefixedProp];

              if (!shorthandProperties) {
                return;
              }

              for (const shorthandProperty of shorthandProperties) {
                const prefixedShorthandProperty = prefix + shorthandProperty;

                if (!longhandDeclarations[prefixedShorthandProperty]) {
                  longhandDeclarations[prefixedShorthandProperty] = [];
                }

                longhandDeclarations[prefixedShorthandProperty].push(prop);

                const prefixedShorthandData = shorthandData[shorthandProperty].map(
                item => prefix + item);


                if (
                !arrayEqual(
                prefixedShorthandData.sort(),
                longhandDeclarations[prefixedShorthandProperty].sort()))

                {
                  continue;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.expected(prefixedShorthandProperty) });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/shorthandData": 145, "../../utils/arrayEqual": 351, "../../utils/eachDeclarationBlock": 360, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 193: [function (require, module, exports) {
      'use strict';

      const eachDeclarationBlock = require('../../utils/eachDeclarationBlock');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const shorthandData = require('../../reference/shorthandData');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');

      const ruleName = 'declaration-block-no-shorthand-property-overrides';

      const messages = ruleMessages(ruleName, {
        rejected: (shorthand, original) => `Unexpected shorthand "${shorthand}" after "${original}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          eachDeclarationBlock(root, eachDecl => {
            /** @type {Record<string, string>} */
            const declarations = {};

            eachDecl(decl => {
              const prop = decl.prop;
              const unprefixedProp = vendor.unprefixed(prop);
              const prefix = vendor.prefix(prop).toLowerCase();

              const overrideables = shorthandData[unprefixedProp.toLowerCase()];

              if (!overrideables) {
                declarations[prop.toLowerCase()] = prop;

                return;
              }

              for (const longhandProp of overrideables) {
                if (!Object.prototype.hasOwnProperty.call(declarations, prefix + longhandProp)) {
                  continue;
                }

                report({
                  ruleName,
                  result,
                  node: decl,
                  message: messages.rejected(prop, declarations[prefix + longhandProp]) });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/shorthandData": 145, "../../utils/eachDeclarationBlock": 360, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444 }], 194: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const nextNonCommentNode = require('../../utils/nextNonCommentNode');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ";"',
        expectedAfterMultiLine: () => 'Expected newline after ";" in a multi-line declaration block',
        rejectedAfterMultiLine: () => 'Unexpected newline after ";" in a multi-line declaration block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextNode = decl.next();

            if (!nextNode) {
              return;
            }

            // Allow end-of-line comment
            const nodeToCheck = nextNonCommentNode(nextNode);

            if (!nodeToCheck) {
              return;
            }

            checker.afterOneOnly({
              source: rawNodeString(nodeToCheck),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    const index = nodeToCheck.raws.before.search(/\r?\n/);

                    nodeToCheck.raws.before =
                    index >= 0 ?
                    nodeToCheck.raws.before.slice(index) :
                    context.newline + nodeToCheck.raws.before;

                    return;
                  }

                  if (primary === 'never-multi-line') {
                    nodeToCheck.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/nextNonCommentNode": 427, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 195: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ";"',
        expectedBeforeMultiLine: () => 'Expected newline before ";" in a multi-line declaration block',
        rejectedBeforeMultiLine: () =>
        'Unexpected whitespace before ";" in a multi-line declaration block' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.beforeAllowingIndentation({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 196: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const rawNodeString = require('../../utils/rawNodeString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ";"',
        rejectedAfter: () => 'Unexpected whitespace after ";"',
        expectedAfterSingleLine: () =>
        'Expected single space after ";" in a single-line declaration block',
        rejectedAfterSingleLine: () =>
        'Unexpected whitespace after ";" in a single-line declaration block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return function (root, result) {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const nextDecl = decl.next();

            if (!nextDecl) {
              return;
            }

            checker.after({
              source: rawNodeString(nextDecl),
              index: -1,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  if (primary.startsWith('always')) {
                    nextDecl.raws.before = ' ';

                    return;
                  }

                  if (primary.startsWith('never')) {
                    nextDecl.raws.before = '';

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length + 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/rawNodeString": 432, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 197: [function (require, module, exports) {
      'use strict';

      const blockString = require('../../utils/blockString');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');
      const { isAtRule, isRule } = require('../../utils/typeGuards');

      const ruleName = 'declaration-block-semicolon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ";"',
        rejectedBefore: () => 'Unexpected whitespace before ";"',
        expectedBeforeSingleLine: () =>
        'Expected single space before ";" in a single-line declaration block',
        rejectedBeforeSingleLine: () =>
        'Unexpected whitespace before ";" in a single-line declaration block' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            // Ignore last declaration if there's no trailing semicolon
            const parentRule = decl.parent;

            if (!parentRule) throw new Error('A parent node must be present');

            if (!isAtRule(parentRule) && !isRule(parentRule)) {
              return;
            }

            if (!parentRule.raws.semicolon && parentRule.last === decl) {
              return;
            }

            const declString = decl.toString();

            checker.before({
              source: declString,
              index: declString.length,
              lineCheckStr: blockString(parentRule),
              err: m => {
                if (context.fix) {
                  const value = getDeclarationValue(decl);

                  if (primary.startsWith('always')) {
                    if (decl.important) {
                      decl.raws.important = ' !important ';
                    } else {
                      setDeclarationValue(decl, value.replace(/\s*$/, ' '));
                    }

                    return;
                  }

                  if (primary.startsWith('never')) {
                    if (decl.raws.important) {
                      decl.raws.important = decl.raws.important.replace(/\s*$/, '');
                    } else {
                      setDeclarationValue(decl, value.replace(/\s*$/, ''));
                    }

                    return;
                  }
                }

                report({
                  message: m,
                  node: decl,
                  index: decl.toString().length - 1,
                  result,
                  ruleName });

              } });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/blockString": 354, "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 198: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const blockString = require('../../utils/blockString');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'declaration-block-single-line-max-declarations';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} ${max === 1 ? 'declaration' : 'declarations'}` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isNumber] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isSingleLineString(blockString(ruleNode))) {
              return;
            }

            if (!ruleNode.nodes) {
              return;
            }

            const decls = ruleNode.nodes.filter(node => node.type === 'decl');

            if (decls.length <= primary) {
              return;
            }

            report({
              message: messages.expected(primary),
              node: ruleNode,
              index: beforeBlockString(ruleNode, { noRawBefore: true }).length,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/blockString": 354, "../../utils/isSingleLineString": 407, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 199: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-block-trailing-semicolon';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a trailing semicolon',
        rejected: 'Unexpected trailing semicolon' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['single-declaration'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (!atRule.parent) throw new Error('A parent node must be present');

            if (atRule.parent === root) {
              return;
            }

            if (atRule !== atRule.parent.last) {
              return;
            }

            if (hasBlock(atRule)) {
              return;
            }

            checkLastNode(atRule);
          });

          root.walkDecls(decl => {
            if (!decl.parent) throw new Error('A parent node must be present');

            if (decl.parent.type === 'object') {
              return;
            }

            if (decl !== decl.parent.last) {
              return;
            }

            checkLastNode(decl);
          });

          /**
           * @param {import('postcss').Node} node
           */
          function checkLastNode(node) {
            if (!node.parent) throw new Error('A parent node must be present');

            const hasSemicolon = node.parent.raws.semicolon;
            const ignoreSingleDeclaration = optionsMatches(
            secondaryOptions,
            'ignore',
            'single-declaration');


            if (ignoreSingleDeclaration && node.parent.first === node) {
              return;
            }

            let message;

            if (primary === 'always') {
              if (hasSemicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = true;

                if (node.type === 'atrule') {
                  node.raws.between = '';
                  node.parent.raws.after = ' ';
                }

                return;
              }

              message = messages.expected;
            } else if (primary === 'never') {
              if (!hasSemicolon) {
                return;
              }

              // auto-fix
              if (context.fix) {
                node.parent.raws.semicolon = false;

                return;
              }

              message = messages.rejected;
            } else {
              throw new Error(`Unexpected primary option: "${primary}"`);
            }

            report({
              message,
              node,
              index: node.toString().trim().length - 1,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 375, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 200: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ":"',
        expectedAfterMultiLine: () => 'Expected newline after ":" with a multi-line declaration' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            // Get the raw prop, and only the prop
            const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

            // The extra characters tacked onto the end ensure that there is a character to check
            // after the colon. Otherwise, with `background:pink` the character after the
            const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

            for (let i = 0, l = propPlusColon.length; i < l; i++) {
              if (propPlusColon[i] !== ':') {
                continue;
              }

              const indexToCheck = /^[^\S\r\n]*\/\*/.test(propPlusColon.slice(i + 1)) ?
              propPlusColon.indexOf('*/', i) + 1 :
              i;

              checker.afterOneOnly({
                source: propPlusColon,
                index: indexToCheck,
                lineCheckStr: decl.value,
                err: m => {
                  if (context.fix) {
                    const between = decl.raws.between;

                    if (between == null) throw new Error('`between` must be present');

                    const betweenStart = declarationValueIndex(decl) - between.length;
                    const sliceIndex = indexToCheck - betweenStart + 1;
                    const betweenBefore = between.slice(0, sliceIndex);
                    const betweenAfter = between.slice(sliceIndex);

                    decl.raws.between = /^\s*\n/.test(betweenAfter) ?
                    betweenBefore + betweenAfter.replace(/^[^\S\r\n]*/, '') :
                    betweenBefore + context.newline + betweenAfter;

                    return;
                  }

                  report({
                    message: m,
                    node: decl,
                    index: indexToCheck,
                    result,
                    ruleName });

                } });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445 }], 201: [function (require, module, exports) {
      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"',
        expectedAfterSingleLine: () => 'Expected single space after ":" with a single-line declaration' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (between == null) throw new Error('`between` must be present');

              if (primary.startsWith('always')) {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ': ');

                return true;
              }

              if (primary === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex) + between.slice(colonIndex).replace(/^:\s*/, ':');

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../declarationColonSpaceChecker": 210 }], 202: [function (require, module, exports) {
      'use strict';

      const declarationColonSpaceChecker = require('../declarationColonSpaceChecker');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'declaration-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          declarationColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (decl, index) => {
              const colonIndex = index - declarationValueIndex(decl);
              const between = decl.raws.between;

              if (between == null) throw new Error('`between` must be present');

              if (primary === 'always') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, ' ') + between.slice(colonIndex);

                return true;
              }

              if (primary === 'never') {
                decl.raws.between =
                between.slice(0, colonIndex).replace(/\s*$/, '') + between.slice(colonIndex);

                return true;
              }

              return false;
            } :
            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../declarationColonSpaceChecker": 210 }], 203: [function (require, module, exports) {
      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const blockString = require('../../utils/blockString');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterComment = require('../../utils/isAfterComment');
      const isAfterStandardPropertyDeclaration = require('../../utils/isAfterStandardPropertyDeclaration');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isRule, isRoot } = require('../../utils/typeGuards');

      const ruleName = 'declaration-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before declaration',
        rejected: 'Unexpected empty line before declaration' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['first-nested', 'after-comment', 'after-declaration'],
              ignore: [
              'after-comment',
              'after-declaration',
              'first-nested',
              'inside-single-line-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const parent = decl.parent;

            if (parent == null) {
              return;
            }

            // Ignore the first node
            if (isFirstNodeOfRoot(decl)) {
              return;
            }

            if (!isAtRule(parent) && !isRule(parent) && !isRoot(parent)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            // Optionally ignore the node if a comment precedes it
            if (optionsMatches(secondaryOptions, 'ignore', 'after-comment') && isAfterComment(decl)) {
              return;
            }

            // Optionally ignore the node if a declaration precedes it
            if (
            optionsMatches(secondaryOptions, 'ignore', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(secondaryOptions, 'ignore', 'first-nested') && isFirstNested(decl)) {
              return;
            }

            // Optionally ignore nodes inside single-line blocks
            if (
            optionsMatches(secondaryOptions, 'ignore', 'inside-single-line-block') &&
            isSingleLineString(blockString(parent)))
            {
              return;
            }

            let expectEmptyLineBefore = primary === 'always';

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(secondaryOptions, 'except', 'first-nested') && isFirstNested(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-comment') && isAfterComment(decl) ||
            optionsMatches(secondaryOptions, 'except', 'after-declaration') &&
            isAfterStandardPropertyDeclaration(decl))
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            // Check for at least one empty line
            const hasEmptyLineBefore = hasEmptyLine(decl.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (context.newline == null) return;

              if (expectEmptyLineBefore) {
                addEmptyLineBefore(decl, context.newline);
              } else {
                removeEmptyLinesBefore(decl, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({ message, node: decl, result, ruleName });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 350, "../../utils/blockString": 354, "../../utils/hasEmptyLine": 377, "../../utils/isAfterComment": 383, "../../utils/isAfterStandardPropertyDeclaration": 385, "../../utils/isCustomProperty": 393, "../../utils/isFirstNested": 395, "../../utils/isFirstNodeOfRoot": 396, "../../utils/isSingleLineString": 407, "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesBefore": 434, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442 }], 204: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.important) {
              return;
            }

            report({
              message: messages.rejected,
              node: decl,
              word: 'important',
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 205: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'declaration-property-unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      /** @type {import('stylelint').Rule<Record<string, string[]>>} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isPlainObject] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['inside-function'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = primary[propKey];

            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function') {
                if (node.value.toLowerCase() === 'url') {
                  return false;
                }

                if (optionsMatches(secondaryOptions, 'ignore', 'inside-function')) {
                  return false;
                }
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || (unit && propList.indexOf(unit.toLowerCase())) !== -1) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/matchesStringOrRegExp": 426, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "is-plain-object": 35, "postcss-value-parser": 83 }], 206: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'declaration-property-unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, unit) => `Unexpected unit "${unit}" for property "${property}"` });


      /** @type {import('stylelint').Rule<Record<string, string[]>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);

            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = primary[propKey];

            if (!propList) {
              return;
            }

            valueParser(value).walk(node => {
              // Ignore wrong units within `url` function
              if (node.type === 'function' && node.value.toLowerCase() === 'url') {
                return false;
              }

              if (node.type === 'string') {
                return;
              }

              const unit = getUnitFromValueNode(node);

              if (!unit || unit && !propList.includes(unit.toLowerCase())) {
                return;
              }

              report({
                message: messages.rejected(prop, unit),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "is-plain-object": 35, "postcss-value-parser": 83 }], 207: [function (require, module, exports) {
      'use strict';

      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'declaration-property-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      /** @type {import('stylelint').Rule<Record<string, (string | RegExp)[]>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = primary[propKey];

            if (!propList || propList.length === 0) {
              return;
            }

            if (matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "is-plain-object": 35 }], 208: [function (require, module, exports) {
      'use strict';

      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'declaration-property-value-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, value) => `Unexpected value "${value}" for property "${property}"` });


      /** @type {import('stylelint').Rule<Record<string, (string | RegExp)[]>>} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const value = decl.value;

            const unprefixedProp = vendor.unprefixed(prop);
            const propKey = Object.keys(primary).find((propIdentifier) =>
            matchesStringOrRegExp(unprefixedProp, propIdentifier));


            if (!propKey) {
              return;
            }

            const propList = primary[propKey];

            if (!propList || propList.length === 0) {
              return;
            }

            if (!matchesStringOrRegExp(value, propList)) {
              return;
            }

            report({
              message: messages.rejected(prop, value),
              node: decl,
              result,
              ruleName });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "is-plain-object": 35 }], 209: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /** @typedef {import('postcss').Declaration} Declaration */

      /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       *   fix: ((decl: Declaration, index: number) => boolean) | null,
       * }} opts
       * @returns {void}
       */
      module.exports = function declarationBangSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          const indexOffset = declarationValueIndex(decl);
          const declString = decl.toString();
          const valueString = decl.toString().slice(indexOffset);

          if (!valueString.includes('!')) {
            return;
          }

          styleSearch({ source: valueString, target: '!' }, match => {
            check(declString, match.startIndex + indexOffset, decl);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {Declaration} decl
         */
        function check(source, index, decl) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              if (opts.fix && opts.fix(decl, index)) {
                return;
              }

              report({
                message,
                node: decl,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/declarationValueIndex": 359, "../utils/report": 435, "style-search": 121 }], 210: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const report = require('../utils/report');

      /** @typedef {(args: { source: string, index: number, lineCheckStr: string, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   fix: ((decl: import('postcss').Declaration, index: number) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function declarationColonSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl)) {
            return;
          }

          // Get the raw prop, and only the prop
          const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || '').length - 1;

          // The extra characters tacked onto the end ensure that there is a character to check
          // after the colon. Otherwise, with `background:pink` the character after the
          const propPlusColon = `${decl.toString().slice(0, endOfPropIndex)}xxx`;

          for (let i = 0, l = propPlusColon.length; i < l; i++) {
            if (propPlusColon[i] !== ':') {
              continue;
            }

            opts.locationChecker({
              source: propPlusColon,
              index: i,
              lineCheckStr: decl.value,
              err: message => {
                if (opts.fix && opts.fix(decl, i)) {
                  return;
                }

                report({
                  message,
                  node: decl,
                  index: decl.prop.toString().length + 1,
                  result: opts.result,
                  ruleName: opts.checkedRuleName });

              } });

            break;
          }
        });
      };

    }, { "../utils/declarationValueIndex": 359, "../utils/isStandardSyntaxDeclaration": 412, "../utils/report": 435 }], 211: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const rangeOperators = ['>=', '<=', '>', '<', '='];

      /** @typedef {import('style-search').StyleSearchMatch} StyleSearchMatch */

      /**
       * @template {import('postcss').AtRule} T
       * @param {T} atRule
       * @param {(match: StyleSearchMatch, params: string, atRule: T) => void} cb
       */
      module.exports = function findMediaOperator(atRule, cb) {
        if (atRule.name.toLowerCase() !== 'media') {
          return;
        }

        const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

        styleSearch({ source: params, target: rangeOperators }, match => {
          const before = params[match.startIndex - 1];

          if (before === '>' || before === '<') {
            return;
          }

          cb(match, params, atRule);
        });
      };

    }, { "style-search": 121 }], 212: [function (require, module, exports) {
      'use strict';

      const findFontFamily = require('../../utils/findFontFamily');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'font-family-name-quotes';

      const messages = ruleMessages(ruleName, {
        expected: family => `Expected quotes around "${family}"`,
        rejected: family => `Unexpected quotes around "${family}"` });


      /**
       * @param {string} font
       * @returns {boolean}
       */
      function isSystemFontKeyword(font) {
        if (font.startsWith('-apple-')) {
          return true;
        }

        if (font === 'BlinkMacSystemFont') {
          return true;
        }

        return false;
      }

      /**
       * "To avoid mistakes in escaping, it is recommended to quote font family names
       * that contain white space, digits, or punctuation characters other than hyphens"
       * (https://www.w3.org/TR/CSS2/fonts.html#font-family-prop)
       *
       * @param {string} family
       * @returns {boolean}
       */
      function quotesRecommended(family) {
        return !/^[-a-zA-Z]+$/.test(family);
      }

      /**
       * Quotes are required if the family is not a valid CSS identifier
       * (regexes from https://mathiasbynens.be/notes/unquoted-font-family)
       *
       * @param {string} family
       * @returns {boolean}
       */
      function quotesRequired(family) {
        return family.
        split(/\s+/).
        some(word => /^(?:-?\d|--)/.test(word) || !/^[-\w\u{00A0}-\u{10FFFF}]+$/u.test(word));
      }

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always-where-required', 'always-where-recommended', 'always-unless-keyword'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            for (const fontFamilyNode of fontFamilies) {
              let rawFamily = fontFamilyNode.value;

              if ('quote' in fontFamilyNode) {
                rawFamily = fontFamilyNode.quote + rawFamily + fontFamilyNode.quote;
              }

              checkFamilyName(rawFamily, decl);
            }
          });

          /**
           * @param {string} rawFamily
           * @param {import('postcss').Declaration} decl
           */
          function checkFamilyName(rawFamily, decl) {
            if (!isStandardSyntaxValue(rawFamily)) {
              return;
            }

            if (isVariable(rawFamily)) {
              return;
            }

            const hasQuotes = rawFamily.startsWith("'") || rawFamily.startsWith('"');

            // Clean the family of its quotes
            const family = rawFamily.replace(/^['"]|['"]$/g, '');

            // Disallow quotes around (case-insensitive) keywords
            // and system font keywords in all cases
            if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {
              if (hasQuotes) {
                return complain(messages.rejected(family), family, decl);
              }

              return;
            }

            const required = quotesRequired(family);
            const recommended = quotesRecommended(family);

            switch (primary) {
              case 'always-unless-keyword':
                if (!hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }

                return;

              case 'always-where-recommended':
                if (!recommended && hasQuotes) {
                  return complain(messages.rejected(family), family, decl);
                }

                if (recommended && !hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }

                return;

              case 'always-where-required':
                if (!required && hasQuotes) {
                  return complain(messages.rejected(family), family, decl);
                }

                if (required && !hasQuotes) {
                  return complain(messages.expected(family), family, decl);
                }}

          }

          /**
           * @param {string} message
           * @param {string} family
           * @param {import('postcss').Declaration} decl
           */
          function complain(message, family, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              word: family });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/findFontFamily": 363, "../../utils/isStandardSyntaxValue": 421, "../../utils/isVariable": 424, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 213: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'font-family-no-duplicate-names';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected duplicate name ${name}` });


      /**
       * @param {import('postcss-value-parser').Node} node
       */
      const isFamilyNameKeyword = (node) =>
      !('quote' in node) && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreFontFamilyNames: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            const keywords = new Set();
            const familyNames = new Set();

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            for (const fontFamilyNode of fontFamilies) {
              const family = fontFamilyNode.value.trim();

              if (optionsMatches(secondaryOptions, 'ignoreFontFamilyNames', family)) {
                continue;
              }

              if (isFamilyNameKeyword(fontFamilyNode)) {
                if (keywords.has(family.toLowerCase())) {
                  complain(
                  messages.rejected(family),
                  declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                  decl);


                  continue;
                }

                keywords.add(family);

                continue;
              }

              if (familyNames.has(family)) {
                complain(
                messages.rejected(family),
                declarationValueIndex(decl) + fontFamilyNode.sourceIndex,
                decl);


                continue;
              }

              familyNames.add(family);
            }
          });

          /**
           * @param {string} message
           * @param {number} index
           * @param {import('postcss').Declaration} decl
           */
          function complain(message, index, decl) {
            report({
              result,
              ruleName,
              message,
              node: decl,
              index });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/findFontFamily": 363, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 214: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findFontFamily = require('../../utils/findFontFamily');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule } = require('../../utils/typeGuards');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'font-family-no-missing-generic-family-keyword';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing generic font family' });


      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {boolean}
       */
      const isFamilyNameKeyword = (node) =>
      !('quote' in node) && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase());

      /**
       * @param {string} value
       * @returns {boolean}
       */
      const isLastFontFamilyVariable = value => {
        const lastValue = postcss.list.comma(value).pop();

        return lastValue != null && (isVariable(lastValue) || !isStandardSyntaxValue(lastValue));
      };

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreFontFamilies: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(/^font(-family)?$/i, decl => {
            // Ignore @font-face
            const parent = decl.parent;

            if (parent && isAtRule(parent) && parent.name.toLowerCase() === 'font-face') {
              return;
            }

            if (decl.prop === 'font' && keywordSets.systemFontValues.has(decl.value.toLowerCase())) {
              return;
            }

            if (isLastFontFamilyVariable(decl.value)) {
              return;
            }

            const fontFamilies = findFontFamily(decl.value);

            if (fontFamilies.length === 0) {
              return;
            }

            if (fontFamilies.some(node => isFamilyNameKeyword(node))) {
              return;
            }

            if (
            fontFamilies.some((node) =>
            optionsMatches(secondaryOptions, 'ignoreFontFamilies', node.value)))

            {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.rejected,
              node: decl,
              index: declarationValueIndex(decl) + fontFamilies[fontFamilies.length - 1].sourceIndex });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/findFontFamily": 363, "../../utils/isStandardSyntaxValue": 421, "../../utils/isVariable": 424, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss": 103 }], 215: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isNumbery = require('../../utils/isNumbery');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const isVariable = require('../../utils/isVariable');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule } = require('../../utils/typeGuards');

      const ruleName = 'font-weight-notation';

      const messages = ruleMessages(ruleName, {
        expected: type => `Expected ${type} font-weight notation`,
        invalidNamed: name => `Unexpected invalid font-weight name "${name}"` });


      const INHERIT_KEYWORD = 'inherit';
      const INITIAL_KEYWORD = 'initial';
      const NORMAL_KEYWORD = 'normal';
      const WEIGHTS_WITH_KEYWORD_EQUIVALENTS = new Set(['400', '700']);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['numeric', 'named-where-possible'] },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['relative'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'font-weight') {
              checkWeight(decl.value, decl);
            }

            if (decl.prop.toLowerCase() === 'font') {
              checkFont(decl);
            }
          });

          /**
           * @param {import('postcss').Declaration} decl
           */
          function checkFont(decl) {
            const valueList = postcss.list.space(decl.value);
            // We do not need to more carefully distinguish font-weight
            // numbers from unitless line-heights because line-heights in
            // `font` values need to be part of a font-size/line-height pair
            const hasNumericFontWeight = valueList.some(value => isNumbery(value));

            for (const value of postcss.list.space(decl.value)) {
              if (
              value.toLowerCase() === NORMAL_KEYWORD && !hasNumericFontWeight ||
              isNumbery(value) ||
              value.toLowerCase() !== NORMAL_KEYWORD &&
              keywordSets.fontWeightKeywords.has(value.toLowerCase()))
              {
                checkWeight(value, decl);

                return;
              }
            }
          }

          /**
           * @param {string} weightValue
           * @param {import('postcss').Declaration} decl
           */
          function checkWeight(weightValue, decl) {
            if (!isStandardSyntaxValue(weightValue)) {
              return;
            }

            if (isVariable(weightValue)) {
              return;
            }

            if (
            weightValue.toLowerCase() === INHERIT_KEYWORD ||
            weightValue.toLowerCase() === INITIAL_KEYWORD)
            {
              return;
            }

            if (
            optionsMatches(secondaryOptions, 'ignore', 'relative') &&
            keywordSets.fontWeightRelativeKeywords.has(weightValue.toLowerCase()))
            {
              return;
            }

            const weightValueOffset = decl.value.indexOf(weightValue);

            if (primary === 'numeric') {
              const parent = decl.parent;

              if (parent && isAtRule(parent) && parent.name.toLowerCase() === 'font-face') {
                const weightValueNumbers = postcss.list.space(weightValue);

                if (!weightValueNumbers.every(value => isNumbery(value))) {
                  return complain(messages.expected('numeric'));
                }

                return;
              }

              if (!isNumbery(weightValue)) {
                return complain(messages.expected('numeric'));
              }
            }

            if (primary === 'named-where-possible') {
              if (isNumbery(weightValue)) {
                if (WEIGHTS_WITH_KEYWORD_EQUIVALENTS.has(weightValue)) {
                  complain(messages.expected('named'));
                }

                return;
              }

              if (
              !keywordSets.fontWeightKeywords.has(weightValue.toLowerCase()) &&
              weightValue.toLowerCase() !== NORMAL_KEYWORD)
              {
                return complain(messages.invalidNamed(weightValue));
              }
            }

            /**
             * @param {string} message
             */
            function complain(message) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + weightValueOffset });

            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/isNumbery": 401, "../../utils/isStandardSyntaxValue": 421, "../../utils/isVariable": 424, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "postcss": 103 }], 216: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const list = [primary].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (matchesStringOrRegExp(vendor.unprefixed(node.value), list)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxFunction": 413, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "postcss-value-parser": 83 }], 217: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-calc-no-unspaced-operator';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}" operator`,
        expectedAfter: operator => `Expected single space after "${operator}" operator`,
        expectedOperatorBeforeSign: operator => `Expected an operator before sign "${operator}"` });


      const OPERATORS = new Set(['*', '/', '+', '-']);
      const OPERATOR_REGEX = /[*/+-]/;

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) return;

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           */
          function complain(message, node, index) {
            report({ message, node, index, result, ruleName });
          }

          root.walkDecls(decl => {
            let needsFix = false;
            const valueIndex = declarationValueIndex(decl);
            const parsedValue = valueParser(getDeclarationValue(decl));

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             * @param {number} operatorIndex
             * @param {-1 | 1} direction
             */
            function checkAroundOperator(nodes, operatorIndex, direction) {
              const isBeforeOp = direction === -1;
              const currentNode = nodes[operatorIndex + direction];
              const operator = nodes[operatorIndex].value;
              const operatorSourceIndex = nodes[operatorIndex].sourceIndex;

              if (currentNode && !isSingleSpace(currentNode)) {
                if (currentNode.type === 'word') {
                  if (isBeforeOp) {
                    const lastChar = currentNode.value.slice(-1);

                    if (OPERATORS.has(lastChar)) {
                      if (context.fix) {
                        currentNode.value = `${currentNode.value.slice(0, -1)} ${lastChar}`;

                        return true;
                      }

                      complain(messages.expectedOperatorBeforeSign(operator), decl, operatorSourceIndex);

                      return true;
                    }
                  } else {
                    const firstChar = currentNode.value.slice(0, 1);

                    if (OPERATORS.has(firstChar)) {
                      if (context.fix) {
                        currentNode.value = `${firstChar} ${currentNode.value.slice(1)}`;

                        return true;
                      }

                      complain(messages.expectedAfter(operator), decl, operatorSourceIndex);

                      return true;
                    }
                  }

                  if (context.fix) {
                    needsFix = true;
                    currentNode.value = isBeforeOp ? `${currentNode.value} ` : ` ${currentNode.value}`;

                    return true;
                  }

                  complain(
                  isBeforeOp ? messages.expectedBefore(operator) : messages.expectedAfter(operator),
                  decl,
                  valueIndex + operatorSourceIndex);


                  return true;
                }

                if (currentNode.type === 'space') {
                  const indexOfFirstNewLine = currentNode.value.search(/(\n|\r\n)/);

                  if (indexOfFirstNewLine === 0) return;

                  if (context.fix) {
                    needsFix = true;

                    currentNode.value =
                    indexOfFirstNewLine === -1 ? ' ' : currentNode.value.slice(indexOfFirstNewLine);

                    return true;
                  }

                  const message = isBeforeOp ?
                  messages.expectedBefore(operator) :
                  messages.expectedAfter(operator);

                  complain(message, decl, valueIndex + operatorSourceIndex);

                  return true;
                }

                if (currentNode.type === 'function') {
                  if (context.fix) {
                    needsFix = true;
                    nodes.splice(operatorIndex, 0, { type: 'space', value: ' ', sourceIndex: 0 });

                    return true;
                  }

                  const message = isBeforeOp ?
                  messages.expectedBefore(operator) :
                  messages.expectedAfter(operator);

                  complain(message, decl, valueIndex + operatorSourceIndex);

                  return true;
                }
              }

              return false;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkForOperatorInFirstNode(nodes) {
              const firstNode = nodes[0];

              const operatorIndex =
              (firstNode.type === 'word' || -1) && firstNode.value.search(OPERATOR_REGEX);
              const operator = firstNode.value.slice(operatorIndex, operatorIndex + 1);

              if (operatorIndex <= 0) return false;

              const charBefore = firstNode.value.charAt(operatorIndex - 1);
              const charAfter = firstNode.value.charAt(operatorIndex + 1);

              if (charBefore && charBefore !== ' ' && charAfter && charAfter !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex + 1, ' ');
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedBefore(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex);

                  complain(
                  messages.expectedAfter(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex + 1);

                }
              } else if (charBefore && charBefore !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedBefore(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex);

                }
              } else if (charAfter && charAfter !== ' ') {
                if (context.fix) {
                  needsFix = true;
                  firstNode.value = insertCharAtIndex(firstNode.value, operatorIndex, ' ');
                } else {
                  complain(
                  messages.expectedAfter(operator),
                  decl,
                  valueIndex + firstNode.sourceIndex + operatorIndex + 1);

                }
              }

              return true;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkForOperatorInLastNode(nodes) {
              if (nodes.length === 1) return false;

              const lastNode = nodes[nodes.length - 1];

              const operatorIndex =
              (lastNode.type === 'word' || -1) && lastNode.value.search(OPERATOR_REGEX);

              if (lastNode.value[operatorIndex - 1] === ' ') return false;

              if (context.fix) {
                needsFix = true;
                lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex + 1, ' ').trim();
                lastNode.value = insertCharAtIndex(lastNode.value, operatorIndex, ' ').trim();

                return true;
              }

              complain(
              messages.expectedOperatorBeforeSign(lastNode.value[operatorIndex]),
              decl,
              valueIndex + lastNode.sourceIndex + operatorIndex);


              return true;
            }

            /**
             * @param {import('postcss-value-parser').Node[]} nodes
             */
            function checkWords(nodes) {
              if (checkForOperatorInFirstNode(nodes) || checkForOperatorInLastNode(nodes)) return;

              for (const [index, node] of nodes.entries()) {
                const lastChar = node.value.slice(-1);
                const firstChar = node.value.slice(0, 1);

                if (node.type === 'word') {
                  if (index === 0 && OPERATORS.has(lastChar)) {
                    if (context.fix) {
                      node.value = `${node.value.slice(0, -1)} ${lastChar}`;

                      continue;
                    }

                    complain(messages.expectedBefore(lastChar), decl, node.sourceIndex);
                  } else if (index === nodes.length && OPERATORS.has(firstChar)) {
                    if (context.fix) {
                      node.value = `${firstChar} ${node.value.slice(1)}`;

                      continue;
                    }

                    complain(messages.expectedOperatorBeforeSign(firstChar), decl, node.sourceIndex);
                  }
                }
              }
            }

            parsedValue.walk(node => {
              if (node.type !== 'function' || node.value.toLowerCase() !== 'calc') return;

              let foundOperatorNode = false;

              for (const [nodeIndex, currNode] of node.nodes.entries()) {
                if (currNode.type !== 'word' || !OPERATORS.has(currNode.value)) continue;

                foundOperatorNode = true;

                const nodeBefore = node.nodes[nodeIndex - 1];
                const nodeAfter = node.nodes[nodeIndex + 1];

                if (isSingleSpace(nodeBefore) && isSingleSpace(nodeAfter)) continue;

                if (checkAroundOperator(node.nodes, nodeIndex, 1)) continue;

                checkAroundOperator(node.nodes, nodeIndex, -1);
              }

              if (!foundOperatorNode) {
                checkWords(node.nodes);
              }
            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} str
       * @param {number} index
       * @param {string} char
       */
      function insertCharAtIndex(str, index, char) {
        return str.slice(0, index) + char + str.slice(index, str.length);
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {node is import('postcss-value-parser').SpaceNode & { value: ' ' } }
       */
      function isSingleSpace(node) {
        return node && node.type === 'space' && node.value === ' ';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 218: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line function',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'after',
              symb: context.newline || '' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../functionCommaSpaceChecker": 233, "../functionCommaSpaceFix": 234 }], 219: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line function',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'before',
              symb: context.newline || '' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../functionCommaSpaceChecker": 233, "../functionCommaSpaceFix": 234 }], 220: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line function',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'after',
              symb: ' ' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../functionCommaSpaceChecker": 233, "../functionCommaSpaceFix": 234 }], 221: [function (require, module, exports) {
      'use strict';

      const fixer = require('../functionCommaSpaceFix');
      const functionCommaSpaceChecker = require('../functionCommaSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'function-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line function',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          functionCommaSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (div, index, nodes) =>
            fixer({
              div,
              index,
              nodes,
              expectation: primary,
              position: 'before',
              symb: ' ' }) :

            null });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../functionCommaSpaceChecker": 233, "../functionCommaSpaceFix": 234 }], 222: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected function "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const value = decl.value;

            valueParser(value).walk(node => {
              if (node.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(node)) {
                return;
              }

              if (!matchesStringOrRegExp(vendor.unprefixed(node.value), primary)) {
                return;
              }

              report({
                message: messages.rejected(node.value),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxFunction": 413, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "postcss-value-parser": 83 }], 223: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'function-linear-gradient-no-nonstandard-direction';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected nonstandard direction' });


      /**
       * @param {string} source
       * @param {boolean} withToPrefix
       */
      function isStandardDirection(source, withToPrefix) {
        const regexp = withToPrefix ?
        /^to (top|left|bottom|right)(?: (top|left|bottom|right))?$/ :
        /^(top|left|bottom|right)(?: (top|left|bottom|right))?$/;

        const matches = source.match(regexp);

        if (!matches) {
          return false;
        }

        if (matches.length === 2) {
          return true;
        }

        // Cannot repeat side-or-corner, e.g. "to top top"
        if (matches.length === 3 && matches[1] !== matches[2]) {
          return true;
        }

        return false;
      }

      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            valueParser(decl.value).walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              functionArgumentsSearch(
              valueParser.stringify(valueNode).toLowerCase(),
              'linear-gradient',
              (expression, expressionIndex) => {
                const firstArg = expression.split(',')[0].trim();

                // If the first arg is not standard, return early
                if (!isStandardSyntaxValue(firstArg)) {
                  return;
                }

                // If the first character is a number, we can assume the user intends an angle
                if (/[\d.]/.test(firstArg[0])) {
                  if (/^[\d.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {
                    return;
                  }

                  complain();

                  return;
                }

                // The first argument may not be a direction: it may be an angle,
                // or a color stop (in which case user gets default direction, "to bottom")
                // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax
                if (!/left|right|top|bottom/.test(firstArg)) {
                  return;
                }

                const withToPrefix = !vendor.prefix(valueNode.value);

                if (!isStandardDirection(firstArg, withToPrefix)) {
                  complain();
                }

                function complain() {
                  report({
                    message: messages.rejected,
                    node: decl,
                    index: declarationValueIndex(decl) + valueNode.sourceIndex + expressionIndex,
                    result,
                    ruleName });

                }
              });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/functionArgumentsSearch": 364, "../../utils/isStandardSyntaxValue": 421, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "postcss-value-parser": 83 }], 224: [function (require, module, exports) {
      'use strict';

      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'function-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      /**
       * @param {import('postcss').Declaration} decl
       */
      function placeIndexOnValueStart(decl) {
        if (decl.raws.between == null) throw new Error('`between` must be present');

        return decl.prop.length + decl.raws.between.length - 1;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const maxAdjacentNewlines = primary + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            const stringValue = getDeclarationValue(decl);
            /** @type {Array<[string, string]>} */
            const splittedValue = [];
            let sourceIndexStart = 0;

            valueParser(stringValue).walk(node => {
              if (
              node.type !== 'function' /* ignore non functions */ ||
              node.value.length === 0 /* ignore sass lists */)
                {
                  return;
                }

              const stringifiedNode = valueParser.stringify(node);

              if (
              !violatedLFNewLinesRegex.test(stringifiedNode) &&
              !violatedCRLFNewLinesRegex.test(stringifiedNode))
              {
                return;
              }

              if (context.fix) {
                const newNodeString = stringifiedNode.
                replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
                replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

                splittedValue.push([
                stringValue.slice(sourceIndexStart, node.sourceIndex),
                newNodeString]);

                sourceIndexStart = node.sourceIndex + stringifiedNode.length;
              } else {
                report({
                  message: messages.expected(primary),
                  node: decl,
                  index: placeIndexOnValueStart(decl) + node.sourceIndex,
                  result,
                  ruleName });

              }
            });

            if (context.fix && splittedValue.length > 0) {
              const updatedValue =
              splittedValue.reduce((acc, curr) => acc + curr[0] + curr[1], '') +
              stringValue.slice(sourceIndexStart);

              setDeclarationValue(decl, updatedValue);
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 225: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const keywordSets = require('../../reference/keywordSets');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      const mapLowercaseFunctionNamesToCamelCase = new Map();

      for (const func of keywordSets.camelCaseFunctionNames) {
        mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func);
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['lower', 'upper'] },

          {
            actual: secondaryOptions,
            possible: {
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            let needFix = false;
            const parsed = valueParser(getDeclarationValue(decl));

            parsed.walk(node => {
              if (node.type !== 'function' || !isStandardSyntaxFunction(node)) {
                return;
              }

              const functionName = node.value;
              const functionNameLowerCase = functionName.toLowerCase();

              const ignoreFunctions = secondaryOptions && secondaryOptions.ignoreFunctions || [];

              if (ignoreFunctions.length > 0 && matchesStringOrRegExp(functionName, ignoreFunctions)) {
                return;
              }

              let expectedFunctionName = null;

              if (
              primary === 'lower' &&
              mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase))
              {
                expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase);
              } else if (primary === 'lower') {
                expectedFunctionName = functionNameLowerCase;
              } else {
                expectedFunctionName = functionName.toUpperCase();
              }

              if (functionName === expectedFunctionName) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedFunctionName;

                return;
              }

              report({
                message: messages.expected(functionName, expectedFunctionName),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              setDeclarationValue(decl, parsed.toString());
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isStandardSyntaxFunction": 413, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 226: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-newline-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected newline after "("',
        expectedClosing: 'Expected newline before ")"',
        expectedOpeningMultiLine: 'Expected newline after "(" in a multi-line function',
        rejectedOpeningMultiLine: 'Unexpected whitespace after "(" in a multi-line function',
        expectedClosingMultiLine: 'Expected newline before ")" in a multi-line function',
        rejectedClosingMultiLine: 'Unexpected whitespace before ")" in a multi-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = getDeclarationValue(decl);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isMultiLine = !isSingleLineString(functionString);
              const containsNewline = /** @type {string} */str => str.includes('\n');

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;
              const checkBefore = getCheckBefore(valueNode);

              if (primary === 'always' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkBefore)) {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedOpeningMultiLine, openingIndex);
                }
              }

              if (isMultiLine && primary === 'never-multi-line' && checkBefore !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixBeforeForNever(valueNode);
                } else {
                  complain(messages.rejectedOpeningMultiLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;
              const checkAfter = getCheckAfter(valueNode);

              if (primary === 'always' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (isMultiLine && primary === 'always-multi-line' && !containsNewline(checkAfter)) {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForAlways(valueNode, context.newline || '');
                } else {
                  complain(messages.expectedClosingMultiLine, closingIndex);
                }
              }

              if (isMultiLine && primary === 'never-multi-line' && checkAfter !== '') {
                if (context.fix) {
                  hasFixed = true;
                  fixAfterForNever(valueNode);
                } else {
                  complain(messages.rejectedClosingMultiLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              setDeclarationValue(decl, parsedValue.toString());
            }

            /**
             * @param {string} message
             * @param {number} offset
             */
            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      };

      /** @typedef {import('postcss-value-parser').FunctionNode} FunctionNode */

      /**
       * @param {FunctionNode} valueNode
       */
      function getCheckBefore(valueNode) {
        let before = valueNode.before;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            before += node.value;
            continue;
          }

          break;
        }

        return before;
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function getCheckAfter(valueNode) {
        let after = '';

        for (const node of [...valueNode.nodes].reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            after = node.value + after;
            continue;
          }

          break;
        }

        after += valueNode.after;

        return after;
      }

      /**
       * @param {FunctionNode} valueNode
       * @param {string} newline
       */
      function fixBeforeForAlways(valueNode, newline) {
        let target;

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            target = node;
            continue;
          }

          break;
        }

        if (target) {
          target.value = newline + target.value;
        } else {
          valueNode.before = newline + valueNode.before;
        }
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function fixBeforeForNever(valueNode) {
        valueNode.before = '';

        for (const node of valueNode.nodes) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      /**
       * @param {FunctionNode} valueNode
       * @param {string} newline
       */
      function fixAfterForAlways(valueNode, newline) {
        valueNode.after = newline + valueNode.after;
      }

      /**
       * @param {FunctionNode} valueNode
       */
      function fixAfterForNever(valueNode) {
        valueNode.after = '';

        for (const node of [...valueNode.nodes].reverse()) {
          if (node.type === 'comment') {
            continue;
          }

          if (node.type === 'space') {
            node.value = '';
            continue;
          }

          break;
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isSingleLineString": 407, "../../utils/isStandardSyntaxFunction": 413, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 227: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxFunction = require('../../utils/isStandardSyntaxFunction');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'function-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"',
        expectedOpeningSingleLine: 'Expected single space after "(" in a single-line function',
        rejectedOpeningSingleLine: 'Unexpected whitespace after "(" in a single-line function',
        expectedClosingSingleLine: 'Expected single space before ")" in a single-line function',
        rejectedClosingSingleLine: 'Unexpected whitespace before ")" in a single-line function' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!decl.value.includes('(')) {
              return;
            }

            let hasFixed = false;
            const declValue = getDeclarationValue(decl);
            const parsedValue = valueParser(declValue);

            parsedValue.walk(valueNode => {
              if (valueNode.type !== 'function') {
                return;
              }

              if (!isStandardSyntaxFunction(valueNode)) {
                return;
              }

              // Ignore function without parameters
              if (!valueNode.nodes.length) {
                return;
              }

              const functionString = valueParser.stringify(valueNode);
              const isSingleLine = isSingleLineString(functionString);

              // Check opening ...

              const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1;

              if (primary === 'always' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpening, openingIndex);
                }
              }

              if (primary === 'never' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpening, openingIndex);
                }
              }

              if (isSingleLine && primary === 'always-single-line' && valueNode.before !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = ' ';
                } else {
                  complain(messages.expectedOpeningSingleLine, openingIndex);
                }
              }

              if (isSingleLine && primary === 'never-single-line' && valueNode.before !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.before = '';
                } else {
                  complain(messages.rejectedOpeningSingleLine, openingIndex);
                }
              }

              // Check closing ...

              const closingIndex = valueNode.sourceIndex + functionString.length - 2;

              if (primary === 'always' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosing, closingIndex);
                }
              }

              if (primary === 'never' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosing, closingIndex);
                }
              }

              if (isSingleLine && primary === 'always-single-line' && valueNode.after !== ' ') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = ' ';
                } else {
                  complain(messages.expectedClosingSingleLine, closingIndex);
                }
              }

              if (isSingleLine && primary === 'never-single-line' && valueNode.after !== '') {
                if (context.fix) {
                  hasFixed = true;
                  valueNode.after = '';
                } else {
                  complain(messages.rejectedClosingSingleLine, closingIndex);
                }
              }
            });

            if (hasFixed) {
              setDeclarationValue(decl, parsedValue.toString());
            }

            /**
             * @param {string} message
             * @param {number} offset
             */
            function complain(message, offset) {
              report({
                ruleName,
                result,
                message,
                node: decl,
                index: declarationValueIndex(decl) + offset });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isSingleLineString": 407, "../../utils/isStandardSyntaxFunction": 413, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 228: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-no-scheme-relative';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected scheme-relative url' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const url = args.trim().replace(/^['"]+|['"]+$/g, '');

              if (!isStandardSyntaxUrl(url) || !url.startsWith('//')) {
                return;
              }

              report({
                message: messages.rejected,
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 364, "../../utils/isStandardSyntaxUrl": 420, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 229: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-url-quotes';

      const messages = ruleMessages(ruleName, {
        expected: functionName => `Expected quotes around "${functionName}" function argument`,
        rejected: functionName => `Unexpected quotes around "${functionName}" function argument` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: ['always', 'never'] },

          {
            actual: secondaryOptions,
            possible: {
              except: ['empty'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(checkAtRuleParams);
          root.walkDecls(checkDeclParams);

          /**
           * @param {import('postcss').Declaration} decl
           */
          function checkDeclParams(decl) {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              checkArgs(args, decl, index, 'url');
            });
          }

          /**
           * @param {import('postcss').AtRule} atRule
           */
          function checkAtRuleParams(atRule) {
            const atRuleParamsLowerCase = atRule.params.toLowerCase();

            functionArgumentsSearch(atRuleParamsLowerCase, 'url', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'url-prefix', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'url-prefix');
            });
            functionArgumentsSearch(atRuleParamsLowerCase, 'domain', (args, index) => {
              checkArgs(args, atRule, index + atRuleParamIndex(atRule), 'domain');
            });
          }

          /**
           * @param {string} args
           * @param {import('postcss').Node} node
           * @param {number} index
           * @param {string} functionName
           */
          function checkArgs(args, node, index, functionName) {
            let shouldHasQuotes = primary === 'always';

            const leftTrimmedArgs = args.trimStart();

            if (!isStandardSyntaxUrl(leftTrimmedArgs)) {
              return;
            }

            const complaintIndex = index + args.length - leftTrimmedArgs.length;
            const hasQuotes = leftTrimmedArgs.startsWith("'") || leftTrimmedArgs.startsWith('"');

            const trimmedArg = args.trim();
            const isEmptyArgument = ['', "''", '""'].includes(trimmedArg);

            if (optionsMatches(secondaryOptions, 'except', 'empty') && isEmptyArgument) {
              shouldHasQuotes = !shouldHasQuotes;
            }

            if (shouldHasQuotes) {
              if (hasQuotes) {
                return;
              }

              complain(messages.expected(functionName), node, complaintIndex);
            } else {
              if (!hasQuotes) {
                return;
              }

              complain(messages.rejected(functionName), node, complaintIndex);
            }
          }

          /**
           * @param {string} message
           * @param {import('postcss').Node} node
           * @param {number} index
           */
          function complain(message, node, index) {
            report({
              message,
              node,
              index,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/functionArgumentsSearch": 364, "../../utils/isStandardSyntaxUrl": 420, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 230: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-url-scheme-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = args.trim();

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (matchesStringOrRegExp(scheme, primary)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 364, "../../utils/getSchemeFromUrl": 373, "../../utils/isStandardSyntaxUrl": 420, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 231: [function (require, module, exports) {
      'use strict';

      const functionArgumentsSearch = require('../../utils/functionArgumentsSearch');
      const getSchemeFromUrl = require('../../utils/getSchemeFromUrl');
      const isStandardSyntaxUrl = require('../../utils/isStandardSyntaxUrl');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'function-url-scheme-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: scheme => `Unexpected URL scheme "${scheme}:"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            functionArgumentsSearch(decl.toString().toLowerCase(), 'url', (args, index) => {
              const unspacedUrlString = args.trim();

              if (!isStandardSyntaxUrl(unspacedUrlString)) {
                return;
              }

              const urlString = unspacedUrlString.replace(/^['"]+|['"]+$/g, '');
              const scheme = getSchemeFromUrl(urlString);

              if (scheme === null) {
                return;
              }

              if (!matchesStringOrRegExp(scheme, primary)) {
                return;
              }

              report({
                message: messages.rejected(scheme),
                node: decl,
                index,
                result,
                ruleName });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/functionArgumentsSearch": 364, "../../utils/getSchemeFromUrl": 373, "../../utils/isStandardSyntaxUrl": 420, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 232: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isWhitespace = require('../../utils/isWhitespace');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'function-whitespace-after';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected whitespace after ")"',
        rejected: 'Unexpected whitespace after ")"' });


      const ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([')', ',', '}', ':', '/', undefined]);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /**
           * @param {import('postcss').Node} node
           * @param {string} value
           * @param {number} nodeIndex
           * @param {((index: number) => void) | undefined} fix
           */
          function check(node, value, nodeIndex, fix) {
            styleSearch(
            {
              source: value,
              target: ')',
              functionArguments: 'only' },

            match => {
              checkClosingParen(value, match.startIndex + 1, node, nodeIndex, fix);
            });

          }

          /**
           * @param {string} source
           * @param {number} index
           * @param {import('postcss').Node} node
           * @param {number} nodeIndex
           * @param {((index: number) => void) | undefined} fix
           */
          function checkClosingParen(source, index, node, nodeIndex, fix) {
            const nextChar = source[index];

            if (primary === 'always') {
              // Allow for the next character to be a single empty space,
              // another closing parenthesis, a comma, or the end of the value
              if (nextChar === ' ') {
                return;
              }

              if (nextChar === '\n') {
                return;
              }

              if (source.substr(index, 2) === '\r\n') {
                return;
              }

              if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {
                return;
              }

              if (fix) {
                fix(index);

                return;
              }

              report({
                message: messages.expected,
                node,
                index: nodeIndex + index,
                result,
                ruleName });

            } else if (primary === 'never' && isWhitespace(nextChar)) {
              if (fix) {
                fix(index);

                return;
              }

              report({
                message: messages.rejected,
                node,
                index: nodeIndex + index,
                result,
                ruleName });

            }
          }

          /**
           * @param {string} value
           */
          function createFixer(value) {
            let fixed = '';
            let lastIndex = 0;
            /** @type {(index: number) => void} */
            let applyFix;

            if (primary === 'always') {
              applyFix = index => {
                // eslint-disable-next-line prefer-template
                fixed += value.slice(lastIndex, index) + ' ';
                lastIndex = index;
              };
            } else if (primary === 'never') {
              applyFix = index => {
                let whitespaceEndIndex = index + 1;

                while (whitespaceEndIndex < value.length && isWhitespace(value[whitespaceEndIndex])) {
                  whitespaceEndIndex++;
                }

                fixed += value.slice(lastIndex, index);
                lastIndex = whitespaceEndIndex;
              };
            } else {
              throw new Error(`Unexpected option: "${primary}"`);
            }

            return {
              applyFix,
              get hasFixed() {
                return Boolean(lastIndex);
              },
              get fixed() {
                return fixed + value.slice(lastIndex);
              } };

          }

          root.walkAtRules(/^import$/i, atRule => {
            const param = atRule.raws.params && atRule.raws.params.raw || atRule.params;
            const fixer = context.fix && createFixer(param);

            check(atRule, param, atRuleParamIndex(atRule), fixer ? fixer.applyFix : undefined);

            if (fixer && fixer.hasFixed) {
              if (atRule.raws.params) {
                atRule.raws.params.raw = fixer.fixed;
              } else {
                atRule.params = fixer.fixed;
              }
            }
          });
          root.walkDecls(decl => {
            const value = getDeclarationValue(decl);
            const fixer = context.fix && createFixer(value);

            check(decl, value, declarationValueIndex(decl), fixer ? fixer.applyFix : undefined);

            if (fixer && fixer.hasFixed) {
              setDeclarationValue(decl, fixer.fixed);
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isWhitespace": 425, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "style-search": 121 }], 233: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../utils/declarationValueIndex');
      const getDeclarationValue = require('../utils/getDeclarationValue');
      const isStandardSyntaxFunction = require('../utils/isStandardSyntaxFunction');
      const report = require('../utils/report');
      const setDeclarationValue = require('../utils/setDeclarationValue');
      const valueParser = require('postcss-value-parser');

      /** @typedef {import('postcss-value-parser').Node} ValueParserNode */
      /** @typedef {import('postcss-value-parser').DivNode} ValueParserDivNode */
      /** @typedef {(args: { source: string, index: number, err: (message: string) => void }) => void} LocationChecker */

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: LocationChecker,
       *   fix: ((node: ValueParserDivNode, index: number, nodes: ValueParserNode[]) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function functionCommaSpaceChecker(opts) {
        opts.root.walkDecls(decl => {
          const declValue = getDeclarationValue(decl);

          let hasFixed;
          const parsedValue = valueParser(declValue);

          parsedValue.walk(valueNode => {
            if (valueNode.type !== 'function') {
              return;
            }

            if (!isStandardSyntaxFunction(valueNode)) {
              return;
            }

            // Ignore `url()` arguments, which may contain data URIs or other funky stuff
            if (valueNode.value.toLowerCase() === 'url') {
              return;
            }

            const argumentStrings = valueNode.nodes.map(node => valueParser.stringify(node));

            const functionArguments = (() => {
              // Remove function name and parens
              let result = valueNode.before + argumentStrings.join('') + valueNode.after;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              result = result.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return result;
            })();

            /**
             * Gets the index of the comma for checking.
             * @param {ValueParserDivNode} commaNode The comma node
             * @param {number} nodeIndex The index of the comma node
             * @returns {number} The index of the comma for checking
             */
            const getCommaCheckIndex = (commaNode, nodeIndex) => {
              let commaBefore =
              valueNode.before + argumentStrings.slice(0, nodeIndex).join('') + commaNode.before;

              // 1. Remove comments including preceding whitespace (when only succeeded by whitespace)
              // 2. Remove all other comments, but leave adjacent whitespace intact
              commaBefore = commaBefore.replace(/( *\/(\*.*\*\/(?!\S)|\/.*)|(\/(\*.*\*\/|\/.*)))/, '');

              return commaBefore.length;
            };

            /** @type {{ commaNode: ValueParserDivNode, checkIndex: number, nodeIndex: number }[]} */
            const commaDataList = [];

            for (const [nodeIndex, node] of valueNode.nodes.entries()) {
              if (node.type !== 'div' || node.value !== ',') {
                continue;
              }

              const checkIndex = getCommaCheckIndex(node, nodeIndex);

              commaDataList.push({
                commaNode: node,
                checkIndex,
                nodeIndex });

            }

            for (const { commaNode, checkIndex, nodeIndex } of commaDataList) {
              opts.locationChecker({
                source: functionArguments,
                index: checkIndex,
                err: message => {
                  const index =
                  declarationValueIndex(decl) + commaNode.sourceIndex + commaNode.before.length;

                  if (opts.fix && opts.fix(commaNode, nodeIndex, valueNode.nodes)) {
                    hasFixed = true;

                    return;
                  }

                  report({
                    index,
                    message,
                    node: decl,
                    result: opts.result,
                    ruleName: opts.checkedRuleName });

                } });

            }
          });

          if (hasFixed) {
            setDeclarationValue(decl, parsedValue.toString());
          }
        });
      };

    }, { "../utils/declarationValueIndex": 359, "../utils/getDeclarationValue": 366, "../utils/isStandardSyntaxFunction": 413, "../utils/report": 435, "../utils/setDeclarationValue": 438, "postcss-value-parser": 83 }], 234: [function (require, module, exports) {
      'use strict';

      /**
       * @param {{
       *   div: import('postcss-value-parser').DivNode,
       *   index: number,
       *   nodes: import('postcss-value-parser').Node[],
       *   expectation: string,
       *   position: 'before' | 'after',
       *   symb: string,
       * }} params
       * @returns {boolean}
       */
      module.exports = function functionCommaSpaceFix(params) {
        const { div, index, nodes, expectation, position, symb } = params;

        if (expectation.startsWith('always')) {
          div[position] = symb;

          return true;
        }

        if (expectation.startsWith('never')) {
          div[position] = '';

          for (let i = index + 1; i < nodes.length; i++) {
            const node = nodes[i];

            if (node.type === 'comment') {
              continue;
            }

            if (node.type === 'space') {
              node.value = '';
              continue;
            }

            break;
          }

          return true;
        }

        return false;
      };

    }, {}], 235: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'hue-degree-notation';

      const messages = ruleMessages(ruleName, {
        expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"` });


      const HUE_FIRST_ARG_FUNCS = ['hsl', 'hsla', 'hwb'];
      const HUE_THIRD_ARG_FUNCS = ['lch'];
      const HUE_FUNCS = new Set([...HUE_FIRST_ARG_FUNCS, ...HUE_THIRD_ARG_FUNCS]);

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['angle', 'number'] });


          if (!validOptions) return;

          root.walkDecls(decl => {
            let needsFix = false;
            const parsedValue = valueParser(getDeclarationValue(decl));

            parsedValue.walk(node => {
              if (node.type !== 'function') return;

              if (!HUE_FUNCS.has(node.value.toLowerCase())) return;

              const hue = findHue(node);

              if (!hue) return;

              const { value } = hue;

              if (!isStandardSyntaxValue(value)) return;

              if (!isDegree(value) && !isNumber(value)) return;

              if (primary === 'angle' && isDegree(value)) return;

              if (primary === 'number' && isNumber(value)) return;

              const fixed = primary === 'angle' ? asDegree(value) : asNumber(value);
              const unfixed = value;

              if (context.fix) {
                hue.value = fixed;
                needsFix = true;

                return;
              }

              report({
                message: messages.expected(unfixed, fixed),
                node: decl,
                index: declarationValueIndex(decl) + hue.sourceIndex,
                result,
                ruleName });

            });

            if (needsFix) {
              setDeclarationValue(decl, parsedValue.toString());
            }
          });
        };
      };

      /**
       * @param {string} value
       */
      function asDegree(value) {
        return `${value}deg`;
      }

      /**
       * @param {string} value
       */
      function asNumber(value) {
        const dimension = valueParser.unit(value);

        if (dimension) return dimension.number;

        throw new TypeError(`The "${value}" value must have a unit`);
      }

      /**
       * @param {import('postcss-value-parser').FunctionNode} node
       */
      function findHue(node) {
        const args = node.nodes.filter(({ type }) => type === 'word' || type === 'function');
        const value = node.value.toLowerCase();

        if (HUE_FIRST_ARG_FUNCS.includes(value)) {
          return args[0];
        }

        if (HUE_THIRD_ARG_FUNCS.includes(value)) {
          return args[2];
        }

        return undefined;
      }

      /**
       * @param {string} value
       */
      function isDegree(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit.toLowerCase() === 'deg';
      }

      /**
       * @param {string} value
       */
      function isNumber(value) {
        const dimension = valueParser.unit(value);

        return dimension && dimension.unit === '';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/isStandardSyntaxValue": 421, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 236: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('../../utils/beforeBlockString');
      const hasBlock = require('../../utils/hasBlock');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRoot, isRule } = require('../../utils/typeGuards');
      const { isBoolean, isNumber, isString } = require('../../utils/validateTypes');

      const ruleName = 'indentation';
      const messages = ruleMessages(ruleName, {
        expected: x => `Expected indentation of ${x}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions = {}, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isNumber, 'tab'] },

          {
            actual: secondaryOptions,
            possible: {
              baseIndentLevel: [isNumber, 'auto'],
              except: ['block', 'value', 'param'],
              ignore: ['value', 'param', 'inside-parens'],
              indentInsideParens: ['twice', 'once-at-root-twice-in-block'],
              indentClosingBrace: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const spaceCount = isNumber(primary) ? primary : null;
          const indentChar = spaceCount == null ? '\t' : ' '.repeat(spaceCount);
          const warningWord = primary === 'tab' ? 'tab' : 'space';

          /** @type {number | 'auto'} */
          const baseIndentLevel = secondaryOptions.baseIndentLevel;
          /** @type {boolean} */
          const indentClosingBrace = secondaryOptions.indentClosingBrace;

          /**
           * @param {number} level
           */
          const legibleExpectation = level => {
            const count = spaceCount == null ? level : level * spaceCount;
            const quantifiedWarningWord = count === 1 ? warningWord : `${warningWord}s`;

            return `${count} ${quantifiedWarningWord}`;
          };

          // Cycle through all nodes using walk.
          root.walk(node => {
            if (isRoot(node)) {
              // Ignore nested template literals root in css-in-js lang
              return;
            }

            const nodeLevel = indentationLevel(node);

            // Cut out any * and _ hacks from `before`
            const before = (node.raws.before || '').replace(/[*_]$/, '');
            const after = 'after' in node.raws && node.raws.after || '';
            const parent = node.parent;

            if (!parent) throw new Error('A parent node must be present');

            const expectedOpeningBraceIndentation = indentChar.repeat(nodeLevel);

            // Only inspect the spaces before the node
            // if this is the first node in root
            // or there is a newline in the `before` string.
            // (If there is no newline before a node,
            // there is no "indentation" to check.)
            const isFirstChild = parent.type === 'root' && parent.first === node;
            const lastIndexOfNewline = before.lastIndexOf('\n');

            // Inspect whitespace in the `before` string that is
            // *after* the *last* newline character,
            // because anything besides that is not indentation for this node:
            // it is some other kind of separation, checked by some separate rule
            if (
            (lastIndexOfNewline !== -1 ||
            isFirstChild && (
            !getDocument(parent) ||
            parent.raws.codeBefore && parent.raws.codeBefore.endsWith('\n'))) &&
            before.slice(lastIndexOfNewline + 1) !== expectedOpeningBraceIndentation)
            {
              if (context.fix) {
                if (isFirstChild && isString(node.raws.before)) {
                  node.raws.before = node.raws.before.replace(
                  /^[ \t]*(?=\S|$)/,
                  expectedOpeningBraceIndentation);

                }

                node.raws.before = fixIndentation(node.raws.before, expectedOpeningBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(nodeLevel)),
                  node,
                  result,
                  ruleName });

              }
            }

            // Only blocks have the `after` string to check.
            // Only inspect `after` strings that start with a newline;
            // otherwise there's no indentation involved.
            // And check `indentClosingBrace` to see if it should be indented an extra level.
            const closingBraceLevel = indentClosingBrace ? nodeLevel + 1 : nodeLevel;
            const expectedClosingBraceIndentation = indentChar.repeat(closingBraceLevel);

            if (
            (isRule(node) || isAtRule(node)) &&
            hasBlock(node) &&
            after &&
            after.includes('\n') &&
            after.slice(after.lastIndexOf('\n') + 1) !== expectedClosingBraceIndentation)
            {
              if (context.fix) {
                node.raws.after = fixIndentation(node.raws.after, expectedClosingBraceIndentation);
              } else {
                report({
                  message: messages.expected(legibleExpectation(closingBraceLevel)),
                  node,
                  index: node.toString().length - 1,
                  result,
                  ruleName });

              }
            }

            // If this is a declaration, check the value
            if (isDeclaration(node)) {
              checkValue(node, nodeLevel);
            }

            // If this is a rule, check the selector
            if (isRule(node)) {
              checkSelector(node, nodeLevel);
            }

            // If this is an at rule, check the params
            if (isAtRule(node)) {
              checkAtRuleParams(node, nodeLevel);
            }
          });

          /**
           * @param {import('postcss').Node} node
           * @param {number} level
           * @returns {number}
           */
          function indentationLevel(node, level = 0) {
            if (!node.parent) throw new Error('A parent node must be present');

            if (isRoot(node.parent)) {
              return level + getRootBaseIndentLevel(node.parent, baseIndentLevel, primary);
            }

            let calculatedLevel;

            // Indentation level equals the ancestor nodes
            // separating this node from root; so recursively
            // run this operation
            calculatedLevel = indentationLevel(node.parent, level + 1);

            // If `secondaryOptions.except` includes "block",
            // blocks are taken down one from their calculated level
            // (all blocks are the same level as their parents)
            if (
            optionsMatches(secondaryOptions, 'except', 'block') && (
            isRule(node) || isAtRule(node)) &&
            hasBlock(node))
            {
              calculatedLevel--;
            }

            return calculatedLevel;
          }

          /**
           * @param {import('postcss').Declaration} decl
           * @param {number} declLevel
           */
          function checkValue(decl, declLevel) {
            if (!decl.value.includes('\n')) {
              return;
            }

            if (optionsMatches(secondaryOptions, 'ignore', 'value')) {
              return;
            }

            const declString = decl.toString();
            const valueLevel = optionsMatches(secondaryOptions, 'except', 'value') ?
            declLevel :
            declLevel + 1;

            checkMultilineBit(declString, valueLevel, decl);
          }

          /**
           * @param {import('postcss').Rule} ruleNode
           * @param {number} ruleLevel
           */
          function checkSelector(ruleNode, ruleLevel) {
            const selector = ruleNode.selector;

            // Less mixins have params, and they should be indented extra
            // @ts-expect-error -- TS2339: Property 'params' does not exist on type 'Rule'.
            if (ruleNode.params) {
              ruleLevel += 1;
            }

            checkMultilineBit(selector, ruleLevel, ruleNode);
          }

          /**
           * @param {import('postcss').AtRule} atRule
           * @param {number} ruleLevel
           */
          function checkAtRuleParams(atRule, ruleLevel) {
            if (optionsMatches(secondaryOptions, 'ignore', 'param')) {
              return;
            }

            // @nest and SCSS's @at-root rules should be treated like regular rules, not expected
            // to have their params (selectors) indented
            const paramLevel =
            optionsMatches(secondaryOptions, 'except', 'param') ||
            atRule.name === 'nest' ||
            atRule.name === 'at-root' ?
            ruleLevel :
            ruleLevel + 1;

            checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule);
          }

          /**
           * @param {string} source
           * @param {number} newlineIndentLevel
           * @param {import('postcss').Node} node
           */
          function checkMultilineBit(source, newlineIndentLevel, node) {
            if (!source.includes('\n')) {
              return;
            }

            // Data for current node fixing
            /** @type {Array<{ expectedIndentation: string, currentIndentation: string, startIndex: number }>} */
            const fixPositions = [];

            // `outsideParens` because function arguments and also non-standard parenthesized stuff like
            // Sass maps are ignored to allow for arbitrary indentation
            let parentheticalDepth = 0;

            const ignoreInsideParans = optionsMatches(secondaryOptions, 'ignore', 'inside-parens');

            styleSearch(
            {
              source,
              target: '\n',
              // @ts-expect-error -- The `outsideParens` option is unsupported. Why?
              outsideParens: ignoreInsideParans },

            (match, matchCount) => {
              const precedesClosingParenthesis = /^[ \t]*\)/.test(source.slice(match.startIndex + 1));

              if (ignoreInsideParans && (precedesClosingParenthesis || match.insideParens)) {
                return;
              }

              let expectedIndentLevel = newlineIndentLevel;

              // Modififications for parenthetical content
              if (!ignoreInsideParans && match.insideParens) {
                // If the first match in is within parentheses, reduce the parenthesis penalty
                if (matchCount === 1) parentheticalDepth -= 1;

                // Account for windows line endings
                let newlineIndex = match.startIndex;

                if (source[match.startIndex - 1] === '\r') {
                  newlineIndex--;
                }

                const followsOpeningParenthesis = /\([ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningParenthesis) {
                  parentheticalDepth += 1;
                }

                const followsOpeningBrace = /\{[ \t]*$/.test(source.slice(0, newlineIndex));

                if (followsOpeningBrace) {
                  parentheticalDepth += 1;
                }

                const startingClosingBrace = /^[ \t]*\}/.test(source.slice(match.startIndex + 1));

                if (startingClosingBrace) {
                  parentheticalDepth -= 1;
                }

                expectedIndentLevel += parentheticalDepth;

                // Past this point, adjustments to parentheticalDepth affect next line

                if (precedesClosingParenthesis) {
                  parentheticalDepth -= 1;
                }

                switch (secondaryOptions.indentInsideParens) {
                  case 'twice':
                    if (!precedesClosingParenthesis || indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  case 'once-at-root-twice-in-block':
                    if (node.parent === node.root()) {
                      if (precedesClosingParenthesis && !indentClosingBrace) {
                        expectedIndentLevel -= 1;
                      }

                      break;
                    }

                    if (!precedesClosingParenthesis || indentClosingBrace) {
                      expectedIndentLevel += 1;
                    }

                    break;
                  default:
                    if (precedesClosingParenthesis && !indentClosingBrace) {
                      expectedIndentLevel -= 1;
                    }}

              }

              // Starting at the index after the newline, we want to
              // check that the whitespace characters (excluding newlines) before the first
              // non-whitespace character equal the expected indentation
              const afterNewlineSpaceMatches = /^([ \t]*)\S/.exec(source.slice(match.startIndex + 1));

              if (!afterNewlineSpaceMatches) {
                return;
              }

              const afterNewlineSpace = afterNewlineSpaceMatches[1];
              const expectedIndentation = indentChar.repeat(
              expectedIndentLevel > 0 ? expectedIndentLevel : 0);


              if (afterNewlineSpace !== expectedIndentation) {
                if (context.fix) {
                  // Adding fixes position in reverse order, because if we change indent in the beginning of the string it will break all following fixes for that string
                  fixPositions.unshift({
                    expectedIndentation,
                    currentIndentation: afterNewlineSpace,
                    startIndex: match.startIndex });

                } else {
                  report({
                    message: messages.expected(legibleExpectation(expectedIndentLevel)),
                    node,
                    index: match.startIndex + afterNewlineSpace.length + 1,
                    result,
                    ruleName });

                }
              }
            });


            if (fixPositions.length) {
              if (isRule(node)) {
                for (const fixPosition of fixPositions) {
                  node.selector = replaceIndentation(
                  node.selector,
                  fixPosition.currentIndentation,
                  fixPosition.expectedIndentation,
                  fixPosition.startIndex);

                }
              }

              if (isDeclaration(node)) {
                const declProp = node.prop;
                const declBetween = node.raws.between;

                if (!isString(declBetween)) {
                  throw new TypeError('The `between` property must be a string');
                }

                for (const fixPosition of fixPositions) {
                  if (fixPosition.startIndex < declProp.length + declBetween.length) {
                    node.raws.between = replaceIndentation(
                    declBetween,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length);

                  } else {
                    node.value = replaceIndentation(
                    node.value,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - declProp.length - declBetween.length);

                  }
                }
              }

              if (isAtRule(node)) {
                const atRuleName = node.name;
                const atRuleAfterName = node.raws.afterName;
                const atRuleParams = node.params;

                if (!isString(atRuleAfterName)) {
                  throw new TypeError('The `afterName` property must be a string');
                }

                for (const fixPosition of fixPositions) {
                  // 1  it's a @ length
                  if (fixPosition.startIndex < 1 + atRuleName.length + atRuleAfterName.length) {
                    node.raws.afterName = replaceIndentation(
                    atRuleAfterName,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - 1);

                  } else {
                    node.params = replaceIndentation(
                    atRuleParams,
                    fixPosition.currentIndentation,
                    fixPosition.expectedIndentation,
                    fixPosition.startIndex - atRuleName.length - atRuleAfterName.length - 1);

                  }
                }
              }
            }
          }
        };
      };

      /**
       * @param {import('postcss').Root} root
       * @param {number | 'auto'} baseIndentLevel
       * @param {string} space
       * @returns {number}
       */
      function getRootBaseIndentLevel(root, baseIndentLevel, space) {
        const document = getDocument(root);

        if (!document) {
          return 0;
        }

        if (!root.source) {
          throw new Error('The root node must have a source');
        }

        /** @type {import('postcss').Source & { baseIndentLevel?: number }} */
        const source = root.source;

        const indentLevel = source.baseIndentLevel;

        if (isNumber(indentLevel) && Number.isSafeInteger(indentLevel)) {
          return indentLevel;
        }

        const newIndentLevel = inferRootIndentLevel(root, baseIndentLevel, () =>
        inferDocIndentSize(document, space));


        source.baseIndentLevel = newIndentLevel;

        return newIndentLevel;
      }

      /**
       * @param {import('postcss').Node} node
       */
      function getDocument(node) {
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.
        const document = node.document;

        if (document) {
          return document;
        }

        const root = node.root();

        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Node'.
        return root && root.document;
      }

      /**
       * @param {import('postcss').Document} document
       * @param {string} space
       * returns {number}
       */
      function inferDocIndentSize(document, space) {
        if (!document.source) throw new Error('The document node must have a source');

        /** @type {import('postcss').Source & { indentSize?: number }} */
        const docSource = document.source;

        let indentSize = docSource.indentSize;

        if (isNumber(indentSize) && Number.isSafeInteger(indentSize)) {
          return indentSize;
        }

        const source = document.source.input.css;
        const indents = source.match(/^ *(?=\S)/gm);

        if (indents) {
          /** @type {Map<number, number>} */
          const scores = new Map();
          let lastIndentSize = 0;
          let lastLeadingSpacesLength = 0;

          /**
           * @param {number} leadingSpacesLength
           */
          const vote = leadingSpacesLength => {
            if (leadingSpacesLength) {
              lastIndentSize = Math.abs(leadingSpacesLength - lastLeadingSpacesLength) || lastIndentSize;

              if (lastIndentSize > 1) {
                const score = scores.get(lastIndentSize);

                if (score) {
                  scores.set(lastIndentSize, score + 1);
                } else {
                  scores.set(lastIndentSize, 1);
                }
              }
            } else {
              lastIndentSize = 0;
            }

            lastLeadingSpacesLength = leadingSpacesLength;
          };

          for (const leadingSpaces of indents) {
            vote(leadingSpaces.length);
          }

          let bestScore = 0;

          for (const [indentSizeDate, score] of scores.entries()) {
            if (score > bestScore) {
              bestScore = score;
              indentSize = indentSizeDate;
            }
          }
        }

        indentSize = Number(indentSize) || indents && indents[0].length || Number(space) || 2;
        docSource.indentSize = indentSize;

        return indentSize;
      }

      /**
       * @param {import('postcss').Root} root
       * @param {number | 'auto'} baseIndentLevel
       * @param {() => number} indentSize
       * @returns {number}
       */
      function inferRootIndentLevel(root, baseIndentLevel, indentSize) {
        /**
         * @param {string} indent
         */
        function getIndentLevel(indent) {
          const tabMatch = indent.match(/\t/g);
          const tabCount = tabMatch ? tabMatch.length : 0;

          const spaceMatch = indent.match(/ /g);
          const spaceCount = spaceMatch ? Math.round(spaceMatch.length / indentSize()) : 0;

          return tabCount + spaceCount;
        }

        let newBaseIndentLevel = 0;

        if (!isNumber(baseIndentLevel) || !Number.isSafeInteger(baseIndentLevel)) {
          if (!root.source) throw new Error('The root node must have a source');

          let source = root.source.input.css;

          source = source.replace(/^[^\r\n]+/, firstLine => {
            const match = root.raws.codeBefore && /(?:^|\n)([ \t]*)$/.exec(root.raws.codeBefore);

            if (match) {
              return match[1] + firstLine;
            }

            return '';
          });

          const indents = source.match(/^[ \t]*(?=\S)/gm);

          if (indents) {
            return Math.min(...indents.map(indent => getIndentLevel(indent)));
          }

          newBaseIndentLevel = 1;
        } else {
          newBaseIndentLevel = baseIndentLevel;
        }

        const indents = [];
        const foundIndents = root.raws.codeBefore && /(?:^|\n)([ \t]*)\S/m.exec(root.raws.codeBefore);

        // The indent level of the CSS code block in non-CSS-like files is determined by the shortest indent of non-empty line.
        if (foundIndents) {
          let shortest = Number.MAX_SAFE_INTEGER;
          let i = 0;

          while (++i < foundIndents.length) {
            const current = getIndentLevel(foundIndents[i]);

            if (current < shortest) {
              shortest = current;

              if (shortest === 0) {
                break;
              }
            }
          }

          if (shortest !== Number.MAX_SAFE_INTEGER) {
            indents.push(new Array(shortest).fill(' ').join(''));
          }
        }

        const after = root.raws.after;

        if (after) {
          let afterEnd;

          if (after.endsWith('\n')) {
            // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
            const document = root.document;

            if (document) {
              const nextRoot = document.nodes[document.nodes.indexOf(root) + 1];

              afterEnd = nextRoot ? nextRoot.raws.codeBefore : document.raws.codeAfter;
            } else {
              // Nested root node in css-in-js lang
              const parent = root.parent;

              if (!parent) throw new Error('The root node must have a parent');

              const nextRoot = parent.nodes[parent.nodes.indexOf(root) + 1];

              afterEnd = nextRoot ? nextRoot.raws.codeBefore : root.raws.codeAfter;
            }
          } else {
            afterEnd = after;
          }

          if (afterEnd) indents.push(afterEnd.match(/^[ \t]*/)[0]);
        }

        if (indents.length) {
          return Math.max(...indents.map(indent => getIndentLevel(indent))) + newBaseIndentLevel;
        }

        return newBaseIndentLevel;
      }

      /**
       * @param {string | undefined} str
       * @param {string} whitespace
       */
      function fixIndentation(str, whitespace) {
        if (!isString(str)) {
          return str;
        }

        return str.replace(/\n[ \t]*(?=\S|$)/g, `\n${whitespace}`);
      }

      /**
       * @param {string} input
       * @param {string} searchString
       * @param {string} replaceString
       * @param {number} startIndex
       */
      function replaceIndentation(input, searchString, replaceString, startIndex) {
        const offset = startIndex + 1;
        const stringStart = input.slice(0, offset);
        const stringEnd = input.slice(offset + searchString.length);

        return stringStart + replaceString + stringEnd;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/beforeBlockString": 353, "../../utils/hasBlock": 375, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "style-search": 121 }], 237: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const importLazy = require('import-lazy');

      /** @type {typeof import('stylelint').rules} */
      const rules = {
        'alpha-value-notation': importLazy(() => require('./alpha-value-notation'))(),
        'at-rule-allowed-list': importLazy(() => require('./at-rule-allowed-list'))(),
        'at-rule-disallowed-list': importLazy(() => require('./at-rule-disallowed-list'))(),
        'at-rule-empty-line-before': importLazy(() => require('./at-rule-empty-line-before'))(),
        'at-rule-name-case': importLazy(() => require('./at-rule-name-case'))(),
        'at-rule-name-newline-after': importLazy(() => require('./at-rule-name-newline-after'))(),
        'at-rule-semicolon-space-before': importLazy(() => require('./at-rule-semicolon-space-before'))(),
        'at-rule-name-space-after': importLazy(() => require('./at-rule-name-space-after'))(),
        'at-rule-no-unknown': importLazy(() => require('./at-rule-no-unknown'))(),
        /* 'at-rule-no-vendor-prefix': importLazy(() => require('./at-rule-no-vendor-prefix'))(), */
        'at-rule-property-required-list': importLazy(() => require('./at-rule-property-required-list'))(),
        'at-rule-semicolon-newline-after': importLazy(() =>
        require('./at-rule-semicolon-newline-after'))(),

        'block-closing-brace-empty-line-before': importLazy(() =>
        require('./block-closing-brace-empty-line-before'))(),

        'block-closing-brace-newline-after': importLazy(() =>
        require('./block-closing-brace-newline-after'))(),

        'block-closing-brace-newline-before': importLazy(() =>
        require('./block-closing-brace-newline-before'))(),

        'block-closing-brace-space-after': importLazy(() =>
        require('./block-closing-brace-space-after'))(),

        'block-closing-brace-space-before': importLazy(() =>
        require('./block-closing-brace-space-before'))(),

        'block-no-empty': importLazy(() => require('./block-no-empty'))(),
        'block-opening-brace-newline-after': importLazy(() =>
        require('./block-opening-brace-newline-after'))(),

        'block-opening-brace-newline-before': importLazy(() =>
        require('./block-opening-brace-newline-before'))(),

        'block-opening-brace-space-after': importLazy(() =>
        require('./block-opening-brace-space-after'))(),

        'block-opening-brace-space-before': importLazy(() =>
        require('./block-opening-brace-space-before'))(),

        'color-function-notation': importLazy(() => require('./color-function-notation'))(),
        'color-hex-alpha': importLazy(() => require('./color-hex-alpha'))(),
        'color-hex-case': importLazy(() => require('./color-hex-case'))(),
        'color-hex-length': importLazy(() => require('./color-hex-length'))(),
        'color-named': importLazy(() => require('./color-named'))(),
        'color-no-hex': importLazy(() => require('./color-no-hex'))(),
        'color-no-invalid-hex': importLazy(() => require('./color-no-invalid-hex'))(),
        'comment-empty-line-before': importLazy(() => require('./comment-empty-line-before'))(),
        'comment-no-empty': importLazy(() => require('./comment-no-empty'))(),
        'comment-pattern': importLazy(() => require('./comment-pattern'))(),
        'comment-whitespace-inside': importLazy(() => require('./comment-whitespace-inside'))(),
        'comment-word-disallowed-list': importLazy(() => require('./comment-word-disallowed-list'))(),
        'custom-media-pattern': importLazy(() => require('./custom-media-pattern'))(),
        'custom-property-empty-line-before': importLazy(() =>
        require('./custom-property-empty-line-before'))(),

        'custom-property-no-missing-var-function': importLazy(() =>
        require('./custom-property-no-missing-var-function'))(),

        'custom-property-pattern': importLazy(() => require('./custom-property-pattern'))(),
        'declaration-bang-space-after': importLazy(() => require('./declaration-bang-space-after'))(),
        'declaration-bang-space-before': importLazy(() => require('./declaration-bang-space-before'))(),
        'declaration-block-no-duplicate-custom-properties': importLazy(() =>
        require('./declaration-block-no-duplicate-custom-properties'))(),

        'declaration-block-no-duplicate-properties': importLazy(() =>
        require('./declaration-block-no-duplicate-properties'))(),

        'declaration-block-no-redundant-longhand-properties': importLazy(() =>
        require('./declaration-block-no-redundant-longhand-properties'))(),

        'declaration-block-no-shorthand-property-overrides': importLazy(() =>
        require('./declaration-block-no-shorthand-property-overrides'))(),

        'declaration-block-semicolon-newline-after': importLazy(() =>
        require('./declaration-block-semicolon-newline-after'))(),

        'declaration-block-semicolon-newline-before': importLazy(() =>
        require('./declaration-block-semicolon-newline-before'))(),

        'declaration-block-semicolon-space-after': importLazy(() =>
        require('./declaration-block-semicolon-space-after'))(),

        'declaration-block-semicolon-space-before': importLazy(() =>
        require('./declaration-block-semicolon-space-before'))(),

        'declaration-block-single-line-max-declarations': importLazy(() =>
        require('./declaration-block-single-line-max-declarations'))(),

        'declaration-block-trailing-semicolon': importLazy(() =>
        require('./declaration-block-trailing-semicolon'))(),

        'declaration-colon-newline-after': importLazy(() =>
        require('./declaration-colon-newline-after'))(),

        'declaration-colon-space-after': importLazy(() => require('./declaration-colon-space-after'))(),
        'declaration-colon-space-before': importLazy(() => require('./declaration-colon-space-before'))(),
        'declaration-empty-line-before': importLazy(() => require('./declaration-empty-line-before'))(),
        'declaration-no-important': importLazy(() => require('./declaration-no-important'))(),
        'declaration-property-unit-allowed-list': importLazy(() =>
        require('./declaration-property-unit-allowed-list'))(),

        'declaration-property-unit-disallowed-list': importLazy(() =>
        require('./declaration-property-unit-disallowed-list'))(),

        'declaration-property-value-allowed-list': importLazy(() =>
        require('./declaration-property-value-allowed-list'))(),

        'declaration-property-value-disallowed-list': importLazy(() =>
        require('./declaration-property-value-disallowed-list'))(),

        'font-family-no-missing-generic-family-keyword': importLazy(() =>
        require('./font-family-no-missing-generic-family-keyword'))(),

        'font-family-name-quotes': importLazy(() => require('./font-family-name-quotes'))(),
        'font-family-no-duplicate-names': importLazy(() => require('./font-family-no-duplicate-names'))(),
        'font-weight-notation': importLazy(() => require('./font-weight-notation'))(),
        'function-allowed-list': importLazy(() => require('./function-allowed-list'))(),
        'function-calc-no-unspaced-operator': importLazy(() =>
        require('./function-calc-no-unspaced-operator'))(),

        'function-comma-newline-after': importLazy(() => require('./function-comma-newline-after'))(),
        'function-comma-newline-before': importLazy(() => require('./function-comma-newline-before'))(),
        'function-comma-space-after': importLazy(() => require('./function-comma-space-after'))(),
        'function-comma-space-before': importLazy(() => require('./function-comma-space-before'))(),
        'function-disallowed-list': importLazy(() => require('./function-disallowed-list'))(),
        'function-linear-gradient-no-nonstandard-direction': importLazy(() =>
        require('./function-linear-gradient-no-nonstandard-direction'))(),

        'function-max-empty-lines': importLazy(() => require('./function-max-empty-lines'))(),
        'function-name-case': importLazy(() => require('./function-name-case'))(),
        'function-parentheses-newline-inside': importLazy(() =>
        require('./function-parentheses-newline-inside'))(),

        'function-parentheses-space-inside': importLazy(() =>
        require('./function-parentheses-space-inside'))(),

        'function-url-no-scheme-relative': importLazy(() =>
        require('./function-url-no-scheme-relative'))(),

        'function-url-quotes': importLazy(() => require('./function-url-quotes'))(),
        'function-url-scheme-allowed-list': importLazy(() =>
        require('./function-url-scheme-allowed-list'))(),

        'function-url-scheme-disallowed-list': importLazy(() =>
        require('./function-url-scheme-disallowed-list'))(),

        'function-whitespace-after': importLazy(() => require('./function-whitespace-after'))(),
        'hue-degree-notation': importLazy(() => require('./hue-degree-notation'))(),
        'keyframe-declaration-no-important': importLazy(() =>
        require('./keyframe-declaration-no-important'))(),

        'keyframes-name-pattern': importLazy(() => require('./keyframes-name-pattern'))(),
        'length-zero-no-unit': importLazy(() => require('./length-zero-no-unit'))(),
        linebreaks: importLazy(() => require('./linebreaks'))(),
        'max-empty-lines': importLazy(() => require('./max-empty-lines'))(),
        'max-line-length': importLazy(() => require('./max-line-length'))(),
        'max-nesting-depth': importLazy(() => require('./max-nesting-depth'))(),
        'media-feature-colon-space-after': importLazy(() =>
        require('./media-feature-colon-space-after'))(),

        'media-feature-colon-space-before': importLazy(() =>
        require('./media-feature-colon-space-before'))(),

        'media-feature-name-allowed-list': importLazy(() =>
        require('./media-feature-name-allowed-list'))(),

        'media-feature-name-case': importLazy(() => require('./media-feature-name-case'))(),
        'media-feature-name-disallowed-list': importLazy(() =>
        require('./media-feature-name-disallowed-list'))(),

        'media-feature-name-no-unknown': importLazy(() => require('./media-feature-name-no-unknown'))(),
        /* 'media-feature-name-no-vendor-prefix': importLazy(() =>
        	require('./media-feature-name-no-vendor-prefix'),
        )(), */
        'media-feature-name-value-allowed-list': importLazy(() =>
        require('./media-feature-name-value-allowed-list'))(),

        'media-feature-parentheses-space-inside': importLazy(() =>
        require('./media-feature-parentheses-space-inside'))(),

        'media-feature-range-operator-space-after': importLazy(() =>
        require('./media-feature-range-operator-space-after'))(),

        'media-feature-range-operator-space-before': importLazy(() =>
        require('./media-feature-range-operator-space-before'))(),

        'media-query-list-comma-newline-after': importLazy(() =>
        require('./media-query-list-comma-newline-after'))(),

        'media-query-list-comma-newline-before': importLazy(() =>
        require('./media-query-list-comma-newline-before'))(),

        'media-query-list-comma-space-after': importLazy(() =>
        require('./media-query-list-comma-space-after'))(),

        'media-query-list-comma-space-before': importLazy(() =>
        require('./media-query-list-comma-space-before'))(),

        'named-grid-areas-no-invalid': importLazy(() => require('./named-grid-areas-no-invalid'))(),
        'no-descending-specificity': importLazy(() => require('./no-descending-specificity'))(),
        'no-duplicate-at-import-rules': importLazy(() => require('./no-duplicate-at-import-rules'))(),
        'no-duplicate-selectors': importLazy(() => require('./no-duplicate-selectors'))(),
        'no-empty-source': importLazy(() => require('./no-empty-source'))(),
        'no-empty-first-line': importLazy(() => require('./no-empty-first-line'))(),
        'no-eol-whitespace': importLazy(() => require('./no-eol-whitespace'))(),
        'no-extra-semicolons': importLazy(() => require('./no-extra-semicolons'))(),
        'no-invalid-double-slash-comments': importLazy(() =>
        require('./no-invalid-double-slash-comments'))(),

        'no-invalid-position-at-import-rule': importLazy(() =>
        require('./no-invalid-position-at-import-rule'))(),

        'no-irregular-whitespace': importLazy(() => require('./no-irregular-whitespace'))(),
        'no-missing-end-of-source-newline': importLazy(() =>
        require('./no-missing-end-of-source-newline'))(),

        'no-unknown-animations': importLazy(() => require('./no-unknown-animations'))(),
        'number-leading-zero': importLazy(() => require('./number-leading-zero'))(),
        'number-max-precision': importLazy(() => require('./number-max-precision'))(),
        'number-no-trailing-zeros': importLazy(() => require('./number-no-trailing-zeros'))(),
        'property-allowed-list': importLazy(() => require('./property-allowed-list'))(),
        'property-case': importLazy(() => require('./property-case'))(),
        'property-disallowed-list': importLazy(() => require('./property-disallowed-list'))(),
        'property-no-unknown': importLazy(() => require('./property-no-unknown'))(),
        /* 'property-no-vendor-prefix': importLazy(() => require('./property-no-vendor-prefix'))(), */
        'rule-empty-line-before': importLazy(() => require('./rule-empty-line-before'))(),
        'rule-selector-property-disallowed-list': importLazy(() =>
        require('./rule-selector-property-disallowed-list'))(),

        'selector-attribute-brackets-space-inside': importLazy(() =>
        require('./selector-attribute-brackets-space-inside'))(),

        'selector-attribute-name-disallowed-list': importLazy(() =>
        require('./selector-attribute-name-disallowed-list'))(),

        'selector-attribute-operator-allowed-list': importLazy(() =>
        require('./selector-attribute-operator-allowed-list'))(),

        'selector-attribute-operator-disallowed-list': importLazy(() =>
        require('./selector-attribute-operator-disallowed-list'))(),

        'selector-attribute-operator-space-after': importLazy(() =>
        require('./selector-attribute-operator-space-after'))(),

        'selector-attribute-operator-space-before': importLazy(() =>
        require('./selector-attribute-operator-space-before'))(),

        'selector-attribute-quotes': importLazy(() => require('./selector-attribute-quotes'))(),
        'selector-class-pattern': importLazy(() => require('./selector-class-pattern'))(),
        'selector-combinator-allowed-list': importLazy(() =>
        require('./selector-combinator-allowed-list'))(),

        'selector-combinator-disallowed-list': importLazy(() =>
        require('./selector-combinator-disallowed-list'))(),

        'selector-combinator-space-after': importLazy(() =>
        require('./selector-combinator-space-after'))(),

        'selector-combinator-space-before': importLazy(() =>
        require('./selector-combinator-space-before'))(),

        'selector-descendant-combinator-no-non-space': importLazy(() =>
        require('./selector-descendant-combinator-no-non-space'))(),

        'selector-disallowed-list': importLazy(() => require('./selector-disallowed-list'))(),
        'selector-id-pattern': importLazy(() => require('./selector-id-pattern'))(),
        'selector-list-comma-newline-after': importLazy(() =>
        require('./selector-list-comma-newline-after'))(),

        'selector-list-comma-newline-before': importLazy(() =>
        require('./selector-list-comma-newline-before'))(),

        'selector-list-comma-space-after': importLazy(() =>
        require('./selector-list-comma-space-after'))(),

        'selector-list-comma-space-before': importLazy(() =>
        require('./selector-list-comma-space-before'))(),

        'selector-max-attribute': importLazy(() => require('./selector-max-attribute'))(),
        'selector-max-class': importLazy(() => require('./selector-max-class'))(),
        'selector-max-combinators': importLazy(() => require('./selector-max-combinators'))(),
        'selector-max-compound-selectors': importLazy(() =>
        require('./selector-max-compound-selectors'))(),

        'selector-max-empty-lines': importLazy(() => require('./selector-max-empty-lines'))(),
        'selector-max-id': importLazy(() => require('./selector-max-id'))(),
        'selector-max-pseudo-class': importLazy(() => require('./selector-max-pseudo-class'))(),
        'selector-max-specificity': importLazy(() => require('./selector-max-specificity'))(),
        'selector-max-type': importLazy(() => require('./selector-max-type'))(),
        'selector-max-universal': importLazy(() => require('./selector-max-universal'))(),
        'selector-nested-pattern': importLazy(() => require('./selector-nested-pattern'))(),
        'selector-no-qualifying-type': importLazy(() => require('./selector-no-qualifying-type'))(),
        /* 'selector-no-vendor-prefix': importLazy(() => require('./selector-no-vendor-prefix'))(), */
        'selector-pseudo-class-allowed-list': importLazy(() =>
        require('./selector-pseudo-class-allowed-list'))(),

        'selector-pseudo-class-case': importLazy(() => require('./selector-pseudo-class-case'))(),
        'selector-pseudo-class-disallowed-list': importLazy(() =>
        require('./selector-pseudo-class-disallowed-list'))(),

        'selector-pseudo-class-no-unknown': importLazy(() =>
        require('./selector-pseudo-class-no-unknown'))(),

        'selector-pseudo-class-parentheses-space-inside': importLazy(() =>
        require('./selector-pseudo-class-parentheses-space-inside'))(),

        'selector-pseudo-element-allowed-list': importLazy(() =>
        require('./selector-pseudo-element-allowed-list'))(),

        'selector-pseudo-element-case': importLazy(() => require('./selector-pseudo-element-case'))(),
        'selector-pseudo-element-colon-notation': importLazy(() =>
        require('./selector-pseudo-element-colon-notation'))(),

        'selector-pseudo-element-disallowed-list': importLazy(() =>
        require('./selector-pseudo-element-disallowed-list'))(),

        'selector-pseudo-element-no-unknown': importLazy(() =>
        require('./selector-pseudo-element-no-unknown'))(),

        'selector-type-case': importLazy(() => require('./selector-type-case'))(),
        'selector-type-no-unknown': importLazy(() => require('./selector-type-no-unknown'))(),
        'shorthand-property-no-redundant-values': importLazy(() =>
        require('./shorthand-property-no-redundant-values'))(),

        'string-no-newline': importLazy(() => require('./string-no-newline'))(),
        'string-quotes': importLazy(() => require('./string-quotes'))(),
        'time-min-milliseconds': importLazy(() => require('./time-min-milliseconds'))(),
        'unicode-bom': importLazy(() => require('./unicode-bom'))(),
        'unit-allowed-list': importLazy(() => require('./unit-allowed-list'))(),
        'unit-case': importLazy(() => require('./unit-case'))(),
        'unit-disallowed-list': importLazy(() => require('./unit-disallowed-list'))(),
        'unit-no-unknown': importLazy(() => require('./unit-no-unknown'))(),
        'value-keyword-case': importLazy(() => require('./value-keyword-case'))(),
        'value-list-comma-newline-after': importLazy(() => require('./value-list-comma-newline-after'))(),
        'value-list-comma-newline-before': importLazy(() =>
        require('./value-list-comma-newline-before'))(),

        'value-list-comma-space-after': importLazy(() => require('./value-list-comma-space-after'))(),
        'value-list-comma-space-before': importLazy(() => require('./value-list-comma-space-before'))(),
        'value-list-max-empty-lines': importLazy(() => require('./value-list-max-empty-lines'))(),
        /* 'value-no-vendor-prefix': importLazy(() => require('./value-no-vendor-prefix'))(), */
        indentation: importLazy(() => require('./indentation'))() /* Placedhere for better autofixing */ };


      module.exports = rules;

    }, { "./alpha-value-notation": 149, "./at-rule-allowed-list": 150, "./at-rule-disallowed-list": 151, "./at-rule-empty-line-before": 152, "./at-rule-name-case": 153, "./at-rule-name-newline-after": 154, "./at-rule-name-space-after": 155, "./at-rule-no-unknown": 156, "./at-rule-property-required-list": 157, "./at-rule-semicolon-newline-after": 158, "./at-rule-semicolon-space-before": 159, "./block-closing-brace-empty-line-before": 161, "./block-closing-brace-newline-after": 162, "./block-closing-brace-newline-before": 163, "./block-closing-brace-space-after": 164, "./block-closing-brace-space-before": 165, "./block-no-empty": 166, "./block-opening-brace-newline-after": 167, "./block-opening-brace-newline-before": 168, "./block-opening-brace-space-after": 169, "./block-opening-brace-space-before": 170, "./color-function-notation": 171, "./color-hex-alpha": 172, "./color-hex-case": 173, "./color-hex-length": 174, "./color-named": 176, "./color-no-hex": 177, "./color-no-invalid-hex": 178, "./comment-empty-line-before": 179, "./comment-no-empty": 180, "./comment-pattern": 181, "./comment-whitespace-inside": 182, "./comment-word-disallowed-list": 183, "./custom-media-pattern": 184, "./custom-property-empty-line-before": 185, "./custom-property-no-missing-var-function": 186, "./custom-property-pattern": 187, "./declaration-bang-space-after": 188, "./declaration-bang-space-before": 189, "./declaration-block-no-duplicate-custom-properties": 190, "./declaration-block-no-duplicate-properties": 191, "./declaration-block-no-redundant-longhand-properties": 192, "./declaration-block-no-shorthand-property-overrides": 193, "./declaration-block-semicolon-newline-after": 194, "./declaration-block-semicolon-newline-before": 195, "./declaration-block-semicolon-space-after": 196, "./declaration-block-semicolon-space-before": 197, "./declaration-block-single-line-max-declarations": 198, "./declaration-block-trailing-semicolon": 199, "./declaration-colon-newline-after": 200, "./declaration-colon-space-after": 201, "./declaration-colon-space-before": 202, "./declaration-empty-line-before": 203, "./declaration-no-important": 204, "./declaration-property-unit-allowed-list": 205, "./declaration-property-unit-disallowed-list": 206, "./declaration-property-value-allowed-list": 207, "./declaration-property-value-disallowed-list": 208, "./font-family-name-quotes": 212, "./font-family-no-duplicate-names": 213, "./font-family-no-missing-generic-family-keyword": 214, "./font-weight-notation": 215, "./function-allowed-list": 216, "./function-calc-no-unspaced-operator": 217, "./function-comma-newline-after": 218, "./function-comma-newline-before": 219, "./function-comma-space-after": 220, "./function-comma-space-before": 221, "./function-disallowed-list": 222, "./function-linear-gradient-no-nonstandard-direction": 223, "./function-max-empty-lines": 224, "./function-name-case": 225, "./function-parentheses-newline-inside": 226, "./function-parentheses-space-inside": 227, "./function-url-no-scheme-relative": 228, "./function-url-quotes": 229, "./function-url-scheme-allowed-list": 230, "./function-url-scheme-disallowed-list": 231, "./function-whitespace-after": 232, "./hue-degree-notation": 235, "./indentation": 236, "./keyframe-declaration-no-important": 238, "./keyframes-name-pattern": 239, "./length-zero-no-unit": 240, "./linebreaks": 241, "./max-empty-lines": 242, "./max-line-length": 243, "./max-nesting-depth": 244, "./media-feature-colon-space-after": 245, "./media-feature-colon-space-before": 246, "./media-feature-name-allowed-list": 247, "./media-feature-name-case": 248, "./media-feature-name-disallowed-list": 249, "./media-feature-name-no-unknown": 250, "./media-feature-name-value-allowed-list": 251, "./media-feature-parentheses-space-inside": 252, "./media-feature-range-operator-space-after": 253, "./media-feature-range-operator-space-before": 254, "./media-query-list-comma-newline-after": 255, "./media-query-list-comma-newline-before": 256, "./media-query-list-comma-space-after": 257, "./media-query-list-comma-space-before": 258, "./named-grid-areas-no-invalid": 261, "./no-descending-specificity": 264, "./no-duplicate-at-import-rules": 265, "./no-duplicate-selectors": 266, "./no-empty-first-line": 267, "./no-empty-source": 268, "./no-eol-whitespace": 269, "./no-extra-semicolons": 270, "./no-invalid-double-slash-comments": 271, "./no-invalid-position-at-import-rule": 272, "./no-irregular-whitespace": 273, "./no-missing-end-of-source-newline": 274, "./no-unknown-animations": 275, "./number-leading-zero": 276, "./number-max-precision": 277, "./number-no-trailing-zeros": 278, "./property-allowed-list": 279, "./property-case": 280, "./property-disallowed-list": 281, "./property-no-unknown": 282, "./rule-empty-line-before": 284, "./rule-selector-property-disallowed-list": 285, "./selector-attribute-brackets-space-inside": 286, "./selector-attribute-name-disallowed-list": 287, "./selector-attribute-operator-allowed-list": 288, "./selector-attribute-operator-disallowed-list": 289, "./selector-attribute-operator-space-after": 290, "./selector-attribute-operator-space-before": 291, "./selector-attribute-quotes": 292, "./selector-class-pattern": 293, "./selector-combinator-allowed-list": 294, "./selector-combinator-disallowed-list": 295, "./selector-combinator-space-after": 296, "./selector-combinator-space-before": 297, "./selector-descendant-combinator-no-non-space": 298, "./selector-disallowed-list": 299, "./selector-id-pattern": 300, "./selector-list-comma-newline-after": 301, "./selector-list-comma-newline-before": 302, "./selector-list-comma-space-after": 303, "./selector-list-comma-space-before": 304, "./selector-max-attribute": 305, "./selector-max-class": 306, "./selector-max-combinators": 307, "./selector-max-compound-selectors": 308, "./selector-max-empty-lines": 309, "./selector-max-id": 310, "./selector-max-pseudo-class": 311, "./selector-max-specificity": 312, "./selector-max-type": 313, "./selector-max-universal": 314, "./selector-nested-pattern": 315, "./selector-no-qualifying-type": 316, "./selector-pseudo-class-allowed-list": 317, "./selector-pseudo-class-case": 318, "./selector-pseudo-class-disallowed-list": 319, "./selector-pseudo-class-no-unknown": 320, "./selector-pseudo-class-parentheses-space-inside": 321, "./selector-pseudo-element-allowed-list": 322, "./selector-pseudo-element-case": 323, "./selector-pseudo-element-colon-notation": 324, "./selector-pseudo-element-disallowed-list": 325, "./selector-pseudo-element-no-unknown": 326, "./selector-type-case": 327, "./selector-type-no-unknown": 328, "./shorthand-property-no-redundant-values": 332, "./string-no-newline": 333, "./string-quotes": 334, "./time-min-milliseconds": 335, "./unicode-bom": 336, "./unit-allowed-list": 337, "./unit-case": 338, "./unit-disallowed-list": 339, "./unit-no-unknown": 340, "./value-keyword-case": 341, "./value-list-comma-newline-after": 342, "./value-list-comma-newline-before": 343, "./value-list-comma-space-after": 344, "./value-list-comma-space-before": 345, "./value-list-max-empty-lines": 346, "import-lazy": 31 }], 238: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'keyframe-declaration-no-important';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected !important' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {
            atRuleKeyframes.walkDecls(decl => {
              if (!decl.important) {
                return;
              }

              report({
                message: messages.rejected,
                node: decl,
                word: 'important',
                result,
                ruleName });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 239: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'keyframes-name-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (keyframeName, pattern) =>
        `Expected keyframe name "${keyframeName}" to match pattern "${pattern}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const regex = isString(primary) ? new RegExp(primary) : primary;

          root.walkAtRules(/keyframes/i, keyframesNode => {
            const value = keyframesNode.params;

            if (regex.test(value)) {
              return;
            }

            report({
              index: atRuleParamIndex(keyframesNode),
              message: messages.expected(value, primary),
              node: keyframesNode,
              ruleName,
              result });

          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 240: [function (require, module, exports) {
      'use strict';

      const valueParser = require('postcss-value-parser');

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getAtRuleParams = require('../../utils/getAtRuleParams');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const isCustomProperty = require('../../utils/isCustomProperty');
      const isMathFunction = require('../../utils/isMathFunction');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setAtRuleParams = require('../../utils/setAtRuleParams');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'length-zero-no-unit';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected unit' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['custom-properties'],
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) return;

          let needsFix;

          /**
           * @param {import('postcss').Node} node
           * @param {number} nodeIndex
           * @param {import('postcss-value-parser').Node} valueNode
           */
          function check(node, nodeIndex, valueNode) {
            const { value, sourceIndex } = valueNode;

            if (isMathFunction(valueNode)) return false;

            if (isFunction(valueNode) && optionsMatches(secondaryOptions, 'ignoreFunctions', value))
            return false;

            if (!isWord(valueNode)) return;

            const numberUnit = valueParser.unit(value);

            if (numberUnit === false) return;

            const { number, unit } = numberUnit;

            if (unit === '') return;

            if (!isLength(unit)) return;

            if (isFraction(unit)) return;

            if (!isZero(number)) return;

            if (context.fix) {
              valueNode.value = number;
              needsFix = true;

              return;
            }

            report({
              index: nodeIndex + sourceIndex + number.length,
              message: messages.rejected,
              node,
              result,
              ruleName });

          }

          /**
           * @param {import('postcss').AtRule} node
           */
          function checkAtRule(node) {
            if (!isStandardSyntaxAtRule(node)) return;

            needsFix = false;

            const index = atRuleParamIndex(node);
            const parsedValue = valueParser(getAtRuleParams(node));

            parsedValue.walk(valueNode => check(node, index, valueNode));

            if (needsFix) {
              setAtRuleParams(node, parsedValue.toString());
            }
          }

          /**
           * @param {import('postcss').Declaration} node
           */
          function checkDecl(node) {
            needsFix = false;

            const { prop } = node;

            if (isLineHeight(prop)) return;

            if (isFlex(prop)) return;

            if (optionsMatches(secondaryOptions, 'ignore', 'custom-properties') && isCustomProperty(prop))
            return;

            const index = declarationValueIndex(node);
            const parsedValue = valueParser(getDeclarationValue(node));

            parsedValue.walk((valueNode, valueNodeIndex, valueNodes) => {
              if (isLineHeightValue(node, valueNodes, valueNodeIndex)) return;

              return check(node, index, valueNode);
            });

            if (needsFix) {
              setDeclarationValue(node, parsedValue.toString());
            }
          }

          root.walkAtRules(checkAtRule);
          root.walkDecls(checkDecl);
        };
      };

      /**
       * @param {import('postcss').Declaration} decl
       * @param {import('postcss-value-parser').Node[]} nodes
       * @param {number} index
       */
      function isLineHeightValue({ prop }, nodes, index) {
        return (
          prop.toLowerCase() === 'font' &&
          index > 0 &&
          nodes[index - 1].type === 'div' &&
          nodes[index - 1].value === '/');

      }

      /**
       * @param {string} prop
       */
      function isLineHeight(prop) {
        return prop.toLowerCase() === 'line-height';
      }

      /**
       * @param {string} prop
       */
      function isFlex(prop) {
        return prop.toLowerCase() === 'flex';
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isWord({ type }) {
        return type === 'word';
      }

      /**
       * @param {string} unit
       */
      function isLength(unit) {
        return keywordSets.lengthUnits.has(unit.toLowerCase());
      }

      /**
       * @param {import('postcss-value-parser').Node} node
       */
      function isFunction({ type }) {
        return type === 'function';
      }

      /**
       * @param {string} unit
       */
      function isFraction(unit) {
        return unit.toLowerCase() === 'fr';
      }

      /**
       * @param {string} number
       */
      function isZero(number) {
        return Number.parseFloat(number) === 0;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getAtRuleParams": 365, "../../utils/getDeclarationValue": 366, "../../utils/isCustomProperty": 393, "../../utils/isMathFunction": 399, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setAtRuleParams": 437, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 241: [function (require, module, exports) {
      'use strict';

      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'linebreaks';

      const messages = ruleMessages(ruleName, {
        expected: linebreak => `Expected linebreak to be ${linebreak}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['unix', 'windows'] });


          if (!validOptions) {
            return;
          }

          const shouldHaveCR = primary === 'windows';

          if (context.fix) {
            root.walk(node => {
              if ('selector' in node) {
                node.selector = fixData(node.selector);
              }

              if ('value' in node) {
                node.value = fixData(node.value);
              }

              if ('text' in node) {
                node.text = fixData(node.text);
              }

              if (node.raws.before) {
                node.raws.before = fixData(node.raws.before);
              }

              if ('after' in node.raws && node.raws.after) {
                node.raws.after = fixData(node.raws.after);
              }
            });

            if ('after' in root.raws && root.raws.after) {
              root.raws.after = fixData(root.raws.after);
            }
          } else {
            if (root.source == null) throw new Error('The root node must have a source');

            const lines = root.source.input.css.split('\n');

            for (let i = 0; i < lines.length; i++) {
              let line = lines[i];

              if (i < lines.length - 1 && !line.includes('\r')) {
                line += '\n';
              }

              if (hasError(line)) {
                const lineNum = i + 1;
                const colNum = line.length;

                reportNewlineError(lineNum, colNum);
              }
            }
          }

          /**
           * @param {string} dataToCheck
           */
          function hasError(dataToCheck) {
            const hasNewlineToVerify = /[\r\n]/.test(dataToCheck);
            const hasCR = hasNewlineToVerify ? /\r/.test(dataToCheck) : false;

            return hasNewlineToVerify && hasCR !== shouldHaveCR;
          }

          /**
           * @param {string} data
           */
          function fixData(data) {
            if (data) {
              let res = data.replace(/\r/g, '');

              if (shouldHaveCR) {
                res = res.replace(/\n/g, '\r\n');
              }

              return res;
            }

            return data;
          }

          /**
           * @param {number} line
           * @param {number} column
           */
          function reportNewlineError(line, column) {
            // Creating a node manually helps us to point to empty lines.
            const node = postcss.rule({
              source: {
                start: { line, column, offset: 0 },
                input: new postcss.Input('') } });



            report({
              message: messages.expected(primary),
              node,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss": 103 }], 242: [function (require, module, exports) {
      'use strict';

      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        let emptyLines = 0;
        let lastIndex = -1;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNumber },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['comments'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
          const getChars = replaceEmptyLines.bind(null, primary);

          /**
           * 1. walk nodes & replace enterchar
           * 2. deal with special case.
           */
          if (context.fix) {
            root.walk(node => {
              if (node.type === 'comment' && !ignoreComments) {
                node.raws.left = getChars(node.raws.left);
                node.raws.right = getChars(node.raws.right);
              }

              if (node.raws.before) {
                node.raws.before = getChars(node.raws.before);
              }
            });

            // first node
            const firstNodeRawsBefore = root.first && root.first.raws.before;
            // root raws
            const rootRawsAfter = root.raws.after;

            // not document node
            // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Root'.
            if ((root.document && root.document.constructor.name) !== 'Document') {
              if (firstNodeRawsBefore) {
                root.first.raws.before = getChars(firstNodeRawsBefore, true);
              }

              if (rootRawsAfter) {
                // when max setted 0, should be treated as 1 in this situation.
                root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter, true);
              }
            } else if (rootRawsAfter) {
              // `css in js` or `html`
              root.raws.after = replaceEmptyLines(primary === 0 ? 1 : primary, rootRawsAfter);
            }

            return;
          }

          emptyLines = 0;
          lastIndex = -1;
          const rootString = root.toString();

          styleSearch(
          {
            source: rootString,
            target: /\r\n/.test(rootString) ? '\r\n' : '\n',
            comments: ignoreComments ? 'skip' : 'check' },

          match => {
            checkMatch(rootString, match.startIndex, match.endIndex, root);
          });


          /**
           * @param {string} source
           * @param {number} matchStartIndex
           * @param {number} matchEndIndex
           * @param {import('postcss').Root} node
           */
          function checkMatch(source, matchStartIndex, matchEndIndex, node) {
            const eof = matchEndIndex === source.length;
            let problem = false;

            // Additional check for beginning of file
            if (!matchStartIndex || lastIndex === matchStartIndex) {
              emptyLines++;
            } else {
              emptyLines = 0;
            }

            lastIndex = matchEndIndex;

            if (emptyLines > primary) problem = true;

            if (!eof && !problem) return;

            if (problem) {
              report({
                message: messages.expected(primary),
                node,
                index: matchStartIndex,
                result,
                ruleName });

            }

            // Additional check for end of file
            if (eof && primary) {
              emptyLines++;

              if (emptyLines > primary && isEofNode(result.root, node)) {
                report({
                  message: messages.expected(primary),
                  node,
                  index: matchEndIndex,
                  result,
                  ruleName });

              }
            }
          }

          /**
           * @param {number} maxLines
           * @param {unknown} str
           * @param {boolean?} isSpecialCase
           */
          function replaceEmptyLines(maxLines, str, isSpecialCase = false) {
            const repeatTimes = isSpecialCase ? maxLines : maxLines + 1;

            if (repeatTimes === 0 || typeof str !== 'string') {
              return '';
            }

            const emptyLFLines = '\n'.repeat(repeatTimes);
            const emptyCRLFLines = '\r\n'.repeat(repeatTimes);

            return /(?:\r\n)+/.test(str) ?
            str.replace(/(\r\n)+/g, $1 => {
              if ($1.length / 2 > repeatTimes) {
                return emptyCRLFLines;
              }

              return $1;
            }) :
            str.replace(/(\n)+/g, $1 => {
              if ($1.length > repeatTimes) {
                return emptyLFLines;
              }

              return $1;
            });
          }
        };
      };

      /**
       * Checks whether the given node is the last node of file.
       * @param {import('stylelint').PostcssResult['root']} document - the document node with `postcss-html` and `postcss-jsx`.
       * @param {import('postcss').Root} root - the root node of css
       */
      function isEofNode(document, root) {
        if (!document || document.constructor.name !== 'Document' || !('type' in document)) {
          return true;
        }

        // In the `postcss-html` and `postcss-jsx` syntax, checks that there is text after the given node.
        let after;

        // @ts-expect-error -- TS2367: This condition will always return 'false' since the types 'Root' and 'ChildNode | undefined' have no overlap.
        if (root === document.last) {
          after = document.raws && document.raws.codeAfter;
        } else {
          // @ts-expect-error -- TS2345: Argument of type 'Root' is not assignable to parameter of type 'number | ChildNode'.
          const rootIndex = document.index(root);

          const nextNode = document.nodes[rootIndex + 1];

          // @ts-expect-error -- TS2339: Property 'codeBefore' does not exist on type 'CommentRaws'.
          after = nextNode && nextNode.raws && nextNode.raws.codeBefore;
        }

        return !String(after).trim();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "style-search": 121 }], 243: [function (require, module, exports) {
      'use strict';

      const execall = require('execall');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'max-line-length';
      const EXCLUDED_PATTERNS = [
      /url\(\s*(\S.*\S)\s*\)/gi, // allow tab, whitespace in url content
      /@import\s+(['"].*['"])/gi];


      const messages = ruleMessages(ruleName, {
        expected: (max) =>
        `Expected line length to be no more than ${max} ${max === 1 ? 'character' : 'characters'}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: isNumber },

          {
            actual: secondaryOptions,
            possible: {
              ignore: ['non-comments', 'comments'],
              ignorePattern: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          if (root.source == null) {
            throw new Error('The root node must have a source');
          }

          const ignoreNonComments = optionsMatches(secondaryOptions, 'ignore', 'non-comments');
          const ignoreComments = optionsMatches(secondaryOptions, 'ignore', 'comments');
          const rootString = context.fix ? root.toString() : root.source.input.css;
          // Array of skipped sub strings, i.e `url(...)`, `@import "..."`
          /** @type {Array<[number, number]>} */
          let skippedSubStrings = [];
          let skippedSubStringsIndex = 0;

          for (const pattern of EXCLUDED_PATTERNS)
          for (const match of execall(pattern, rootString)) {
            const subMatch = match.subMatches[0] || '';
            const startOfSubString = match.index + match.match.indexOf(subMatch);

            skippedSubStrings.push([startOfSubString, startOfSubString + subMatch.length]);
            continue;
          }

          skippedSubStrings = skippedSubStrings.sort((a, b) => a[0] - b[0]);

          // Check first line
          checkNewline({ endIndex: 0 });
          // Check subsequent lines
          styleSearch({ source: rootString, target: ['\n'], comments: 'check' }, (match) =>
          checkNewline(match));


          /**
           * @param {number} index
           */
          function complain(index) {
            report({
              index,
              result,
              ruleName,
              message: messages.expected(primary),
              node: root });

          }

          /**
           * @param {number} start
           * @param {number} end
           */
          function tryToPopSubString(start, end) {
            const [startSubString, endSubString] = skippedSubStrings[skippedSubStringsIndex];

            // Excluded substring does not presented in current line
            if (end < startSubString) {
              return 0;
            }

            // Compute excluded substring size regarding to current line indexes
            const excluded = Math.min(end, endSubString) - Math.max(start, startSubString);

            // Current substring is out of range for next lines
            if (endSubString <= end) {
              skippedSubStringsIndex++;
            }

            return excluded;
          }

          /**
           * @param {import('style-search').StyleSearchMatch | { endIndex: number }} match
           */
          function checkNewline(match) {
            let nextNewlineIndex = rootString.indexOf('\n', match.endIndex);

            if (rootString[nextNewlineIndex - 1] === '\r') {
              nextNewlineIndex -= 1;
            }

            // Accommodate last line
            if (nextNewlineIndex === -1) {
              nextNewlineIndex = rootString.length;
            }

            const rawLineLength = nextNewlineIndex - match.endIndex;
            const excludedLength = skippedSubStrings[skippedSubStringsIndex] ?
            tryToPopSubString(match.endIndex, nextNewlineIndex) :
            0;
            const lineText = rootString.slice(match.endIndex, nextNewlineIndex);

            // Case sensitive ignorePattern match
            if (optionsMatches(secondaryOptions, 'ignorePattern', lineText)) {
              return;
            }

            // If the line's length is less than or equal to the specified
            // max, ignore it ... So anything below is liable to be complained about.
            // **Note that the length of any url arguments or import urls
            // are excluded from the calculation.**
            if (rawLineLength - excludedLength <= primary) {
              return;
            }

            const complaintIndex = nextNewlineIndex - 1;

            if (ignoreComments) {
              if ('insideComment' in match && match.insideComment) {
                return;
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars === '/*' || nextTwoChars === '//') {
                return;
              }
            }

            if (ignoreNonComments) {
              if ('insideComment' in match && match.insideComment) {
                return complain(complaintIndex);
              }

              // This trimming business is to notice when the line starts a
              // comment but that comment is indented, e.g.
              //       /* something here */
              const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2);

              if (nextTwoChars !== '/*' && nextTwoChars !== '//') {
                return;
              }

              return complain(complaintIndex);
            }

            // If there are no spaces besides initial (indent) spaces, ignore it
            const lineString = rootString.slice(match.endIndex, nextNewlineIndex);

            if (!lineString.replace(/^\s+/, '').includes(' ')) {
              return;
            }

            return complain(complaintIndex);
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "execall": 18, "style-search": 121 }], 244: [function (require, module, exports) {
      'use strict';

      const hasBlock = require('../../utils/hasBlock');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parser = require('postcss-selector-parser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isAtRule, isDeclaration, isRoot, isRule } = require('../../utils/typeGuards');
      const { isNumber, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'max-nesting-depth';

      const messages = ruleMessages(ruleName, {
        expected: depth => `Expected nesting depth to be no more than ${depth}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        /**
         * @param {import('postcss').Node} node
         */
        const isIgnoreAtRule = (node) =>
        isAtRule(node) && optionsMatches(secondaryOptions, 'ignoreAtRules', node.name);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary,
            possible: [isNumber] },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['blockless-at-rules', 'pseudo-classes'],
              ignoreAtRules: [isString, isRegExp],
              ignorePseudoClasses: [isString, isRegExp] } });




          if (!validOptions) return;

          root.walkRules(checkStatement);
          root.walkAtRules(checkStatement);

          /**
           * @param {import('postcss').Rule | import('postcss').AtRule} statement
           */
          function checkStatement(statement) {
            if (isIgnoreAtRule(statement)) {
              return;
            }

            if (!hasBlock(statement)) {
              return;
            }

            if (isRule(statement) && !isStandardSyntaxRule(statement)) {
              return;
            }

            const depth = nestingDepth(statement, 0);

            if (depth > primary) {
              report({
                ruleName,
                result,
                node: statement,
                message: messages.expected(primary) });

            }
          }
        };

        /**
         * @param {import('postcss').Node} node
         * @param {number} level
         * @returns {number}
         */
        function nestingDepth(node, level) {
          const parent = node.parent;

          if (parent == null) {
            throw new Error('The parent node must exist');
          }

          if (isIgnoreAtRule(parent)) {
            return 0;
          }

          // The nesting depth level's computation has finished
          // when this function, recursively called, receives
          // a node that is not nested -- a direct child of the
          // root node
          if (isRoot(parent) || isAtRule(parent) && parent.parent && isRoot(parent.parent)) {
            return level;
          }

          /**
           * @param {string} selector
           */
          function containsPseudoClassesOnly(selector) {
            const normalized = parser().processSync(selector, { lossless: false });
            const selectors = normalized.split(',');

            return selectors.every(sel => extractPseudoRule(sel));
          }

          /**
           * @param {string[]} selectors
           * @returns {boolean}
           */
          function containsIgnoredPseudoClassesOnly(selectors) {
            if (!(secondaryOptions && secondaryOptions.ignorePseudoClasses)) return false;

            return selectors.every(selector => {
              const pseudoRule = extractPseudoRule(selector);

              if (!pseudoRule) return false;

              return optionsMatches(secondaryOptions, 'ignorePseudoClasses', pseudoRule);
            });
          }

          if (
          optionsMatches(secondaryOptions, 'ignore', 'blockless-at-rules') &&
          isAtRule(node) &&
          node.every(child => !isDeclaration(child)) ||
          optionsMatches(secondaryOptions, 'ignore', 'pseudo-classes') &&
          isRule(node) &&
          containsPseudoClassesOnly(node.selector) ||
          isRule(node) && containsIgnoredPseudoClassesOnly(node.selectors))
          {
            return nestingDepth(parent, level);
          }

          // Unless any of the conditions above apply, we want to
          // add 1 to the nesting depth level and then check the parent,
          // continuing to add and move up the hierarchy
          // until we hit the root node
          return nestingDepth(parent, level + 1);
        }
      };

      /**
       * @param {string} selector
       * @returns {string | undefined}
       */
      function extractPseudoRule(selector) {
        return selector.startsWith('&:') && selector[2] !== ':' ? selector.substr(2) : undefined;
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/hasBlock": 375, "../../utils/isStandardSyntaxRule": 417, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-selector-parser": 53 }], 245: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ":"',
        rejectedAfter: () => 'Unexpected whitespace after ":"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, colonIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of colonIndices.sort((a, b) => b - a)) {
                const beforeColon = params.slice(0, index + 1);
                const afterColon = params.slice(index + 1);

                if (primary === 'always') {
                  params = beforeColon + afterColon.replace(/^\s*/, ' ');
                } else if (primary === 'never') {
                  params = beforeColon + afterColon.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaFeatureColonSpaceChecker": 259 }], 246: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaFeatureColonSpaceChecker = require('../mediaFeatureColonSpaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-colon-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ":"',
        rejectedBefore: () => 'Unexpected whitespace before ":"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaFeatureColonSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramColonIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const colonIndices = fixData.get(atRule) || [];

              colonIndices.push(paramColonIndex);
              fixData.set(atRule, colonIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, colonIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of colonIndices.sort((a, b) => b - a)) {
                const beforeColon = params.slice(0, index);
                const afterColon = params.slice(index);

                if (primary === 'always') {
                  params = beforeColon.replace(/\s*$/, ' ') + afterColon;
                } else if (primary === 'never') {
                  params = beforeColon.replace(/\s*$/, '') + afterColon;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaFeatureColonSpaceChecker": 259 }], 247: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (matchesStringOrRegExp(value, primary)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/isCustomMediaQuery": 392, "../../utils/isRangeContextMediaFeature": 404, "../../utils/isStandardSyntaxMediaFeatureName": 415, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../rangeContextNodeParser": 283, "postcss-media-query-parser": 46 }], 248: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'media-feature-name-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            let hasComments = atRule.raws.params && atRule.raws.params.raw;
            const mediaRule = hasComments ? hasComments : atRule.params;

            mediaParser(mediaRule).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              const expectedFeatureName = primary === 'lower' ? value.toLowerCase() : value.toUpperCase();

              if (value === expectedFeatureName) {
                return;
              }

              if (context.fix) {
                if (hasComments) {
                  hasComments =
                  hasComments.slice(0, sourceIndex) +
                  expectedFeatureName +
                  hasComments.slice(sourceIndex + expectedFeatureName.length);

                  if (atRule.raws.params == null) {
                    throw new Error('The `AtRuleRaws` node must have a `params` property');
                  }

                  atRule.raws.params.raw = hasComments;
                } else {
                  atRule.params =
                  atRule.params.slice(0, sourceIndex) +
                  expectedFeatureName +
                  atRule.params.slice(sourceIndex + expectedFeatureName.length);
                }

                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.expected(value, expectedFeatureName),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/isCustomMediaQuery": 392, "../../utils/isRangeContextMediaFeature": 404, "../../utils/isStandardSyntaxMediaFeatureName": 415, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../rangeContextNodeParser": 283, "postcss-media-query-parser": 46 }], 249: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected media feature name "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (!matchesStringOrRegExp(value, primary)) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/isCustomMediaQuery": 392, "../../utils/isRangeContextMediaFeature": 404, "../../utils/isStandardSyntaxMediaFeatureName": 415, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../rangeContextNodeParser": 283, "postcss-media-query-parser": 46 }], 250: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomMediaQuery = require('../../utils/isCustomMediaQuery');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const isStandardSyntaxMediaFeatureName = require('../../utils/isStandardSyntaxMediaFeatureName');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'media-feature-name-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: mediaFeatureName => `Unexpected unknown media feature name "${mediaFeatureName}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              ignoreMediaFeatureNames: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const parent = mediaFeatureNode.parent;
              const mediaFeatureRangeContext = isRangeContextMediaFeature(parent.value);

              let value;
              let sourceIndex;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                value = parsedRangeContext.name.value;
                sourceIndex = parsedRangeContext.name.sourceIndex;
              } else {
                value = mediaFeatureNode.value;
                sourceIndex = mediaFeatureNode.sourceIndex;
              }

              if (!isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {
                return;
              }

              if (optionsMatches(secondaryOptions, 'ignoreMediaFeatureNames', value)) {
                return;
              }

              if (vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {
                return;
              }

              report({
                index: atRuleParamIndex(atRule) + sourceIndex,
                message: messages.rejected(value),
                node: atRule,
                ruleName,
                result });

            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/atRuleParamIndex": 352, "../../utils/isCustomMediaQuery": 392, "../../utils/isRangeContextMediaFeature": 404, "../../utils/isStandardSyntaxMediaFeatureName": 415, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "../rangeContextNodeParser": 283, "postcss-media-query-parser": 46 }], 251: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isRangeContextMediaFeature = require('../../utils/isRangeContextMediaFeature');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const mediaParser = require('postcss-media-query-parser').default;
      const rangeContextNodeParser = require('../rangeContextNodeParser');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'media-feature-name-value-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (name, value) => `Unexpected value "${value}" for name "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            mediaParser(atRule.params).walk(/^media-feature-expression$/i, node => {
              if (!node.nodes) return;

              const mediaFeatureRangeContext = isRangeContextMediaFeature(node.parent.value);

              // Ignore boolean
              if (!node.value.includes(':') && !mediaFeatureRangeContext) {
                return;
              }

              const mediaFeatureNode = node.nodes.find(n => n.type === 'media-feature');

              if (mediaFeatureNode == null) throw new Error('A `media-feature` node must be present');

              let mediaFeatureName;
              let values;

              if (mediaFeatureRangeContext) {
                const parsedRangeContext = rangeContextNodeParser(mediaFeatureNode);

                mediaFeatureName = parsedRangeContext.name.value;
                values = parsedRangeContext.values;
              } else {
                mediaFeatureName = mediaFeatureNode.value;
                const valueNode = node.nodes.find(n => n.type === 'value');

                if (valueNode == null) throw new Error('A `value` node must be present');

                values = [valueNode];
              }

              for (const valueNode of values) {
                const value = valueNode.value;
                const unprefixedMediaFeatureName = vendor.unprefixed(mediaFeatureName);

                const allowedValuesKey = Object.keys(primary).find((featureName) =>
                matchesStringOrRegExp(unprefixedMediaFeatureName, featureName));


                if (allowedValuesKey == null) {
                  return;
                }

                const allowedValues = primary[allowedValuesKey];

                if (allowedValues == null) {
                  return;
                }

                if (matchesStringOrRegExp(value, allowedValues)) {
                  return;
                }

                report({
                  index: atRuleParamIndex(atRule) + valueNode.sourceIndex,
                  message: messages.rejected(mediaFeatureName, value),
                  node: atRule,
                  ruleName,
                  result });

              }
            });
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/isRangeContextMediaFeature": 404, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "../rangeContextNodeParser": 283, "is-plain-object": 35, "postcss-media-query-parser": 46 }], 252: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'media-feature-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            // If there are comments in the params, the complete string
            // will be at atRule.raws.params.raw
            const params = atRule.raws.params && atRule.raws.params.raw || atRule.params;
            const indexBoost = atRuleParamIndex(atRule);
            /** @type {Array<{ message: string, index: number }>} */
            const problems = [];

            const parsedParams = valueParser(params).walk(node => {
              if (node.type === 'function') {
                const len = valueParser.stringify(node).length;

                if (primary === 'never') {
                  if (/[ \t]/.test(node.before)) {
                    if (context.fix) node.before = '';

                    problems.push({
                      message: messages.rejectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (/[ \t]/.test(node.after)) {
                    if (context.fix) node.after = '';

                    problems.push({
                      message: messages.rejectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                } else if (primary === 'always') {
                  if (node.before === '') {
                    if (context.fix) node.before = ' ';

                    problems.push({
                      message: messages.expectedOpening,
                      index: node.sourceIndex + 1 + indexBoost });

                  }

                  if (node.after === '') {
                    if (context.fix) node.after = ' ';

                    problems.push({
                      message: messages.expectedClosing,
                      index: node.sourceIndex - 2 + len + indexBoost });

                  }
                }
              }
            });

            if (problems.length) {
              if (context.fix) {
                atRule.params = parsedParams.toString();

                return;
              }

              for (const err of problems) {
                report({
                  message: err.message,
                  node: atRule,
                  index: err.index,
                  result,
                  ruleName });

              }
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 253: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after range operator',
        rejectedAfter: () => 'Unexpected whitespace after range operator' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            /** @type {number[]} */
            const fixOperatorIndices = [];
            /** @type {((index: number) => void) | null} */
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkAfterOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
                const beforeOperator = params.slice(0, index + 1);
                const afterOperator = params.slice(index + 1);

                if (primary === 'always') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, ' ');
                } else if (primary === 'never') {
                  params = beforeOperator + afterOperator.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          /**
           * @param {import('style-search').StyleSearchMatch} match
           * @param {string} params
           * @param {import('postcss').AtRule} node
           * @param {((index: number) => void) | null} fix
           */
          function checkAfterOperator(match, params, node, fix) {
            const endIndex = match.startIndex + match.target.length - 1;

            checker.after({
              source: params,
              index: endIndex,
              err: m => {
                if (fix) {
                  fix(endIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: endIndex + atRuleParamIndex(node) + 1,
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../findMediaOperator": 211 }], 254: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const findMediaOperator = require('../findMediaOperator');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-feature-range-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before range operator',
        rejectedBefore: () => 'Unexpected whitespace before range operator' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(/^media$/i, atRule => {
            /** @type {number[]} */
            const fixOperatorIndices = [];
            /** @type {((index: number) => void) | null} */
            const fix = context.fix ? index => fixOperatorIndices.push(index) : null;

            findMediaOperator(atRule, (match, params, node) => {
              checkBeforeOperator(match, params, node, fix);
            });

            if (fixOperatorIndices.length) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of fixOperatorIndices.sort((a, b) => b - a)) {
                const beforeOperator = params.slice(0, index);
                const afterOperator = params.slice(index);

                if (primary === 'always') {
                  params = beforeOperator.replace(/\s*$/, ' ') + afterOperator;
                } else if (primary === 'never') {
                  params = beforeOperator.replace(/\s*$/, '') + afterOperator;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          });

          /**
           * @param {import('style-search').StyleSearchMatch} match
           * @param {string} params
           * @param {import('postcss').AtRule} node
           * @param {((index: number) => void) | null} fix
           */
          function checkBeforeOperator(match, params, node, fix) {
            // The extra `+ 1` is because the match itself contains
            // the character before the operator
            checker.before({
              source: params,
              index: match.startIndex,
              err: m => {
                if (fix) {
                  fix(match.startIndex);

                  return;
                }

                report({
                  message: m,
                  node,
                  index: match.startIndex - 1 + atRuleParamIndex(node),
                  result,
                  ruleName });

              } });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../findMediaOperator": 211 }], 255: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          // Only check for the newline after the comma, while allowing
          // arbitrary indentation after the newline
          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            allowTrailingComments: primary.startsWith('always'),
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (primary.startsWith('always')) {
                  params = /^\s*\n/.test(afterComma) ?
                  beforeComma + afterComma.replace(/^[^\S\r\n]*/, '') :
                  beforeComma + context.newline + afterComma;
                } else if (primary.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaQueryListCommaWhitespaceChecker": 260 }], 256: [function (require, module, exports) {
      'use strict';

      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        const checker = whitespaceChecker('newline', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaQueryListCommaWhitespaceChecker": 260 }], 257: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index + 1);
                const afterComma = params.slice(index + 1);

                if (primary.startsWith('always')) {
                  params = beforeComma + afterComma.replace(/^\s*/, ' ');
                } else if (primary.startsWith('never')) {
                  params = beforeComma + afterComma.replace(/^\s*/, '');
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaQueryListCommaWhitespaceChecker": 260 }], 258: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const mediaQueryListCommaWhitespaceChecker = require('../mediaQueryListCommaWhitespaceChecker');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'media-query-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        const checker = whitespaceChecker('space', primary, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          /** @type {Map<import('postcss').AtRule, number[]> | undefined} */
          let fixData;

          mediaQueryListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (atRule, index) => {
              const paramCommaIndex = index - atRuleParamIndex(atRule);

              fixData = fixData || new Map();
              const commaIndices = fixData.get(atRule) || [];

              commaIndices.push(paramCommaIndex);
              fixData.set(atRule, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [atRule, commaIndices] of fixData.entries()) {
              let params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeComma = params.slice(0, index);
                const afterComma = params.slice(index);

                if (primary.startsWith('always')) {
                  params = beforeComma.replace(/\s*$/, ' ') + afterComma;
                } else if (primary.startsWith('never')) {
                  params = beforeComma.replace(/\s*$/, '') + afterComma;
                }
              }

              if (atRule.raws.params) {
                atRule.raws.params.raw = params;
              } else {
                atRule.params = params;
              }
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../mediaQueryListCommaWhitespaceChecker": 260 }], 259: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
       *   fix: ((node: import('postcss').AtRule, index: number) => boolean) | null,
       *   result: import('stylelint').PostcssResult,
       *   checkedRuleName: string,
       * }} opts
       */
      module.exports = function mediaFeatureColonSpaceChecker(opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ':' }, match => {
            checkColon(params, match.startIndex, atRule);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkColon(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              const colonIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, colonIndex)) {
                return;
              }

              report({
                message,
                node,
                index: colonIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 352, "../utils/report": 435, "style-search": 121 }], 260: [function (require, module, exports) {
      'use strict';

      const atRuleParamIndex = require('../utils/atRuleParamIndex');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      /**
       * @param {{
       *   root: import('postcss').Root,
       *   result: import('stylelint').PostcssResult,
       *   locationChecker: (args: { source: string, index: number, err: (message: string) => void }) => void,
       *   checkedRuleName: string,
       *   fix?: ((atRule: import('postcss').AtRule, index: number) => boolean) | null | undefined,
       *   allowTrailingComments?: boolean,
       * }} opts
       */
      module.exports = function mediaQueryListCommaWhitespaceChecker(opts) {
        opts.root.walkAtRules(/^media$/i, atRule => {
          const params = atRule.raws.params ? atRule.raws.params.raw : atRule.params;

          styleSearch({ source: params, target: ',' }, match => {
            let index = match.startIndex;

            if (opts.allowTrailingComments) {
              // if there is a comment on the same line at after the comma, check the space after the comment.
              let execResult;

              while (execResult = /^[^\S\r\n]*\/\*([\s\S]*?)\*\//.exec(params.slice(index + 1))) {
                index += execResult[0].length;
              }

              if (execResult = /^([^\S\r\n]*\/\/[\s\S]*?)\r?\n/.exec(params.slice(index + 1))) {
                index += execResult[1].length;
              }
            }

            checkComma(params, index, atRule);
          });
        });

        /**
         * @param {string} source
         * @param {number} index
         * @param {import('postcss').AtRule} node
         */
        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: message => {
              const commaIndex = index + atRuleParamIndex(node);

              if (opts.fix && opts.fix(node, commaIndex)) {
                return;
              }

              report({
                message,
                node,
                index: commaIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/atRuleParamIndex": 352, "../utils/report": 435, "style-search": 121 }], 261: [function (require, module, exports) {
      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findNotContiguousOrRectangular = require('./utils/findNotContiguousOrRectangular');
      const isRectangular = require('./utils/isRectangular');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'named-grid-areas-no-invalid';

      const messages = ruleMessages(ruleName, {
        expectedToken: () => 'Expected cell token within string',
        expectedSameNumber: () => 'Expected same number of cell tokens in each string',
        expectedRectangle: name => `Expected single filled-in rectangle for "${name}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          root.walkDecls(/^(?:grid|grid-template|grid-template-areas)$/i, decl => {
            const { value } = decl;

            if (value.toLowerCase().trim() === 'none') return;

            /** @type {string[][]} */
            const areas = [];
            let reportSent = false;

            valueParser(value).walk(({ sourceIndex, type, value: tokenValue }) => {
              if (type !== 'string') return;

              if (tokenValue === '') {
                complain(messages.expectedToken(), sourceIndex);
                reportSent = true;

                return;
              }

              areas.push(
              tokenValue.
              trim().
              split(' ').
              filter(s => s.length > 0));

            });

            if (reportSent) return;

            if (!isRectangular(areas)) {
              complain(messages.expectedSameNumber());

              return;
            }

            const notContiguousOrRectangular = findNotContiguousOrRectangular(areas);

            for (const name of notContiguousOrRectangular.sort()) {
              complain(messages.expectedRectangle(name));
            }

            /**
             * @param {string} message
             * @param {number} [sourceIndex=0]
             */
            function complain(message, sourceIndex = 0) {
              report({
                message,
                node: decl,
                index: declarationValueIndex(decl) + sourceIndex,
                result,
                ruleName });

            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "./utils/findNotContiguousOrRectangular": 262, "./utils/isRectangular": 263, "postcss-value-parser": 83 }], 262: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('../../../utils/arrayEqual');

      /**
       *
       * @param {string[][]} areas
       * @param {string} name
       * @returns {boolean}
       */
      function isContiguousAndRectangular(areas, name) {
        const indicesByRow = areas.map(row => {
          const indices = [];
          let idx = row.indexOf(name);

          while (idx !== -1) {
            indices.push(idx);
            idx = row.indexOf(name, idx + 1);
          }

          return indices;
        });

        for (let i = 0; i < indicesByRow.length; i++) {
          for (let j = i + 1; j < indicesByRow.length; j++) {
            if (indicesByRow[i].length === 0 || indicesByRow[j].length === 0) {
              continue;
            }

            if (!arrayEqual(indicesByRow[i], indicesByRow[j])) {
              return false;
            }
          }
        }

        return true;
      }

      /**
       *
       * @param {string[][]} areas
       * @returns {string[]}
       */
      function namedAreas(areas) {
        const names = new Set(areas.flat());

        names.delete('.');

        return [...names];
      }

      /**
       *
       * @param {string[][]} areas
       * @returns {string[]}
       */
      function findNotContiguousOrRectangular(areas) {
        return namedAreas(areas).filter(name => !isContiguousAndRectangular(areas, name));
      }

      module.exports = findNotContiguousOrRectangular;

    }, { "../../../utils/arrayEqual": 351 }], 263: [function (require, module, exports) {
      'use strict';

      /**
       *
       * @param {string[][]} areas
       * @returns {boolean}
       */
      function isRectangular(areas) {
        return areas.every((row, _i, arr) => row.length === arr[0].length);
      }

      module.exports = isRectangular;

    }, {}], 264: [function (require, module, exports) {
      'use strict';

      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const specificity = require('specificity');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-descending-specificity';

      const messages = ruleMessages(ruleName, {
        rejected: (b, a) => `Expected selector "${b}" to come before selector "${a}"` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['selectors-within-list'] } });




          if (!validOptions) {
            return;
          }

          const selectorContextLookup = nodeContextLookup();

          root.walkRules(ruleNode => {
            // Ignore nested property `foo: {};`
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Ignores selectors within list of selectors
            if (
            optionsMatches(secondaryOptions, 'ignore', 'selectors-within-list') &&
            ruleNode.selectors.length > 1)
            {
              return;
            }

            const comparisonContext = selectorContextLookup.getContext(
            ruleNode,
            findAtRuleContext(ruleNode));


            for (const selector of ruleNode.selectors) {
              const trimSelector = selector.trim();

              // Ignore `.selector, { }`
              if (trimSelector === '') {
                continue;
              }

              // The edge-case of duplicate selectors will act acceptably
              const index = ruleNode.selector.indexOf(trimSelector);

              // Resolve any nested selectors before checking
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, s => {
                  if (!isStandardSyntaxSelector(resolvedSelector)) {
                    return;
                  }

                  checkSelector(s, ruleNode, index, comparisonContext);
                });
              }
            }
          });

          /**
           * @param {import('postcss-selector-parser').Root} selectorNode
           * @param {import('postcss').Rule} ruleNode
           * @param {number} sourceIndex
           * @param {Map<any, any>} comparisonContext
           */
          function checkSelector(selectorNode, ruleNode, sourceIndex, comparisonContext) {
            const selector = selectorNode.toString();
            const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode);
            const selectorSpecificity = specificity.calculate(selector)[0].specificityArray;
            const entry = { selector, specificity: selectorSpecificity };

            if (!comparisonContext.has(referenceSelectorNode)) {
              comparisonContext.set(referenceSelectorNode, [entry]);

              return;
            }

            /** @type {Array<{ selector: string, specificity: import('specificity').SpecificityArray }>} */
            const priorComparableSelectors = comparisonContext.get(referenceSelectorNode);

            for (const priorEntry of priorComparableSelectors) {
              if (specificity.compare(selectorSpecificity, priorEntry.specificity) === -1) {
                report({
                  ruleName,
                  result,
                  node: ruleNode,
                  message: messages.rejected(selector, priorEntry.selector),
                  index: sourceIndex });

              }
            }

            priorComparableSelectors.push(entry);
          }
        };
      };

      /**
       * @param {import('postcss-selector-parser').Root} selectorNode
       */
      function lastCompoundSelectorWithoutPseudoClasses(selectorNode) {
        const nodesByCombinator = selectorNode.nodes[0].split(node => node.type === 'combinator');
        const nodesAfterLastCombinator = nodesByCombinator[nodesByCombinator.length - 1];

        const nodesWithoutPseudoClasses = nodesAfterLastCombinator.
        filter(node => {
          return node.type !== 'pseudo' || keywordSets.pseudoElements.has(node.value.replace(/:/g, ''));
        }).
        join('');

        return nodesWithoutPseudoClasses.toString();
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/findAtRuleContext": 362, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/nodeContextLookup": 428, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50, "specificity": 120 }], 265: [function (require, module, exports) {
      'use strict';

      const mediaParser = require('postcss-media-query-parser').default;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'no-duplicate-at-import-rules';

      const messages = ruleMessages(ruleName, {
        rejected: atImport => `Unexpected duplicate @import rule ${atImport}` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          /** @type {Record<string, string[]>} */
          const imports = {};

          root.walkAtRules(/^import$/i, atRule => {
            const [firstParam, ...restParams] = valueParser(atRule.params).nodes;

            if (!firstParam) {
              return;
            }

            // extract uri from url() if exists
            const uri =
            firstParam.type === 'function' && firstParam.value === 'url' ?
            firstParam.nodes[0].value :
            firstParam.value;

            // extract media queries if any
            const media = (mediaParser(valueParser.stringify(restParams)).nodes || []).
            map(n => n.value.replace(/\s/g, '')).
            filter(n => n.length);

            const isDuplicate = media.length ?
            imports[uri] && media.some(q => imports[uri].includes(q)) :
            imports[uri];

            if (isDuplicate) {
              report({
                message: messages.rejected(uri),
                node: atRule,
                result,
                ruleName });


              return;
            }

            if (!imports[uri]) imports[uri] = [];

            imports[uri] = imports[uri].concat(media);
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-media-query-parser": 46, "postcss-value-parser": 83 }], 266: [function (require, module, exports) {
      'use strict';

      const findAtRuleContext = require('../../utils/findAtRuleContext');
      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const nodeContextLookup = require('../../utils/nodeContextLookup');
      const normalizeSelector = require('normalize-selector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean } = require('../../utils/validateTypes');

      const ruleName = 'no-duplicate-selectors';

      const messages = ruleMessages(ruleName, {
        rejected: (selector, firstDuplicateLine) =>
        `Unexpected duplicate selector "${selector}", first used at line ${firstDuplicateLine}` });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual: primary },
          {
            actual: secondaryOptions,
            possible: {
              disallowInList: [isBoolean] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldDisallowDuplicateInList = secondaryOptions && secondaryOptions.disallowInList;

          // The top level of this map will be rule sources.
          // Each source maps to another map, which maps rule parents to a set of selectors.
          // This ensures that selectors are only checked against selectors
          // from other rules that share the same parent and the same source.
          const selectorContextLookup = nodeContextLookup();

          root.walkRules(ruleNode => {
            if (isKeyframeRule(ruleNode)) {
              return;
            }

            const contextSelectorSet = selectorContextLookup.getContext(
            ruleNode,
            findAtRuleContext(ruleNode));

            const resolvedSelectorList = [
            ...new Set(
            ruleNode.selectors.flatMap(selector => resolvedNestedSelector(selector, ruleNode)))];


            const normalizedSelectorList = resolvedSelectorList.map((selector) =>
            normalizeSelector(selector));


            // Sort the selectors list so that the order of the constituents
            // doesn't matter
            const sortedSelectorList = [...normalizedSelectorList].sort().join(',');

            if (!ruleNode.source) throw new Error('The rule node must have a source');

            if (!ruleNode.source.start) throw new Error('The rule source must have a start position');

            const selectorLine = ruleNode.source.start.line;

            // Complain if the same selector list occurs twice

            let previousDuplicatePosition;
            // When `disallowInList` is true, we must parse `sortedSelectorList` into
            // list items.
            /** @type {string[]} */
            const selectorListParsed = [];

            if (shouldDisallowDuplicateInList) {
              parseSelector(sortedSelectorList, result, ruleNode, selectors => {
                selectors.each(s => {
                  const selector = String(s);

                  selectorListParsed.push(selector);

                  if (contextSelectorSet.get(selector)) {
                    previousDuplicatePosition = contextSelectorSet.get(selector);
                  }
                });
              });
            } else {
              previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList);
            }

            if (previousDuplicatePosition) {
              // If the selector isn't nested we can use its raw value; otherwise,
              // we have to approximate something for the message -- which is close enough
              const isNestedSelector = resolvedSelectorList.join(',') !== ruleNode.selectors.join(',');
              const selectorForMessage = isNestedSelector ?
              resolvedSelectorList.join(', ') :
              ruleNode.selector;

              return report({
                result,
                ruleName,
                node: ruleNode,
                message: messages.rejected(selectorForMessage, previousDuplicatePosition) });

            }

            const presentedSelectors = new Set();
            const reportedSelectors = new Set();

            // Or complain if one selector list contains the same selector more than once
            for (const selector of ruleNode.selectors) {
              const normalized = normalizeSelector(selector);

              if (presentedSelectors.has(normalized)) {
                if (reportedSelectors.has(normalized)) {
                  continue;
                }

                report({
                  result,
                  ruleName,
                  node: ruleNode,
                  message: messages.rejected(selector, selectorLine) });

                reportedSelectors.add(normalized);
              } else {
                presentedSelectors.add(normalized);
              }
            }

            if (shouldDisallowDuplicateInList) {
              for (const selector of selectorListParsed) {
                // [selectorLine] will not really be accurate for multi-line
                // selectors, such as "bar" in "foo,\nbar {}".
                contextSelectorSet.set(selector, selectorLine);
              }
            } else {
              contextSelectorSet.set(sortedSelectorList, selectorLine);
            }
          });
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/findAtRuleContext": 362, "../../utils/isKeyframeRule": 397, "../../utils/nodeContextLookup": 428, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "normalize-selector": 42, "postcss-resolve-nested-selector": 50 }], 267: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-first-line';
      const noEmptyFirstLineTest = /^\s*[\r\n]/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty line' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          // @ts-expect-error -- TS2339: Property 'inline' does not exist on type 'Source'. Property 'lang' does not exist on type 'Source'.
          if (!validOptions || root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          if (!rootString.trim()) {
            return;
          }

          if (noEmptyFirstLineTest.test(rootString)) {
            if (context.fix) {
              if (root.first == null) {
                throw new Error('The root node must have the first node.');
              }

              if (root.first.raws.before == null) {
                throw new Error('The first node must have spaces before.');
              }

              root.first.raws.before = root.first.raws.before.trimStart();

              return;
            }

            report({
              message: messages.rejected,
              node: root,
              result,
              ruleName });

          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 268: [function (require, module, exports) {
      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-empty-source';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected empty source' });


      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          if (rootString.trim()) {
            return;
          }

          report({
            message: messages.rejected,
            node: root,
            result,
            ruleName });

        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 269: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const isStandardSyntaxComment = require('../../utils/isStandardSyntaxComment');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const { isAtRule, isComment, isDeclaration, isRule } = require('../../utils/typeGuards');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-eol-whitespace';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected whitespace at end of line' });


      const whitespacesToReject = new Set([' ', '\t']);

      /**
       * @param {string} str
       * @returns {string}
       */
      function fixString(str) {
        return str.replace(/[ \t]+$/, '');
      }

      /**
       * @param {number} lastEOLIndex
       * @param {string} string
       * @param {{ ignoreEmptyLines?: boolean, isRootFirst?: boolean }} [options]
       * @returns {number}
       */
      function findErrorStartIndex(
      lastEOLIndex,
      string,
      { ignoreEmptyLines, isRootFirst } = {
        ignoreEmptyLines: false,
        isRootFirst: false })

      {
        const eolWhitespaceIndex = lastEOLIndex - 1;

        // If the character before newline is not whitespace, ignore
        if (!whitespacesToReject.has(string[eolWhitespaceIndex])) {
          return -1;
        }

        if (ignoreEmptyLines) {
          // If there is only whitespace between the previous newline and
          // this newline, ignore
          const beforeNewlineIndex = string.lastIndexOf('\n', eolWhitespaceIndex);

          if (beforeNewlineIndex >= 0 || isRootFirst) {
            const line = string.substring(beforeNewlineIndex, eolWhitespaceIndex);

            if (isOnlyWhitespace(line)) {
              return -1;
            }
          }
        }

        return eolWhitespaceIndex;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: primary },

          {
            optional: true,
            actual: secondaryOptions,
            possible: {
              ignore: ['empty-lines'] } });




          if (!validOptions) {
            return;
          }

          const ignoreEmptyLines = optionsMatches(secondaryOptions, 'ignore', 'empty-lines');

          if (context.fix) {
            fix(root);
          }

          const rootString = context.fix ? root.toString() : root.source && root.source.input.css || '';

          /**
           * @param {number} index
           */
          const reportFromIndex = index => {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          };

          eachEolWhitespace(rootString, reportFromIndex, true);

          const errorIndex = findErrorStartIndex(rootString.length, rootString, {
            ignoreEmptyLines,
            isRootFirst: true });


          if (errorIndex > -1) {
            reportFromIndex(errorIndex);
          }

          /**
           * Iterate each whitespace at the end of each line of the given string.
           * @param {string} string - the source code string
           * @param {(index: number) => void} callback - callback the whitespace index at the end of each line.
           * @param {boolean} isRootFirst - set `true` if the given string is the first token of the root.
           * @returns {void}
           */
          function eachEolWhitespace(string, callback, isRootFirst) {
            styleSearch(
            {
              source: string,
              target: ['\n', '\r'],
              comments: 'check' },

            match => {
              const index = findErrorStartIndex(match.startIndex, string, {
                ignoreEmptyLines,
                isRootFirst });


              if (index > -1) {
                callback(index);
              }
            });

          }

          /**
           * @param {import('postcss').Root} rootNode
           */
          function fix(rootNode) {
            let isRootFirst = true;

            rootNode.walk(node => {
              fixText(
              node.raws.before,
              fixed => {
                node.raws.before = fixed;
              },
              isRootFirst);

              isRootFirst = false;

              if (isAtRule(node)) {
                fixText(node.raws.afterName, fixed => {
                  node.raws.afterName = fixed;
                });

                const rawsParams = node.raws.params;

                if (rawsParams) {
                  fixText(rawsParams.raw, fixed => {
                    rawsParams.raw = fixed;
                  });
                } else {
                  fixText(node.params, fixed => {
                    node.params = fixed;
                  });
                }
              }

              if (isRule(node)) {
                const rawsSelector = node.raws.selector;

                if (rawsSelector) {
                  fixText(rawsSelector.raw, fixed => {
                    rawsSelector.raw = fixed;
                  });
                } else {
                  fixText(node.selector, fixed => {
                    node.selector = fixed;
                  });
                }
              }

              if (isAtRule(node) || isRule(node) || isDeclaration(node)) {
                fixText(node.raws.between, fixed => {
                  node.raws.between = fixed;
                });
              }

              if (isDeclaration(node)) {
                if (node.raws.value) {
                  fixText(node.raws.value.raw, fixed => {
                    node.raws.value.raw = fixed;
                  });
                } else {
                  fixText(node.value, fixed => {
                    node.value = fixed;
                  });
                }
              }

              if (isComment(node)) {
                fixText(node.raws.left, fixed => {
                  node.raws.left = fixed;
                });

                if (!isStandardSyntaxComment(node)) {
                  node.raws.right = node.raws.right && fixString(node.raws.right);
                } else {
                  fixText(node.raws.right, fixed => {
                    node.raws.right = fixed;
                  });
                }

                fixText(node.text, fixed => {
                  node.text = fixed;
                });
              }

              if (isAtRule(node) || isRule(node)) {
                fixText(node.raws.after, fixed => {
                  node.raws.after = fixed;
                });
              }
            });

            fixText(
            rootNode.raws.after,
            fixed => {
              rootNode.raws.after = fixed;
            },
            isRootFirst);


            if (typeof rootNode.raws.after === 'string') {
              const lastEOL = Math.max(
              rootNode.raws.after.lastIndexOf('\n'),
              rootNode.raws.after.lastIndexOf('\r'));


              if (lastEOL !== rootNode.raws.after.length - 1) {
                rootNode.raws.after =
                rootNode.raws.after.slice(0, lastEOL + 1) +
                fixString(rootNode.raws.after.slice(lastEOL + 1));
              }
            }
          }

          /**
           * @param {string | undefined} value
           * @param {(text: string) => void} fixFn
           * @param {boolean} isRootFirst
           */
          function fixText(value, fixFn, isRootFirst = false) {
            if (!value) {
              return;
            }

            let fixed = '';
            let lastIndex = 0;

            eachEolWhitespace(
            value,
            index => {
              const newlineIndex = index + 1;

              fixed += fixString(value.slice(lastIndex, newlineIndex));
              lastIndex = newlineIndex;
            },
            isRootFirst);


            if (lastIndex) {
              fixed += value.slice(lastIndex);
              fixFn(fixed);
            }
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isOnlyWhitespace": 402, "../../utils/isStandardSyntaxComment": 411, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/typeGuards": 440, "../../utils/validateOptions": 442, "style-search": 121 }], 270: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-extra-semicolons';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected extra semicolon' });


      /**
       * @param {import('postcss').Node} node
       * @returns {number}
       */
      function getOffsetByNode(node) {
        // @ts-expect-error -- TS2339: Property 'document' does not exist on type 'Document | Container<ChildNode>'
        if (node.parent && node.parent.document) {
          return 0;
        }

        const root = node.root();

        if (!root.source) throw new Error('The root node must have a source');

        if (!node.source) throw new Error('The node must have a source');

        if (!node.source.start) throw new Error('The source must have a start position');

        const string = root.source.input.css;
        const nodeColumn = node.source.start.column;
        const nodeLine = node.source.start.line;
        let line = 1;
        let column = 1;
        let index = 0;

        for (let i = 0; i < string.length; i++) {
          if (column === nodeColumn && nodeLine === line) {
            index = i;
            break;
          }

          if (string[i] === '\n') {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }

        return index;
      }

      /** @type {import('stylelint').Rule} */
      const rule = (primary, _secondaryOptions, context) => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: primary });

          if (!validOptions) {
            return;
          }

          if (root.raws.after && root.raws.after.trim().length !== 0) {
            const rawAfterRoot = root.raws.after;

            /** @type {number[]} */
            const fixSemiIndices = [];

            styleSearch({ source: rawAfterRoot, target: ';' }, match => {
              if (context.fix) {
                fixSemiIndices.push(match.startIndex);

                return;
              }

              if (!root.source) throw new Error('The root node must have a source');

              complain(root.source.input.css.length - rawAfterRoot.length + match.startIndex);
            });

            // fix
            if (fixSemiIndices.length) {
              root.raws.after = removeIndices(rawAfterRoot, fixSemiIndices);
            }
          }

          root.walk(node => {
            if (node.type === 'atrule' && !isStandardSyntaxAtRule(node)) {
              return;
            }

            if (node.type === 'rule' && !isStandardSyntaxRule(node)) {
              return;
            }

            if (node.raws.before && node.raws.before.trim().length !== 0) {
              const rawBeforeNode = node.raws.before;
              const allowedSemi = 0;

              const rawBeforeIndexStart = 0;

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawBeforeNode, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex - rawBeforeIndexStart);

                  return;
                }

                complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.before = removeIndices(rawBeforeNode, fixSemiIndices);
              }
            }

            if ('after' in node.raws && node.raws.after && node.raws.after.trim().length !== 0) {
              const rawAfterNode = node.raws.after;

              /**
               * If the last child is a Less mixin followed by more than one semicolon,
               * node.raws.after will be populated with that semicolon.
               * Since we ignore Less mixins, exit here
               */
              if (
              'last' in node &&
              node.last &&
              node.last.type === 'atrule' &&
              !isStandardSyntaxAtRule(node.last))
              {
                return;
              }

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawAfterNode, target: ';' }, match => {
                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                1 -
                rawAfterNode.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.after = removeIndices(rawAfterNode, fixSemiIndices);
              }
            }

            if ('ownSemicolon' in node.raws && node.raws.ownSemicolon) {
              const rawOwnSemicolon = node.raws.ownSemicolon;
              const allowedSemi = 0;

              /** @type {number[]} */
              const fixSemiIndices = [];

              styleSearch({ source: rawOwnSemicolon, target: ';' }, (match, count) => {
                if (count === allowedSemi) {
                  return;
                }

                if (context.fix) {
                  fixSemiIndices.push(match.startIndex);

                  return;
                }

                const index =
                getOffsetByNode(node) +
                node.toString().length -
                rawOwnSemicolon.length +
                match.startIndex;

                complain(index);
              });

              // fix
              if (fixSemiIndices.length) {
                node.raws.ownSemicolon = removeIndices(rawOwnSemicolon, fixSemiIndices);
              }
            }
          });

          /**
           * @param {number} index
           */
          function complain(index) {
            report({
              message: messages.rejected,
              node: root,
              index,
              result,
              ruleName });

          }

          /**
           * @param {string} str
           * @param {number[]} indices
           * @returns {string}
           */
          function removeIndices(str, indices) {
            for (const index of indices.reverse()) {
              str = str.slice(0, index) + str.slice(index + 1);
            }

            return str;
          }
        };
      };

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/isStandardSyntaxRule": 417, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "style-search": 121 }], 271: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-invalid-double-slash-comments';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected double-slash CSS comment' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (decl.prop.startsWith('//')) {
              report({
                message: messages.rejected,
                node: decl,
                result,
                ruleName });

            }
          });

          root.walkRules(ruleNode => {
            for (const selector of ruleNode.selectors) {
              if (selector.startsWith('//')) {
                report({
                  message: messages.rejected,
                  node: ruleNode,
                  result,
                  ruleName });

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 272: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'no-invalid-position-at-import-rule';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected invalid position @import rule' });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          let invalidPosition = false;

          root.walk(node => {
            const nodeName = node.name && node.name.toLowerCase();

            if (
            node.type === 'atrule' &&
            nodeName !== 'charset' &&
            nodeName !== 'import' &&
            !optionsMatches(options, 'ignoreAtRules', node.name) &&
            isStandardSyntaxAtRule(node) ||
            node.type === 'rule' && isStandardSyntaxRule(node))
            {
              invalidPosition = true;

              return;
            }

            if (node.type === 'atrule' && nodeName === 'import' && invalidPosition) {
              report({
                message: messages.rejected,
                node,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxAtRule": 408, "../../utils/isStandardSyntaxRule": 417, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 273: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-irregular-whitespace';
      const messages = ruleMessages(ruleName, {
        unexpected: 'Unexpected irregular whitespace' });


      const IRREGULAR_WHITESPACES = [
      '\u000B', // Line Tabulation (\v) - <VT>
      '\u000C', // Form Feed (\f) - <FF>
      '\u00A0', // No-Break Space - <NBSP>
      '\u0085', // Next Line
      '\u1680', // Ogham Space Mark
      '\u180E', // Mongolian Vowel Separator - <MVS>
      '\uFEFF', // Zero Width No-Break Space - <BOM>
      '\u2000', // En Quad
      '\u2001', // Em Quad
      '\u2002', // En Space - <ENSP>
      '\u2003', // Em Space - <EMSP>
      '\u2004', // Tree-Per-Em
      '\u2005', // Four-Per-Em
      '\u2006', // Six-Per-Em
      '\u2007', // Figure Space
      '\u2008', // Punctuation Space - <PUNCSP>
      '\u2009', // Thin Space
      '\u200A', // Hair Space
      '\u200B', // Zero Width Space - <ZWSP>
      '\u2028', // Line Separator
      '\u2029', // Paragraph Separator
      '\u202F', // Narrow No-Break Space
      '\u205F', // Medium Mathematical Space
      '\u3000' // Ideographic Space
      ];

      const IRREGULAR_WHITESPACES_PATTERN = new RegExp(`([${IRREGULAR_WHITESPACES.join('')}])`);

      const generateInvalidWhitespaceValidator = () => {
        return str => typeof str === 'string' && IRREGULAR_WHITESPACES_PATTERN.exec(str);
      };

      const declarationSchema = {
        prop: 'string',
        value: 'string',
        raws: {
          before: 'string',
          between: 'string' } };



      const atRuleSchema = {
        name: 'string',
        params: 'string',
        raws: {
          before: 'string',
          between: 'string',
          afterName: 'string',
          after: 'string' } };



      const ruleSchema = {
        selector: 'string',
        raws: {
          before: 'string',
          between: 'string',
          after: 'string' } };



      const generateNodeValidator = (nodeSchema, validator) => {
        const allKeys = Object.keys(nodeSchema);
        const validatorForKey = {};

        for (const key of allKeys) {
          if (typeof nodeSchema[key] === 'string') validatorForKey[key] = validator;

          if (typeof nodeSchema[key] === 'object')
          validatorForKey[key] = generateNodeValidator(nodeSchema[key], validator);
        }

        // This will be called many times, so it's optimized for performance and not readibility.
        // Surprisingly, this seem to be slightly faster then concatenating the params and running the validator once.
        return node => {
          for (const currentKey of allKeys) {
            if (validatorForKey[currentKey](node[currentKey])) {
              return validatorForKey[currentKey](node[currentKey]);
            }
          }
        };
      };

      function rule(on) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual: on });

          if (!validOptions) {
            return;
          }

          const genericValidator = generateInvalidWhitespaceValidator();

          const validate = (node, validator) => {
            const issue = validator(node);

            if (issue) {
              report({
                ruleName,
                result,
                message: messages.unexpected,
                node,
                word: issue[1] });

            }
          };

          const atRuleValidator = generateNodeValidator(atRuleSchema, genericValidator);
          const ruleValidator = generateNodeValidator(ruleSchema, genericValidator);
          const declValidator = generateNodeValidator(declarationSchema, genericValidator);

          root.walkAtRules(atRule => validate(atRule, atRuleValidator));
          root.walkRules(selector => validate(selector, ruleValidator));
          root.walkDecls(declaration => validate(declaration, declValidator));
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 274: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-missing-end-of-source-newline';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected missing end-of-source newline' });


      function rule(primary, _, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { primary });

          if (!validOptions) {
            return;
          }

          if (root.source.inline || root.source.lang === 'object-literal') {
            return;
          }

          const rootString = context.fix ? root.toString() : root.source.input.css;

          if (!rootString.trim() || rootString.endsWith('\n')) {
            return;
          }

          // Fix
          if (context.fix) {
            root.raws.after = context.newline;

            return;
          }

          report({
            message: messages.rejected,
            node: root,
            index: rootString.length - 1,
            result,
            ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 275: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const findAnimationName = require('../../utils/findAnimationName');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'no-unknown-animations';

      const messages = ruleMessages(ruleName, {
        rejected: animationName => `Unexpected unknown animation name "${animationName}"` });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          const declaredAnimations = new Set();

          root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule => {
            declaredAnimations.add(atRule.params);
          });

          root.walkDecls(decl => {
            if (decl.prop.toLowerCase() === 'animation' || decl.prop.toLowerCase() === 'animation-name') {
              const animationNames = findAnimationName(decl.value);

              if (animationNames.length === 0) {
                return;
              }

              for (const animationNameNode of animationNames) {
                if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {
                  continue;
                }

                if (declaredAnimations.has(animationNameNode.value)) {
                  continue;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(animationNameNode.value),
                  node: decl,
                  index: declarationValueIndex(decl) + animationNameNode.sourceIndex });

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/findAnimationName": 361, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 276: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-leading-zero';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected a leading zero',
        rejected: 'Unexpected leading zero' });


      function rule(expectation, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            const neverFixPositions = [];
            const alwaysFixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              // Check leading zero
              if (expectation === 'always') {
                const match = /(?:\D|^)(\.\d+)/.exec(valueNode.value);

                if (match === null) {
                  return;
                }

                // The regexp above consists of 2 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-.5" as an input
                // for regex. And we need the index of ".5".
                const capturingGroupIndex = match[0].length - match[1].length;

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  alwaysFixPositions.unshift({
                    index });


                  return;
                }

                complain(messages.expected, node, getIndex(node) + index);
              }

              if (expectation === 'never') {
                const match = /(?:\D|^)(0+)(\.\d+)/.exec(valueNode.value);

                if (match === null) {
                  return;
                }

                // The regexp above consists of 3 capturing groups (or capturing parentheses).
                // We need the index of the second group. This makes sanse when we have "-00.5"
                // as an input for regex. And we need the index of "00".
                const capturingGroupIndex = match[0].length - (match[1].length + match[2].length);

                const index = valueNode.sourceIndex + match.index + capturingGroupIndex;

                if (context.fix) {
                  neverFixPositions.unshift({
                    startIndex: index,
                    // match[1].length is the length of our matched zero(s)
                    endIndex: index + match[1].length });


                  return;
                }

                complain(messages.rejected, node, getIndex(node) + index);
              }
            });

            if (alwaysFixPositions.length) {
              for (const fixPosition of alwaysFixPositions) {
                const index = fixPosition.index;

                if (node.type === 'atrule') {
                  node.params = addLeadingZero(node.params, index);
                } else {
                  node.value = addLeadingZero(node.value, index);
                }
              }
            }

            if (neverFixPositions.length) {
              for (const fixPosition of neverFixPositions) {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeLeadingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeLeadingZeros(node.value, startIndex, endIndex);
                }
              }
            }
          }

          function complain(message, node, index) {
            report({
              result,
              ruleName,
              message,
              node,
              index });

          }
        };
      }

      function addLeadingZero(input, index) {
        // eslint-disable-next-line prefer-template
        return input.slice(0, index) + '0' + input.slice(index);
      }

      function removeLeadingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 277: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber, isRegExp, isString } = require('../../utils/validateTypes');

      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-max-precision';

      const messages = ruleMessages(ruleName, {
        expected: (number, precision) => `Expected "${number}" to be "${number.toFixed(precision)}"` });


      function rule(precision, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: precision,
            possible: [isNumber] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignoreUnits: [isString, isRegExp] } });




          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            const prop = node.prop;

            if (optionsMatches(options, 'ignoreProperties', prop)) {
              return;
            }

            valueParser(value).walk(valueNode => {
              const unit = getUnitFromValueNode(valueNode);

              if (optionsMatches(options, 'ignoreUnits', unit)) {
                return;
              }

              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\d*\.(\d+)/.exec(valueNode.value);

              if (match === null) {
                return;
              }

              if (match[1].length <= precision) {
                return;
              }

              report({
                result,
                ruleName,
                node,
                index: getIndex(node) + valueNode.sourceIndex + match.index,
                message: messages.expected(Number.parseFloat(match[0]), precision) });

            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 278: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'number-no-trailing-zeros';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected trailing zero(s)' });


      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkAtRules(atRule => {
            if (atRule.name.toLowerCase() === 'import') {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });

          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));

          function check(node, value, getIndex) {
            const fixPositions = [];

            // Get out quickly if there are no periods
            if (!value.includes('.')) {
              return;
            }

            valueParser(value).walk(valueNode => {
              // Ignore `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              // Ignore strings, comments, etc
              if (valueNode.type !== 'word') {
                return;
              }

              const match = /\.(\d{0,100}?)(0+)(?:\D|$)/.exec(valueNode.value);

              // match[1] is any numbers between the decimal and our trailing zero, could be empty
              // match[2] is our trailing zero(s)
              if (match === null) {
                return;
              }

              // our index is:
              //  the index of our valueNode +
              //  the index of our match +
              //  1 for our decimal +
              //  the length of our potential non-zero number match (match[1])
              const index = valueNode.sourceIndex + match.index + 1 + match[1].length;

              // our startIndex is identical to our index except when we have only
              // trailing zeros after our decimal. in that case we don't need the decimal
              // either so we move our index back by 1.
              const startIndex = match[1].length > 0 ? index : index - 1;

              // our end index is our original index + the length of our trailing zeros
              const endIndex = index + match[2].length;

              if (context.fix) {
                fixPositions.unshift({
                  startIndex,
                  endIndex });


                return;
              }

              report({
                message: messages.rejected,
                node,
                // this is the index of the _first_ trailing zero
                index: getIndex(node) + index,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              for (const fixPosition of fixPositions) {
                const startIndex = fixPosition.startIndex;
                const endIndex = fixPosition.endIndex;

                if (node.type === 'atrule') {
                  node.params = removeTrailingZeros(node.params, startIndex, endIndex);
                } else {
                  node.value = removeTrailingZeros(node.value, startIndex, endIndex);
                }
              }
            }
          }
        };
      }

      function removeTrailingZeros(input, startIndex, endIndex) {
        return input.slice(0, startIndex) + input.slice(endIndex);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 279: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxProperty": 416, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 280: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'property-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            const expectedProp = expectation === 'lower' ? prop.toLowerCase() : prop.toUpperCase();

            if (prop === expectedProp) {
              return;
            }

            if (context.fix) {
              decl.prop = expectedProp;

              return;
            }

            report({
              message: messages.expected(prop, expectedProp),
              node: decl,
              ruleName,
              result });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxProperty": 416, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 281: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected property "${property}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!matchesStringOrRegExp(vendor.unprefixed(prop), list)) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxProperty": 416, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 282: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isCustomProperty = require('../../utils/isCustomProperty');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const optionsMatches = require('../../utils/optionsMatches');
      const properties = require('known-css-properties').all;
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isBoolean, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'property-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: property => `Unexpected unknown property "${property}"` });


      function rule(actual, options) {
        const allValidProperties = new Set(properties);

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreProperties: [isString, isRegExp],
              checkPrefixed: isBoolean,
              ignoreSelectors: [isString, isRegExp],
              ignoreAtRules: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldCheckPrefixed = options && options.checkPrefixed;

          root.walkDecls(checkStatement);

          function checkStatement(decl) {
            const prop = decl.prop;

            if (!isStandardSyntaxProperty(prop)) {
              return;
            }

            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            if (isCustomProperty(prop)) {
              return;
            }

            if (!shouldCheckPrefixed && vendor.prefix(prop)) {
              return;
            }

            if (optionsMatches(options, 'ignoreProperties', prop)) {
              return;
            }

            const { selector } = decl.parent;

            if (selector && optionsMatches(options, 'ignoreSelectors', selector)) {
              return;
            }

            let node = decl.parent;

            while (node && node.type !== 'root') {
              const { type, name } = node;

              if (type === 'atrule' && optionsMatches(options, 'ignoreAtRules', name)) {
                return;
              }

              node = node.parent;
            }

            if (allValidProperties.has(prop.toLowerCase())) {
              return;
            }

            report({
              message: messages.rejected(prop),
              node: decl,
              result,
              ruleName });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isCustomProperty": 393, "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/isStandardSyntaxProperty": 416, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "known-css-properties": 39 }], 283: [function (require, module, exports) {
      'use strict';

      const styleSearch = require('style-search');

      const rangeOperators = ['>=', '<=', '>', '<', '='];

      /**
       * @param {import('postcss-media-query-parser').Node} node
       */
      function getRangeContextOperators(node) {
        /** @type {string[]} */
        const operators = [];

        const source = node.value;

        styleSearch({ source, target: rangeOperators }, match => {
          const before = source[match.startIndex - 1];

          if (before === '>' || before === '<') {
            return;
          }

          operators.push(match.target);
        });

        // Sorting helps when using the operators to split
        // E.g. for "(10em < width <= 50em)" this returns ["<=", "<"]
        return operators.sort((a, b) => b.length - a.length);
      }

      /**
       * @param {string[]} parsedNode
       */
      function getRangeContextName(parsedNode) {
        // When the node is like "(10em < width < 50em)"
        // The parsedNode is ["10em", "width", "50em"] - the name is always in the second position
        if (parsedNode.length === 3) {
          return parsedNode[1];
        }

        // When the node is like "(width > 10em)" or "(10em < width)"
        // Regex is needed because the name can either be in the first or second position
        return parsedNode.find(value => value.match(/^(?!--)\D+/) || value.match(/^(--).+/));
      }

      /**
       * @param {import('postcss-media-query-parser').Node} node
       * @returns {{ name: { value: string, sourceIndex: number }, values: Array<{ value: string, sourceIndex: number }> }}
       */
      module.exports = function rangeContextNodeParser(node) {
        const nodeValue = node.value;

        const operators = getRangeContextOperators(node);

        // Remove spaces and parentheses and split by the operators
        const parsedMedia = nodeValue.replace(/[()\s]/g, '').split(new RegExp(operators.join('|')));

        const name = getRangeContextName(parsedMedia);

        if (name == null) throw new Error('The context name must be present');

        const nameObj = {
          value: name,
          sourceIndex: node.sourceIndex + nodeValue.indexOf(name) };


        const values = parsedMedia.
        filter(parsedValue => parsedValue !== name).
        map(value => {
          return {
            value,
            sourceIndex: node.sourceIndex + nodeValue.indexOf(value) };

        });

        return {
          name: nameObj,
          values };

      };

    }, { "style-search": 121 }], 284: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const addEmptyLineBefore = require('../../utils/addEmptyLineBefore');
      const getPreviousNonSharedLineCommentNode = require('../../utils/getPreviousNonSharedLineCommentNode');
      const hasEmptyLine = require('../../utils/hasEmptyLine');
      const isAfterSingleLineComment = require('../../utils/isAfterSingleLineComment');
      const isFirstNested = require('../../utils/isFirstNested');
      const isFirstNodeOfRoot = require('../../utils/isFirstNodeOfRoot');
      const isSingleLineString = require('../../utils/isSingleLineString');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const removeEmptyLinesBefore = require('../../utils/removeEmptyLinesBefore');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'rule-empty-line-before';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected empty line before rule',
        rejected: 'Unexpected empty line before rule' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['always', 'never', 'always-multi-line', 'never-multi-line'] },

          {
            actual: options,
            possible: {
              ignore: ['after-comment', 'first-nested', 'inside-block'],
              except: [
              'after-rule',
              'after-single-line-comment',
              'first-nested',
              'inside-block-and-after-rule',
              'inside-block'] },


            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Ignore the first node
            if (isFirstNodeOfRoot(ruleNode)) {
              return;
            }

            // Optionally ignore the expectation if a comment precedes this node
            if (
            optionsMatches(options, 'ignore', 'after-comment') &&
            ruleNode.prev() &&
            ruleNode.prev().type === 'comment')
            {
              return;
            }

            // Optionally ignore the node if it is the first nested
            if (optionsMatches(options, 'ignore', 'first-nested') && isFirstNested(ruleNode)) {
              return;
            }

            const isNested = ruleNode.parent.type !== 'root';

            // Optionally ignore the expectation if inside a block
            if (optionsMatches(options, 'ignore', 'inside-block') && isNested) {
              return;
            }

            // Ignore if the expectation is for multiple and the rule is single-line
            if (expectation.includes('multi-line') && isSingleLineString(ruleNode.toString())) {
              return;
            }

            let expectEmptyLineBefore = Boolean(expectation.includes('always'));

            // Optionally reverse the expectation if any exceptions apply
            if (
            optionsMatches(options, 'except', 'first-nested') && isFirstNested(ruleNode) ||
            optionsMatches(options, 'except', 'after-rule') && isAfterRule(ruleNode) ||
            optionsMatches(options, 'except', 'inside-block-and-after-rule') &&
            isNested &&
            isAfterRule(ruleNode) ||
            optionsMatches(options, 'except', 'after-single-line-comment') &&
            isAfterSingleLineComment(ruleNode) ||
            optionsMatches(options, 'except', 'inside-block') && isNested)
            {
              expectEmptyLineBefore = !expectEmptyLineBefore;
            }

            const hasEmptyLineBefore = hasEmptyLine(ruleNode.raws.before);

            // Return if the expectation is met
            if (expectEmptyLineBefore === hasEmptyLineBefore) {
              return;
            }

            // Fix
            if (context.fix) {
              if (expectEmptyLineBefore) {
                addEmptyLineBefore(ruleNode, context.newline);
              } else {
                removeEmptyLinesBefore(ruleNode, context.newline);
              }

              return;
            }

            const message = expectEmptyLineBefore ? messages.expected : messages.rejected;

            report({
              message,
              node: ruleNode,
              result,
              ruleName });

          });
        };
      }

      function isAfterRule(ruleNode) {
        const prevNode = getPreviousNonSharedLineCommentNode(ruleNode);

        return prevNode && prevNode.type === 'rule';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/addEmptyLineBefore": 350, "../../utils/getPreviousNonSharedLineCommentNode": 371, "../../utils/hasEmptyLine": 377, "../../utils/isAfterSingleLineComment": 384, "../../utils/isFirstNested": 395, "../../utils/isFirstNodeOfRoot": 396, "../../utils/isSingleLineString": 407, "../../utils/isStandardSyntaxRule": 417, "../../utils/optionsMatches": 429, "../../utils/removeEmptyLinesBefore": 434, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 285: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isPlainObject } = require('is-plain-object');

      const ruleName = 'rule-selector-property-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: (property, selector) => `Unexpected property "${property}" for selector "${selector}"` });


      /** @type {import('stylelint').Rule} */
      const rule = primary => {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: primary,
            possible: [isPlainObject] });


          if (!validOptions) {
            return;
          }

          const selectors = Object.keys(primary);

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selectorKey = selectors.find((selector) =>
            matchesStringOrRegExp(ruleNode.selector, selector));


            if (!selectorKey) {
              return;
            }

            const disallowedProperties = primary[selectorKey];

            for (const node of ruleNode.nodes) {
              const isDisallowedProperty =
              node.type === 'decl' && matchesStringOrRegExp(node.prop, disallowedProperties);

              if (isDisallowedProperty) {
                report({
                  message: messages.rejected(node.prop, ruleNode.selector),
                  node,
                  result,
                  ruleName });

              }
            }
          });
        };
      };

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "is-plain-object": 35 }], 286: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-brackets-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "["',
        rejectedOpening: 'Unexpected whitespace after "["',
        expectedClosing: 'Expected single space before "]"',
        rejectedClosing: 'Unexpected whitespace before "]"' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[')) {
              return;
            }

            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            let hasFixed;
            const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeSelectorString = attributeNode.toString();

                styleSearch({ source: attributeSelectorString, target: '[' }, match => {
                  const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex + 1;

                  if (nextCharIsSpace && expectation === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.rejectedOpening, index);
                  }

                  if (!nextCharIsSpace && expectation === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixBefore(attributeNode);

                      return;
                    }

                    complain(messages.expectedOpening, index);
                  }
                });

                styleSearch({ source: attributeSelectorString, target: ']' }, match => {
                  const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === ' ';
                  const index = attributeNode.sourceIndex + match.startIndex - 1;

                  if (prevCharIsSpace && expectation === 'never') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.rejectedClosing, index);
                  }

                  if (!prevCharIsSpace && expectation === 'always') {
                    if (context.fix) {
                      hasFixed = true;
                      fixAfter(attributeNode);

                      return;
                    }

                    complain(messages.expectedClosing, index);
                  }
                });
              });
            });

            if (hasFixed) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };

        function fixBefore(attributeNode) {
          const rawAttrBefore =
          attributeNode.raws.spaces &&
          attributeNode.raws.spaces.attribute &&
          attributeNode.raws.spaces.attribute.before;
          const { attrBefore, setAttrBefore } = rawAttrBefore ?
          {
            attrBefore: rawAttrBefore,
            setAttrBefore(fixed) {
              attributeNode.raws.spaces.attribute.before = fixed;
            } } :

          {
            attrBefore:
            attributeNode.spaces.attribute && attributeNode.spaces.attribute.before || '',
            setAttrBefore(fixed) {
              if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};

              attributeNode.spaces.attribute.before = fixed;
            } };


          if (expectation === 'always') {
            setAttrBefore(attrBefore.replace(/^\s*/, ' '));
          } else if (expectation === 'never') {
            setAttrBefore(attrBefore.replace(/^\s*/, ''));
          }
        }

        function fixAfter(attributeNode) {
          let key;

          if (attributeNode.operator) {
            key = attributeNode.insensitive ? 'insensitive' : 'value';
          } else {
            key = 'attribute';
          }

          const rawAfter =
          attributeNode.raws.spaces &&
          attributeNode.raws.spaces[key] &&
          attributeNode.raws.spaces[key].after;
          const { after, setAfter } = rawAfter ?
          {
            after: rawAfter,
            setAfter(fixed) {
              attributeNode.raws.spaces[key].after = fixed;
            } } :

          {
            after: attributeNode.spaces[key] && attributeNode.spaces[key].after || '',
            setAfter(fixed) {
              if (!attributeNode.spaces[key]) attributeNode.spaces[key] = {};

              attributeNode.spaces[key].after = fixed;
            } };


          if (expectation === 'always') {
            setAfter(after.replace(/\s*$/, ' '));
          } else if (expectation === 'never') {
            setAfter(after.replace(/\s*$/, ''));
          }
        }
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "style-search": 121 }], 287: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-name-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: name => `Unexpected name "${name}"` });


      function rule(listInput) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const attributeName = attributeNode.qualifiedAttribute;

                if (!matchesStringOrRegExp(attributeName, list)) {
                  return;
                }

                report({
                  message: messages.rejected(attributeName),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('attribute'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 288: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-operator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 289: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-attribute-operator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: operator => `Unexpected operator "${operator}"` });


      function rule(listInput) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const operator = attributeNode.operator;

                if (!operator || operator && !list.includes(operator)) {
                  return;
                }

                report({
                  message: messages.rejected(operator),
                  node: ruleNode,
                  index: attributeNode.sourceIndex + attributeNode.offsetOf('operator'),
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 290: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: operator => `Expected single space after "${operator}"`,
        rejectedAfter: operator => `Unexpected whitespace after "${operator}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const checker = whitespaceChecker('space', expectation, messages);
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            checkBeforeOperator: false,
            fix: context.fix ?
            attributeNode => {
              const { operatorAfter, setOperatorAfter } = (() => {
                const rawOperator = attributeNode.raws.operator;

                if (rawOperator) {
                  return {
                    operatorAfter: rawOperator.slice(attributeNode.operator.length),
                    setOperatorAfter(fixed) {
                      delete attributeNode.raws.operator;

                      if (!attributeNode.raws.spaces) attributeNode.raws.spaces = {};

                      if (!attributeNode.raws.spaces.operator)
                      attributeNode.raws.spaces.operator = {};

                      attributeNode.raws.spaces.operator.after = fixed;
                    } };

                }

                const rawOperatorAfter =
                attributeNode.raws.spaces &&
                attributeNode.raws.spaces.operator &&
                attributeNode.raws.spaces.operator.after;

                if (rawOperatorAfter) {
                  return {
                    operatorAfter: rawOperatorAfter,
                    setOperatorAfter(fixed) {
                      attributeNode.raws.spaces.operator.after = fixed;
                    } };

                }

                return {
                  operatorAfter:
                  attributeNode.spaces.operator && attributeNode.spaces.operator.after || '',
                  setOperatorAfter(fixed) {
                    if (!attributeNode.spaces.operator) attributeNode.spaces.operator = {};

                    attributeNode.spaces.operator.after = fixed;
                  } };

              })();

              if (expectation === 'always') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ' '));

                return true;
              }

              if (expectation === 'never') {
                setOperatorAfter(operatorAfter.replace(/^\s*/, ''));

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorAttributeOperatorSpaceChecker": 329 }], 291: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorAttributeOperatorSpaceChecker = require('../selectorAttributeOperatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-attribute-operator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: operator => `Expected single space before "${operator}"`,
        rejectedBefore: operator => `Unexpected whitespace before "${operator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorAttributeOperatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            checkBeforeOperator: true,
            fix: context.fix ?
            attributeNode => {
              const rawAttrAfter =
              attributeNode.raws.spaces &&
              attributeNode.raws.spaces.attribute &&
              attributeNode.raws.spaces.attribute.after;
              const { attrAfter, setAttrAfter } = rawAttrAfter ?
              {
                attrAfter: rawAttrAfter,
                setAttrAfter(fixed) {
                  attributeNode.raws.spaces.attribute.after = fixed;
                } } :

              {
                attrAfter:
                attributeNode.spaces.attribute && attributeNode.spaces.attribute.after || '',
                setAttrAfter(fixed) {
                  if (!attributeNode.spaces.attribute) attributeNode.spaces.attribute = {};

                  attributeNode.spaces.attribute.after = fixed;
                } };


              if (expectation === 'always') {
                setAttrAfter(attrAfter.replace(/\s*$/, ' '));

                return true;
              }

              if (expectation === 'never') {
                setAttrAfter(attrAfter.replace(/\s*$/, ''));

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorAttributeOperatorSpaceChecker": 329 }], 292: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const getRuleSelector = require('../../utils/getRuleSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-attribute-quotes';

      const messages = ruleMessages(ruleName, {
        expected: value => `Expected quotes around "${value}"`,
        rejected: value => `Unexpected quotes around "${value}"` });


      const acceptedQuoteMark = '"';

      function rule(expectation, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            parseSelector(getRuleSelector(ruleNode), result, ruleNode, selectorTree => {
              let selectorFixed = false;

              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.operator) {
                  return;
                }

                if (!attributeNode.quoted && expectation === 'always') {
                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = acceptedQuoteMark;
                  } else {
                    complain(
                    messages.expected(attributeNode.value),
                    attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                  }
                }

                if (attributeNode.quoted && expectation === 'never') {
                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = null;
                  } else {
                    complain(
                    messages.rejected(attributeNode.value),
                    attributeNode.sourceIndex + attributeNode.offsetOf('value'));

                  }
                }
              });

              if (selectorFixed) {
                ruleNode.selector = selectorTree.toString();
              }
            });

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/getRuleSelector": 372, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 293: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolveNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isBoolean, isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-class-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected class selector ".${selectorValue}" to match pattern "${pattern}"` });


      function rule(pattern, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: pattern,
            possible: [isRegExp, isString] },

          {
            actual: options,
            possible: {
              resolveNestedSelectors: isBoolean },

            optional: true });



          if (!validOptions) {
            return;
          }

          const shouldResolveNestedSelectors = options && options.resolveNestedSelectors;
          const normalizedPattern = isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkRules(ruleNode => {
            const selector = ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            // Only bother resolving selectors that have an interpolating &
            if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {
              for (const nestedSelector of resolveNestedSelector(selector, ruleNode)) {
                if (!isStandardSyntaxSelector(nestedSelector)) {
                  continue;
                }

                parseSelector(nestedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
              }
            } else {
              parseSelector(selector, result, ruleNode, s => checkSelector(s, ruleNode));
            }
          });

          function checkSelector(fullSelector, ruleNode) {
            fullSelector.walkClasses(classNode => {
              const value = classNode.value;
              const sourceIndex = classNode.sourceIndex;

              if (normalizedPattern.test(value)) {
                return;
              }

              report({
                result,
                ruleName,
                message: messages.expected(value, pattern),
                node: ruleNode,
                index: sourceIndex });

            });
          }
        };
      }

      // An "interpolating ampersand" means an "&" used to interpolate
      // within another simple selector, rather than an "&" that
      // stands on its own as a simple selector
      function hasInterpolatingAmpersand(selector) {
        for (let i = 0, l = selector.length; i < l; i++) {
          if (selector[i] !== '&') {
            continue;
          }

          if (selector[i - 1] !== undefined && !isCombinator(selector[i - 1])) {
            return true;
          }

          if (selector[i + 1] !== undefined && !isCombinator(selector[i + 1])) {
            return true;
          }
        }

        return false;
      }

      function isCombinator(x) {
        return /[\s+>~]/.test(x);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isKeyframeSelector": 398, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-resolve-nested-selector": 50 }], 294: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-combinator-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 410, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 295: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxCombinator = require('../../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-combinator-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: combinator => `Unexpected combinator "${combinator}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (!isStandardSyntaxCombinator(combinatorNode)) {
                  return;
                }

                const value = normalizeCombinator(combinatorNode.value);

                if (!list.includes(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: combinatorNode.sourceIndex });

              });
            });
          });
        };
      }

      function normalizeCombinator(value) {
        return value.replace(/\s+/g, ' ');
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxCombinator": 410, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 296: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: combinator => `Expected single space after "${combinator}"`,
        rejectedAfter: combinator => `Unexpected whitespace after "${combinator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.after,
            locationType: 'after',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (expectation === 'always') {
                combinator.spaces.after = ' ';

                return true;
              }

              if (expectation === 'never') {
                combinator.spaces.after = '';

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorCombinatorSpaceChecker": 330 }], 297: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorCombinatorSpaceChecker = require('../selectorCombinatorSpaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-combinator-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: combinator => `Expected single space before "${combinator}"`,
        rejectedBefore: combinator => `Unexpected whitespace before "${combinator}"` });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          selectorCombinatorSpaceChecker({
            root,
            result,
            locationChecker: checker.before,
            locationType: 'before',
            checkedRuleName: ruleName,
            fix: context.fix ?
            combinator => {
              if (expectation === 'always') {
                combinator.spaces.before = ' ';

                return true;
              }

              if (expectation === 'never') {
                combinator.spaces.before = '';

                return true;
              }
            } :
            null });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorCombinatorSpaceChecker": 330 }], 298: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-descendant-combinator-no-non-space';

      const messages = ruleMessages(ruleName, {
        rejected: nonSpaceCharacter => `Unexpected "${nonSpaceCharacter}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            let hasFixed = false;
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            // Return early for selectors containing comments
            // TODO: renable when parser and stylelint are compatible
            if (selector.includes('/*')) return;

            const fixedSelector = parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walkCombinators(combinatorNode => {
                if (combinatorNode.value !== ' ') {
                  return;
                }

                const value = combinatorNode.toString();

                if (
                value.includes('  ') ||
                value.includes('\t') ||
                value.includes('\n') ||
                value.includes('\r'))
                {
                  if (context.fix && /^\s+$/.test(value)) {
                    hasFixed = true;
                    combinatorNode.raws.value = ' ';
                    combinatorNode.rawSpaceBefore = combinatorNode.rawSpaceBefore.replace(/^\s+/, '');
                    combinatorNode.rawSpaceAfter = combinatorNode.rawSpaceAfter.replace(/\s+$/, '');

                    return;
                  }

                  report({
                    result,
                    ruleName,
                    message: messages.rejected(value),
                    node: ruleNode,
                    index: combinatorNode.sourceIndex });

                }
              });
            });

            if (hasFixed) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 299: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected selector "${selector}"` });


      function rule(listInput) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!matchesStringOrRegExp(selector, list)) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.rejected(selector),
              node: ruleNode });

          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 300: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-id-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selectorValue, pattern) =>
        `Expected ID selector "#${selectorValue}" to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            parseSelector(selector, result, ruleNode, fullSelector => {
              fullSelector.walk(selectorNode => {
                if (selectorNode.type !== 'id') {
                  return;
                }

                const value = selectorNode.value;
                const sourceIndex = selectorNode.sourceIndex;

                if (normalizedPattern.test(value)) {
                  return;
                }

                report({
                  result,
                  ruleName,
                  message: messages.expected(value, pattern),
                  node: ruleNode,
                  index: sourceIndex });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 301: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Get raw selector so we can allow end-of-line comments, e.g.
            // a, /* comment */
            // b {}
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            const fixIndices = [];

            styleSearch(
            {
              source: selector,
              target: ',',
              functionArguments: 'skip' },

            match => {
              const nextChars = selector.substr(match.endIndex, selector.length - match.endIndex);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^\s+\/\//.test(nextChars)) {
                return;
              }

              // If there are spaces and then a comment begins, look for the newline
              const indextoCheckAfter = /^\s+\/\*/.test(nextChars) ?
              selector.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;

              checker.afterOneOnly({
                source: selector,
                index: indextoCheckAfter,
                err: m => {
                  if (context.fix) {
                    fixIndices.push(indextoCheckAfter + 1);

                    return;
                  }

                  report({
                    message: m,
                    node: ruleNode,
                    index: match.startIndex,
                    result,
                    ruleName });

                } });

            });


            if (fixIndices.length) {
              let fixedSelector = selector;

              for (const index of fixIndices.sort((a, b) => b - a)) {
                const beforeSelector = fixedSelector.slice(0, index);
                let afterSelector = fixedSelector.slice(index);

                if (expectation.startsWith('always')) {
                  afterSelector = context.newline + afterSelector;
                } else if (expectation.startsWith('never-multi-line')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                fixedSelector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = fixedSelector;
              } else {
                ruleNode.selector = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "style-search": 121 }], 302: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (expectation.startsWith('always')) {
                  const spaceIndex = beforeSelector.search(/\s+$/);

                  if (spaceIndex >= 0) {
                    beforeSelector =
                    beforeSelector.slice(0, spaceIndex) +
                    context.newline +
                    beforeSelector.slice(spaceIndex);
                  } else {
                    beforeSelector += context.newline;
                  }
                } else if (expectation === 'never-multi-line') {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorListCommaWhitespaceChecker": 331 }], 303: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                const beforeSelector = selector.slice(0, index + 1);
                let afterSelector = selector.slice(index + 1);

                if (expectation.startsWith('always')) {
                  afterSelector = afterSelector.replace(/^\s*/, ' ');
                } else if (expectation.startsWith('never')) {
                  afterSelector = afterSelector.replace(/^\s*/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorListCommaWhitespaceChecker": 331 }], 304: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const selectorListCommaWhitespaceChecker = require('../selectorListCommaWhitespaceChecker');
      const validateOptions = require('../../utils/validateOptions');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'selector-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Expected single space before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          selectorListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (ruleNode, index) => {
              fixData = fixData || new Map();
              const commaIndices = fixData.get(ruleNode) || [];

              commaIndices.push(index);
              fixData.set(ruleNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [ruleNode, commaIndices] of fixData.entries()) {
              let selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

              for (const index of commaIndices.sort((a, b) => b - a)) {
                let beforeSelector = selector.slice(0, index);
                const afterSelector = selector.slice(index);

                if (expectation.includes('always')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, ' ');
                } else if (expectation.includes('never')) {
                  beforeSelector = beforeSelector.replace(/\s*$/, '');
                }

                selector = beforeSelector + afterSelector;
              }

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = selector;
              } else {
                ruleNode.selector = selector;
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../selectorListCommaWhitespaceChecker": 331 }], 305: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-attribute';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} attribute ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: isNonNegativeInteger },

          {
            actual: options,
            possible: {
              ignoreAttributes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type !== 'attribute') {
                // Not an attribute node -> ignore
                return total;
              }

              if (optionsMatches(options, 'ignoreAttributes', childNode.attribute)) {
                // it's an attribute that is supposed to be ignored
                return total;
              }

              total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-resolve-nested-selector": 50 }], 306: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${max === 1 ? 'class' : 'classes'}` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'class') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50 }], 307: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-combinators';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ${
        max === 1 ? 'combinator' : 'combinators'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'combinator') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50 }], 308: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-compound-selectors';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} compound ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          // Finds actual selectors in selectorNode object and checks them
          function checkSelector(selectorNode, ruleNode) {
            let compoundCount = 1;

            selectorNode.each(childNode => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              // Compound selectors are separated by combinators, so increase count when meeting one
              if (childNode.type === 'combinator') {
                compoundCount++;
              }
            });

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && compoundCount > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Using `.selectors` gets us each selector if there is a comma separated set
            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                // Process each resolved selector with `checkSelector` via postcss-selector-parser
                parseSelector(resolvedSelector, result, ruleNode, s => checkSelector(s, ruleNode));
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50 }], 309: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function rule(max, options, context) {
        const maxAdjacentNewlines = max + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkRules(ruleNode => {
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;

            if (context.fix) {
              const newSelectorString = selector.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = newSelectorString;
              } else {
                ruleNode.selector = newSelectorString;
              }
            } else if (
            violatedLFNewLinesRegex.test(selector) ||
            violatedCRLFNewLinesRegex.test(selector))
            {
              report({
                message: messages.expected(max),
                node: ruleNode,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 310: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-id';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} ID ${max === 1 ? 'selector' : 'selectors'}` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: isNonNegativeInteger },

          {
            actual: options,
            possible: {
              ignoreContextFunctionalPseudoClasses: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes that are not part of ignored functional pseudo-classes
              if (
              childNode.type === 'selector' ||
              isContextFunctionalPseudoClass(childNode) &&
              !isIgnoredContextFunctionalPseudoClass(childNode))
              {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'id') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          function isIgnoredContextFunctionalPseudoClass(node) {
            return (
              node.type === 'pseudo' &&
              optionsMatches(options, 'ignoreContextFunctionalPseudoClasses', node.value));

          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-resolve-nested-selector": 50 }], 311: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-pseudo-class';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} pseudo-${max === 1 ? 'class' : 'classes'}` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              // Exclude pseudo elements from the count
              if (
              childNode.type === 'pseudo' && (
              childNode.value.includes('::') ||
              keywordSets.levelOneAndTwoPseudoElements.has(childNode.value.toLowerCase().slice(1))))
              {
                return total;
              }

              if (childNode.type === 'pseudo') {
                total += 1;
              }

              return total;
            }, 0);

            if (count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, rule, selectorTree => {
                  checkSelector(selectorTree, ruleNode);
                });
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50 }], 312: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const specificity = require('specificity');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-specificity';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) => `Expected "${selector}" to have a specificity no more than "${max}"` });


      // Return an array representation of zero specificity. We need a new array each time so that it can mutated
      const zeroSpecificity = () => [0, 0, 0, 0];

      // Calculate the sum of given array of specificity arrays
      const specificitySum = specificities => {
        const sum = zeroSpecificity();

        for (const specificityArray of specificities) {
          for (const [i, value] of specificityArray.entries()) {
            sum[i] += value;
          }
        }

        return sum;
      };

      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: [
            // Check that the max specificity is in the form "a,b,c"
            spec => /^\d+,\d+,\d+$/.test(spec)] },


          {
            actual: options,
            possible: {
              ignoreSelectors: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          // Calculate the specificity of a simple selector (type, attribute, class, ID, or pseudos's own value)
          const simpleSpecificity = selector => {
            if (optionsMatches(options, 'ignoreSelectors', selector)) {
              return zeroSpecificity();
            }

            return specificity.calculate(selector)[0].specificityArray;
          };

          // Calculate the the specificity of the most specific direct child
          const maxChildSpecificity = (node) =>
          node.reduce((maxSpec, child) => {
            const childSpecificity = nodeSpecificity(child); // eslint-disable-line no-use-before-define

            return specificity.compare(childSpecificity, maxSpec) === 1 ? childSpecificity : maxSpec;
          }, zeroSpecificity());

          // Calculate the specificity of a pseudo selector including own value and children
          const pseudoSpecificity = node => {
            // `node.toString()` includes children which should be processed separately,
            // so use `node.value` instead
            const ownValue = node.value;
            const ownSpecificity =
            ownValue === ':not' || ownValue === ':matches' ?
            // :not and :matches don't add specificity themselves, but their children do
            zeroSpecificity() :
            simpleSpecificity(ownValue);

            return specificitySum([ownSpecificity, maxChildSpecificity(node)]);
          };

          const shouldSkipPseudoClassArgument = node => {
            // postcss-selector-parser includes the arguments to nth-child() functions
            // as "tags", so we need to ignore them ourselves.
            // The fake-tag's "parent" is actually a selector node, whose parent
            // should be the :nth-child pseudo node.
            const parentNode = node.parent.parent;

            if (parentNode && parentNode.value) {
              const parentNodeValue = parentNode.value;
              const normalisedParentNode = parentNodeValue.toLowerCase().replace(/:+/, '');

              return (
                parentNode.type === 'pseudo' && (
                keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentNode) ||
                keywordSets.linguisticPseudoClasses.has(normalisedParentNode)));

            }

            return false;
          };

          // Calculate the specificity of a node parsed by `postcss-selector-parser`
          const nodeSpecificity = node => {
            if (shouldSkipPseudoClassArgument(node)) {
              return zeroSpecificity();
            }

            switch (node.type) {
              case 'attribute':
              case 'class':
              case 'id':
              case 'tag':
                return simpleSpecificity(node.toString());
              case 'pseudo':
                return pseudoSpecificity(node);
              case 'selector':
                // Calculate the sum of all the direct children
                return specificitySum(node.map(n => nodeSpecificity(n)));
              default:
                return zeroSpecificity();}

          };

          const maxSpecificityArray = `0,${max}`.split(',').map(s => Number.parseFloat(s));

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            // Using `.selectors` gets us each selector in the eventuality we have a comma separated set
            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                try {
                  // Skip non-standard syntax selectors
                  if (!isStandardSyntaxSelector(resolvedSelector)) {
                    continue;
                  }

                  parseSelector(resolvedSelector, result, ruleNode, selectorTree => {
                    // Check if the selector specificity exceeds the allowed maximum
                    if (
                    specificity.compare(maxChildSpecificity(selectorTree), maxSpecificityArray) === 1)
                    {
                      report({
                        ruleName,
                        result,
                        node: ruleNode,
                        message: messages.expected(resolvedSelector, max),
                        word: selector });

                    }
                  });
                } catch (_unused) {
                  result.warn('Cannot parse selector', {
                    node: ruleNode,
                    stylelintType: 'parseError' });

                }
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-resolve-nested-selector": 50, "specificity": 120 }], 313: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isContextFunctionalPseudoClass = require('../../utils/isContextFunctionalPseudoClass');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isOnlyWhitespace = require('../../utils/isOnlyWhitespace');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-max-type';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} type ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: max,
            possible: isNonNegativeInteger },

          {
            actual: options,
            possible: {
              ignore: ['descendant', 'child', 'compounded', 'next-sibling'],
              ignoreTypes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          const ignoreDescendant = optionsMatches(options, 'ignore', 'descendant');
          const ignoreChild = optionsMatches(options, 'ignore', 'child');
          const ignoreCompounded = optionsMatches(options, 'ignore', 'compounded');
          const ignoreNextSibling = optionsMatches(options, 'ignore', 'next-sibling');

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors and context functional pseudo-classes
              if (childNode.type === 'selector' || isContextFunctionalPseudoClass(childNode)) {
                checkSelector(childNode, ruleNode);
              }

              if (optionsMatches(options, 'ignoreTypes', childNode.value)) {
                return total;
              }

              if (ignoreDescendant && hasDescendantCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreChild && hasChildCombinatorBefore(childNode)) {
                return total;
              }

              if (ignoreCompounded && hasCompoundSelector(childNode)) {
                return total;
              }

              if (ignoreNextSibling && hasNextSiblingCombinator(childNode)) {
                return total;
              }

              if (childNode.type === 'tag' && !isStandardSyntaxTypeSelector(childNode)) {
                return total;
              }

              return total + (childNode.type === 'tag');
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            for (const selector of ruleNode.selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                if (!isStandardSyntaxSelector(resolvedSelector)) {
                  continue;
                }

                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      function hasDescendantCombinatorBefore(node) {
        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(n => isDescendantCombinator(n));
      }

      function hasChildCombinatorBefore(node) {
        const nodeIndex = node.parent.nodes.indexOf(node);

        return node.parent.nodes.slice(0, nodeIndex).some(n => isChildCombinator(n));
      }

      function hasCompoundSelector(node) {
        if (node.prev() && !isCombinator(node.prev())) {
          return true;
        }

        return node.next() && !isCombinator(node.next());
      }

      function hasNextSiblingCombinator(node) {
        return node.prev() && isNextSiblingCombinator(node.prev());
      }

      function isCombinator(node) {
        if (!node) return false;

        return node.type === 'combinator';
      }

      function isDescendantCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && isOnlyWhitespace(node.value);
      }

      function isChildCombinator(node) {
        if (!node) return false;

        return isCombinator(node) && node.value === '>';
      }

      function isNextSiblingCombinator(node) {
        return isCombinator(node) && node.value === '+';
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isContextFunctionalPseudoClass": 388, "../../utils/isKeyframeSelector": 398, "../../utils/isNonNegativeInteger": 400, "../../utils/isOnlyWhitespace": 402, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/isStandardSyntaxTypeSelector": 419, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-resolve-nested-selector": 50 }], 314: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isNonNegativeInteger = require('../../utils/isNonNegativeInteger');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const selectorParser = require('postcss-selector-parser');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-max-universal';

      const messages = ruleMessages(ruleName, {
        expected: (selector, max) =>
        `Expected "${selector}" to have no more than ${max} universal ${
        max === 1 ? 'selector' : 'selectors'
        }` });


      function rule(max) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNonNegativeInteger });


          if (!validOptions) {
            return;
          }

          function checkSelector(selectorNode, ruleNode) {
            const count = selectorNode.reduce((total, childNode) => {
              // Only traverse inside actual selectors
              // All logical combinations will be resolved as nested selector in `postcss-resolve-nested-selector`
              if (childNode.type === 'selector') {
                checkSelector(childNode, ruleNode);
              }

              if (childNode.type === 'universal') total += 1;

              return total;
            }, 0);

            if (selectorNode.type !== 'root' && selectorNode.type !== 'pseudo' && count > max) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.expected(selectorNode, max),
                word: selectorNode });

            }
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selectors = [];

            selectorParser().
            astSync(ruleNode.selector).
            walk(node => {
              if (node.type === 'selector') {
                selectors.push(String(node).trim());
              }
            });

            for (const selector of selectors) {
              for (const resolvedSelector of resolvedNestedSelector(selector, ruleNode)) {
                parseSelector(resolvedSelector, result, ruleNode, (container) =>
                checkSelector(container, ruleNode));

              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isNonNegativeInteger": 400, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50, "postcss-selector-parser": 53 }], 315: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-nested-pattern';

      const messages = ruleMessages(ruleName, {
        expected: (selector, pattern) =>
        `Expected nested selector "${selector}" to match pattern "${pattern}"` });


      function rule(pattern) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: pattern,
            possible: [isRegExp, isString] });


          if (!validOptions) {
            return;
          }

          const normalizedPattern = isString(pattern) ? new RegExp(pattern) : pattern;

          root.walkRules(ruleNode => {
            if (ruleNode.parent.type !== 'rule') {
              return;
            }

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (normalizedPattern.test(selector)) {
              return;
            }

            report({
              result,
              ruleName,
              message: messages.expected(selector, pattern),
              node: ruleNode });

          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 316: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isKeyframeRule = require('../../utils/isKeyframeRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const resolvedNestedSelector = require('postcss-resolve-nested-selector');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-no-qualifying-type';

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected qualifying type selector' });


      const selectorCharacters = ['#', '.', '['];

      function isSelectorCharacters(value) {
        return selectorCharacters.some(char => value.includes(char));
      }

      function getRightNodes(node) {
        const result = [];
        let rightNode = node;

        while (rightNode = rightNode.next()) {
          if (rightNode.type === 'combinator') {
            break;
          }

          if (rightNode.type !== 'id' && rightNode.type !== 'class' && rightNode.type !== 'attribute') {
            continue;
          }

          result.push(rightNode);
        }

        return result;
      }

      function rule(enabled, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: enabled,
            possible: [true, false] },

          {
            actual: options,
            possible: {
              ignore: ['attribute', 'class', 'id'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (isKeyframeRule(ruleNode)) {
              return;
            }

            if (!isSelectorCharacters(ruleNode.selector)) {
              return;
            }

            function checkSelector(selectorAST) {
              selectorAST.walkTags(selector => {
                const selectorParent = selector.parent;

                if (selectorParent.nodes.length === 1) {
                  return;
                }

                const selectorNodes = getRightNodes(selector);
                const index = selector.sourceIndex;

                for (const selectorNode of selectorNodes) {
                  if (selectorNode.type === 'id' && !optionsMatches(options, 'ignore', 'id')) {
                    complain(index);
                  }

                  if (selectorNode.type === 'class' && !optionsMatches(options, 'ignore', 'class')) {
                    complain(index);
                  }

                  if (
                  selectorNode.type === 'attribute' &&
                  !optionsMatches(options, 'ignore', 'attribute'))
                  {
                    complain(index);
                  }
                }
              });
            }

            for (const resolvedSelector of resolvedNestedSelector(ruleNode.selector, ruleNode)) {
              if (!isStandardSyntaxSelector(resolvedSelector)) {
                continue;
              }

              parseSelector(resolvedSelector, result, ruleNode, checkSelector);
            }

            function complain(index) {
              report({
                ruleName,
                result,
                node: ruleNode,
                message: messages.rejected,
                index });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isKeyframeRule": 397, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-resolve-nested-selector": 50 }], 317: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 318: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            const fixedSelector = parseSelector(
            ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector,
            result,
            ruleNode,
            selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudo = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudo)) {
                  return;
                }

                if (
                pseudo.includes('::') ||
                keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudo =
                expectation === 'lower' ? pseudo.toLowerCase() : pseudo.toUpperCase();

                if (pseudo === expectedPseudo) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudo;

                  return;
                }

                report({
                  message: messages.expected(pseudo, expectedPseudo),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });


            if (context.fix) {
              if (ruleNode.raws.selector) {
                ruleNode.raws.selector.raw = fixedSelector;
              } else {
                ruleNode.selector = fixedSelector;
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 319: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-class "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-elements

                if (value.slice(0, 2) === '::') {
                  return;
                }

                const name = value.slice(1);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 320: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const isCustomSelector = require('../../utils/isCustomSelector');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-class-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-class selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignorePseudoClasses: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function check(selector, node) {
            parseSelector(selector, result, node, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                if (isCustomSelector(value)) {
                  return;
                }

                // Ignore pseudo-elements
                if (value.slice(0, 2) === '::') {
                  return;
                }

                if (optionsMatches(options, 'ignorePseudoClasses', pseudoNode.value.slice(1))) {
                  return;
                }

                let index = null;
                const name = value.slice(1).toLowerCase();

                if (node.type === 'atrule' && node.name === 'page') {
                  if (keywordSets.atRulePagePseudoClasses.has(name)) {
                    return;
                  }

                  index = atRuleParamIndex(node) + pseudoNode.sourceIndex;
                } else {
                  if (
                  vendor.prefix(name) ||
                  keywordSets.pseudoClasses.has(name) ||
                  keywordSets.pseudoElements.has(name))
                  {
                    return;
                  }

                  let prevPseudoElement = pseudoNode;

                  do {
                    prevPseudoElement = prevPseudoElement.prev();

                    if (prevPseudoElement && prevPseudoElement.value.slice(0, 2) === '::') {
                      break;
                    }
                  } while (prevPseudoElement);

                  if (prevPseudoElement) {
                    const prevPseudoElementValue = vendor.unprefixed(
                    prevPseudoElement.value.toLowerCase().slice(2));


                    if (
                    keywordSets.webkitProprietaryPseudoElements.has(prevPseudoElementValue) &&
                    keywordSets.webkitProprietaryPseudoClasses.has(name))
                    {
                      return;
                    }
                  }

                  index = pseudoNode.sourceIndex;
                }

                report({
                  message: messages.rejected(value),
                  node,
                  index,
                  ruleName,
                  result });

              });
            });
          }

          root.walk(node => {
            let selector = null;

            if (node.type === 'rule') {
              if (!isStandardSyntaxRule(node)) {
                return;
              }

              selector = node.selector;
            } else if (node.type === 'atrule' && node.name === 'page' && node.params) {
              if (!isStandardSyntaxAtRule(node)) {
                return;
              }

              selector = node.params;
            }

            // Return if selector empty, it is meaning node type is not a rule or a at-rule

            if (!selector) {
              return;
            }

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            check(selector, node);
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/atRuleParamIndex": 352, "../../utils/isCustomSelector": 394, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 321: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-class-parentheses-space-inside';

      const messages = ruleMessages(ruleName, {
        expectedOpening: 'Expected single space after "("',
        rejectedOpening: 'Unexpected whitespace after "("',
        expectedClosing: 'Expected single space before ")"',
        rejectedClosing: 'Unexpected whitespace before ")"' });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('(')) {
              return;
            }

            let hasFixed = false;
            const selector = ruleNode.raws.selector ? ruleNode.raws.selector.raw : ruleNode.selector;
            const fixedSelector = parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                if (!pseudoNode.length) {
                  return;
                }

                const paramString = pseudoNode.map(node => String(node)).join(',');
                const nextCharIsSpace = paramString.startsWith(' ');
                const openIndex =
                pseudoNode.sourceIndex + stringifyProperty(pseudoNode, 'value').length + 1;

                if (nextCharIsSpace && expectation === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, '');
                  } else {
                    complain(messages.rejectedOpening, openIndex);
                  }
                }

                if (!nextCharIsSpace && expectation === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setFirstNodeSpaceBefore(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedOpening, openIndex);
                  }
                }

                const prevCharIsSpace = paramString.endsWith(' ');
                const closeIndex = openIndex + paramString.length - 1;

                if (prevCharIsSpace && expectation === 'never') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, '');
                  } else {
                    complain(messages.rejectedClosing, closeIndex);
                  }
                }

                if (!prevCharIsSpace && expectation === 'always') {
                  if (context.fix) {
                    hasFixed = true;
                    setLastNodeSpaceAfter(pseudoNode, ' ');
                  } else {
                    complain(messages.expectedClosing, closeIndex);
                  }
                }
              });
            });

            if (hasFixed) {
              if (!ruleNode.raws.selector) {
                ruleNode.selector = fixedSelector;
              } else {
                ruleNode.raws.selector.raw = fixedSelector;
              }
            }

            function complain(message, index) {
              report({
                message,
                index,
                result,
                ruleName,
                node: ruleNode });

            }
          });
        };
      }

      function setFirstNodeSpaceBefore(node, value) {
        const target = node.first;

        if (target.type === 'selector') {
          setFirstNodeSpaceBefore(target, value);
        } else {
          target.spaces.before = value;
        }
      }

      function setLastNodeSpaceAfter(node, value) {
        const target = node.last;

        if (target.type === 'selector') {
          setLastNodeSpaceAfter(target, value);
        } else {
          target.spaces.after = value;
        }
      }

      function stringifyProperty(node, propName) {
        return node.raws && node.raws[propName] || node[propName];
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 322: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 323: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const transformSelector = require('../../utils/transformSelector');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes(':')) {
              return;
            }

            transformSelector(result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const pseudoElement = pseudoNode.value;

                if (!isStandardSyntaxSelector(pseudoElement)) {
                  return;
                }

                if (
                !pseudoElement.includes('::') &&
                !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice(1)))
                {
                  return;
                }

                const expectedPseudoElement =
                expectation === 'lower' ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase();

                if (pseudoElement === expectedPseudoElement) {
                  return;
                }

                if (context.fix) {
                  pseudoNode.value = expectedPseudoElement;

                  return;
                }

                report({
                  message: messages.expected(pseudoElement, expectedPseudoElement),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/transformSelector": 439, "../../utils/validateOptions": 442 }], 324: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const keywordSets = require('../../reference/keywordSets');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const styleSearch = require('style-search');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'selector-pseudo-element-colon-notation';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} colon pseudo-element notation` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['single', 'double'] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            // get out early if no pseudo elements or classes
            if (!selector.includes(':')) {
              return;
            }

            const fixPositions = [];

            // match only level 1 and 2 pseudo elements
            const pseudoElementsWithColons = [...keywordSets.levelOneAndTwoPseudoElements].map(
            x => `:${x}`);


            styleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, match => {
              const prevCharIsColon = selector[match.startIndex - 1] === ':';

              if (expectation === 'single' && !prevCharIsColon) {
                return;
              }

              if (expectation === 'double' && prevCharIsColon) {
                return;
              }

              if (context.fix) {
                fixPositions.unshift({ ruleNode, startIndex: match.startIndex });

                return;
              }

              report({
                message: messages.expected(expectation),
                node: ruleNode,
                index: match.startIndex,
                result,
                ruleName });

            });

            if (fixPositions.length) {
              // If expecting : then we found :: so remove one of the colons
              // If expecting :: then we found : so add one extra colon
              const expectedSingle = expectation === 'single';
              const offset = expectedSingle ? 1 : 0;
              const extraColon = expectedSingle ? '' : ':';

              for (const fixPosition of fixPositions) {
                ruleNode.selector =
                ruleNode.selector.substring(0, fixPosition.startIndex - offset) +
                extraColon +
                ruleNode.selector.substring(fixPosition.startIndex);
              }
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxRule": 417, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "style-search": 121 }], 325: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected pseudo-element "${selector}"` });


      function rule(list) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: list,
            possible: [isString, isRegExp] });


          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            if (!selector.includes('::')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                // Ignore pseudo-classes
                if (value[1] !== ':') {
                  return;
                }

                const name = value.slice(2);

                if (!matchesStringOrRegExp(vendor.unprefixed(name), list)) {
                  return;
                }

                report({
                  index: pseudoNode.sourceIndex,
                  message: messages.rejected(name),
                  node: ruleNode,
                  result,
                  ruleName });

              });
            });
          });
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxRule": 417, "../../utils/matchesStringOrRegExp": 426, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 326: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const vendor = require('../../utils/vendor');
      const { isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-pseudo-element-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown pseudo-element selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignorePseudoElements: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            const selector = ruleNode.selector;

            // Return early before parse if no pseudos for performance

            if (!selector.includes(':')) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkPseudos(pseudoNode => {
                const value = pseudoNode.value;

                if (!isStandardSyntaxSelector(value)) {
                  return;
                }

                // Ignore pseudo-classes
                if (value.slice(0, 2) !== '::') {
                  return;
                }

                if (optionsMatches(options, 'ignorePseudoElements', pseudoNode.value.slice(2))) {
                  return;
                }

                const name = value.slice(2);

                if (vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {
                  return;
                }

                report({
                  message: messages.rejected(value),
                  node: ruleNode,
                  index: pseudoNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxSelector": 418, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444 }], 327: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const { isString } = require('../../utils/validateTypes');
      const keywordSets = require('../../reference/keywordSets');

      const ruleName = 'selector-type-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['lower', 'upper'] },

          {
            actual: options,
            possible: {
              ignoreTypes: [isString] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            let hasComments = ruleNode.raws.selector && ruleNode.raws.selector.raw;
            const selector = hasComments ? hasComments : ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorAST => {
              selectorAST.walkTags(tag => {
                if (!isStandardSyntaxTypeSelector(tag)) {
                  return;
                }

                if (keywordSets.validMixedCaseSvgElements.has(tag.value)) {
                  return;
                }

                if (optionsMatches(options, 'ignoreTypes', tag.value)) {
                  return;
                }

                const sourceIndex = tag.sourceIndex;
                const value = tag.value;

                const expectedValue = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();

                if (value === expectedValue) {
                  return;
                }

                if (context.fix) {
                  if (hasComments) {
                    hasComments =
                    hasComments.slice(0, sourceIndex) +
                    expectedValue +
                    hasComments.slice(sourceIndex + value.length);
                    ruleNode.raws.selector.raw = hasComments;
                  } else {
                    ruleNode.selector =
                    ruleNode.selector.slice(0, sourceIndex) +
                    expectedValue +
                    ruleNode.selector.slice(sourceIndex + value.length);
                  }

                  return;
                }

                report({
                  message: messages.expected(value, expectedValue),
                  node: ruleNode,
                  index: sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isKeyframeSelector": 398, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxTypeSelector": 419, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 328: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const htmlTags = require('html-tags');
      const isCustomElement = require('../../utils/isCustomElement');
      const isKeyframeSelector = require('../../utils/isKeyframeSelector');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const isStandardSyntaxTypeSelector = require('../../utils/isStandardSyntaxTypeSelector');
      const keywordSets = require('../../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const optionsMatches = require('../../utils/optionsMatches');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const svgTags = require('svg-tags');
      const validateOptions = require('../../utils/validateOptions');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'selector-type-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: selector => `Unexpected unknown type selector "${selector}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignore: ['custom-elements', 'default-namespace'],
              ignoreNamespaces: [isString, isRegExp],
              ignoreTypes: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkRules(ruleNode => {
            const selector = ruleNode.selector;
            const selectors = ruleNode.selectors;

            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (selectors.some(s => isKeyframeSelector(s))) {
              return;
            }

            parseSelector(selector, result, ruleNode, selectorTree => {
              selectorTree.walkTags(tagNode => {
                if (!isStandardSyntaxTypeSelector(tagNode)) {
                  return;
                }

                if (
                optionsMatches(options, 'ignore', 'custom-elements') &&
                isCustomElement(tagNode.value))
                {
                  return;
                }

                if (
                optionsMatches(options, 'ignore', 'default-namespace') &&
                !(typeof tagNode.namespace === 'string'))
                {
                  return;
                }

                if (optionsMatches(options, 'ignoreNamespaces', tagNode.namespace)) {
                  return;
                }

                if (optionsMatches(options, 'ignoreTypes', tagNode.value)) {
                  return;
                }

                const tagName = tagNode.value;
                const tagNameLowerCase = tagName.toLowerCase();

                if (
                htmlTags.includes(tagNameLowerCase) ||
                // SVG tags are case-sensitive
                svgTags.includes(tagName) ||
                keywordSets.nonStandardHtmlTags.has(tagNameLowerCase) ||
                mathMLTags.includes(tagNameLowerCase))
                {
                  return;
                }

                report({
                  message: messages.rejected(tagName),
                  node: ruleNode,
                  index: tagNode.sourceIndex,
                  ruleName,
                  result });

              });
            });
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/isCustomElement": 391, "../../utils/isKeyframeSelector": 398, "../../utils/isStandardSyntaxRule": 417, "../../utils/isStandardSyntaxTypeSelector": 419, "../../utils/optionsMatches": 429, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "html-tags": 28, "mathml-tag-names": 40, "svg-tags": 448 }], 329: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (options) {
        options.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          if (!rule.selector.includes('[') || !rule.selector.includes('=')) {
            return;
          }

          let hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, options.result, rule, selectorTree => {
            selectorTree.walkAttributes(attributeNode => {
              const operator = attributeNode.operator;

              if (!operator) {
                return;
              }

              const attributeNodeString = attributeNode.toString();

              styleSearch({ source: attributeNodeString, target: operator }, match => {
                const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1;

                checkOperator(attributeNodeString, index, rule, attributeNode, operator);
              });
            });
          });

          if (hasFixed) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }

          function checkOperator(source, index, node, attributeNode, operator) {
            options.locationChecker({
              source,
              index,
              err: m => {
                if (options.fix && options.fix(attributeNode)) {
                  hasFixed = true;

                  return;
                }

                report({
                  message: m.replace(
                  options.checkBeforeOperator ? operator[0] : operator[operator.length - 1],
                  operator),

                  node,
                  index: attributeNode.sourceIndex + index,
                  result: options.result,
                  ruleName: options.checkedRuleName });

              } });

          }
        });
      };

    }, { "../utils/isStandardSyntaxRule": 417, "../utils/parseSelector": 430, "../utils/report": 435, "style-search": 121 }], 330: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxCombinator = require('../utils/isStandardSyntaxCombinator');
      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const parseSelector = require('../utils/parseSelector');
      const report = require('../utils/report');

      module.exports = function (opts) {
        let hasFixed;

        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          hasFixed = false;
          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          const fixedSelector = parseSelector(selector, opts.result, rule, selectorTree => {
            selectorTree.walkCombinators(node => {
              // Ignore non-standard combinators
              if (!isStandardSyntaxCombinator(node)) {
                return;
              }

              // Ignore spaced descendant combinator
              if (/\s/.test(node.value)) {
                return;
              }

              // Check the exist of node in prev of the combinator.
              // in case some that aren't the first begin with combinators (nesting syntax)
              if (opts.locationType === 'before' && !node.prev()) {
                return;
              }

              const parentParentNode = node.parent && node.parent.parent;

              // Ignore pseudo-classes selector like `.foo:nth-child(2n + 1) {}`
              if (parentParentNode && parentParentNode.type === 'pseudo') {
                return;
              }

              const sourceIndex = node.sourceIndex;
              const index =
              node.value.length > 1 && opts.locationType === 'before' ?
              sourceIndex :
              sourceIndex + node.value.length - 1;

              check(selector, node, index, rule, sourceIndex);
            });
          });

          if (hasFixed) {
            if (!rule.raws.selector) {
              rule.selector = fixedSelector;
            } else {
              rule.raws.selector.raw = fixedSelector;
            }
          }
        });

        function check(source, combinator, index, node, sourceIndex) {
          opts.locationChecker({
            source,
            index,
            errTarget: combinator.value,
            err: m => {
              if (opts.fix && opts.fix(combinator)) {
                hasFixed = true;

                return;
              }

              report({
                message: m,
                node,
                index: sourceIndex,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxCombinator": 410, "../utils/isStandardSyntaxRule": 417, "../utils/parseSelector": 430, "../utils/report": 435 }], 331: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxRule = require('../utils/isStandardSyntaxRule');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkRules(rule => {
          if (!isStandardSyntaxRule(rule)) {
            return;
          }

          const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector;

          styleSearch(
          {
            source: selector,
            target: ',',
            functionArguments: 'skip' },

          match => {
            checkDelimiter(selector, match.startIndex, rule);
          });

        });

        function checkDelimiter(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message: m,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxRule": 417, "../utils/report": 435, "style-search": 121 }], 332: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../../utils/isStandardSyntaxProperty');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');

      const ruleName = 'shorthand-property-no-redundant-values';

      const messages = ruleMessages(ruleName, {
        rejected: (unexpected, expected) =>
        `Unexpected longhand value '${unexpected}' instead of '${expected}'` });


      const propertiesWithShorthandNotation = new Set([
      'margin',
      'padding',
      'border-color',
      'border-radius',
      'border-style',
      'border-width',
      'grid-gap']);


      const ignoredCharacters = ['+', '*', '/', '(', ')', '$', '@', '--', 'var('];

      function hasIgnoredCharacters(value) {
        return ignoredCharacters.some(char => value.includes(char));
      }

      function isShorthandProperty(property) {
        return propertiesWithShorthandNotation.has(property);
      }

      function canCondense(top, right, bottom, left) {
        const lowerTop = top.toLowerCase();
        const lowerRight = right.toLowerCase();
        const lowerBottom = bottom && bottom.toLowerCase();
        const lowerLeft = left && left.toLowerCase();

        if (canCondenseToOneValue(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top];
        }

        if (canCondenseToTwoValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right];
        }

        if (canCondenseToThreeValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {
          return [top, right, bottom];
        }

        return [top, right, bottom, left];
      }

      function canCondenseToOneValue(top, right, bottom, left) {
        if (top !== right) {
          return false;
        }

        return top === bottom && (bottom === left || !left) || !bottom && !left;
      }

      function canCondenseToTwoValues(top, right, bottom, left) {
        return top === bottom && right === left || top === bottom && !left && top !== right;
      }

      function canCondenseToThreeValues(top, right, bottom, left) {
        return right === left;
      }

      function rule(actual, secondary, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
              return;
            }

            const prop = decl.prop;
            const value = decl.value;

            const normalizedProp = vendor.unprefixed(prop.toLowerCase());

            if (hasIgnoredCharacters(value) || !isShorthandProperty(normalizedProp)) {
              return;
            }

            const valuesToShorthand = [];

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'word') {
                return;
              }

              valuesToShorthand.push(valueParser.stringify(valueNode));
            });

            if (valuesToShorthand.length <= 1 || valuesToShorthand.length > 4) {
              return;
            }

            const shortestForm = canCondense(...valuesToShorthand);
            const shortestFormString = shortestForm.filter(Boolean).join(' ');
            const valuesFormString = valuesToShorthand.join(' ');

            if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {
              return;
            }

            if (context.fix) {
              decl.value = decl.value.replace(value, shortestFormString);
            } else {
              report({
                message: messages.rejected(value, shortestFormString),
                node: decl,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/isStandardSyntaxProperty": 416, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/vendor": 444, "postcss-value-parser": 83 }], 333: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'string-no-newline';
      const reNewLine = /\r?\n/;

      const messages = ruleMessages(ruleName, {
        rejected: 'Unexpected newline in string' });


      function rule(actual) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, { actual });

          if (!validOptions) {
            return;
          }

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          function checkRule(ruleNode) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(ruleNode.selector)) {
              return;
            }

            if (!isStandardSyntaxSelector(ruleNode.selector)) {
              return;
            }

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              selectorTree.walkAttributes(attributeNode => {
                const match = reNewLine.exec(attributeNode.value);

                if (!match) {
                  return;
                }

                const openIndex = [
                // length of our attribute
                attributeNode.attribute,
                // length of our operator , ie '='
                attributeNode.operator,
                // length of the contents before newline
                match.input.slice(0, match.index)].
                reduce(
                (index, str) => index + str.length,
                // index of the start of our attribute node in our source
                // plus 1 for the opening quotation mark
                attributeNode.sourceIndex + 1);


                report({
                  message: messages.rejected,
                  node: ruleNode,
                  index: openIndex,
                  result,
                  ruleName });

              });
            });
          }

          function checkDeclOrAtRule(node, value, getIndex) {
            // Get out quickly if there are no new line
            if (!reNewLine.test(value)) {
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type !== 'string') {
                return;
              }

              const match = reNewLine.exec(valueNode.value);

              if (!match) {
                return;
              }

              const openIndex = [
              // length of the quote
              valueNode.quote,
              // length of the contents before newline
              match.input.slice(0, match.index)].
              reduce((index, str) => index + str.length, valueNode.sourceIndex);

              report({
                message: messages.rejected,
                node,
                index: getIndex(node) + openIndex,
                result,
                ruleName });

            });
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxSelector": 418, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 334: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule');
      const parseSelector = require('../../utils/parseSelector');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isBoolean } = require('../../utils/validateTypes');

      const ruleName = 'string-quotes';

      const messages = ruleMessages(ruleName, {
        expected: q => `Expected ${q} quotes` });


      const singleQuote = `'`;
      const doubleQuote = `"`;

      function rule(expectation, secondary, context) {
        const correctQuote = expectation === 'single' ? singleQuote : doubleQuote;
        const erroneousQuote = expectation === 'single' ? doubleQuote : singleQuote;

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['single', 'double'] },

          {
            actual: secondary,
            possible: {
              avoidEscape: isBoolean },

            optional: true });



          if (!validOptions) {
            return;
          }

          const avoidEscape =
          secondary && secondary.avoidEscape !== undefined ? secondary.avoidEscape : true;

          root.walk(node => {
            switch (node.type) {
              case 'atrule':
                checkDeclOrAtRule(node, node.params, atRuleParamIndex);
                break;
              case 'decl':
                checkDeclOrAtRule(node, node.value, declarationValueIndex);
                break;
              case 'rule':
                checkRule(node);
                break;}

          });

          function checkRule(ruleNode) {
            if (!isStandardSyntaxRule(ruleNode)) {
              return;
            }

            if (!ruleNode.selector.includes('[') || !ruleNode.selector.includes('=')) {
              return;
            }

            const fixPositions = [];

            parseSelector(ruleNode.selector, result, ruleNode, selectorTree => {
              let selectorFixed = false;

              selectorTree.walkAttributes(attributeNode => {
                if (!attributeNode.quoted) {
                  return;
                }

                if (attributeNode.quoteMark === correctQuote && avoidEscape) {
                  const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                  const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                  if (needsOtherEscape) {
                    return;
                  }

                  if (needsCorrectEscape) {
                    if (context.fix) {
                      selectorFixed = true;
                      attributeNode.quoteMark = erroneousQuote;
                    } else {
                      report({
                        message: messages.expected(expectation === 'single' ? 'double' : expectation),
                        node: ruleNode,
                        index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                        result,
                        ruleName });

                    }
                  }
                }

                if (attributeNode.quoteMark === erroneousQuote) {
                  if (avoidEscape) {
                    const needsCorrectEscape = attributeNode.value.includes(correctQuote);
                    const needsOtherEscape = attributeNode.value.includes(erroneousQuote);

                    if (needsOtherEscape) {
                      if (context.fix) {
                        selectorFixed = true;
                        attributeNode.quoteMark = correctQuote;
                      } else {
                        report({
                          message: messages.expected(expectation),
                          node: ruleNode,
                          index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                          result,
                          ruleName });

                      }

                      return;
                    }

                    if (needsCorrectEscape) {
                      return;
                    }
                  }

                  if (context.fix) {
                    selectorFixed = true;
                    attributeNode.quoteMark = correctQuote;
                  } else {
                    report({
                      message: messages.expected(expectation),
                      node: ruleNode,
                      index: attributeNode.sourceIndex + attributeNode.offsetOf('value'),
                      result,
                      ruleName });

                  }
                }
              });

              if (selectorFixed) {
                ruleNode.selector = selectorTree.toString();
              }
            });

            for (const fixIndex of fixPositions) {
              ruleNode.selector = replaceQuote(ruleNode.selector, fixIndex, correctQuote);
            }
          }

          function checkDeclOrAtRule(node, value, getIndex) {
            const fixPositions = [];

            // Get out quickly if there are no erroneous quotes
            if (!value.includes(erroneousQuote)) {
              return;
            }

            if (node.type === 'atrule' && node.name === 'charset') {
              // allow @charset rules to have double quotes, in spite of the configuration
              // TODO: @charset should always use double-quotes, see https://github.com/stylelint/stylelint/issues/2788
              return;
            }

            valueParser(value).walk(valueNode => {
              if (valueNode.type === 'string' && valueNode.quote === erroneousQuote) {
                const needsEscape = valueNode.value.includes(correctQuote);

                if (avoidEscape && needsEscape) {
                  // don't consider this an error
                  return;
                }

                const openIndex = valueNode.sourceIndex;

                // we currently don't fix escapes
                if (context.fix && !needsEscape) {
                  const closeIndex = openIndex + valueNode.value.length + erroneousQuote.length;

                  fixPositions.push(openIndex, closeIndex);
                } else {
                  report({
                    message: messages.expected(expectation),
                    node,
                    index: getIndex(node) + openIndex,
                    result,
                    ruleName });

                }
              }
            });

            for (const fixIndex of fixPositions) {
              if (node.type === 'atrule') {
                node.params = replaceQuote(node.params, fixIndex, correctQuote);
              } else {
                node.value = replaceQuote(node.value, fixIndex, correctQuote);
              }
            }
          }
        };
      }

      function replaceQuote(string, index, replace) {
        return string.substring(0, index) + replace + string.substring(index + replace.length);
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/isStandardSyntaxRule": 417, "../../utils/parseSelector": 430, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 335: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const keywordSets = require('../../reference/keywordSets');
      const optionsMatches = require('../../utils/optionsMatches');
      const postcss = require('postcss');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'time-min-milliseconds';

      const messages = ruleMessages(ruleName, {
        expected: time => `Expected a minimum of ${time} milliseconds` });


      const DELAY_PROPERTIES = new Set(['animation-delay', 'transition-delay']);

      function rule(minimum, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: minimum,
            possible: isNumber },

          {
            actual: options,
            possible: {
              ignore: ['delay'] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const propertyName = vendor.unprefixed(decl.prop.toLowerCase());

            if (
            keywordSets.longhandTimeProperties.has(propertyName) &&
            !isIgnoredProperty(propertyName) &&
            !isAcceptableTime(decl.value))
            {
              complain(decl);
            }

            if (keywordSets.shorthandTimeProperties.has(propertyName)) {
              const valueListList = postcss.list.comma(decl.value);

              for (const valueListString of valueListList) {
                const valueList = postcss.list.space(valueListString);

                if (optionsMatches(options, 'ignore', 'delay')) {
                  // Check only duration time values
                  const duration = getDuration(valueList);

                  if (duration && !isAcceptableTime(duration)) {
                    complain(decl, decl.value.indexOf(duration));
                  }
                } else {
                  // Check all time values
                  for (const value of valueList) {
                    if (!isAcceptableTime(value)) {
                      complain(decl, decl.value.indexOf(value));
                    }
                  }
                }
              }
            }
          });

          /**
           * Get the duration within an `animation` or `transition` shorthand property value.
           *
           * @param {Node[]} valueList
           *
           * @returns {Node}
           */
          function getDuration(valueList) {
            for (const value of valueList) {
              const parsedTime = valueParser.unit(value);

              if (!parsedTime) continue;

              // The first numeric value in an animation shorthand is the duration.
              return value;
            }
          }

          function isIgnoredProperty(propertyName) {
            if (optionsMatches(options, 'ignore', 'delay') && DELAY_PROPERTIES.has(propertyName)) {
              return true;
            }

            return false;
          }

          function isAcceptableTime(time) {
            const parsedTime = valueParser.unit(time);

            if (!parsedTime) return true;

            if (parsedTime.number <= 0) {
              return true;
            }

            if (parsedTime.unit.toLowerCase() === 'ms' && parsedTime.number < minimum) {
              return false;
            }

            if (parsedTime.unit.toLowerCase() === 's' && parsedTime.number * 1000 < minimum) {
              return false;
            }

            return true;
          }

          function complain(decl, offset = 0) {
            report({
              result,
              ruleName,
              message: messages.expected(minimum),
              index: declarationValueIndex(decl) + offset,
              node: decl });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "postcss": 103, "postcss-value-parser": 83 }], 336: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');

      const ruleName = 'unicode-bom';

      const messages = ruleMessages(ruleName, {
        expected: 'Expected Unicode BOM',
        rejected: 'Unexpected Unicode BOM' });


      function rule(expectation) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never'] });


          if (
          !validOptions ||
          root.source.inline ||
          root.source.lang === 'object-literal' ||
          // Ignore HTML documents
          root.document !== undefined)
          {
            return;
          }

          const { hasBOM } = root.source.input;

          if (expectation === 'always' && !hasBOM) {
            report({
              result,
              ruleName,
              message: messages.expected,
              root,
              line: 1 });

          }

          if (expectation === 'never' && hasBOM) {
            report({
              result,
              ruleName,
              message: messages.rejected,
              root,
              line: 1 });

          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442 }], 337: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'unit-allowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      function rule(listInput, options) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([isString, isRegExp]) } });




          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit || unit && list.includes(unit.toLowerCase())) {
                return;
              }

              if (options && optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {
                return;
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateObjectWithArrayProps": 441, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 338: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');

      const ruleName = 'unit-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['lower', 'upper'] });


          if (!validOptions) {
            return;
          }

          function check(node, checkedValue, getIndex) {
            const problems = [];

            function processValue(valueNode) {
              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return false;
              }

              const expectedUnit = expectation === 'lower' ? unit.toLowerCase() : unit.toUpperCase();

              if (unit === expectedUnit) {
                return false;
              }

              problems.push({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.expected(unit, expectedUnit) });


              return true;
            }

            const parsedValue = valueParser(checkedValue).walk(valueNode => {
              // Ignore wrong units within `url` function
              let needFix = false;
              const value = valueNode.value;

              if (valueNode.type === 'function' && value.toLowerCase() === 'url') {
                return false;
              }

              if (value.includes('*')) {
                value.split('*').some(val => {
                  return processValue(_extends({},
                  valueNode, {
                    sourceIndex: value.indexOf(val) + val.length + 1,
                    value: val }));

                });
              }

              needFix = processValue(valueNode);

              if (needFix && context.fix) {
                valueNode.value = expectation === 'lower' ? value.toLowerCase() : value.toUpperCase();
              }
            });

            if (problems.length) {
              if (context.fix) {
                if (node.name === 'media') {
                  node.params = parsedValue.toString();
                } else {
                  node.value = parsedValue.toString();
                }
              } else {
                for (const err of problems) {
                  report({
                    index: err.index,
                    message: err.message,
                    node,
                    result,
                    ruleName });

                }
              }
            }
          }

          root.walkAtRules(atRule => {
            if (!/^media$/i.test(atRule.name) && !atRule.variable) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => check(decl, decl.value, declarationValueIndex));
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "postcss-value-parser": 83 }], 339: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateObjectWithArrayProps = require('../../utils/validateObjectWithArrayProps');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'unit-disallowed-list';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unit "${unit}"` });


      // a function to retrieve only the media feature name
      // could be externalized in an utils function if needed in other code
      const getMediaFeatureName = mediaFeatureNode => {
        const value = mediaFeatureNode.value.toLowerCase();

        return /((?:-?\w*)*)/.exec(value)[1];
      };

      function rule(listInput, options) {
        const list = [listInput].flat();

        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: list,
            possible: [isString] },

          {
            optional: true,
            actual: options,
            possible: {
              ignoreProperties: validateObjectWithArrayProps([isString, isRegExp]),
              ignoreMediaFeatureNames: validateObjectWithArrayProps([isString, isRegExp]) } });




          if (!validOptions) {
            return;
          }

          function check(node, nodeIndex, valueNode, input, option) {
            const unit = getUnitFromValueNode(valueNode);

            // There is not unit or it is not configured as a problem
            if (!unit || unit && !list.includes(unit.toLowerCase())) {
              return;
            }

            // The unit has an ignore option for the specific input
            if (optionsMatches(option, unit.toLowerCase(), input)) {
              return;
            }

            report({
              index: nodeIndex + valueNode.sourceIndex,
              message: messages.rejected(unit),
              node,
              result,
              ruleName });

          }

          function checkMedia(node, value, getIndex) {
            mediaParser(node.params).walk(/^media-feature$/i, mediaFeatureNode => {
              const mediaName = getMediaFeatureName(mediaFeatureNode);
              const parentValue = mediaFeatureNode.parent.value;

              valueParser(value).walk(valueNode => {
                // Ignore all non-word valueNode and
                // the values not included in the parentValue string
                if (valueNode.type !== 'word' || !parentValue.includes(valueNode.value)) {
                  return;
                }

                check(
                node,
                getIndex(node),
                valueNode,
                mediaName,
                options ? options.ignoreMediaFeatureNames : {});

              });
            });
          }

          function checkDecl(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');

            valueParser(value).walk(valueNode => {
              // Ignore wrong units within `url` function
              if (valueNode.type === 'function' && valueNode.value.toLowerCase() === 'url') {
                return false;
              }

              check(node, getIndex(node), valueNode, node.prop, options ? options.ignoreProperties : {});
            });
          }

          root.walkAtRules(/^media$/i, atRule => checkMedia(atRule, atRule.params, atRuleParamIndex));
          root.walkDecls(decl => checkDecl(decl, decl.value, declarationValueIndex));
        };
      }

      rule.primaryOptionArray = true;

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateObjectWithArrayProps": 441, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-media-query-parser": 46, "postcss-value-parser": 83 }], 340: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const atRuleParamIndex = require('../../utils/atRuleParamIndex');
      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isStandardSyntaxAtRule = require('../../utils/isStandardSyntaxAtRule');
      const isStandardSyntaxDeclaration = require('../../utils/isStandardSyntaxDeclaration');
      const keywordSets = require('../../reference/keywordSets');
      const mediaParser = require('postcss-media-query-parser').default;
      const optionsMatches = require('../../utils/optionsMatches');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const vendor = require('../../utils/vendor');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'unit-no-unknown';

      const messages = ruleMessages(ruleName, {
        rejected: unit => `Unexpected unknown unit "${unit}"` });


      function rule(actual, options) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          { actual },
          {
            actual: options,
            possible: {
              ignoreUnits: [isString, isRegExp],
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          function check(node, value, getIndex) {
            // make sure multiplication operations (*) are divided - not handled
            // by postcss-value-parser
            value = value.replace(/\*/g, ',');
            const parsedValue = valueParser(value);

            parsedValue.walk(valueNode => {
              // Ignore wrong units within `url` function
              // and within functions listed in the `ignoreFunctions` option
              if (
              valueNode.type === 'function' && (
              valueNode.value.toLowerCase() === 'url' ||
              optionsMatches(options, 'ignoreFunctions', valueNode.value)))
              {
                return false;
              }

              const unit = getUnitFromValueNode(valueNode);

              if (!unit) {
                return;
              }

              if (optionsMatches(options, 'ignoreUnits', unit)) {
                return;
              }

              if (keywordSets.units.has(unit.toLowerCase()) && unit.toLowerCase() !== 'x') {
                return;
              }

              if (unit.toLowerCase() === 'x') {
                if (
                node.type === 'atrule' &&
                node.name === 'media' &&
                node.params.toLowerCase().includes('resolution'))
                {
                  let ignoreUnit = false;

                  mediaParser(node.params).walk((mediaNode, i, mediaNodes) => {
                    const lastMediaNode = mediaNodes[mediaNodes.length - 1];

                    if (
                    mediaNode.value.toLowerCase().includes('resolution') &&
                    lastMediaNode.sourceIndex === valueNode.sourceIndex)
                    {
                      ignoreUnit = true;

                      return false;
                    }
                  });

                  if (ignoreUnit) {
                    return;
                  }
                }

                if (node.type === 'decl') {
                  if (node.prop.toLowerCase() === 'image-resolution') {
                    return;
                  }

                  if (/^(?:-webkit-)?image-set[\s(]/i.test(value)) {
                    const imageSet = parsedValue.nodes.find(
                    n => vendor.unprefixed(n.value) === 'image-set');

                    const imageSetLastNode = imageSet.nodes[imageSet.nodes.length - 1];
                    const imageSetValueLastIndex = imageSetLastNode.sourceIndex;

                    if (imageSetValueLastIndex >= valueNode.sourceIndex) {
                      return;
                    }
                  }
                }
              }

              report({
                index: getIndex(node) + valueNode.sourceIndex,
                message: messages.rejected(unit),
                node,
                result,
                ruleName });

            });
          }

          root.walkAtRules(/^media$/i, atRule => {
            if (!isStandardSyntaxAtRule(atRule)) {
              return;
            }

            check(atRule, atRule.params, atRuleParamIndex);
          });
          root.walkDecls(decl => {
            if (!isStandardSyntaxDeclaration(decl)) {
              return;
            }

            check(decl, decl.value, declarationValueIndex);
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/atRuleParamIndex": 352, "../../utils/declarationValueIndex": 359, "../../utils/getUnitFromValueNode": 374, "../../utils/isStandardSyntaxAtRule": 408, "../../utils/isStandardSyntaxDeclaration": 412, "../../utils/optionsMatches": 429, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "../../utils/vendor": 444, "postcss-media-query-parser": 46, "postcss-value-parser": 83 }], 341: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const getUnitFromValueNode = require('../../utils/getUnitFromValueNode');
      const isCounterIncrementCustomIdentValue = require('../../utils/isCounterIncrementCustomIdentValue');
      const isCounterResetCustomIdentValue = require('../../utils/isCounterResetCustomIdentValue');
      const isStandardSyntaxValue = require('../../utils/isStandardSyntaxValue');
      const keywordSets = require('../../reference/keywordSets');
      const matchesStringOrRegExp = require('../../utils/matchesStringOrRegExp');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueParser = require('postcss-value-parser');
      const { isRegExp, isString } = require('../../utils/validateTypes');

      const ruleName = 'value-keyword-case';

      const messages = ruleMessages(ruleName, {
        expected: (actual, expected) => `Expected "${actual}" to be "${expected}"` });


      // Operators are interpreted as "words" by the value parser, so we want to make sure to ignore them.
      const ignoredCharacters = new Set(['+', '-', '/', '*', '%']);
      const gridRowProps = new Set(['grid-row', 'grid-row-start', 'grid-row-end']);
      const gridColumnProps = new Set(['grid-column', 'grid-column-start', 'grid-column-end']);

      const mapLowercaseKeywordsToCamelCase = new Map();

      for (const func of keywordSets.camelCaseKeywords) {
        mapLowercaseKeywordsToCamelCase.set(func.toLowerCase(), func);
      }

      function rule(expectation, options, context) {
        return (root, result) => {
          const validOptions = validateOptions(
          result,
          ruleName,
          {
            actual: expectation,
            possible: ['lower', 'upper'] },

          {
            actual: options,
            possible: {
              ignoreProperties: [isString, isRegExp],
              ignoreKeywords: [isString, isRegExp],
              ignoreFunctions: [isString, isRegExp] },

            optional: true });



          if (!validOptions) {
            return;
          }

          root.walkDecls(decl => {
            const prop = decl.prop;
            const propLowerCase = decl.prop.toLowerCase();
            const value = decl.value;

            const parsed = valueParser(getDeclarationValue(decl));

            let needFix = false;

            parsed.walk(node => {
              const valueLowerCase = node.value.toLowerCase();

              // Ignore system colors
              if (keywordSets.systemColors.has(valueLowerCase)) {
                return;
              }

              // Ignore keywords within `url` and `var` function
              if (
              node.type === 'function' && (
              valueLowerCase === 'url' ||
              valueLowerCase === 'var' ||
              valueLowerCase === 'counter' ||
              valueLowerCase === 'counters' ||
              valueLowerCase === 'attr'))
              {
                return false;
              }

              // ignore keywords within ignoreFunctions functions

              const ignoreFunctions = options && options.ignoreFunctions || [];

              if (
              node.type === 'function' &&
              ignoreFunctions.length > 0 &&
              matchesStringOrRegExp(valueLowerCase, ignoreFunctions))
              {
                return false;
              }

              const keyword = node.value;

              // Ignore css variables, and hex values, and math operators, and sass interpolation
              if (
              node.type !== 'word' ||
              !isStandardSyntaxValue(node.value) ||
              value.includes('#') ||
              ignoredCharacters.has(keyword) ||
              getUnitFromValueNode(node))
              {
                return;
              }

              if (
              propLowerCase === 'animation' &&
              !keywordSets.animationShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'animation-name' &&
              !keywordSets.animationNameKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font' &&
              !keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'font-family' &&
              !keywordSets.fontFamilyKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'counter-increment' &&
              isCounterIncrementCustomIdentValue(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'counter-reset' && isCounterResetCustomIdentValue(valueLowerCase)) {
                return;
              }

              if (gridRowProps.has(propLowerCase) && !keywordSets.gridRowKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              gridColumnProps.has(propLowerCase) &&
              !keywordSets.gridColumnKeywords.has(valueLowerCase))
              {
                return;
              }

              if (propLowerCase === 'grid-area' && !keywordSets.gridAreaKeywords.has(valueLowerCase)) {
                return;
              }

              if (
              propLowerCase === 'list-style' &&
              !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              if (
              propLowerCase === 'list-style-type' &&
              !keywordSets.listStyleTypeKeywords.has(valueLowerCase))
              {
                return;
              }

              const ignoreKeywords = options && options.ignoreKeywords || [];
              const ignoreProperties = options && options.ignoreProperties || [];

              if (ignoreKeywords.length > 0 && matchesStringOrRegExp(keyword, ignoreKeywords)) {
                return;
              }

              if (ignoreProperties.length > 0 && matchesStringOrRegExp(prop, ignoreProperties)) {
                return;
              }

              const keywordLowerCase = keyword.toLocaleLowerCase();
              let expectedKeyword = null;

              if (expectation === 'lower' && mapLowercaseKeywordsToCamelCase.has(keywordLowerCase)) {
                expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase);
              } else if (expectation === 'lower') {
                expectedKeyword = keyword.toLowerCase();
              } else {
                expectedKeyword = keyword.toUpperCase();
              }

              if (keyword === expectedKeyword) {
                return;
              }

              if (context.fix) {
                needFix = true;
                node.value = expectedKeyword;

                return;
              }

              report({
                message: messages.expected(keyword, expectedKeyword),
                node: decl,
                index: declarationValueIndex(decl) + node.sourceIndex,
                result,
                ruleName });

            });

            if (context.fix && needFix) {
              decl.value = parsed.toString();
            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../reference/keywordSets": 142, "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/getUnitFromValueNode": 374, "../../utils/isCounterIncrementCustomIdentValue": 389, "../../utils/isCounterResetCustomIdentValue": 390, "../../utils/isStandardSyntaxValue": 421, "../../utils/matchesStringOrRegExp": 426, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443, "postcss-value-parser": 83 }], 342: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected newline after ","',
        expectedAfterMultiLine: () => 'Expected newline after "," in a multi-line list',
        rejectedAfterMultiLine: () => 'Unexpected whitespace after "," in a multi-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.afterOneOnly,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null,
            determineIndex: (declString, match) => {
              const nextChars = declString.substr(match.endIndex, declString.length - match.endIndex);

              // If there's a // comment, that means there has to be a newline
              // ending the comment so we're fine
              if (/^[ \t]*\/\//.test(nextChars)) {
                return false;
              }

              // If there are spaces and then a comment begins, look for the newline
              return /^[ \t]*\/\*/.test(nextChars) ?
              declString.indexOf('*/', match.endIndex) + 1 :
              match.startIndex;
            } });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => a - b).reverse()) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (expectation.startsWith('always')) {
                  afterValue = context.newline + afterValue;
                } else if (expectation.startsWith('never-multi-line')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../valueListCommaWhitespaceChecker": 347 }], 343: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const ruleMessages = require('../../utils/ruleMessages');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-newline-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected newline before ","',
        expectedBeforeMultiLine: () => 'Expected newline before "," in a multi-line list',
        rejectedBeforeMultiLine: () => 'Unexpected whitespace before "," in a multi-line list' });


      function rule(expectation) {
        const checker = whitespaceChecker('newline', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'always-multi-line', 'never-multi-line'] });


          if (!validOptions) {
            return;
          }

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.beforeAllowingIndentation,
            checkedRuleName: ruleName });

        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/ruleMessages": 436, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../valueListCommaWhitespaceChecker": 347 }], 344: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-after';

      const messages = ruleMessages(ruleName, {
        expectedAfter: () => 'Expected single space after ","',
        rejectedAfter: () => 'Unexpected whitespace after ","',
        expectedAfterSingleLine: () => 'Expected single space after "," in a single-line list',
        rejectedAfterSingleLine: () => 'Unexpected whitespace after "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.after,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => b - a)) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                const beforeValue = value.slice(0, valueIndex + 1);
                let afterValue = value.slice(valueIndex + 1);

                if (expectation.startsWith('always')) {
                  afterValue = afterValue.replace(/^\s*/, ' ');
                } else if (expectation.startsWith('never')) {
                  afterValue = afterValue.replace(/^\s*/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../valueListCommaWhitespaceChecker": 347 }], 345: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const declarationValueIndex = require('../../utils/declarationValueIndex');
      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const valueListCommaWhitespaceChecker = require('../valueListCommaWhitespaceChecker');
      const whitespaceChecker = require('../../utils/whitespaceChecker');

      const ruleName = 'value-list-comma-space-before';

      const messages = ruleMessages(ruleName, {
        expectedBefore: () => 'Expected single space before ","',
        rejectedBefore: () => 'Unexpected whitespace before ","',
        expectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list',
        rejectedBeforeSingleLine: () => 'Unexpected whitespace before "," in a single-line list' });


      function rule(expectation, options, context) {
        const checker = whitespaceChecker('space', expectation, messages);

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: expectation,
            possible: ['always', 'never', 'always-single-line', 'never-single-line'] });


          if (!validOptions) {
            return;
          }

          let fixData;

          valueListCommaWhitespaceChecker({
            root,
            result,
            locationChecker: checker.before,
            checkedRuleName: ruleName,
            fix: context.fix ?
            (declNode, index) => {
              const valueIndex = declarationValueIndex(declNode);

              if (index <= valueIndex) {
                return false;
              }

              fixData = fixData || new Map();
              const commaIndices = fixData.get(declNode) || [];

              commaIndices.push(index);
              fixData.set(declNode, commaIndices);

              return true;
            } :
            null });


          if (fixData) {
            for (const [decl, commaIndices] of fixData.entries()) {
              for (const index of commaIndices.sort((a, b) => b - a)) {
                const value = getDeclarationValue(decl);
                const valueIndex = index - declarationValueIndex(decl);
                let beforeValue = value.slice(0, valueIndex);
                const afterValue = value.slice(valueIndex);

                if (expectation.startsWith('always')) {
                  beforeValue = beforeValue.replace(/\s*$/, ' ');
                } else if (expectation.startsWith('never')) {
                  beforeValue = beforeValue.replace(/\s*$/, '');
                }

                setDeclarationValue(decl, beforeValue + afterValue);
              }
            }
          }
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/declarationValueIndex": 359, "../../utils/getDeclarationValue": 366, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/whitespaceChecker": 445, "../valueListCommaWhitespaceChecker": 347 }], 346: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const getDeclarationValue = require('../../utils/getDeclarationValue');
      const report = require('../../utils/report');
      const ruleMessages = require('../../utils/ruleMessages');
      const setDeclarationValue = require('../../utils/setDeclarationValue');
      const validateOptions = require('../../utils/validateOptions');
      const { isNumber } = require('../../utils/validateTypes');

      const ruleName = 'value-list-max-empty-lines';

      const messages = ruleMessages(ruleName, {
        expected: max => `Expected no more than ${max} empty ${max === 1 ? 'line' : 'lines'}` });


      function rule(max, options, context) {
        const maxAdjacentNewlines = max + 1;

        return (root, result) => {
          const validOptions = validateOptions(result, ruleName, {
            actual: max,
            possible: isNumber });


          if (!validOptions) {
            return;
          }

          const violatedCRLFNewLinesRegex = new RegExp(`(?:\r\n){${maxAdjacentNewlines + 1},}`);
          const violatedLFNewLinesRegex = new RegExp(`\n{${maxAdjacentNewlines + 1},}`);
          const allowedLFNewLinesString = context.fix ? '\n'.repeat(maxAdjacentNewlines) : '';
          const allowedCRLFNewLinesString = context.fix ? '\r\n'.repeat(maxAdjacentNewlines) : '';

          root.walkDecls(decl => {
            const value = getDeclarationValue(decl);

            if (context.fix) {
              const newValueString = value.
              replace(new RegExp(violatedLFNewLinesRegex, 'gm'), allowedLFNewLinesString).
              replace(new RegExp(violatedCRLFNewLinesRegex, 'gm'), allowedCRLFNewLinesString);

              setDeclarationValue(decl, newValueString);
            } else if (violatedLFNewLinesRegex.test(value) || violatedCRLFNewLinesRegex.test(value)) {
              report({
                message: messages.expected(max),
                node: decl,
                index: 0,
                result,
                ruleName });

            }
          });
        };
      }

      rule.ruleName = ruleName;
      rule.messages = messages;
      module.exports = rule;

    }, { "../../utils/getDeclarationValue": 366, "../../utils/report": 435, "../../utils/ruleMessages": 436, "../../utils/setDeclarationValue": 438, "../../utils/validateOptions": 442, "../../utils/validateTypes": 443 }], 347: [function (require, module, exports) {
      // @ts-nocheck

      'use strict';

      const isStandardSyntaxDeclaration = require('../utils/isStandardSyntaxDeclaration');
      const isStandardSyntaxProperty = require('../utils/isStandardSyntaxProperty');
      const report = require('../utils/report');
      const styleSearch = require('style-search');

      module.exports = function (opts) {
        opts.root.walkDecls(decl => {
          if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {
            return;
          }

          const declString = decl.toString();

          styleSearch(
          {
            source: declString,
            target: ',',
            functionArguments: 'skip' },

          match => {
            const indexToCheckAfter = opts.determineIndex ?
            opts.determineIndex(declString, match) :
            match.startIndex;

            if (indexToCheckAfter === false) {
              return;
            }

            checkComma(declString, indexToCheckAfter, decl);
          });

        });

        function checkComma(source, index, node) {
          opts.locationChecker({
            source,
            index,
            err: m => {
              if (opts.fix && opts.fix(node, index)) {
                return;
              }

              report({
                message: m,
                node,
                index,
                result: opts.result,
                ruleName: opts.checkedRuleName });

            } });

        }
      };

    }, { "../utils/isStandardSyntaxDeclaration": 412, "../utils/isStandardSyntaxProperty": 416, "../utils/report": 435, "style-search": 121 }], 348: [function (require, module, exports) {
      (function (process) {(function () {
          'use strict';

          /* const debug = require('debug')('stylelint:standalone'); */
          /* const fastGlob = require('fast-glob'); */
          /* const fs = require('fs'); */
          /* const globby = require('globby'); */
          /* const normalizePath = require('normalize-path'); */
          /* const path = require('path'); */

          const createStylelint = require('./createStylelint');
          const createStylelintResult = require('./createStylelintResult');
          /* const FileCache = require('./utils/FileCache'); */
          /* const filterFilePaths = require('./utils/filterFilePaths'); */
          const formatters = require('./formatters');
          const getFileIgnorer = require('./utils/getFileIgnorer');
          const getFormatterOptionsText = require('./utils/getFormatterOptionsText');
          /* const hash = require('./utils/hash'); */
          /* const NoFilesFoundError = require('./utils/noFilesFoundError'); */
          /* const pkg = require('../package.json'); */
          const prepareReturnValue = require('./prepareReturnValue');

          const ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];
          /* const writeFileAtomic = require('write-file-atomic'); */

          /** @typedef {import('stylelint').LinterOptions} LinterOptions */
          /** @typedef {import('stylelint').LinterResult} LinterResult */
          /** @typedef {import('stylelint').LintResult} StylelintResult */
          /** @typedef {import('stylelint').Formatter} Formatter */
          /** @typedef {import('stylelint').FormatterType} FormatterType */

          /**
           *
           * @param {LinterOptions} options
           * @returns {Promise<LinterResult>}
           */
          async function standalone({
            allowEmptyInput = false,
            cache: useCache = false,
            cacheLocation,
            code,
            codeFilename,
            config,
            configBasedir,
            configFile,
            customSyntax,
            cwd = process.cwd(),
            disableDefaultIgnores,
            files,
            fix,
            formatter,
            globbyOptions,
            ignoreDisables,
            ignorePath,
            ignorePattern,
            maxWarnings,
            quiet,
            reportDescriptionlessDisables,
            reportInvalidScopeDisables,
            reportNeedlessDisables,
            syntax })
          {
            /** @type {FileCache} */
            let fileCache;
            const startTime = Date.now();

            const isValidCode = typeof code === 'string';

            if (!files && !isValidCode || files && (code || isValidCode)) {
              return Promise.reject(
              new Error('You must pass stylelint a `files` glob or a `code` string, though not both'));

            }

            // The ignorer will be used to filter file paths after the glob is checked,
            // before any files are actually read

            /** @type {import('ignore').Ignore} */
            let ignorer;

            try {
              /* ignorer = getFileIgnorer({ cwd, ignorePath, ignorePattern }); */
            } catch (error) {
              return Promise.reject(error);
            }

            /** @type {Formatter} */
            let formatterFunction;

            try {
              formatterFunction = getFormatterFunction(formatter);
            } catch (error) {
              return Promise.reject(error);
            }

            const stylelint = createStylelint({
              config,
              configFile,
              configBasedir,
              cwd,
              ignoreDisables,
              ignorePath,
              reportNeedlessDisables,
              reportInvalidScopeDisables,
              reportDescriptionlessDisables,
              syntax,
              customSyntax,
              fix,
              quiet });


            if (!files) {
              const absoluteCodeFilename =
              codeFilename !== undefined && ! /* path.isAbsolute(codeFilename) */
              true ?
              path.join(cwd, codeFilename) :
              codeFilename;

              // if file is ignored, return nothing
              if (
              absoluteCodeFilename /* &&
              !filterFilePaths(ignorer, [path.relative(cwd, absoluteCodeFilename)]).length */ &&
              false)
              {
                return prepareReturnValue([], maxWarnings, formatterFunction, cwd);
              }

              let stylelintResult;

              try {
                const postcssResult = await stylelint._lintSource({
                  code,
                  codeFilename: absoluteCodeFilename });


                stylelintResult = await stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);
              } catch (error) {
                stylelintResult = await handleError(stylelint, error);
              }

              const postcssResult = stylelintResult._postcssResult;
              const returnValue = prepareReturnValue([stylelintResult], maxWarnings, formatterFunction, cwd);

              if (
              fix &&
              postcssResult &&
              !postcssResult.stylelint.ignored &&
              !postcssResult.stylelint.ruleDisableFix)
              {
                returnValue.output =
                !postcssResult.stylelint.disableWritingFix && postcssResult.opts ?
                // If we're fixing, the output should be the fixed code
                postcssResult.root.toString(postcssResult.opts.syntax) :
                // If the writing of the fix is disabled, the input code is returned as-is
                code;
              }

              return returnValue;
            }

            /* let fileList = [files].flat().map((entry) => {
            	const globCWD = (globbyOptions && globbyOptions.cwd) || cwd;
            	const absolutePath = !path.isAbsolute(entry)
            		? path.join(globCWD, entry)
            		: path.normalize(entry);
            		if (fs.existsSync(absolutePath)) {
            		// This path points to a file. Return an escaped path to avoid globbing
            		return fastGlob.escapePath(normalizePath(entry));
            	}
            		return entry;
            });
            	if (!disableDefaultIgnores) {
            	fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map((glob) => `!${glob}`));
            }
            	if (useCache) {
            	const stylelintVersion = pkg.version;
            	const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);
            		fileCache = new FileCache(cacheLocation, cwd, hashOfConfig);
            } else {
            	// No need to calculate hash here, we just want to delete cache file.
            	fileCache = new FileCache(cacheLocation, cwd);
            	// Remove cache file if cache option is disabled
            	fileCache.destroy();
            }
            	const effectiveGlobbyOptions = {
            	cwd,
            	...(globbyOptions || {}),
            	absolute: true,
            };
            	const globCWD = effectiveGlobbyOptions.cwd;
            	let filePaths = await globby(fileList, effectiveGlobbyOptions);
            	// The ignorer filter needs to check paths relative to cwd
            filePaths = filterFilePaths(
            	ignorer,
            	filePaths.map((p) => path.relative(globCWD, p)),
            );
            	let stylelintResults;
            	if (filePaths.length) {
            	let absoluteFilePaths = filePaths.map((filePath) => {
            		const absoluteFilepath = !path.isAbsolute(filePath)
            			? path.join(globCWD, filePath)
            			: path.normalize(filePath);
            			return absoluteFilepath;
            	});
            		if (useCache) {
            		absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));
            	}
            		const getStylelintResults = absoluteFilePaths.map(async (absoluteFilepath) => {
            		debug(`Processing ${absoluteFilepath}`);
            			try {
            			const postcssResult = await stylelint._lintSource({
            				filePath: absoluteFilepath,
            			});
            				if (postcssResult.stylelint.stylelintError && useCache) {
            				debug(`${absoluteFilepath} contains linting errors and will not be cached.`);
            				fileCache.removeEntry(absoluteFilepath);
            			}
            				
            			if (
            				postcssResult.root &&
            				postcssResult.opts &&
            				!postcssResult.stylelint.ignored &&
            				fix &&
            				!postcssResult.stylelint.disableWritingFix
            			) {
            				const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);
            					if (
            					postcssResult.root &&
            					postcssResult.root.source &&
            					postcssResult.root.source.input.css !== fixedCss
            				) {
            					await writeFileAtomic(absoluteFilepath, fixedCss);
            				}
            			}
            				return stylelint._createStylelintResult(postcssResult, absoluteFilepath);
            		} catch (error) {
            			// On any error, we should not cache the lint result
            			fileCache.removeEntry(absoluteFilepath);
            				return handleError(stylelint, error, absoluteFilepath);
            		}
            	});
            		stylelintResults = await Promise.all(getStylelintResults);
            } else if (allowEmptyInput) {
            	stylelintResults = await Promise.all([]);
            } else {
            	stylelintResults = await Promise.reject(new NoFilesFoundError(fileList));
            }
            	if (useCache) {
            	fileCache.reconcile();
            }
            	const result = prepareReturnValue(stylelintResults, maxWarnings, formatterFunction, cwd);
            	debug(`Linting complete in ${Date.now() - startTime}ms`);
            	return result; */

























          }

          /**
           * @param {FormatterType | Formatter | undefined} selected
           * @returns {Formatter}
           */
          function getFormatterFunction(selected) {
            /** @type {Formatter} */
            let formatterFunction;

            if (typeof selected === 'string') {
              formatterFunction = formatters[selected];

              if (formatterFunction === undefined) {
                throw new Error(
                `You must use a valid formatter option: ${getFormatterOptionsText()} or a function`);

              }
            } else if (typeof selected === 'function') {
              formatterFunction = selected;
            } else {
              formatterFunction = formatters.json;
            }

            return formatterFunction;
          }

          /**
           * @param {import('stylelint').InternalApi} stylelint
           * @param {any} error
           * @param {string} [filePath]
           * @return {Promise<StylelintResult>}
           */
          function handleError(stylelint, error, filePath = undefined) {
            if (error.name === 'CssSyntaxError') {
              return createStylelintResult(stylelint, undefined, filePath, error);
            }

            throw error;
          }

          module.exports = /** @type {typeof import('stylelint').lint} */standalone;

        }).call(this);}).call(this, require('_process'));
    }, { "./createStylelint": 125, "./createStylelintResult": 126, "./formatters": 129, "./prepareReturnValue": 141, "./utils/getFileIgnorer": 367, "./utils/getFormatterOptionsText": 368, "_process": 115 }], 349: [function (require, module, exports) {
      'use strict';

      /**
       * Add an empty line after a node. Mutates the node.
       *
       * @template {import('postcss').Rule | import('postcss').AtRule} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function addEmptyLineAfter(node, newline) {
        const { raws } = node;

        if (typeof raws.after !== 'string') {
          return node;
        }

        const spaces = raws.after.split(';');
        const after = spaces[spaces.length - 1] || '';

        if (!/\r?\n/.test(after)) {
          raws.after += newline.repeat(2);
        } else {
          raws.after = raws.after.replace(/(\r?\n)/, `${newline}$1`);
        }

        return node;
      };

    }, {}], 350: [function (require, module, exports) {
      'use strict';

      /**
       * Add an empty line before a node. Mutates the node.
       *
       * @template {import('postcss').ChildNode} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function addEmptyLineBefore(node, newline) {
        const { raws } = node;

        if (typeof raws.before !== 'string') {
          return node;
        }

        raws.before = !/\r?\n/.test(raws.before) ?
        newline.repeat(2) + raws.before :
        raws.before.replace(/(\r?\n)/, `${newline}$1`);

        return node;
      };

    }, {}], 351: [function (require, module, exports) {
      'use strict';

      /**
       * Tests if two arrays are equal.
       *
       * @param {unknown} a
       * @param {unknown} b
       * @returns {boolean}
       */
      module.exports = function arrayEqual(a, b) {
        if (!Array.isArray(a) || !Array.isArray(b)) return false;

        if (a.length !== b.length) return false;

        return a.every((elem, index) => elem === b[index]);
      };

    }, {}], 352: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {number}
       */
      module.exports = function (atRule) {
        // Initial 1 is for the `@`
        let index = 1 + atRule.name.length;

        if (atRule.raws.afterName) {
          index += atRule.raws.afterName.length;
        }

        return index;
      };

    }, {}], 353: [function (require, module, exports) {
      'use strict';

      const { isAtRule, isRule } = require('./typeGuards');

      /**
       * @param {import('postcss').Container} statement
       * @returns {string}
       */
      module.exports = function beforeBlockString(statement, { noRawBefore } = { noRawBefore: false }) {
        let result = '';

        const before = statement.raws.before || '';

        if (!noRawBefore) {
          result += before;
        }

        if (isRule(statement)) {
          result += statement.selector;
        } else if (isAtRule(statement)) {
          result += `@${statement.name}${statement.raws.afterName || ''}${statement.params}`;
        } else {
          return '';
        }

        result += statement.raws.between || '';

        return result;
      };

    }, { "./typeGuards": 440 }], 354: [function (require, module, exports) {
      'use strict';

      const beforeBlockString = require('./beforeBlockString');
      const hasBlock = require('./hasBlock');
      const rawNodeString = require('./rawNodeString');

      /**
       * Return a CSS statement's block -- the string that starts and `{` and ends with `}`.
       *
       * If the statement has no block (e.g. `@import url(foo.css);`), returns an empty string.
       *
       * @param {import('postcss').Container} statement
       * @returns {string}
       */
      module.exports = function blockString(statement) {
        if (!hasBlock(statement)) {
          return '';
        }

        return rawNodeString(statement).slice(beforeBlockString(statement).length);
      };

    }, { "./beforeBlockString": 353, "./hasBlock": 375, "./rawNodeString": 432 }], 355: [function (require, module, exports) {
      'use strict';

      /**
       * @param {string} source
       *
       * @returns {string}
       */
      module.exports = function (source, blurChar = ' ') {
        return source.replace(/[#@{}]+/g, blurChar);
      };

    }, {}], 356: [function (require, module, exports) {
      'use strict';

      const normalizeRuleSettings = require('../normalizeRuleSettings');
      const Result = require('postcss/lib/result');
      const rules = require('../rules');

      /**
       * Useful for third-party code (e.g. plugins) to run a PostCSS Root
       * against a specific rule and do something with the warnings
       * @template T
       * @template {Object} O
       * @param {{
      		ruleName: string,
      		ruleSettings: import('stylelint').ConfigRuleSettings<T, O>,
      		root: import('postcss').Root,
      	}} options
       * @param {(warning: import('postcss').Warning) => void} callback
       * @returns {void}
       */
      function checkAgainstRule(options, callback) {
        if (!options)
        throw new Error(
        "checkAgainstRule requires an options object with 'ruleName', 'ruleSettings', and 'root' properties");


        if (!callback) throw new Error('checkAgainstRule requires a callback');

        if (!options.ruleName) throw new Error("checkAgainstRule requires a 'ruleName' option");

        if (!Object.keys(rules).includes(options.ruleName))
        throw new Error(`Rule '${options.ruleName}' does not exist`);

        if (!options.ruleSettings) throw new Error("checkAgainstRule requires a 'ruleSettings' option");

        if (!options.root) throw new Error("checkAgainstRule requires a 'root' option");

        const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName);

        if (!settings) {
          return;
        }

        // @ts-expect-error - this error should not occur with PostCSS 8
        const tmpPostcssResult = new Result();

        rules[options.ruleName](
        settings[0],
        /** @type {O} */settings[1],
        {})(
        options.root, tmpPostcssResult);

        for (const warning of tmpPostcssResult.warnings()) callback(warning);
      }

      module.exports = /** @type {typeof import('stylelint').utils.checkAgainstRule} */
      checkAgainstRule;


    }, { "../normalizeRuleSettings": 139, "../rules": 237, "postcss/lib/result": 106 }], 357: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').ConfigurationError} ConfigurationError */

      /**
       * Create configurationError from text and set CLI exit code
       * @param {string} text
       * @returns {ConfigurationError}
       */
      module.exports = function (text) {
        const err = /** @type {ConfigurationError} */new Error(text);

        err.code = 78;

        return err;
      };

    }, {}], 358: [function (require, module, exports) {
      'use strict';

      const { isString } = require('./validateTypes');

      /** @typedef {false | { match: string, pattern: string }} ReturnValue */

      /**
       * Checks if a string contains a value. The comparison value can be a string or
       * an array of strings.
       *
       * Any strings starting and ending with `/` are ignored. Use the
       * matchesStringOrRegExp() util to match regexes.
       *
       * @param {string} input
       * @param {string | string[]} comparison
       *
       * @returns {ReturnValue}
       */
      module.exports = function containsString(input, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstString(input, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstString(input, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       *
       * @param {string} value
       * @param {string} comparison
       *
       * @returns {ReturnValue}
       */
      function testAgainstString(value, comparison) {
        if (!comparison) return false;

        if (!isString(comparison)) return false;

        if (comparison.startsWith('/') && comparison.endsWith('/')) {
          return false;
        }

        if (value.includes(comparison)) {
          return { match: value, pattern: comparison };
        }

        return false;
      }

    }, { "./validateTypes": 443 }], 359: [function (require, module, exports) {
      'use strict';

      /**
       * Get the index of a declaration's value
       *
       * @param {import('postcss').Declaration} decl
       * @returns {number}
       */
      module.exports = function declarationValueIndex(decl) {
        const raws = decl.raws;

        return [
        // @ts-expect-error -- TODO TYPES `prop` is missing
        raws.prop && raws.prop.prefix,
        // @ts-expect-error -- TODO TYPES `prop` is missing
        raws.prop && raws.prop.raw || decl.prop,
        // @ts-expect-error -- TODO TYPES `prop` is missing
        raws.prop && raws.prop.suffix,
        raws.between || ':',
        // @ts-expect-error -- TODO TYPES `prefix` is missing
        raws.value && raws.value.prefix].
        reduce((count, str) => {
          if (str) {
            return count + str.length;
          }

          return count;
        }, 0);
      };

    }, {}], 360: [function (require, module, exports) {
      'use strict';

      const { isRoot, isAtRule, isRule } = require('./typeGuards');

      /** @typedef {import('postcss').Root} Root */
      /** @typedef {import('postcss').Root} Document */
      /** @typedef {import('postcss').Node} PostcssNode */
      /** @typedef {import('postcss').Container} PostcssContainerNode */
      /** @typedef {import('postcss').Declaration} Declaration */
      /** @typedef {(callbackFn: (decl: Declaration, index: number, decls: Declaration[]) => void) => void} EachDeclaration */

      /**
       * @param {PostcssNode} node
       * @returns {node is PostcssContainerNode}
       */
      function isContainerNode(node) {
        return isRule(node) || isAtRule(node) || isRoot(node);
      }

      /**
       * In order to accommodate nested blocks (postcss-nested),
       * we need to run a shallow loop (instead of eachDecl() or eachRule(),
       * which loop recursively) and allow each nested block to accumulate
       * its own list of properties -- so that a property in a nested rule
       * does not conflict with the same property in the parent rule
       * executes a provided function once for each declaration block.
       *
       * @param {Root | Document} root - root element of file.
       * @param {(eachDecl: EachDeclaration) => void} callback - Function to execute for each declaration block
       *
       * @returns {void}
       */
      module.exports = function eachDeclarationBlock(root, callback) {
        /**
         * @param {PostcssNode} statement
         *
         * @returns {void}
         */
        function each(statement) {
          if (!isContainerNode(statement)) return;

          if (statement.nodes && statement.nodes.length) {
            /** @type {Declaration[]} */
            const decls = [];

            for (const node of statement.nodes) {
              if (node.type === 'decl') {
                decls.push(node);
              }

              each(node);
            }

            if (decls.length) {
              callback(decls.forEach.bind(decls));
            }
          }
        }

        each(root);
      };

    }, { "./typeGuards": 440 }], 361: [function (require, module, exports) {
      'use strict';

      const getUnitFromValueNode = require('./getUnitFromValueNode');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isVariable = require('./isVariable');
      const keywordSets = require('../reference/keywordSets');
      const postcssValueParser = require('postcss-value-parser');

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       * Get the animation name within an `animation` shorthand property value.
       *
       * @param {string} value
       *
       * @returns {Node[]}
       */
      module.exports = function findAnimationName(value) {
        /** @type {Node[]} */
        const animationNames = [];

        const valueNodes = postcssValueParser(value);

        // Handle `inherit`, `initial` and etc
        if (
        valueNodes.nodes.length === 1 &&
        keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase()))
        {
          return [valueNodes.nodes[0]];
        }

        valueNodes.walk(valueNode => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (valueNode.type !== 'word') {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non-standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other animation parts
          if (keywordSets.animationShorthandKeywords.has(valueLowerCase)) {
            return;
          }

          // Ignore numbers with units
          const unit = getUnitFromValueNode(valueNode);

          if (unit || unit === '') {
            return;
          }

          animationNames.push(valueNode);
        });

        return animationNames;
      };

    }, { "../reference/keywordSets": 142, "./getUnitFromValueNode": 374, "./isStandardSyntaxValue": 421, "./isVariable": 424, "postcss-value-parser": 83 }], 362: [function (require, module, exports) {
      'use strict';

      const { isAtRule, isRule } = require('./typeGuards');

      /**
       * Find the at-rule in which a rule is nested.
       *
       * Returns `null` if the rule is not nested within an at-rule.
       *
       * @param {import('postcss').Rule} rule
       * @returns {null | import('postcss').AtRule}
       */
      module.exports = function findAtRuleContext(rule) {
        const parent = rule.parent;

        if (!parent) {
          return null;
        }

        if (isAtRule(parent)) {
          return parent;
        }

        if (isRule(parent)) {
          return findAtRuleContext(parent);
        }

        return null;
      };

    }, { "./typeGuards": 440 }], 363: [function (require, module, exports) {
      'use strict';

      const isNumbery = require('./isNumbery');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const isValidFontSize = require('./isValidFontSize');
      const isVariable = require('./isVariable');
      const keywordSets = require('../reference/keywordSets');
      const postcssValueParser = require('postcss-value-parser');

      const nodeTypesToCheck = new Set(['word', 'string', 'space', 'div']);

      /** @typedef {import('postcss-value-parser').Node} Node */

      /**
       *
       * @param {Node} firstNode
       * @param {Node} secondNode
       * @param {string | null} charactersBetween
       *
       * @returns {Node}
       */
      function joinValueNodes(firstNode, secondNode, charactersBetween) {
        firstNode.value = firstNode.value + charactersBetween + secondNode.value;

        return firstNode;
      }

      /**
       * Get the font-families within a `font` shorthand property value.
       *
       * @param {string} value
       * @returns {Node[]} Collection font-family nodes
       */
      module.exports = function findFontFamily(value) {
        /** @type {Node[]} */
        const fontFamilies = [];

        const valueNodes = postcssValueParser(value);

        // Handle `inherit`, `initial` and etc
        if (
        valueNodes.nodes.length === 1 &&
        keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase()))
        {
          return [valueNodes.nodes[0]];
        }

        let needMergeNodesByValue = false;
        /** @type {string | null} */
        let mergeCharacters = null;

        valueNodes.walk((valueNode, index, nodes) => {
          if (valueNode.type === 'function') {
            return false;
          }

          if (!nodeTypesToCheck.has(valueNode.type)) {
            return;
          }

          const valueLowerCase = valueNode.value.toLowerCase();

          // Ignore non standard syntax
          if (!isStandardSyntaxValue(valueLowerCase)) {
            return;
          }

          // Ignore variables
          if (isVariable(valueLowerCase)) {
            return;
          }

          // Ignore keywords for other font parts
          if (
          keywordSets.fontShorthandKeywords.has(valueLowerCase) &&
          !keywordSets.fontFamilyKeywords.has(valueLowerCase))
          {
            return;
          }

          // Ignore font-sizes
          if (isValidFontSize(valueNode.value)) {
            return;
          }

          // Ignore anything come after a <font-size>/, because it's a line-height
          if (
          nodes[index - 1] &&
          nodes[index - 1].value === '/' &&
          nodes[index - 2] &&
          isValidFontSize(nodes[index - 2].value))
          {
            return;
          }

          // Ignore number values
          if (isNumbery(valueLowerCase)) {
            return;
          }

          // Detect when a space or comma is dividing a list of font-families, and save the joining character.
          if (
          (valueNode.type === 'space' || valueNode.type === 'div' && valueNode.value !== ',') &&
          fontFamilies.length !== 0)
          {
            needMergeNodesByValue = true;
            mergeCharacters = valueNode.value;

            return;
          }

          if (valueNode.type === 'space' || valueNode.type === 'div') {
            return;
          }

          const fontFamily = valueNode;

          if (needMergeNodesByValue) {
            joinValueNodes(fontFamilies[fontFamilies.length - 1], valueNode, mergeCharacters);
            needMergeNodesByValue = false;
            mergeCharacters = null;
          } else {
            fontFamilies.push(fontFamily);
          }
        });

        return fontFamilies;
      };

    }, { "../reference/keywordSets": 142, "./isNumbery": 401, "./isStandardSyntaxValue": 421, "./isValidFontSize": 422, "./isVariable": 424, "postcss-value-parser": 83 }], 364: [function (require, module, exports) {
      'use strict';

      const balancedMatch = require('balanced-match');
      const styleSearch = require('style-search');

      /**
       * Search a CSS string for functions by name.
       * For every match, invoke the callback, passing the function's
       * "argument(s) string" (whatever is inside the parentheses)
       * as an argument.
       *
       * Callback will be called once for every matching function found,
       * with the function's "argument(s) string" and its starting index
       * as the arguments.
       *
       * @param {string} source
       * @param {string} functionName
       * @param {(expression: string, expressionIndex: number) => void} callback
       */
      module.exports = function functionArgumentsSearch(source, functionName, callback) {
        styleSearch(
        {
          source,
          target: functionName,
          functionNames: 'check' },

        match => {
          if (source[match.endIndex] !== '(') {
            return;
          }

          const parensMatch = balancedMatch('(', ')', source.substr(match.startIndex));

          if (!parensMatch) {
            throw new Error(`No parens match: "${source}"`);
          }

          callback(parensMatch.body, match.endIndex + 1);
        });

      };

    }, { "balanced-match": 447, "style-search": 121 }], 365: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {string}
       */
      module.exports = function getAtRuleParams(atRule) {
        const raws = atRule.raws;

        return raws.params && raws.params.raw || atRule.params;
      };

    }, {}], 366: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Declaration} decl
       * @returns {string}
       */
      module.exports = function getDeclarationValue(decl) {
        const raws = decl.raws;

        return raws.value && raws.value.raw || decl.value;
      };

    }, {}], 367: [function (require, module, exports) {
      'use strict';
      // Try to get file ignorer from '.stylelintignore'

      const fs = require('fs');
      const path = require('path');
      const { default: ignore } = require('ignore');

      const isPathNotFoundError = require('./isPathNotFoundError');

      const DEFAULT_IGNORE_FILENAME = '.stylelintignore';

      /**
       * @param {{ cwd: string, ignorePath?: string, ignorePattern?: string[] }} options
       * @return {import('ignore').Ignore}
       */
      module.exports = function getFileIgnorer(options) {
        const ignoreFilePath = options.ignorePath || DEFAULT_IGNORE_FILENAME;
        const absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath) ?
        ignoreFilePath :
        path.resolve(options.cwd, ignoreFilePath);
        let ignoreText = '';

        try {
          ignoreText = fs.readFileSync(absoluteIgnoreFilePath, 'utf8');
        } catch (readError) {
          if (!isPathNotFoundError(readError)) {
            throw readError;
          }
        }

        return ignore().
        add(ignoreText).
        add(options.ignorePattern || []);
      };

    }, { "./isPathNotFoundError": 403, "fs": 5, "ignore": 30, "path": 44 }], 368: [function (require, module, exports) {
      'use strict';

      const formatters = require('../formatters');

      /**
       * @param {{ useOr?: boolean }} [options={}]
       * @returns {string}
       */
      module.exports = function getFormatterOptionsText(options = {}) {
        let output = Object.keys(formatters).
        map(name => `"${name}"`).
        join(', ');

        if (options.useOr) {
          output = output.replace(/, ([a-z"]+)$/u, ' or $1');
        }

        return output;
      };

    }, { "../formatters": 129 }], 369: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node | void} node
       */
      function getNodeLine(node) {
        return node && node.source && node.source.start && node.source.start.line;
      }

      /**
       * @param {Node | void} node
       * @returns {Node | void}
       */
      module.exports = function getNextNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        /** @type {Node | void} */
        const nextNode = node.next();

        if (!nextNode || nextNode.type !== 'comment') {
          return nextNode;
        }

        if (
        getNodeLine(node) === getNodeLine(nextNode) ||
        getNodeLine(nextNode) === getNodeLine(nextNode.next()))
        {
          return getNextNonSharedLineCommentNode(nextNode);
        }

        return nextNode;
      };

    }, {}], 370: [function (require, module, exports) {
      'use strict';

      const os = require('os');

      // This function simply provides roundabout way of getting os.EOL
      // so we can mock this for Jest tests
      function getOsEl() {
        return os.EOL;
      }

      module.exports = getOsEl;

    }, { "os": 43 }], 371: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */

      /**
       * @param {Node} node
       */
      function getNodeLine(node) {
        return node.source && node.source.start && node.source.start.line;
      }

      /**
       * @param {Node | undefined} node
       * @returns {Node | undefined}
       */
      module.exports = function getPreviousNonSharedLineCommentNode(node) {
        if (node === undefined) {
          return undefined;
        }

        const previousNode = node.prev();

        if (!previousNode || previousNode.type !== 'comment') {
          return previousNode;
        }

        if (getNodeLine(node) === getNodeLine(previousNode)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        const previousNode2 = previousNode.prev();

        if (previousNode2 && getNodeLine(previousNode) === getNodeLine(previousNode2)) {
          return getPreviousNonSharedLineCommentNode(previousNode);
        }

        return previousNode;
      };

    }, {}], 372: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Rule} ruleNode
       * @returns {string}
       */
      module.exports = function getRuleSelector(ruleNode) {
        const raws = ruleNode.raws;

        return raws.selector && raws.selector.raw || ruleNode.selector;
      };

    }, {}], 373: [function (require, module, exports) {
      'use strict';

      const { URL } = require('url');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {string} urlString
       */
      module.exports = function (urlString) {
        let protocol = null;

        try {
          protocol = new URL(urlString).protocol;
        } catch (_unused2) {
          return null;
        }

        if (protocol === null || typeof protocol === 'undefined') {
          return null;
        }

        const scheme = protocol.slice(0, -1); // strip trailing `:`

        // The URL spec does not require a scheme to be followed by `//`, but checking
        // for it allows this rule to differentiate <scheme>:<hostname> urls from
        // <hostname>:<port> urls. `data:` scheme urls are an exception to this rule.
        const slashIndex = protocol.length;
        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2);
        const isSchemeLessUrl = expectedSlashes !== '//' && scheme !== 'data';

        if (isSchemeLessUrl) {
          return null;
        }

        return scheme;
      };

    }, { "url": 450 }], 374: [function (require, module, exports) {
      'use strict';

      const blurInterpolation = require('./blurInterpolation');
      const isStandardSyntaxValue = require('./isStandardSyntaxValue');
      const valueParser = require('postcss-value-parser');

      /**
       * Get unit from value node
       *
       * Returns `null` if the unit is not found.
       *
       * @param {import('postcss-value-parser').Node} node
       *
       * @returns {string | null}
       */
      module.exports = function (node) {
        if (!node || !node.value) {
          return null;
        }

        // Ignore non-word nodes
        if (node.type !== 'word') {
          return null;
        }

        // Ignore non standard syntax
        if (!isStandardSyntaxValue(node.value)) {
          return null;
        }

        // Ignore HEX
        if (node.value.startsWith('#')) {
          return null;
        }

        // Remove non standard stuff
        const value = blurInterpolation(node.value, '')
        // ignore hack unit
        .replace('\\0', '').
        replace('\\9', '');

        const parsedUnit = valueParser.unit(value);

        if (!parsedUnit) {
          return null;
        }

        return parsedUnit.unit;
      };

    }, { "./blurInterpolation": 355, "./isStandardSyntaxValue": 421, "postcss-value-parser": 83 }], 375: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an block (empty or otherwise).
       *
       * @param {import('postcss').Container} statement
       * @return {boolean} True if `statement` has a block (empty or otherwise)
       */
      module.exports = function hasBlock(statement) {
        return statement.nodes !== undefined;
      };

    }, {}], 376: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a statement has an empty block.
       *
       * @param {import('postcss').Rule | import('postcss').AtRule} statement - postcss rule or at-rule node
       * @return {boolean} True if the statement has a block and it is empty
       */
      module.exports = function (statement) {
        return (
          statement.nodes !== undefined && statement.nodes.length === 0 // has block
        ); // and is empty
      };

    }, {}], 377: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string contains at least one empty line
       *
       * @param {string | undefined} string
       * @returns {boolean}
       */
      module.exports = function (string) {
        if (string === '' || string === undefined) return false;

        return /\n[\r\t ]*\n/.test(string);
      };

    }, {}], 378: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a string has interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has interpolation
       */
      module.exports = function (string) {
        // SCSS or Less interpolation
        if (
        hasLessInterpolation(string) ||
        hasScssInterpolation(string) ||
        hasTplInterpolation(string) ||
        hasPsvInterpolation(string))
        {
          return true;
        }

        return false;
      };

    }, { "../utils/hasLessInterpolation": 379, "../utils/hasPsvInterpolation": 380, "../utils/hasScssInterpolation": 381, "../utils/hasTplInterpolation": 382 }], 379: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has less interpolation
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has less interpolation
       */
      module.exports = function (string) {
        return /@\{.+?\}/.test(string);
      };

    }, {}], 380: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has postcss-simple-vars interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /\$\(.+?\)/.test(string);
      };

    }, {}], 381: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has scss interpolation
       *
       * @param {string} string
       */
      module.exports = function (string) {
        return /#\{.+?\}/.test(string);
      };

    }, {}], 382: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a string has JS template literal interpolation or HTML-like template
       *
       * @param {string} string
       * @return {boolean} If `true`, a string has template literal interpolation
       */
      module.exports = function (string) {
        return /\{.+?\}/.test(string);
      };

    }, {}], 383: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const previousNode = node.prev();

        if (!previousNode || previousNode.type !== 'comment') {
          return false;
        }

        return !isSharedLineComment(previousNode);
      };

    }, { "./isSharedLineComment": 406 }], 384: [function (require, module, exports) {
      'use strict';

      const isSharedLineComment = require('./isSharedLineComment');

      /**
       * @param {import('postcss').Node} node
       */
      function isAfterSingleLineComment(node) {
        const prevNode = node.prev();

        return (
          prevNode !== undefined &&
          prevNode.type === 'comment' &&
          !isSharedLineComment(prevNode) &&
          prevNode.source &&
          prevNode.source.start &&
          prevNode.source.end &&
          prevNode.source.start.line === prevNode.source.end.line);

      }

      module.exports = isAfterSingleLineComment;

    }, { "./isSharedLineComment": 406 }], 385: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isCustomProperty = require('./isCustomProperty');
      const isStandardSyntaxDeclaration = require('./isStandardSyntaxDeclaration');
      const { isDeclaration } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} node
       */
      module.exports = function (node) {
        const prevNode = getPreviousNonSharedLineCommentNode(node);

        return (
          prevNode !== undefined &&
          isDeclaration(prevNode) &&
          isStandardSyntaxDeclaration(prevNode) &&
          !isCustomProperty(prevNode.prop || ''));

      };

    }, { "./getPreviousNonSharedLineCommentNode": 371, "./isCustomProperty": 393, "./isStandardSyntaxDeclaration": 412, "./typeGuards": 440 }], 386: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const hasBlock = require('./hasBlock');
      const { isAtRule } = require('./typeGuards');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (atRule.type !== 'atrule') {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        if (previousNode === undefined) {
          return false;
        }

        return isAtRule(previousNode) && !hasBlock(previousNode) && !hasBlock(atRule);
      };

    }, { "./getPreviousNonSharedLineCommentNode": 371, "./hasBlock": 375, "./typeGuards": 440 }], 387: [function (require, module, exports) {
      'use strict';

      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const isBlocklessAtRuleAfterBlocklessAtRule = require('./isBlocklessAtRuleAfterBlocklessAtRule');
      const { isAtRule } = require('./typeGuards');

      /**
       * @param {import('postcss').AtRule} atRule
       * @returns {boolean}
       */
      module.exports = function (atRule) {
        if (!isBlocklessAtRuleAfterBlocklessAtRule(atRule)) {
          return false;
        }

        const previousNode = getPreviousNonSharedLineCommentNode(atRule);

        if (previousNode && isAtRule(previousNode)) {
          return previousNode.name === atRule.name;
        }

        return false;
      };

    }, { "./getPreviousNonSharedLineCommentNode": 371, "./isBlocklessAtRuleAfterBlocklessAtRule": 386, "./typeGuards": 440 }], 388: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a node is a context-functional pseudo-class (i.e. either a logical combination
       * or a 'aNPlusBOfSNotationPseudoClasses' / tree-structural pseudo-class)
       *
       * @param {import('postcss-selector-parser').Pseudo} node postcss-selector-parser node (of type pseudo)
       * @return {boolean} If `true`, the node is a context-functional pseudo-class
       */
      module.exports = function isContextFunctionalPseudoClass(node) {
        if (node.type === 'pseudo') {
          const normalisedParentName = node.value.toLowerCase().replace(/:+/, '');

          return (
            keywordSets.logicalCombinationsPseudoClasses.has(normalisedParentName) ||
            keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName));

        }

        return false;
      };

    }, { "../reference/keywordSets": 142 }], 389: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterIncrementKeywords.has(valueLowerCase) ||
        Number.isFinite(Number.parseInt(valueLowerCase, 10)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 142 }], 390: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check value is a custom ident
       *
       * @param {string} value
       */
      module.exports = function (value) {
        const valueLowerCase = value.toLowerCase();

        if (
        keywordSets.counterResetKeywords.has(valueLowerCase) ||
        Number.isFinite(Number.parseInt(valueLowerCase, 10)))
        {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 142 }], 391: [function (require, module, exports) {
      'use strict';

      const htmlTags = require('html-tags');
      const keywordSets = require('../reference/keywordSets');
      const mathMLTags = require('mathml-tag-names');
      const svgTags = require('svg-tags');

      /**
       * Check whether a type selector is a custom element
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (!/^[a-z]/.test(selector)) {
          return false;
        }

        if (!selector.includes('-')) {
          return false;
        }

        const selectorLowerCase = selector.toLowerCase();

        if (selectorLowerCase !== selector) {
          return false;
        }

        if (svgTags.includes(selectorLowerCase)) {
          return false;
        }

        if (htmlTags.includes(selectorLowerCase)) {
          return false;
        }

        if (keywordSets.nonStandardHtmlTags.has(selectorLowerCase)) {
          return false;
        }

        if (mathMLTags.includes(selectorLowerCase)) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 142, "html-tags": 28, "mathml-tag-names": 40, "svg-tags": 448 }], 392: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media query is a custom
       * @param {string} mediaQuery
       * @returns {boolean}
       */
      module.exports = function (mediaQuery) {
        return mediaQuery.startsWith('--');
      };

    }, {}], 393: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is a custom one
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        return property.startsWith('--');
      };

    }, {}], 394: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a selector is a custom one
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        return selector.startsWith(':--');
      };

    }, {}], 395: [function (require, module, exports) {
      'use strict';

      const { isComment, hasSource } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} statement
       * @returns {boolean}
       */
      module.exports = function (statement) {
        const parentNode = statement.parent;

        if (parentNode === undefined || parentNode.type === 'root') {
          return false;
        }

        if (statement === parentNode.first) {
          return true;
        }

        /*
         * Search for the statement in the parent's nodes, ignoring comment
         * nodes on the same line as the parent's opening brace.
         */

        const parentNodes = parentNode.nodes;

        if (!parentNodes) {
          return false;
        }

        const firstNode = parentNodes[0];

        if (
        !isComment(firstNode) ||
        typeof firstNode.raws.before === 'string' && firstNode.raws.before.includes('\n'))
        {
          return false;
        }

        if (!hasSource(firstNode) || !firstNode.source.start) {
          return false;
        }

        const openingBraceLine = firstNode.source.start.line;

        if (!firstNode.source.end || openingBraceLine !== firstNode.source.end.line) {
          return false;
        }

        for (let i = 1; i < parentNodes.length; i++) {
          const node = parentNodes[i];

          if (node === statement) {
            return true;
          }

          if (
          !isComment(node) ||
          hasSource(node) && node.source.end && node.source.end.line !== openingBraceLine)
          {
            return false;
          }
        }

        /* istanbul ignore next: Should always return in the loop */
        return false;
      };

    }, { "./typeGuards": 440 }], 396: [function (require, module, exports) {
      'use strict';

      const { isRoot } = require('./typeGuards');

      /**
       * @param {import('postcss').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        if (isRoot(node)) return false;

        const parentNode = node.parent;

        if (!parentNode) {
          return false;
        }

        return isRoot(parentNode) && node === parentNode.first;
      };

    }, { "./typeGuards": 440 }], 397: [function (require, module, exports) {
      'use strict';

      const { isAtRule } = require('./typeGuards');

      /**
       * Check if a rule is a keyframe one
       *
       * @param {import('postcss').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        const parent = rule.parent;

        if (!parent) {
          return false;
        }

        return isAtRule(parent) && parent.name.toLowerCase() === 'keyframes';
      };

    }, { "./typeGuards": 440 }], 398: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a string is a keyframe selector.
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        if (keywordSets.keyframeSelectorKeywords.has(selector)) {
          return true;
        }

        // Percentages
        if (/^(?:\d+|\d*\.\d+)%$/.test(selector)) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 142 }], 399: [function (require, module, exports) {
      'use strict';

      const MATH_FUNCTIONS = require('../reference/mathFunctions');

      /**
       * Check whether a node is math function
       *
       * @param {import('postcss-value-parser').Node} node postcss-value-parser node
       * @return {boolean} If `true`, the node is math function
       */
      module.exports = function isMathFunction(node) {
        return node.type === 'function' && MATH_FUNCTIONS.includes(node.value.toLowerCase());
      };

    }, { "../reference/mathFunctions": 143 }], 400: [function (require, module, exports) {
      'use strict';

      /**
       * @param {unknown} value
       */
      module.exports = function isNonNegativeInteger(value) {
        return Number.isInteger(value) && typeof value === 'number' && value >= 0;
      };

    }, {}], 401: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether it's a number or a number-like string:
       * i.e. when coerced to a number it == itself.
       *
       * @param {string | number} value
       */
      module.exports = function (value) {
        /* eslint-disable eqeqeq */
        return value.toString().trim().length !== 0 && Number(value) == value;
        /* eslint-enable eqeqeq */
      };

    }, {}], 402: [function (require, module, exports) {
      'use strict';

      const isWhitespace = require('./isWhitespace');

      /**
       * Returns a Boolean indicating whether the the input string is only whitespace.
       *
       * @param {string} input
       * @returns {boolean}
       */
      module.exports = function (input) {
        let isOnlyWhitespace = true;

        for (const element of input) {
          if (!isWhitespace(element)) {
            isOnlyWhitespace = false;
            break;
          }
        }

        return isOnlyWhitespace;
      };

    }, { "./isWhitespace": 425 }], 403: [function (require, module, exports) {
      'use strict';

      const util = require('util');

      /**
       * @param {unknown} error
       * @returns {error is NodeJS.ErrnoException}
       */
      module.exports = function isPathNotFoundError(error) {
        // @ts-expect-error -- TS2339: Property 'code' does not exist on type 'Error'.
        return util.types.isNativeError(error) && error.code === 'ENOENT';
      };

    }, { "util": 455 }], 404: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature is a range context one
       *
       * @param {string} mediaFeature feature
       * @return {boolean} If `true`, media feature is a range context one
       */
      module.exports = function (mediaFeature) {
        return mediaFeature.includes('=') || mediaFeature.includes('<') || mediaFeature.includes('>');
      };

    }, {}], 405: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a property is SCSS variable
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))
        if (property.startsWith('$')) {
          return true;
        }

        // SCSS var within a namespace (e.g. namespace.$var: x)
        if (property.includes('.$')) {
          return true;
        }

        return false;
      };

    }, {}], 406: [function (require, module, exports) {
      'use strict';

      const getNextNonSharedLineCommentNode = require('./getNextNonSharedLineCommentNode');
      const getPreviousNonSharedLineCommentNode = require('./getPreviousNonSharedLineCommentNode');
      const { isRoot, isComment } = require('./typeGuards');

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       *
       * @param {PostcssNode | void} a
       * @param {PostcssNode | void} b
       */
      function nodesShareLines(a, b) {
        const aLine = a && a.source && a.source.end && a.source.end.line;
        const bLine = b && b.source && b.source.start && b.source.start.line;

        return aLine === bLine;
      }

      /**
       * @param {PostcssNode} node
       * @returns {boolean}
       */
      module.exports = function isSharedLineComment(node) {
        if (!isComment(node)) {
          return false;
        }

        const previousNonSharedLineCommentNode = getPreviousNonSharedLineCommentNode(node);

        if (nodesShareLines(previousNonSharedLineCommentNode, node)) {
          return true;
        }

        const nextNonSharedLineCommentNode = getNextNonSharedLineCommentNode(node);

        if (nextNonSharedLineCommentNode && nodesShareLines(node, nextNonSharedLineCommentNode)) {
          return true;
        }

        const parentNode = node.parent;

        // It's a first child and located on the same line as block start
        if (
        parentNode !== undefined &&
        !isRoot(parentNode) &&
        parentNode.index(node) === 0 &&
        node.raws.before !== undefined &&
        !node.raws.before.includes('\n'))
        {
          return true;
        }

        return false;
      };

    }, { "./getNextNonSharedLineCommentNode": 369, "./getPreviousNonSharedLineCommentNode": 371, "./typeGuards": 440 }], 407: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a string is a single line (i.e. does not contain
       * any newline characters).
       *
       * @param {string} input
       * @return {boolean}
       */
      module.exports = function (input) {
        return !/[\n\r]/.test(input);
      };

    }, {}], 408: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a at-rule is standard
       *
       * @param {import('postcss').AtRule | import('postcss-less').AtRule} atRule postcss at-rule node
       * @return {boolean} If `true`, the declaration is standard
       */
      module.exports = function (atRule) {
        // Ignore scss `@content` inside mixins
        if (!atRule.nodes && atRule.params === '') {
          return false;
        }

        // Ignore Less mixins
        if ('mixin' in atRule && atRule.mixin) {
          return false;
        }

        // Ignore Less detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`
        if (
        'variable' in atRule && atRule.variable ||
        !atRule.nodes && atRule.raws.afterName === '' && atRule.params[0] === '(')
        {
          return false;
        }

        return true;
      };

    }, {}], 409: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxFunction = require('./isStandardSyntaxFunction');

      /**
       * Check whether a function is standard syntax color function
       *
       * @param {import('postcss-value-parser').FunctionNode} node
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxColorFunction(node) {
        if (!isStandardSyntaxFunction(node)) return false;

        // scss can accept a #hex, or $var variables and we need to check all nested fn nodes
        for (const fnNode of node.nodes) {
          if (fnNode.type === 'function') return isStandardSyntaxColorFunction(fnNode);

          if (fnNode.type === 'word' && (fnNode.value.startsWith('#') || fnNode.value.startsWith('$')))
          return false;
        }

        return true;
      };

    }, { "./isStandardSyntaxFunction": 413 }], 410: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a combinator is standard
       *
       * @param {import('postcss-selector-parser').Combinator} node postcss-selector-parser node (of type combinator)
       * @return {boolean} If `true`, the combinator is standard
       */
      module.exports = function (node) {
        // if it's not a combinator, then it's not a standard combinator
        if (node.type !== 'combinator') {
          return false;
        }

        // Ignore reference combinators like `/deep/`
        if (node.value.startsWith('/') || node.value.endsWith('/')) {
          return false;
        }

        // ignore the combinators that are the first or last node in their container
        if (node.parent !== undefined && node.parent !== null) {
          const parent = node.parent;

          if (node === parent.first) {
            return false;
          }

          if (node === parent.last) {
            return false;
          }
        }

        return true;
      };

    }, {}], 411: [function (require, module, exports) {
      'use strict';

      /**
       * @param {import('postcss').Comment} comment
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxComment(comment) {
        // We check both here because the Sass parser uses `raws.inline` to indicate
        // inline comments, while the Less parser uses `inline`.
        if ('inline' in comment) return false;

        if ('inline' in comment.raws) return false;

        return true;
      };

    }, {}], 412: [function (require, module, exports) {
      'use strict';

      const isScssVariable = require('./isScssVariable');
      const { isRoot, isRule } = require('./typeGuards');

      /**
       * @param {string} [lang]
       */
      function isStandardSyntaxLang(lang) {
        return lang && (lang === 'css' || lang === 'custom-template' || lang === 'template-literal');
      }

      /**
       * Check whether a declaration is standard
       *
       * @param {import('postcss').Declaration | import('postcss-less').Declaration} decl
       */
      module.exports = function (decl) {
        const prop = decl.prop;
        const parent = decl.parent;

        // Declarations belong in a declaration block or standard CSS source
        if (
        parent &&
        isRoot(parent) &&
        parent.source &&
        !isStandardSyntaxLang(
        /** @type {import('postcss').Source & {lang?: string}} */parent.source.lang))

        {
          return false;
        }

        // SCSS var; covers map and list declarations
        if (isScssVariable(prop)) {
          return false;
        }

        // Less var (e.g. @var: x), but exclude variable interpolation (e.g. @{var})
        if (prop[0] === '@' && prop[1] !== '{') {
          return false;
        }

        // Less map declaration
        if (parent && parent.type === 'atrule' && parent.raws.afterName === ':') {
          return false;
        }

        // Less map (e.g. #my-map() { myprop: red; })
        if (
        parent &&
        isRule(parent) &&
        parent.selector &&
        parent.selector.startsWith('#') &&
        parent.selector.endsWith('()'))
        {
          return false;
        }

        // Sass nested properties (e.g. border: { style: solid; color: red; })
        if (
        parent &&
        isRule(parent) &&
        parent.selector &&
        parent.selector[parent.selector.length - 1] === ':' &&
        parent.selector.substring(0, 2) !== '--')
        {
          return false;
        }

        // Less &:extend
        if ('extend' in decl && decl.extend) {
          return false;
        }

        return true;
      };

    }, { "./isScssVariable": 405, "./typeGuards": 440 }], 413: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a function is standard
       *
       * @param {import('postcss-value-parser').Node} node
       * @returns {boolean}
       */
      module.exports = function (node) {
        // Function nodes without names are things in parentheses like Sass lists
        if (!node.value) {
          return false;
        }

        return true;
      };

    }, {}], 414: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a hex color is standard
       *
       * @param {string} hex
       * @returns {boolean}
       */
      module.exports = function isStandardSyntaxHexColor(hex) {
        // Less map usage (e.g. .myclass { color: #colors[somecolor]; })
        if (hex.includes('[')) {
          return false;
        }

        return true;
      };

    }, {}], 415: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a media feature name is standard
       *
       * @param {string} mediaFeatureName
       * @returns {boolean}
       */
      module.exports = function (mediaFeatureName) {
        // SCSS interpolation
        if (/#\{.+?\}|\$.+/.test(mediaFeatureName)) {
          return false;
        }

        return true;
      };

    }, {}], 416: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');
      const isScssVariable = require('./isScssVariable');

      /**
       * Check whether a property is standard
       *
       * @param {string} property
       * @returns {boolean}
       */
      module.exports = function (property) {
        // SCSS var
        if (isScssVariable(property)) {
          return false;
        }

        // Less var (e.g. @var: x)
        if (property.startsWith('@')) {
          return false;
        }

        // Less append property value with space (e.g. transform+_: scale(2))
        if (property.endsWith('+') || property.endsWith('+_')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(property)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 378, "./isScssVariable": 405 }], 417: [function (require, module, exports) {
      'use strict';

      const isStandardSyntaxSelector = require('../utils/isStandardSyntaxSelector');

      /**
       * Check whether a Node is a standard rule
       *
       * @param {import('postcss').Rule | import('postcss-less').Rule} rule
       * @returns {boolean}
       */
      module.exports = function (rule) {
        if (rule.type !== 'rule') {
          return false;
        }

        // Ignore Less &:extend rule
        if ('extend' in rule && rule.extend) {
          return false;
        }

        if (!isStandardSyntaxSelector(rule.selector)) {
          return false;
        }

        return true;
      };

    }, { "../utils/isStandardSyntaxSelector": 418 }], 418: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a selector is standard
       *
       * @param {string} selector
       * @returns {boolean}
       */
      module.exports = function (selector) {
        // SCSS or Less interpolation
        if (hasInterpolation(selector)) {
          return false;
        }

        // SCSS placeholder selectors
        if (selector.startsWith('%')) {
          return false;
        }

        // SCSS nested properties
        if (selector.endsWith(':')) {
          return false;
        }

        // Less :extend()
        if (/:extend(?:\(.*?\))?/.test(selector)) {
          return false;
        }

        // Less mixin with resolved nested selectors (e.g. .foo().bar or .foo(@a, @b)[bar])
        if (/\.[\w-]+\(.*\).+/.test(selector)) {
          return false;
        }

        // Less non-outputting mixin definition (e.g. .mixin() {})
        if (selector.endsWith(')') && !selector.includes(':')) {
          return false;
        }

        // Less Parametric mixins (e.g. .mixin(@variable: x) {})
        if (/\(@.*\)$/.test(selector)) {
          return false;
        }

        // ERB template tags
        if (selector.includes('<%') || selector.includes('%>')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 378 }], 419: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');

      /**
       * Check whether a type selector is standard
       *
       * @param {import('postcss-selector-parser').Tag} node postcss-selector-parser node (of type tag)
       * @return {boolean} If `true`, the type selector is standard
       */
      module.exports = function (node) {
        // postcss-selector-parser includes the arguments to nth-child() functions
        // as "tags", so we need to ignore them ourselves.
        // The fake-tag's "parent" is actually a selector node, whose parent
        // should be the :nth-child pseudo node.
        if (!node.parent || !node.parent.parent) {
          return false;
        }

        const _node$parent$parent = node.parent.parent;
        const parentType = _node$parent$parent.type;
        const parentValue = _node$parent$parent.value;

        if (parentValue) {
          const normalisedParentName = parentValue.toLowerCase().replace(/:+/, '');

          if (
          parentType === 'pseudo' && (
          keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.aNPlusBOfSNotationPseudoClasses.has(normalisedParentName) ||
          keywordSets.linguisticPseudoClasses.has(normalisedParentName) ||
          keywordSets.shadowTreePseudoElements.has(normalisedParentName)))
          {
            return false;
          }
        }

        // &-bar is a nesting selector combined with a suffix
        if (node.prev() && node.prev().type === 'nesting') {
          return false;
        }

        if (node.value.startsWith('%')) {
          return false;
        }

        // Reference combinators like `/deep/`
        if (node.value.startsWith('/') && node.value.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../reference/keywordSets": 142 }], 420: [function (require, module, exports) {
      'use strict';

      const hasLessInterpolation = require('../utils/hasLessInterpolation');
      const hasPsvInterpolation = require('../utils/hasPsvInterpolation');
      const hasScssInterpolation = require('../utils/hasScssInterpolation');
      const hasTplInterpolation = require('../utils/hasTplInterpolation');

      /**
       * Check whether a URL is standard
       *
       * @param {string} url
       * @returns {boolean}
       */
      module.exports = function (url) {
        if (url.length === 0) {
          return true;
        }

        // Sass interpolation works anywhere
        if (hasScssInterpolation(url) || hasTplInterpolation(url) || hasPsvInterpolation(url)) {
          return false;
        }

        // Inside `'` and `"` work only LESS interpolation
        if (url.startsWith(`'`) && url.endsWith(`'`) || url.startsWith(`"`) && url.endsWith(`"`)) {
          if (hasLessInterpolation(url)) {
            return false;
          }

          return true;
        }

        // Less variable works only at the beginning
        // Check is less variable, allow use '@url/some/path'
        // https://github.com/less/less.js/blob/3.x/lib/less/parser/parser.js#L547
        if (url.startsWith('@') && /^@@?[\w-]+$/.test(url)) {
          return false;
        }

        // In url without quotes scss variable can be everywhere
        // But in this case it is allowed to use only specific characters
        // Also forbidden "/" at the end of url
        if (url.includes('$') && /^[$\s\w+\-,./*'"]+$/.test(url) && !url.endsWith('/')) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasLessInterpolation": 379, "../utils/hasPsvInterpolation": 380, "../utils/hasScssInterpolation": 381, "../utils/hasTplInterpolation": 382 }], 421: [function (require, module, exports) {
      'use strict';

      const hasInterpolation = require('../utils/hasInterpolation');

      /**
       * Check whether a value is standard
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        let normalizedValue = value;

        // Ignore operators before variables (example -$variable)
        if (/^[-+*/]/.test(value[0])) {
          normalizedValue = normalizedValue.slice(1);
        }

        // SCSS variable (example $variable)
        if (normalizedValue.startsWith('$')) {
          return false;
        }

        // SCSS namespace (example namespace.$variable)
        if (/^.+\.\$/.test(value)) {
          return false;
        }

        // Less variable
        if (normalizedValue.startsWith('@')) {
          return false;
        }

        // SCSS or Less interpolation
        if (hasInterpolation(normalizedValue)) {
          return false;
        }

        // WebExtension replacement keyword used by Chrome/Firefox
        // more information: https://developer.chrome.com/extensions/i18n
        // and https://github.com/stylelint/stylelint/issues/4707
        if (/__MSG_\S+__/.test(value)) {
          return false;
        }

        return true;
      };

    }, { "../utils/hasInterpolation": 378 }], 422: [function (require, module, exports) {
      'use strict';

      const keywordSets = require('../reference/keywordSets');
      const valueParser = require('postcss-value-parser');

      /**
       * Check if a word is a font-size value.
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        if (!word) {
          return false;
        }

        if (keywordSets.fontSizeKeywords.has(word)) {
          return true;
        }

        const numberUnit = valueParser.unit(word);

        if (!numberUnit) {
          return false;
        }

        const unit = numberUnit.unit;

        if (unit === '%') {
          return true;
        }

        if (keywordSets.lengthUnits.has(unit.toLowerCase())) {
          return true;
        }

        return false;
      };

    }, { "../reference/keywordSets": 142, "postcss-value-parser": 83 }], 423: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a value is a valid 3, 4, 6 or 8 digit hex
       *
       * @param {string} value
       * @returns {boolean}
       */
      module.exports = function (value) {
        return /^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(value);
      };

    }, {}], 424: [function (require, module, exports) {
      'use strict';

      /**
       * Check whether a word is a variable i.e var(--custom-property).
       *
       * @param {string} word
       * @returns {boolean}
       */
      module.exports = function (word) {
        return word.toLowerCase().startsWith('var(');
      };

    }, {}], 425: [function (require, module, exports) {
      'use strict';

      /**
       * Check if a character is whitespace.
       *
       * @param {string} char
       * @returns {boolean}
       */
      module.exports = function (char) {
        return [' ', '\n', '\t', '\r', '\f'].includes(char);
      };

    }, {}], 426: [function (require, module, exports) {
      'use strict';

      /**
       * Compares a string to a second value that, if it fits a certain convention,
       * is converted to a regular expression before the comparison.
       * If it doesn't fit the convention, then two strings are compared.
       *
       * Any strings starting and ending with `/` are interpreted
       * as regular expressions.
       *
       * @param {string} input
       * @param {string | RegExp | Array<string | RegExp>} comparison
       *
       * @returns {false | {match: string, pattern: (string | RegExp) }}
       */
      module.exports = function matchesStringOrRegExp(input, comparison) {
        if (!Array.isArray(input)) {
          return testAgainstStringOrRegExpOrArray(input, comparison);
        }

        for (const inputItem of input) {
          const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      };

      /**
       * @param {string} value
       * @param {string | RegExp | Array<string | RegExp>} comparison
       */
      function testAgainstStringOrRegExpOrArray(value, comparison) {
        if (!Array.isArray(comparison)) {
          return testAgainstStringOrRegExp(value, comparison);
        }

        for (const comparisonItem of comparison) {
          const testResult = testAgainstStringOrRegExp(value, comparisonItem);

          if (testResult) {
            return testResult;
          }
        }

        return false;
      }

      /**
       * @param {string} value
       * @param {string | RegExp} comparison
       */
      function testAgainstStringOrRegExp(value, comparison) {
        // If it's a RegExp, test directly
        if (comparison instanceof RegExp) {
          return comparison.test(value) ? { match: value, pattern: comparison } : false;
        }

        // Check if it's RegExp in a string
        const firstComparisonChar = comparison[0];
        const lastComparisonChar = comparison[comparison.length - 1];
        const secondToLastComparisonChar = comparison[comparison.length - 2];

        const comparisonIsRegex =
        firstComparisonChar === '/' && (
        lastComparisonChar === '/' ||
        secondToLastComparisonChar === '/' && lastComparisonChar === 'i');

        const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';

        // If so, create a new RegExp from it
        if (comparisonIsRegex) {
          const valueMatches = hasCaseInsensitiveFlag ?
          new RegExp(comparison.slice(1, -2), 'i').test(value) :
          new RegExp(comparison.slice(1, -1)).test(value);

          return valueMatches ? { match: value, pattern: comparison } : false;
        }

        // Otherwise, it's a string. Do a strict comparison
        return value === comparison ? { match: value, pattern: comparison } : false;
      }

    }, {}], 427: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} PostcssNode */

      /**
       * Get the next non-comment node in a PostCSS AST
       * at or after a given node.
       *
       * @param {PostcssNode | void} startNode
       * @returns {PostcssNode | null}
       */
      module.exports = function nextNonCommentNode(startNode) {
        if (!startNode || !startNode.next) return null;

        if (startNode.type === 'comment') {
          return nextNonCommentNode(startNode.next());
        }

        return startNode;
      };

    }, {}], 428: [function (require, module, exports) {
      'use strict';

      /**
       * Create a collection of Maps that serve to contextualize a given node.
       * This is useful to ensure that you only compare nodes that share a certain
       * context.
       *
       * All nodes are initially contextualized by their input source.
       * From there, you can contextualize them however you want.
       *
       * For a usage example, see `selector-no-descending-specificity`.
       */
      module.exports = function nodeContextLookup() {
        const contextMap = new Map();

        return {
          /**
           * @param {import('postcss').Node} node
           * @param {any[]} subContexts
           * @returns {Map<any, any>}
           */
          getContext(node, ...subContexts) {
            if (!node.source) throw new Error('The node source must be present');

            const nodeSource = node.source.input.from;
            const baseContext = creativeGetMap(contextMap, nodeSource);

            return subContexts.reduce((result, context) => creativeGetMap(result, context), baseContext);
          } };

      };

      /**
       * TODO TYPES
       * @param {Map<any, any>} someMap
       * @param {any} someThing
       */
      function creativeGetMap(someMap, someThing) {
        if (!someMap.has(someThing)) {
          someMap.set(someThing, new Map());
        }

        return someMap.get(someThing);
      }

    }, {}], 429: [function (require, module, exports) {
      'use strict';

      const matchesStringOrRegExp = require('./matchesStringOrRegExp');

      /**
       * Check if an options object's propertyName contains a user-defined string or
       * regex that matches the passed in input.
       *
       * @param {{ [x: string]: any; }} options
       * @param {string} propertyName
       * @param {string} input
       *
       * @returns {boolean}
       */
      module.exports = function optionsMatches(options, propertyName, input) {
        return Boolean(
        options &&
        options[propertyName] &&
        typeof input === 'string' &&
        matchesStringOrRegExp(input, options[propertyName]));

      };

    }, { "./matchesStringOrRegExp": 426 }], 430: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {string} selector
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Node} node
       * @param {(root: import('postcss-selector-parser').Root) => void} callback
       */
      module.exports = function parseSelector(selector, result, node, callback) {
        try {
          return selectorParser(callback).processSync(selector);
        } catch (_unused3) {
          result.warn('Cannot parse selector', { node, stylelintType: 'parseError' });
        }
      };

    }, { "postcss-selector-parser": 53 }], 431: [function (require, module, exports) {
      'use strict';

      /**
       * If `map` already has the given `key`, returns its value. Otherwise, calls
       * `callback`, adds the result to `map` at `key`, and then returns it.
       *
       * @template K
       * @template V
       * @param {Map<K, V>} map
       * @param {K} key
       * @param {() => V} callback
       * @returns {V}
       */
      module.exports = function (map, key, callback) {
        if (map.has(key)) return (/** @type {V} */map.get(key));

        const value = callback();

        map.set(key, value);

        return value;
      };

    }, {}], 432: [function (require, module, exports) {
      'use strict';

      /**
       * Stringify PostCSS node including its raw "before" string.
       *
       * @param {import('postcss').Node} node
       *
       * @returns {string}
       */
      module.exports = function (node) {
        let result = '';

        if (node.raws.before) {
          result += node.raws.before;
        }

        result += node.toString();

        return result;
      };

    }, {}], 433: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @template {import('postcss').Rule | import('postcss').AtRule} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function removeEmptyLinesAfter(node, newline) {
        node.raws.after = node.raws.after ? node.raws.after.replace(/(\r?\n\s*\n)+/g, newline) : '';

        return node;
      };

    }, {}], 434: [function (require, module, exports) {
      'use strict';

      /**
       * Remove empty lines before a node. Mutates the node.
       *
       * @template {import('postcss').Node} T
       * @param {T} node
       * @param {string} newline
       * @returns {T}
       */
      module.exports = function removeEmptyLinesBefore(node, newline) {
        node.raws.before = node.raws.before ? node.raws.before.replace(/(\r?\n\s*\n)+/g, newline) : '';

        return node;
      };

    }, {}], 435: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('stylelint').Problem} Problem */

      /**
       * Report a problem.
       *
       * This function accounts for `disabledRanges` attached to the result.
       * That is, if the reported problem is within a disabledRange,
       * it is ignored. Otherwise, it is attached to the result as a
       * postcss warning.
       *
       * It also accounts for the rule's severity.
       *
       * You *must* pass *either* a node or a line number.
       * @param {Problem} problem
       * @returns {void}
       */
      function report(problem) {
        const ruleName = problem.ruleName;
        const result = problem.result;
        const message = problem.message;
        const line = problem.line;
        const node = problem.node;
        const index = problem.index;
        const word = problem.word;

        result.stylelint = result.stylelint || {
          ruleSeverities: {},
          customMessages: {} };


        // In quiet mode, mere warnings are ignored
        if (result.stylelint.quiet && result.stylelint.ruleSeverities[ruleName] !== 'error') {
          return;
        }

        // If a line is not passed, use the node.positionBy method to get the
        // line number that the complaint pertains to
        // @ts-expect-error -- The type of `Node.prototype.positionBy()` is not be exposed.
        const startLine = line || node.positionBy({ index }).line;

        const { ignoreDisables } = result.stylelint.config || {};

        if (result.stylelint.disabledRanges) {
          const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all;

          for (const range of ranges) {
            if (
            // If the problem is within a disabledRange,
            // and that disabledRange's rules include this one,
            // do not register a warning
            range.start <= startLine && (
            range.end === undefined || range.end >= startLine) && (
            !range.rules || range.rules.includes(ruleName)))
            {
              // Collect disabled warnings
              // Used to report `needlessDisables` in subsequent processing.
              const disabledWarnings =
              result.stylelint.disabledWarnings || (result.stylelint.disabledWarnings = []);

              disabledWarnings.push({
                rule: ruleName,
                line: startLine });


              if (!ignoreDisables) {
                return;
              }

              break;
            }
          }
        }

        const severity = result.stylelint.ruleSeverities && result.stylelint.ruleSeverities[ruleName];

        if (!result.stylelint.stylelintError && severity === 'error') {
          result.stylelint.stylelintError = true;
        }

        /** @type {import('stylelint').WarningOptions} */
        const warningProperties = {
          severity,
          rule: ruleName };


        if (node) {
          warningProperties.node = node;
        }

        if (index) {
          warningProperties.index = index;
        }

        if (word) {
          warningProperties.word = word;
        }

        const warningMessage =
        result.stylelint.customMessages && result.stylelint.customMessages[ruleName] || message;

        result.warn(warningMessage, warningProperties);
      }

      module.exports = /** @type {typeof import('stylelint').utils.report} */report;

    }, {}], 436: [function (require, module, exports) {
      'use strict';

      /**
       * Given an object of problem messages, return another
       * that provides the same messages postfixed with the rule
       * that has been violated.
       *
       * @template {import('stylelint').RuleMessages} T
       * @template {{[K in keyof T]: T[K]}} R
       * @param {string} ruleName
       * @param {T} messages - Object whose keys are message identifiers
       *   and values are either message strings or functions that return message strings
       * @returns {R} New message object, whose messages will be marked with the rule name
       */
      function ruleMessages(ruleName, messages) {
        /** @typedef {keyof T} K */
        const newMessages = /** @type {R} */{};

        for (const [messageId, messageText] of /** @type {[K, T[K]][]} */Object.entries(messages)) {
          if (typeof messageText === 'string') {
            newMessages[messageId] = /** @type {R[K]} */`${messageText} (${ruleName})`;
          } else {
            newMessages[messageId] = /** @type {R[K]} */
            (...args) => `${messageText(...args)} (${ruleName})`;

          }
        }

        return newMessages;
      }

      module.exports = /** @type {typeof import('stylelint').utils.ruleMessages} */ruleMessages;

    }, {}], 437: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').AtRule} AtRule */

      /**
       * @param {AtRule} atRule
       * @param {string} params
       * @returns {AtRule} The atRulearation that was passed in.
       */
      module.exports = function setAtRuleParams(atRule, params) {
        const raws = atRule.raws;

        if (raws.params) {
          raws.params.raw = params;
        } else {
          atRule.params = params;
        }

        return atRule;
      };

    }, {}], 438: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Declaration} Declaration */

      /**
       * @param {Declaration} decl
       * @param {string} value
       * @returns {Declaration} The declaration that was passed in.
       */
      module.exports = function setDeclarationValue(decl, value) {
        const raws = decl.raws;

        if (raws.value) {
          raws.value.raw = value;
        } else {
          decl.value = value;
        }

        return decl;
      };

    }, {}], 439: [function (require, module, exports) {
      'use strict';

      const selectorParser = require('postcss-selector-parser');

      /**
       * @param {import('stylelint').PostcssResult} result
       * @param {import('postcss').Rule} node
       * @param {(root: import('postcss-selector-parser').Root) => void} callback
       */
      module.exports = function transformSelector(result, node, callback) {
        try {
          return selectorParser(callback).processSync(node, { updateSelector: true });
        } catch (_unused4) {
          result.warn('Cannot parse selector', { node, stylelintType: 'parseError' });
        }
      };

    }, { "postcss-selector-parser": 53 }], 440: [function (require, module, exports) {
      'use strict';

      /** @typedef {import('postcss').Node} Node */
      /** @typedef {import('postcss').Node} NodeSource */

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Root}
       */
      module.exports.isRoot = function isRoot(node) {
        return node.type === 'root';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Rule}
       */
      module.exports.isRule = function isRule(node) {
        return node.type === 'rule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').AtRule}
       */
      module.exports.isAtRule = function isAtRule(node) {
        return node.type === 'atrule';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Comment}
       */
      module.exports.isComment = function isComment(node) {
        return node.type === 'comment';
      };

      /**
       * @param {Node} node
       * @returns {node is import('postcss').Declaration}
       */
      module.exports.isDeclaration = function isDeclaration(node) {
        return node.type === 'decl';
      };

      /**
       * @param {import('postcss-value-parser').Node} node
       * @returns {node is import('postcss-value-parser').FunctionNode}
       */
      module.exports.isValueFunction = function isValueFunction(node) {
        return node.type === 'function';
      };

      /**
       * @param {Node} node
       * @returns {node is (Node & {source: NodeSource})}
       */
      module.exports.hasSource = function hasSource(node) {
        return Boolean(node.source);
      };

    }, {}], 441: [function (require, module, exports) {
      'use strict';

      const { isPlainObject } = require('is-plain-object');

      /**
       * @template T
       * @typedef {(i: T) => boolean} Validator
       */

      /**
       * Check whether the variable is an object and all its properties are arrays of string values:
       *
       * ignoreProperties = {
       *   value1: ["item11", "item12", "item13"],
       *   value2: ["item21", "item22", "item23"],
       *   value3: ["item31", "item32", "item33"],
       * }
       * @template T
       * @param {Validator<T>|Validator<T>[]} validator
       * @returns {(value: {[k: any]: T|T[]}) => boolean}
       */
      module.exports = validator => value => {
        if (!isPlainObject(value)) {
          return false;
        }

        return Object.values(value).every(array => {
          if (!Array.isArray(array)) {
            return false;
          }

          // Make sure the array items are strings
          return array.every(item => {
            if (Array.isArray(validator)) {
              return validator.some(v => v(item));
            }

            return validator(item);
          });
        });
      };

    }, { "is-plain-object": 35 }], 442: [function (require, module, exports) {
      'use strict';

      const arrayEqual = require('./arrayEqual');
      const { isPlainObject } = require('is-plain-object');

      const IGNORED_OPTIONS = new Set(['severity', 'message', 'reportDisables', 'disableFix']);

      /** @typedef {import('stylelint').RuleOptions} RuleOptions */
      /** @typedef {import('stylelint').RuleOptionsPossible} Possible */
      /** @typedef {import('stylelint').RuleOptionsPossibleFunc} PossibleFunc */

      /**
       * Validate a rule's options.
       *
       * See existing rules for examples.
       *
       * @param {import('stylelint').PostcssResult} result - postcss result
       * @param {string} ruleName
       * @param {...RuleOptions} optionDescriptions - Each optionDescription can
       *   have the following properties:
       *   - `actual` (required): the actual passed option value or object.
       *   - `possible` (required): a schema representation of what values are
       *      valid for those options. `possible` should be an object if the
       *      options are an object, with corresponding keys; if the options are not an
       *      object, `possible` isn't, either. All `possible` value representations
       *      should be **arrays of either values or functions**. Values are === checked
       *      against `actual`. Functions are fed `actual` as an argument and their
       *      return value is interpreted: truthy = valid, falsy = invalid.
       *    - `optional` (optional): If this is `true`, `actual` can be undefined.
       * @return {boolean} Whether or not the options are valid (true = valid)
       */
      function validateOptions(result, ruleName, ...optionDescriptions) {
        let noErrors = true;

        for (const optionDescription of optionDescriptions) {
          validate(optionDescription, ruleName, complain);
        }

        /**
         * @param {string} message
         */
        function complain(message) {
          noErrors = false;
          result.warn(message, {
            stylelintType: 'invalidOption' });

          result.stylelint = result.stylelint || {
            disabledRanges: {},
            ruleSeverities: {},
            customMessages: {} };

          result.stylelint.stylelintError = true;
        }

        return noErrors;
      }

      /**
       * @param {RuleOptions} opts
       * @param {string} ruleName
       * @param {(message: string) => void} complain
       */
      function validate(opts, ruleName, complain) {
        const possible = opts.possible;
        const actual = opts.actual;
        const optional = opts.optional;

        if (actual === null || arrayEqual(actual, [null])) {
          return;
        }

        const nothingPossible =
        possible === undefined || Array.isArray(possible) && possible.length === 0;

        if (nothingPossible && actual === true) {
          return;
        }

        if (actual === undefined) {
          if (nothingPossible || optional) {
            return;
          }

          complain(`Expected option value for rule "${ruleName}"`);

          return;
        }

        if (nothingPossible) {
          if (optional) {
            complain(
            `Incorrect configuration for rule "${ruleName}". Rule should have "possible" values for options validation`);


            return;
          }

          complain(`Unexpected option value "${String(actual)}" for rule "${ruleName}"`);

          return;
        }

        if (typeof possible === 'function') {
          if (!possible(actual)) {
            complain(`Invalid option "${JSON.stringify(actual)}" for rule ${ruleName}`);
          }

          return;
        }

        // If `possible` is an array instead of an object ...
        if (Array.isArray(possible)) {
          for (const a of [actual].flat()) {
            if (isValid(possible, a)) {
              continue;
            }

            complain(`Invalid option value "${String(a)}" for rule "${ruleName}"`);
          }

          return;
        }

        // If actual is NOT an object ...
        if (!isPlainObject(actual) || typeof actual !== 'object' || actual == null) {
          complain(
          `Invalid option value ${JSON.stringify(actual)} for rule "${ruleName}": should be an object`);


          return;
        }

        for (const [optionName, optionValue] of Object.entries(actual)) {
          if (IGNORED_OPTIONS.has(optionName)) {
            continue;
          }

          const possibleValue = possible && possible[optionName];

          if (!possibleValue) {
            complain(`Invalid option name "${optionName}" for rule "${ruleName}"`);

            continue;
          }

          for (const a of [optionValue].flat()) {
            if (isValid(possibleValue, a)) {
              continue;
            }

            complain(`Invalid value "${a}" for option "${optionName}" of rule "${ruleName}"`);
          }
        }
      }

      /**
       * @param {Possible | Possible[]} possible
       * @param {unknown} actual
       * @returns {boolean}
       */
      function isValid(possible, actual) {
        for (const possibility of [possible].flat()) {
          if (typeof possibility === 'function' && possibility(actual)) {
            return true;
          }

          if (actual === possibility) {
            return true;
          }
        }

        return false;
      }

      module.exports = /** @type {typeof import('stylelint').utils.validateOptions} */validateOptions;

    }, { "./arrayEqual": 351, "is-plain-object": 35 }], 443: [function (require, module, exports) {
      'use strict';

      /**
       * Checks if the value is a boolean or a Boolean object.
       * @param {unknown} value
       * @returns {value is boolean}
       */
      function isBoolean(value) {
        return typeof value === 'boolean' || value instanceof Boolean;
      }

      /**
       * Checks if the value is a number or a Number object.
       * @param {unknown} value
       * @returns {value is number}
       */
      function isNumber(value) {
        return typeof value === 'number' || value instanceof Number;
      }

      /**
       * Checks if the value is a RegExp object.
       * @param {unknown} value
       * @returns {value is RegExp}
       */
      function isRegExp(value) {
        return value instanceof RegExp;
      }

      /**
       * Checks if the value is a string or a String object.
       * @param {unknown} value
       * @returns {value is string}
       */
      function isString(value) {
        return typeof value === 'string' || value instanceof String;
      }

      module.exports = {
        isBoolean,
        isNumber,
        isRegExp,
        isString };


    }, {}], 444: [function (require, module, exports) {
      'use strict';

      /**
       * Contains helpers for working with vendor prefixes.
       *
       * Copied from https://github.com/postcss/postcss/commit/777c55b5d2a10605313a4972888f4f32005f5ac2
       *
       * @namespace vendor
       */
      module.exports = {
        /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} vendor prefix or empty string
         *
         * @example
         * vendor.prefix('-moz-tab-size') //=> '-moz-'
         * vendor.prefix('tab-size')      //=> ''
         */
        prefix(prop) {
          const match = prop.match(/^(-\w+-)/);

          if (match) {
            return match[0];
          }

          return '';
        },

        /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} String name without vendor prefixes.
         *
         * @example
         * vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */
        unprefixed(prop) {
          return prop.replace(/^-\w+-/, '');
        } };


    }, {}], 445: [function (require, module, exports) {
      'use strict';

      const configurationError = require('./configurationError');
      const isSingleLineString = require('./isSingleLineString');
      const isWhitespace = require('./isWhitespace');

      /**
       * @typedef {(message: string) => string} MessageFunction
       */

      /**
       * @typedef {Object} Messages
       * @property {MessageFunction} [expectedBefore]
       * @property {MessageFunction} [rejectedBefore]
       * @property {MessageFunction} [expectedAfter]
       * @property {MessageFunction} [rejectedAfter]
       * @property {MessageFunction} [expectedBeforeSingleLine]
       * @property {MessageFunction} [rejectedBeforeSingleLine]
       * @property {MessageFunction} [expectedBeforeMultiLine]
       * @property {MessageFunction} [rejectedBeforeMultiLine]
       * @property {MessageFunction} [expectedAfterSingleLine]
       * @property {MessageFunction} [rejectedAfterSingleLine]
       * @property {MessageFunction} [expectedAfterMultiLine]
       * @property {MessageFunction} [rejectedAfterMultiLine]
       */

      /**
       * @typedef {Object} WhitespaceCheckerArgs
       * @property {string} source - The source string
       * @property {number} index - The index of the character to check before
       * @property {(message: string) => void} err - If a problem is found, this callback
       *   will be invoked with the relevant warning message.
       *   Typically this callback will report() the problem.
       * @property {string} [errTarget] - If a problem is found, this string
       *   will be sent to the relevant warning message.
       * @property {string} [lineCheckStr] - Single- and multi-line checkers
       *   will use this string to determine whether they should proceed,
       *   i.e. if this string is one line only, single-line checkers will check,
       *   multi-line checkers will ignore.
       *   If none is passed, they will use `source`.
       * @property {boolean} [onlyOneChar=false] - Only check *one* character before.
       *   By default, "always-*" checks will look for the `targetWhitespace` one
       *   before and then ensure there is no whitespace two before. This option
       *   bypasses that second check.
       * @property {boolean} [allowIndentation=false] - Allow arbitrary indentation
       *   between the `targetWhitespace` (almost definitely a newline) and the `index`.
       *   With this option, the checker will see if a newline *begins* the whitespace before
       *   the `index`.
       */

      /**
       * @typedef {(args: WhitespaceCheckerArgs) => void} WhitespaceChecker
       */

      /**
       * @typedef {{
       *   before: WhitespaceChecker,
       *   beforeAllowingIndentation: WhitespaceChecker,
       *   after: WhitespaceChecker,
       *   afterOneOnly: WhitespaceChecker,
       * }} WhitespaceCheckers
       */

      /**
       * Create a whitespaceChecker, which exposes the following functions:
       * - `before()`
       * - `beforeAllowingIndentation()`
       * - `after()`
       * - `afterOneOnly()`
       *
       * @param {"space" | "newline"} targetWhitespace - This is a keyword instead
       *   of the actual character (e.g. " ") in order to accommodate
       *   different styles of newline ("\n" vs "\r\n")
       * @param {"always" | "never" | "always-single-line" | "always-multi-line" | "never-single-line" | "never-multi-line"} expectation
       * @param {Messages} messages - An object of message functions;
       *   calling `before*()` or `after*()` and the `expectation` that is passed
       *   determines which message functions are required
       *
       * @returns {WhitespaceCheckers} The checker, with its exposed checking functions
       */
      module.exports = function whitespaceChecker(targetWhitespace, expectation, messages) {
        // Keep track of active arguments in order to avoid passing
        // too much stuff around, making signatures long and confusing.
        // This variable gets reset anytime a checking function is called.
        /** @type {WhitespaceCheckerArgs} */
        let activeArgs;

        /**
         * Check for whitespace *before* a character.
         * @type {WhitespaceChecker}
         */
        function before({
          source,
          index,
          err,
          errTarget,
          lineCheckStr,
          onlyOneChar = false,
          allowIndentation = false })
        {
          activeArgs = {
            source,
            index,
            err,
            errTarget,
            onlyOneChar,
            allowIndentation };


          switch (expectation) {
            case 'always':
              expectBefore();
              break;
            case 'never':
              rejectBefore();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectBefore(messages.expectedBeforeMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectBefore(messages.rejectedBeforeMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * Check for whitespace *after* a character.
         * @type {WhitespaceChecker}
         */
        function after({ source, index, err, errTarget, lineCheckStr, onlyOneChar = false }) {
          activeArgs = { source, index, err, errTarget, onlyOneChar };

          switch (expectation) {
            case 'always':
              expectAfter();
              break;
            case 'never':
              rejectAfter();
              break;
            case 'always-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterSingleLine);
              break;
            case 'never-single-line':
              if (!isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterSingleLine);
              break;
            case 'always-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              expectAfter(messages.expectedAfterMultiLine);
              break;
            case 'never-multi-line':
              if (isSingleLineString(lineCheckStr || source)) {
                return;
              }

              rejectAfter(messages.rejectedAfterMultiLine);
              break;
            default:
              throw configurationError(`Unknown expectation "${expectation}"`);}

        }

        /**
         * @type {WhitespaceChecker}
         */
        function beforeAllowingIndentation(obj) {
          before(_extends({}, obj, { allowIndentation: true }));
        }

        function expectBefore(messageFunc = messages.expectedBefore) {
          if (activeArgs.allowIndentation) {
            expectBeforeAllowingIndentation(messageFunc);

            return;
          }

          const _activeArgs = activeArgs;
          const source = _activeArgs.source;
          const index = _activeArgs.index;

          const oneCharBefore = source[index - 1];
          const twoCharsBefore = source[index - 2];

          if (!isValue(oneCharBefore)) {
            return;
          }

          if (
          targetWhitespace === 'space' &&
          oneCharBefore === ' ' && (
          activeArgs.onlyOneChar || !isWhitespace(twoCharsBefore)))
          {
            return;
          }

          assertFunction(messageFunc);
          activeArgs.err(messageFunc(activeArgs.errTarget || source[index]));
        }

        function expectBeforeAllowingIndentation(messageFunc = messages.expectedBefore) {
          const _activeArgs2 = activeArgs;
          const source = _activeArgs2.source;
          const index = _activeArgs2.index;
          const err = _activeArgs2.err;

          const expectedChar = function () {
            if (targetWhitespace === 'newline') {
              return '\n';
            }
          }();
          let i = index - 1;

          while (source[i] !== expectedChar) {
            if (source[i] === '\t' || source[i] === ' ') {
              i--;
              continue;
            }

            assertFunction(messageFunc);
            err(messageFunc(activeArgs.errTarget || source[index]));

            return;
          }
        }

        function rejectBefore(messageFunc = messages.rejectedBefore) {
          const _activeArgs3 = activeArgs;
          const source = _activeArgs3.source;
          const index = _activeArgs3.index;

          const oneCharBefore = source[index - 1];

          if (isValue(oneCharBefore) && isWhitespace(oneCharBefore)) {
            assertFunction(messageFunc);
            activeArgs.err(messageFunc(activeArgs.errTarget || source[index]));
          }
        }

        /**
         * @type {WhitespaceChecker}
         */
        function afterOneOnly(obj) {
          after(_extends({}, obj, { onlyOneChar: true }));
        }

        function expectAfter(messageFunc = messages.expectedAfter) {
          const _activeArgs4 = activeArgs;
          const source = _activeArgs4.source;
          const index = _activeArgs4.index;

          const oneCharAfter = source[index + 1];
          const twoCharsAfter = source[index + 2];

          if (!isValue(oneCharAfter)) {
            return;
          }

          if (targetWhitespace === 'newline') {
            // If index is followed by a Windows CR-LF ...
            if (
            oneCharAfter === '\r' &&
            twoCharsAfter === '\n' && (
            activeArgs.onlyOneChar || !isWhitespace(source[index + 3])))
            {
              return;
            }

            // If index is followed by a Unix LF ...
            if (oneCharAfter === '\n' && (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter))) {
              return;
            }
          }

          if (
          targetWhitespace === 'space' &&
          oneCharAfter === ' ' && (
          activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)))
          {
            return;
          }

          assertFunction(messageFunc);
          activeArgs.err(messageFunc(activeArgs.errTarget || source[index]));
        }

        function rejectAfter(messageFunc = messages.rejectedAfter) {
          const _activeArgs5 = activeArgs;
          const source = _activeArgs5.source;
          const index = _activeArgs5.index;

          const oneCharAfter = source[index + 1];

          if (isValue(oneCharAfter) && isWhitespace(oneCharAfter)) {
            assertFunction(messageFunc);
            activeArgs.err(messageFunc(activeArgs.errTarget || source[index]));
          }
        }

        return {
          before,
          beforeAllowingIndentation,
          after,
          afterOneOnly };

      };

      /**
       * @param {unknown} x
       */
      function isValue(x) {
        return x !== undefined && x !== null;
      }

      /**
       * @param {unknown} x
       * @returns {asserts x is Function}
       */
      function assertFunction(x) {
        if (typeof x !== 'function') {
          throw new TypeError(`\`${x}\` must be a function`);
        }
      }

    }, { "./configurationError": 357, "./isSingleLineString": 407, "./isWhitespace": 425 }], 446: [function (require, module, exports) {
      'use strict';

      const validateOptions = require('./utils/validateOptions');
      const { isRegExp, isString } = require('./utils/validateTypes');

      /**
       * @typedef {import('stylelint').PostcssResult} PostcssResult
       * @typedef {import('stylelint').DisableOptions} DisableOptions
       * @typedef {import('stylelint').DisablePropertyName} DisablePropertyName
       * @typedef {import('stylelint').StylelintPostcssResult} StylelintPostcssResult
       */

      /**
       * Validates that the stylelint config for `result` has a valid disable field
       * named `field`, and returns the result in normalized form as well as a
       * `StylelintPostcssResult` for convenience.
       *
       * Returns `null` if no disables should be reported, and automatically reports
       * an invalid configuration. If this returns non-`null`, it guarantees that
       * `result._postcssResult` is defined as well.
       *
       * @param {PostcssResult | undefined} result
       * @param {DisablePropertyName} field
       * @return {[boolean, Required<DisableOptions>, StylelintPostcssResult] | null}
       */
      module.exports = function (result, field) {
        // Files with `CssSyntaxError`s don't have `_postcssResult`s.
        if (!result) return null;

        const stylelintResult = result.stylelint;

        // Files with linting errors may not have configs associated with them.
        if (!stylelintResult.config) return null;

        const rawSettings = stylelintResult.config[field];

        /** @type {boolean} */
        let enabled;
        /** @type {DisableOptions} */
        let options;

        if (Array.isArray(rawSettings)) {
          enabled = rawSettings[0];
          options = rawSettings[1] || {};
        } else {
          enabled = rawSettings || false;
          options = {};
        }

        const validOptions = validateOptions(
        result,
        field,
        {
          actual: enabled,
          possible: [true, false] },

        {
          actual: options,
          possible: {
            except: [isString, isRegExp] } });




        if (!validOptions) return null;

        // If the check is disabled with no exceptions, there's no reason to run
        // it at all.
        if (!enabled && !options.except) return null;

        return [
        enabled,
        {
          except: options.except || [],
          severity: options.severity || stylelintResult.config.defaultSeverity || 'error' },

        stylelintResult];

      };

    }, { "./utils/validateOptions": 442, "./utils/validateTypes": 443 }], 447: [function (require, module, exports) {
      'use strict';
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);

        const r = range(a, b, str);

        return (
          r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length) });


      }

      function maybeMatch(reg, str) {
        const m = str.match(reg);
        return m ? m[0] : null;
      }

      balanced.range = range;
      function range(a, b, str) {
        let begs, beg, left, right, result;
        let ai = str.indexOf(a);
        let bi = str.indexOf(b, ai + 1);
        let i = ai;

        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;

          while (i >= 0 && !result) {
            if (i === ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length === 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }

              bi = str.indexOf(b, i + 1);
            }

            i = ai < bi && ai >= 0 ? ai : bi;
          }

          if (begs.length) {
            result = [left, right];
          }
        }

        return result;
      }

    }, {}], 448: [function (require, module, exports) {
      module.exports = require('./svg-tags.json');
    }, { "./svg-tags.json": 449 }], 449: [function (require, module, exports) {
      module.exports = [
      "a",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern"];

    }, {}], 450: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var punycode = require('punycode');
      var util = require('./util');

      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;

      exports.Url = Url;

      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }

      // Reference: RFC 3986, RFC 1808, RFC 2396

      // define these here so at least they only have to be
      // compiled once on the first module load.
      var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

      // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true },

      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true },

      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true },

      querystring = require('querystring');

      function urlParse(url, parseQueryString, slashesDenoteHost) {
        if (url && util.isObject(url) && url instanceof Url) return url;

        var u = new Url();
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
      }

      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
        if (!util.isString(url)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }

        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'),
        splitter =
        queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);

        var rest = url;

        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();

        if (!slashesDenoteHost && url.split('#').length === 1) {
          // Try fast path regexp
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = '';
              this.query = {};
            }
            return this;
          }
        }

        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }

        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === '//';
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }

        if (!hostlessProtocol[proto] && (
        slashes || proto && !slashedProtocol[proto])) {

          // there's a hostname.
          // the first instance of /, ?, ;, or # ends the host.
          //
          // If there is an @ in the hostname, then non-host chars *are* allowed
          // to the left of the last @ sign, unless some host-ending character
          // comes *before* the @-sign.
          // URLs are obnoxious.
          //
          // ex:
          // http://a@b@c/ => user:a@b host:c
          // http://a@b?@c => user:a host:c path:/?@c

          // v0.12 TODO(isaacs): This is not quite how Chrome does things.
          // Review our test case against browsers more comprehensively.

          // find the first instance of any hostEndingChars
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
          }

          // at this point, either we have an explicit point where the
          // auth portion cannot go past, or the last @ char is the decider.
          var auth, atSign;
          if (hostEnd === -1) {
            // atSign can be anywhere.
            atSign = rest.lastIndexOf('@');
          } else {
            // atSign must be in auth portion.
            // http://a@b/c@d => host:b auth:a path:/c@d
            atSign = rest.lastIndexOf('@', hostEnd);
          }

          // Now we have a portion which is definitely the auth.
          // Pull that off.
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }

          // the host is the remaining to the left of the first non-host char
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
          }
          // if we still have not hit it, then the entire thing is a host.
          if (hostEnd === -1)
          hostEnd = rest.length;

          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);

          // pull out port.
          this.parseHost();

          // we've indicated that there is a hostname,
          // so even if it's empty, it has to be present.
          this.hostname = this.hostname || '';

          // if hostname begins with [ and ends with ]
          // assume that it's an IPv6 address.
          var ipv6Hostname = this.hostname[0] === '[' &&
          this.hostname[this.hostname.length - 1] === ']';

          // validate a little.
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part) continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = '';
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    // we replace non-ASCII char with a temporary placeholder
                    // we need this to make sure size of hostname is not
                    // broken by replacing non-ASCII by nothing
                    newpart += 'x';
                  } else {
                    newpart += part[j];
                  }
                }
                // we test again with ASCII char only
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = '/' + notHost.join('.') + rest;
                  }
                  this.hostname = validParts.join('.');
                  break;
                }
              }
            }
          }

          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
          } else {
            // hostnames are always lower case.
            this.hostname = this.hostname.toLowerCase();
          }

          if (!ipv6Hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            this.hostname = punycode.toASCII(this.hostname);
          }

          var p = this.port ? ':' + this.port : '';
          var h = this.hostname || '';
          this.host = h + p;
          this.href += this.host;

          // strip [ and ] from the hostname
          // the host field still retains them, though
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
              rest = '/' + rest;
            }
          }
        }

        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!unsafeProtocol[lowerProto]) {

          // First, make 100% sure that any "autoEscape" chars get
          // escaped, even if encodeURIComponent doesn't think they
          // need to be.
          for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1)
            continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }


        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
          // got a fragment string.
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          // no query string, but parseQueryString still requested
          this.search = '';
          this.query = {};
        }
        if (rest) this.pathname = rest;
        if (slashedProtocol[lowerProto] &&
        this.hostname && !this.pathname) {
          this.pathname = '/';
        }

        //to support http.request
        if (this.pathname || this.search) {
          var p = this.pathname || '';
          var s = this.search || '';
          this.path = p + s;
        }

        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
      };

      // format a parsed object into a url string
      function urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (util.isString(obj)) obj = urlParse(obj);
        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
        return obj.format();
      }

      Url.prototype.format = function () {
        var auth = this.auth || '';
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ':');
          auth += '@';
        }

        var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(':') === -1 ?
          this.hostname :
          '[' + this.hostname + ']');
          if (this.port) {
            host += ':' + this.port;
          }
        }

        if (this.query &&
        util.isObject(this.query) &&
        Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }

        var search = this.search || query && '?' + query || '';

        if (protocol && protocol.substr(-1) !== ':') protocol += ':';

        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
        (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = '//' + (host || '');
          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
        } else if (!host) {
          host = '';
        }

        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
        if (search && search.charAt(0) !== '?') search = '?' + search;

        pathname = pathname.replace(/[?#]/g, function (match) {
          return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');

        return protocol + host + pathname + search + hash;
      };

      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }

      Url.prototype.resolve = function (relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };

      function urlResolveObject(source, relative) {
        if (!source) return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }

      Url.prototype.resolveObject = function (relative) {
        if (util.isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }

        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }

        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;

        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
          result.href = result.format();
          return result;
        }

        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
          // take everything except the protocol from relative
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
          }

          //urlParse appends trailing / to urls like http://www.example.com
          if (slashedProtocol[result.protocol] &&
          result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
          }

          result.href = result.format();
          return result;
        }

        if (relative.protocol && relative.protocol !== result.protocol) {
          // if it's a known url protocol, then changing
          // the protocol does weird things
          // first, if it's not file:, then we MUST have a host,
          // and if there was a path
          // to begin with, then we MUST have a path.
          // if it is file:, then the host is dropped,
          // because that's known to be hostless.
          // anything else is assumed to be absolute.
          if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
              var k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }

          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = '';
            if (!relative.hostname) relative.hostname = '';
            if (relPath[0] !== '') relPath.unshift('');
            if (relPath.length < 2) relPath.unshift('');
            result.pathname = relPath.join('/');
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || '';
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          // to support http.request
          if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }

        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs =
        relative.host ||
        relative.pathname && relative.pathname.charAt(0) === '/',

        mustEndAbs = isRelAbs || isSourceAbs ||
        result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
          result.hostname = '';
          result.port = null;
          if (result.host) {
            if (srcPath[0] === '') srcPath[0] = result.host;else
            srcPath.unshift(result.host);
          }
          result.host = '';
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === '') relPath[0] = relative.host;else
              relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }

        if (isRelAbs) {
          // it's absolute.
          result.host = relative.host || relative.host === '' ?
          relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === '' ?
          relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
          // fall through to the dot-handling below.
        } else if (relPath.length) {
          // it's relative
          // throw away the existing file, and take the new path instead.
          if (!srcPath) srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util.isNullOrUndefined(relative.search)) {
          // just pull out the search.
          // like href='?foo'.
          // Put this after the other two cases because it simplifies the booleans
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
            result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          //to support http.request
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (
            result.search ? result.search : '');
          }
          result.href = result.format();
          return result;
        }

        if (!srcPath.length) {
          // no path at all.  easy.
          // we've already handled the other stuff above.
          result.pathname = null;
          //to support http.request
          if (result.search) {
            result.path = '/' + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }

        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash =
        (result.host || relative.host || srcPath.length > 1) && (
        last === '.' || last === '..') || last === '';

        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === '.') {
            srcPath.splice(i, 1);
          } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }

        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift('..');
          }
        }

        if (mustEndAbs && srcPath[0] !== '' && (
        !srcPath[0] || srcPath[0].charAt(0) !== '/')) {
          srcPath.unshift('');
        }

        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
          srcPath.push('');
        }

        var isAbsolute = srcPath[0] === '' ||
        srcPath[0] && srcPath[0].charAt(0) === '/';

        // put the host back
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? '' :
          srcPath.length ? srcPath.shift() : '';
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }

        mustEndAbs = mustEndAbs || result.host && srcPath.length;

        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift('');
        }

        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join('/');
        }

        //to support request.http
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (
          result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };

      Url.prototype.parseHost = function () {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ':') {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host) this.hostname = host;
      };

    }, { "./util": 451, "punycode": 116, "querystring": 119 }], 451: [function (require, module, exports) {
      'use strict';

      module.exports = {
        isString: function (arg) {
          return typeof arg === 'string';
        },
        isObject: function (arg) {
          return typeof arg === 'object' && arg !== null;
        },
        isNull: function (arg) {
          return arg === null;
        },
        isNullOrUndefined: function (arg) {
          return arg == null;
        } };


    }, {}], 452: [function (require, module, exports) {
      (function (global) {(function () {

          /**
           * Module exports.
           */

          module.exports = deprecate;

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }

            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
          }

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 453: [function (require, module, exports) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object' &&
        typeof arg.copy === 'function' &&
        typeof arg.fill === 'function' &&
        typeof arg.readUInt8 === 'function';
      };
    }, {}], 454: [function (require, module, exports) {
      // Currently in sync with Node.js lib/internal/util/types.js
      // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

      'use strict';

      var isArgumentsObject = require('is-arguments');
      var isGeneratorFunction = require('is-generator-function');
      var whichTypedArray = require('which-typed-array');
      var isTypedArray = require('is-typed-array');

      function uncurryThis(f) {
        return f.call.bind(f);
      }

      var BigIntSupported = typeof BigInt !== 'undefined';
      var SymbolSupported = typeof Symbol !== 'undefined';

      var ObjectToString = uncurryThis(Object.prototype.toString);

      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);

      if (BigIntSupported) {
        var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }

      if (SymbolSupported) {
        var symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }

      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== 'object') {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }

      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;

      // Taken from here and modified for better browser support
      // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
      function isPromise(input) {
        return (

          typeof Promise !== 'undefined' &&
          input instanceof Promise ||


          input !== null &&
          typeof input === 'object' &&
          typeof input.then === 'function' &&
          typeof input.catch === 'function');


      }
      exports.isPromise = isPromise;

      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }

        return (
          isTypedArray(value) ||
          isDataView(value));

      }
      exports.isArrayBufferView = isArrayBufferView;


      function isUint8Array(value) {
        return whichTypedArray(value) === 'Uint8Array';
      }
      exports.isUint8Array = isUint8Array;

      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === 'Uint8ClampedArray';
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;

      function isUint16Array(value) {
        return whichTypedArray(value) === 'Uint16Array';
      }
      exports.isUint16Array = isUint16Array;

      function isUint32Array(value) {
        return whichTypedArray(value) === 'Uint32Array';
      }
      exports.isUint32Array = isUint32Array;

      function isInt8Array(value) {
        return whichTypedArray(value) === 'Int8Array';
      }
      exports.isInt8Array = isInt8Array;

      function isInt16Array(value) {
        return whichTypedArray(value) === 'Int16Array';
      }
      exports.isInt16Array = isInt16Array;

      function isInt32Array(value) {
        return whichTypedArray(value) === 'Int32Array';
      }
      exports.isInt32Array = isInt32Array;

      function isFloat32Array(value) {
        return whichTypedArray(value) === 'Float32Array';
      }
      exports.isFloat32Array = isFloat32Array;

      function isFloat64Array(value) {
        return whichTypedArray(value) === 'Float64Array';
      }
      exports.isFloat64Array = isFloat64Array;

      function isBigInt64Array(value) {
        return whichTypedArray(value) === 'BigInt64Array';
      }
      exports.isBigInt64Array = isBigInt64Array;

      function isBigUint64Array(value) {
        return whichTypedArray(value) === 'BigUint64Array';
      }
      exports.isBigUint64Array = isBigUint64Array;

      function isMapToString(value) {
        return ObjectToString(value) === '[object Map]';
      }
      isMapToString.working =
      typeof Map !== 'undefined' &&
      isMapToString(new Map());


      function isMap(value) {
        if (typeof Map === 'undefined') {
          return false;
        }

        return isMapToString.working ?
        isMapToString(value) :
        value instanceof Map;
      }
      exports.isMap = isMap;

      function isSetToString(value) {
        return ObjectToString(value) === '[object Set]';
      }
      isSetToString.working =
      typeof Set !== 'undefined' &&
      isSetToString(new Set());

      function isSet(value) {
        if (typeof Set === 'undefined') {
          return false;
        }

        return isSetToString.working ?
        isSetToString(value) :
        value instanceof Set;
      }
      exports.isSet = isSet;

      function isWeakMapToString(value) {
        return ObjectToString(value) === '[object WeakMap]';
      }
      isWeakMapToString.working =
      typeof WeakMap !== 'undefined' &&
      isWeakMapToString(new WeakMap());

      function isWeakMap(value) {
        if (typeof WeakMap === 'undefined') {
          return false;
        }

        return isWeakMapToString.working ?
        isWeakMapToString(value) :
        value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;

      function isWeakSetToString(value) {
        return ObjectToString(value) === '[object WeakSet]';
      }
      isWeakSetToString.working =
      typeof WeakSet !== 'undefined' &&
      isWeakSetToString(new WeakSet());

      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;

      function isArrayBufferToString(value) {
        return ObjectToString(value) === '[object ArrayBuffer]';
      }
      isArrayBufferToString.working =
      typeof ArrayBuffer !== 'undefined' &&
      isArrayBufferToString(new ArrayBuffer());

      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === 'undefined') {
          return false;
        }

        return isArrayBufferToString.working ?
        isArrayBufferToString(value) :
        value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;

      function isDataViewToString(value) {
        return ObjectToString(value) === '[object DataView]';
      }
      isDataViewToString.working =
      typeof ArrayBuffer !== 'undefined' &&
      typeof DataView !== 'undefined' &&
      isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

      function isDataView(value) {
        if (typeof DataView === 'undefined') {
          return false;
        }

        return isDataViewToString.working ?
        isDataViewToString(value) :
        value instanceof DataView;
      }
      exports.isDataView = isDataView;

      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === '[object SharedArrayBuffer]';
      }
      isSharedArrayBufferToString.working =
      typeof SharedArrayBuffer !== 'undefined' &&
      isSharedArrayBufferToString(new SharedArrayBuffer());

      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBuffer === 'undefined') {
          return false;
        }

        return isSharedArrayBufferToString.working ?
        isSharedArrayBufferToString(value) :
        value instanceof SharedArrayBuffer;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;

      function isAsyncFunction(value) {
        return ObjectToString(value) === '[object AsyncFunction]';
      }
      exports.isAsyncFunction = isAsyncFunction;

      function isMapIterator(value) {
        return ObjectToString(value) === '[object Map Iterator]';
      }
      exports.isMapIterator = isMapIterator;

      function isSetIterator(value) {
        return ObjectToString(value) === '[object Set Iterator]';
      }
      exports.isSetIterator = isSetIterator;

      function isGeneratorObject(value) {
        return ObjectToString(value) === '[object Generator]';
      }
      exports.isGeneratorObject = isGeneratorObject;

      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === '[object WebAssembly.Module]';
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;

      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;

      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;

      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;

      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;

      function isBoxedPrimitive(value) {
        return (
          isNumberObject(value) ||
          isStringObject(value) ||
          isBooleanObject(value) ||
          isBigIntObject(value) ||
          isSymbolObject(value));

      }
      exports.isBoxedPrimitive = isBoxedPrimitive;

      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== 'undefined' && (
        isArrayBuffer(value) ||
        isSharedArrayBuffer(value));

      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;

      ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function () {
            throw new Error(method + ' is not supported in userland');
          } });

      });

    }, { "is-arguments": 33, "is-generator-function": 34, "is-typed-array": 37, "which-typed-array": 456 }], 455: [function (require, module, exports) {
      (function (process) {(function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
          function getOwnPropertyDescriptors(obj) {
            var keys = Object.keys(obj);
            var descriptors = {};
            for (var i = 0; i < keys.length; i++) {
              descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
            }
            return descriptors;
          };

          var formatRegExp = /%[sdj%]/g;
          exports.format = function (f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function (x) {
              if (x === '%%') return '%';
              if (i >= len) return x;
              switch (x) {
                case '%s':return String(args[i++]);
                case '%d':return Number(args[i++]);
                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }
                default:
                  return x;}

            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }
            return str;
          };


          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function (fn, msg) {
            if (typeof process !== 'undefined' && process.noDeprecation === true) {
              return fn;
            }

            // Allow for deprecating things in the process of starting up.
            if (typeof process === 'undefined') {
              return function () {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }

            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          };


          var debugs = {};
          var debugEnvRegex = /^$/;

          if (process.env.NODE_DEBUG) {
            var debugEnv = process.env.NODE_DEBUG;
            debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').
            replace(/\*/g, '.*').
            replace(/,/g, '$|^').
            toUpperCase();
            debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
          }
          exports.debuglog = function (set) {
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (debugEnvRegex.test(set)) {
                var pid = process.pid;
                debugs[set] = function () {
                  var msg = exports.format.apply(exports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function () {};
              }
            }
            return debugs[set];
          };


          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
              seen: [],
              stylize: stylizeNoColor };

            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;


          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39] };


          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red' };



          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
              return '\u001b[' + inspect.colors[style][0] + 'm' + str +
              '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }


          function stylizeNoColor(str, styleType) {
            return str;
          }


          function arrayToHash(array) {
            var hash = {};

            array.forEach(function (val, idx) {
              hash[val] = true;
            });

            return hash;
          }


          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
            value &&
            isFunction(value.inspect) &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value) && (
            keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }
              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = '',array = false,braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function (key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
          }


          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
            return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').
              replace(/'/g, "\\'").
              replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
            return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
            return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
            return ctx.stylize('null', 'null');
          }


          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }


          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
              } else {
                output.push('');
              }
            }
            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
              }
            });
            return output;
          }


          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").
                replace(/\\"/g, '"').
                replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }

            return name + ': ' + str;
          }


          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function (prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0) numLinesEst++;
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
              return braces[0] + (
              base === '' ? '' : base + '\n ') +
              ' ' +
              output.join(',\n  ') +
              ' ' +
              braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }


          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          exports.types = require('./support/types');

          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;

          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }
          exports.isBoolean = isBoolean;

          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;

          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;

          function isNumber(arg) {
            return typeof arg === 'number';
          }
          exports.isNumber = isNumber;

          function isString(arg) {
            return typeof arg === 'string';
          }
          exports.isString = isString;

          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }
          exports.isSymbol = isSymbol;

          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }
          exports.isRegExp = isRegExp;
          exports.types.isRegExp = isRegExp;

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          exports.isObject = isObject;

          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }
          exports.isDate = isDate;
          exports.types.isDate = isDate;

          function isError(e) {
            return isObject(e) && (
            objectToString(e) === '[object Error]' || e instanceof Error);
          }
          exports.isError = isError;
          exports.types.isNativeError = isError;

          function isFunction(arg) {
            return typeof arg === 'function';
          }
          exports.isFunction = isFunction;

          function isPrimitive(arg) {
            return arg === null ||
            typeof arg === 'boolean' ||
            typeof arg === 'number' ||
            typeof arg === 'string' ||
            typeof arg === 'symbol' || // ES6 symbol
            typeof arg === 'undefined';
          }
          exports.isPrimitive = isPrimitive;

          exports.isBuffer = require('./support/isBuffer');

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }


          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }


          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
          'Oct', 'Nov', 'Dec'];

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
            pad(d.getMinutes()),
            pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          }


          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function () {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
          };


          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = require('inherits');

          exports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }

          var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

          exports.promisify = function promisify(original) {
            if (typeof original !== 'function')
            throw new TypeError('The "original" argument must be of type Function');

            if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
              var fn = original[kCustomPromisifiedSymbol];
              if (typeof fn !== 'function') {
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              }
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn, enumerable: false, writable: false, configurable: true });

              return fn;
            }

            function fn() {
              var promiseResolve, promiseReject;
              var promise = new Promise(function (resolve, reject) {
                promiseResolve = resolve;
                promiseReject = reject;
              });

              var args = [];
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              args.push(function (err, value) {
                if (err) {
                  promiseReject(err);
                } else {
                  promiseResolve(value);
                }
              });

              try {
                original.apply(this, args);
              } catch (err) {
                promiseReject(err);
              }

              return promise;
            }

            Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

            if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
              value: fn, enumerable: false, writable: false, configurable: true });

            return Object.defineProperties(
            fn,
            getOwnPropertyDescriptors(original));

          };

          exports.promisify.custom = kCustomPromisifiedSymbol;

          function callbackifyOnRejected(reason, cb) {
            // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
            // Because `null` is a special error value in callbacks which means "no error
            // occurred", we error-wrap so the callback consumer can distinguish between
            // "the promise rejected with null" or "the promise fulfilled with undefined".
            if (!reason) {
              var newReason = new Error('Promise was rejected with a falsy value');
              newReason.reason = reason;
              reason = newReason;
            }
            return cb(reason);
          }

          function callbackify(original) {
            if (typeof original !== 'function') {
              throw new TypeError('The "original" argument must be of type Function');
            }

            // We DO NOT return the promise as it gives the user a false sense that
            // the promise is actually somehow related to the callback's execution
            // and that the callback throwing will reject the promise.
            function callbackified() {
              var args = [];
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
              }

              var maybeCb = args.pop();
              if (typeof maybeCb !== 'function') {
                throw new TypeError('The last argument must be of type Function');
              }
              var self = this;
              var cb = function () {
                return maybeCb.apply(self, arguments);
              };
              // In true node style we process the callback on `nextTick` with all the
              // implications (stack, `uncaughtException`, `async_hooks`)
              original.apply(this, args).
              then(function (ret) {process.nextTick(cb.bind(null, null, ret));},
              function (rej) {process.nextTick(callbackifyOnRejected.bind(null, rej, cb));});
            }

            Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
            Object.defineProperties(callbackified,
            getOwnPropertyDescriptors(original));
            return callbackified;
          }
          exports.callbackify = callbackify;

        }).call(this);}).call(this, require('_process'));
    }, { "./support/isBuffer": 453, "./support/types": 454, "_process": 115, "inherits": 32 }], 456: [function (require, module, exports) {
      (function (global) {(function () {
          'use strict';

          var forEach = require('foreach');
          var availableTypedArrays = require('available-typed-arrays');
          var callBound = require('call-bind/callBound');

          var $toString = callBound('Object.prototype.toString');
          var hasSymbols = require('has-symbols')();
          var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

          var typedArrays = availableTypedArrays();

          var $slice = callBound('String.prototype.slice');
          var toStrTags = {};
          var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
          var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function (typedArray) {
              if (typeof global[typedArray] === 'function') {
                var arr = new global[typedArray]();
                if (!(Symbol.toStringTag in arr)) {
                  throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
                }
                var proto = getPrototypeOf(arr);
                var descriptor = gOPD(proto, Symbol.toStringTag);
                if (!descriptor) {
                  var superProto = getPrototypeOf(proto);
                  descriptor = gOPD(superProto, Symbol.toStringTag);
                }
                toStrTags[typedArray] = descriptor.get;
              }
            });
          }

          var tryTypedArrays = function tryAllTypedArrays(value) {
            var foundName = false;
            forEach(toStrTags, function (getter, typedArray) {
              if (!foundName) {
                try {
                  var name = getter.call(value);
                  if (name === typedArray) {
                    foundName = name;
                  }
                } catch (e) {}
              }
            });
            return foundName;
          };

          var isTypedArray = require('is-typed-array');

          module.exports = function whichTypedArray(value) {
            if (!isTypedArray(value)) {return false;}
            if (!hasToStringTag) {return $slice($toString(value), 8, -1);}
            return tryTypedArrays(value);
          };

        }).call(this);}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "available-typed-arrays": 2, "call-bind/callBound": 7, "es-abstract/helpers/getOwnPropertyDescriptor": 17, "foreach": 20, "has-symbols": 24, "is-typed-array": 37 }], "stylelint": [function (require, module, exports) {
      'use strict';

      const checkAgainstRule = require('./utils/checkAgainstRule');
      const createPlugin = require('./createPlugin');
      const createStylelint = require('./createStylelint');
      const formatters = require('./formatters');
      const postcssPlugin = require('./postcssPlugin');
      const report = require('./utils/report');
      const ruleMessages = require('./utils/ruleMessages');
      const rules = require('./rules');
      const standalone = require('./standalone');
      const validateOptions = require('./utils/validateOptions');
      const resolveConfig = require('./resolveConfig');

      /** @type {import('stylelint').PublicApi} */
      const stylelint = Object.assign(postcssPlugin, {
        lint: standalone,
        rules,
        formatters,
        createPlugin,
        resolveConfig,
        createLinter: createStylelint,
        utils: {
          report,
          ruleMessages,
          validateOptions,
          checkAgainstRule } });



      module.exports = stylelint;

    }, { "./createPlugin": 124, "./createStylelint": 125, "./formatters": 129, "./postcssPlugin": 140, "./resolveConfig": 148, "./rules": 237, "./standalone": 348, "./utils/checkAgainstRule": 356, "./utils/report": 435, "./utils/ruleMessages": 436, "./utils/validateOptions": 442 }] }, {}, [])("stylelint");
});})();